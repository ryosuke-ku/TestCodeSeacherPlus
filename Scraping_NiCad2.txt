
    private String stackTraceToString(Throwable throwable) {
        String ret = "";
        while (throwable != null) {
            if (ret != "")
                ret += "\nCaused by: ";
            ret += throwable.toString();
            for (StackTraceElement sTE : throwable.getStackTrace())
                ret += "\n  at " + sTE;
            throwable = throwable.getCause();
        }
        return ret;
    }


    private String stackTraceToString(Throwable throwable) {
        String ret = "";
        while (throwable != null) {
            if (ret != "")
                ret += "\nCaused by: ";
            ret += throwable.toString();
            for (StackTraceElement sTE : throwable.getStackTrace())
                ret += "\n  at " + sTE;
            throwable = throwable.getCause();
        }
        return ret;
    }


    @Test public void invalidSessionId() {
        httpSession.removeAttribute(SConsts.USER_SESS_ATTR);
        try {
            fetchFoldersService.fetch(new ImapFolderImpl(), false);
            fail("Invalid session");
        } catch (InvalidSessionException e) {
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }


    @Test public void invalidSessionId() throws MessagingException {
        httpSession.removeAttribute(SConsts.USER_SESS_ATTR);
        ImapFolder folder = createFolder();
        try {
            deleteFolderService.delete(new DeleteFolderActionImpl(folder));
            fail("Invalid session");
        } catch (InvalidSessionException e) {
        } catch (HupaException e) {
            e.printStackTrace();
            fail();
        }
    }


    @Test public void invalidSessionId(){
        httpSession.removeAttribute(SConsts.USER_SESS_ATTR);
        ImapFolder folder = createFolder();
        try {
            createFolderService.create(new CreateFolderActionImpl(folder));
            fail("Invalid session");
        } catch (InvalidSessionException e) {
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }

    }


    @Test public void delete() throws Exception {
        ImapFolder folder = createFolder();
        MockIMAPStore store = (MockIMAPStore) storeCache.get(testUser);
        Folder f1 = store.getFolder(folder.getFullName());
        f1.create(Folder.HOLDS_FOLDERS);
        try {
            deleteFolderService.delete(new DeleteFolderActionImpl(folder));
            Folder f = store.getFolder(folder.getFullName());
            assertFalse("not exists",f.exists());
        } catch (HupaException e) {
            e.printStackTrace();
            fail();
        }
    }


    @Test public void create() throws MessagingException {
        ImapFolder folder = createFolder();
        MockIMAPStore store = (MockIMAPStore) storeCache.get(testUser);
        Folder f1 = store.getFolder(folder.getFullName());
        assertFalse("not exists", f1.exists());
        try {
            createFolderService.create(new CreateFolderActionImpl(folder));
            Folder f = store.getFolder(folder.getFullName());
            assertTrue("exists", f.exists());
        } catch (Exception e) {
            e.printStackTrace();
            fail();
        }
    }


    @Test public void duplicateFolder() throws MessagingException {
        ImapFolder folder = createFolder();
        MockIMAPStore store = (MockIMAPStore) storeCache.get(testUser);
        Folder f1 = store.getFolder(folder.getFullName());
        f1.create(Folder.HOLDS_FOLDERS);
        try {
            createFolderService.create(new CreateFolderActionImpl(folder));
            fail("Folder already exists");
        } catch (Exception e) {
        }
    }


    protected String txtDocumentToHtml(String txt, String folderName, long uuid) {

        if (txt == null || txt.length() == 0)
            return txt;

        // escape html tags symbols
        txt = replaceAll(txt, regex_lt, repl_lt);
        txt = replaceAll(txt, regex_gt, repl_gt);

        // enclose between <a> http links and emails
        txt = replaceAll(txt, regex_htmllink, repl_htmllink);
        txt = replaceAll(txt, regex_email, repl_email);

        // put break lines
        txt = replaceAll(txt, regex_nl, repl_nl);

        txt = filterHtmlDocument(txt, folderName, uuid);

        return txt;
    }


    protected String filterHtmlDocument(String html, String folderName, long uuid) {

        if (html == null || html.length() == 0)
            return html;

        // Replace in-line images links to use Hupa's download servlet
        html = replaceAll(html, regex_inlineImg, repl_inlineImg).replaceAll("%%FOLDER%%", folderName).replaceAll(
                "%%UID%%", String.valueOf(uuid));
        // Remove head, script and style tags to avoid interferences with Hupa
        html = replaceAll(html, regex_badTags, repl_badTags);
        // Remove body and html tags
        html = replaceAll(html, regex_unneededTags, repl_unneededTags);
        // Remove all onClick attributes
        html = replaceAllRecursive(html, regex_badAttrs, repl_badAttrs);
        html = replaceAll(html, regex_existingHttpLinks, repl_existingHttpLinks);

        // FIXME: These have serious performance problems (see
        // testMessageDetails_Base64Image_Performance)
        // Add <a> tags to links which are not already into <a>
        // html = replaceAll(html, regex_orphandHttpLinks,
        // repl_orphandHttpLinks);
        // Add javascript method to <a> in order to open links in a different
        // window
        // Add <a> tags to emails which are not already into <a>
        // html = replaceAll(html, regex_orphandEmailLinks,
        // repl_orphandEmailLinks);
        // Add a js method to mailto links in order to compose new mails inside
        // hupa
        html = replaceAll(html, regex_existingEmailLinks, repl_existngEmailLinks);

        return html;
    }


    public List<ImapFolder> pullAll() throws MessagingException, HupaException {
        User user = getUser();
        try {

            // get the store for the user
            IMAPStore store = cache.get(user);
            com.sun.mail.imap.IMAPFolder folder = (com.sun.mail.imap.IMAPFolder) store.getDefaultFolder();

            // List of mail 'root' imap folders
            List<ImapFolder> imapFolders = new ArrayList<ImapFolder>();

            // Create IMAPFolder tree list
            for (Folder f : folder.list()) {
                ImapFolder imapFolder = createIMAPFolder(f);
                imapFolders.add(imapFolder);
                walkFolders(f, imapFolder);
            }

            return imapFolders;
        } catch (MessagingException e) {
            e.printStackTrace();
            logger.error("Unable to get folders for User " + user, e);
            e.printStackTrace();
            throw new MessagingException();
        }
    }


    public List<ImapFolder> requestFolders() throws Exception {
        User user = getUser();
        try {
            IMAPStore store = cache.get(user);
            com.sun.mail.imap.IMAPFolder folder = (com.sun.mail.imap.IMAPFolder) store.getDefaultFolder();

            // List of mail 'root' imap folders
            List<ImapFolder> imapFolders = new ArrayList<ImapFolder>();
            // Create IMAPFolder tree list
            for (Folder f : folder.list()) {
                ImapFolder imapFolder = createIMAPFolder(f);
                imapFolders.add(imapFolder);
                walkFolders(f, imapFolder);
            }
            return imapFolders;
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Unable to get folders for User " + user);
        }
    }


    private ImapFolder createIMAPFolder(Folder folder) throws MessagingException, HupaException {

        String fullName = folder.getFullName();
        String delimiter;
        ImapFolder iFolder = null;

        try {
            logger.debug("Creating folder: " + fullName + " for user: " + getUser());
            delimiter = String.valueOf(folder.getSeparator());
            iFolder = new ImapFolderImpl(fullName);
            iFolder.setHasChildren(true);
            iFolder.setDelimiter(delimiter);
            if ("[Gmail]".equals(folder.getFullName()))
                return iFolder;
            iFolder.setMessageCount(folder.getMessageCount());
            iFolder.setSubscribed(folder.isSubscribed());
            iFolder.setUnseenMessageCount(folder.getUnreadMessageCount());
        } catch (MessagingException e) {
            logger.error("Unable to construct folder " + folder.getFullName(), e);
        }

        return iFolder;
    }


    private ImapFolder createIMAPFolder(Folder folder) {

        String fullName = folder.getFullName();
        String delimiter;
        ImapFolder iFolder = null;

        try {
            delimiter = String.valueOf(folder.getSeparator());
            iFolder = new ImapFolderImpl(fullName);
            iFolder.setDelimiter(delimiter);
            if ("[Gmail]".equals(folder.getFullName()))
                return iFolder;
            iFolder.setMessageCount(folder.getMessageCount());
            iFolder.setSubscribed(folder.isSubscribed());
            iFolder.setUnseenMessageCount(folder.getUnreadMessageCount());
        } catch (MessagingException e) {
            e.printStackTrace();
        }

        return iFolder;
    }


    private ImapFolder createImapFolder(Folder folder) throws HupaException {
        String fullName = folder.getFullName();
        String delimiter;
        ImapFolder iFolder = null;
        try {
            new RuntimeException().printStackTrace();
            System.out.println("Creating folder2: " + fullName + " for user: " + this.getUser());
            delimiter = String.valueOf(folder.getSeparator());
            iFolder = new ImapFolderImpl(fullName);
            iFolder.setDelimiter(delimiter);
            if ("[Gmail]".equals(folder.getFullName()))
                return iFolder;
            iFolder.setMessageCount(folder.getMessageCount());
            iFolder.setSubscribed(folder.isSubscribed());
            iFolder.setUnseenMessageCount(folder.getUnreadMessageCount());
            if (folder.list().length != 0) {
                iFolder.setHasChildren(true);
            }
        } catch (MessagingException e) {
            e.printStackTrace();
        }
        return iFolder;
    }


    protected List getAttachments(SendMessageAction action) throws MessagingException, HupaException {
        SendReplyMessageAction replyAction = (SendReplyMessageAction)action;
        List<?> items = new ArrayList();
        IMAPStore store = cache.get(getUser());

        IMAPFolder folder = (IMAPFolder) store.getFolder(replyAction.getFolder().getFullName());
        if (folder.isOpen() == false) {
            folder.open(Folder.READ_ONLY);
        }

        // Only original inline images have to be added to the list
        Message msg = folder.getMessageByUID(replyAction.getUid());
        try {
            items = MessageUtils.extractInlineImages(logger, msg.getContent());
            if (items.size() > 0)
                logger.debug("Replying a message, extracted: " + items.size() + " inline image from");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Put into the list the attachments uploaded by the user
        items.addAll(super.getAttachments(replyAction));

        return items;
    }


    protected List getAttachments(SendMessageAction action) throws MessagingException, HupaException {
        SendForwardMessageAction forwardAction = (SendForwardMessageAction)action;
        List<?> items = new ArrayList();
        IMAPStore store = cache.get(getUser());

        IMAPFolder folder = (IMAPFolder) store.getFolder(forwardAction.getFolder().getFullName());
        if (folder.isOpen() == false) {
            folder.open(Folder.READ_ONLY);
        }
        // Put the original attachments in the list
        Message msg = folder.getMessageByUID(forwardAction.getUid());
        try {
            items = MessageUtils.extractMessageAttachments(logger, msg.getContent());
            logger.debug("Forwarding a message, extracted: " + items.size() + " from original.");
        } catch (IOException e) {
            e.printStackTrace();
        }
        // Put in the list the attachments uploaded by the user
        items.addAll(super.getAttachments(forwardAction));
        return items;
    }


    public FetchMessagesResult fetch(FetchMessagesAction action) throws HupaException {
        User user = getUser();
        // ImapFolder folder = action.getFolder();
        if (action.getFolder() == null || action.getFolder().getFullName() == null) {
            // folder = new
            // ImapFolderImpl(user.getSettings().getInboxFolderName());
            throw new IllegalArgumentException("why you want to ask us for messages in a null folder");
        }
        com.sun.mail.imap.IMAPFolder f = null;
        int start = action.getStart();
        int offset = action.getOffset();
        try {
            IMAPStore store = cache.get(user);

            f = (com.sun.mail.imap.IMAPFolder) store.getFolder(action.getFolder().getFullName());

            // check if the folder is open, if not open it read only
            if (f.isOpen() == false) {
                f.open(com.sun.mail.imap.IMAPFolder.READ_ONLY);
            }

            // if the folder is empty we have no need to process
            int exists = f.getMessageCount();
            if (exists == 0) {
                return new FetchMessagesResultImpl(new ArrayList<org.apache.hupa.shared.domain.Message>(), start,
                        offset, 0, 0);
            }

            MessageConvertArray convArray = getMessagesToConvert(f, action);
            return new FetchMessagesResultImpl(convert(offset, f, convArray.getMesssages()), start, offset,
                    convArray.getRealCount(), f.getUnreadMessageCount());
        } catch (MessagingException e) {
            logger.info("Error fetching messages in folder: " + action.getFolder().getFullName() + " " + e.getMessage());
            // Folder can not contain messages
            return new FetchMessagesResultImpl(new ArrayList<org.apache.hupa.shared.domain.Message>(), start, offset,
                    0, 0);
        } finally {
            if (f != null && f.isOpen()) {
                try {
                    f.close(false);
                } catch (MessagingException e) {
                    // we don't care to much about an exception on close here...
                }
            }
        }
    }


    public FetchMessagesResult fetch(FetchMessagesAction action) throws HupaException{
        User user = getUser();
        ImapFolder folder = action.getFolder();
        if (folder == null) {
            folder = new ImapFolderImpl(user.getSettings().getInboxFolderName());
        }
        com.sun.mail.imap.IMAPFolder f = null;
        int start = action.getStart();
        int offset = action.getOffset();
        try {
            IMAPStore store = cache.get(user);

            f =  (com.sun.mail.imap.IMAPFolder)store.getFolder(folder.getFullName());

             // check if the folder is open, if not open it read only
            if (f.isOpen() == false) {
                f.open(com.sun.mail.imap.IMAPFolder.READ_ONLY);
            }

            // if the folder is empty we have no need to process
            int exists = f.getMessageCount();
            if (exists == 0) {
                 return new FetchMessagesResultImpl(new ArrayList<org.apache.hupa.shared.domain.Message>(), start, offset, 0, 0);
            }

            MessageConvertArray convArray = getMessagesToConvert(f,action);
            return new FetchMessagesResultImpl(convert(offset, f, convArray.getMesssages()),start, offset,convArray.getRealCount(),f.getUnreadMessageCount());
        } catch (MessagingException e) {
            logger.info("Error fetching messages in folder: " + folder.getFullName() + " " + e.getMessage());
            // Folder can not contain messages
            return new FetchMessagesResultImpl(new ArrayList<org.apache.hupa.shared.domain.Message>(), start, offset, 0, 0);
        } finally {
            if (f != null && f.isOpen()) {
                try {
                    f.close(false);
                } catch (MessagingException e) {
                    // we don't care to much about an exception on close here...
                }
            }
        }
    }


    public List<org.apache.hupa.shared.domain.Message> convert(int offset, com.sun.mail.imap.IMAPFolder folder,
            Message[] messages) throws MessagingException {
        List<org.apache.hupa.shared.domain.Message> mList = new ArrayList<org.apache.hupa.shared.domain.Message>();

        // Setup fetchprofile to limit the stuff which is fetched
        FetchProfile fp = getFetchProfile();
        folder.fetch(messages, fp);

        // loop over the fetched messages
        for (int i = 0; i < messages.length && i < offset; i++) {
            org.apache.hupa.shared.domain.Message msg = new org.apache.hupa.shared.data.MessageImpl();
            Message message = messages[i];

            String from = null;
            if (message.getFrom() != null && message.getFrom().length > 0) {
                from = MessageUtils.decodeText(message.getFrom()[0].toString());
            }
            msg.setFrom(from);

            String replyto = null;
            if (message.getReplyTo() != null && message.getReplyTo().length > 0) {
                replyto = MessageUtils.decodeText(message.getReplyTo()[0].toString());
            }
            msg.setReplyto(replyto);

            ArrayList<String> to = new ArrayList<String>();
            // Add to addresses
            Address[] toArray = message.getRecipients(RecipientType.TO);
            if (toArray != null) {
                for (Address addr : toArray) {
                    String mailTo = MessageUtils.decodeText(addr.toString());
                    to.add(mailTo);
                }
            }
            msg.setTo(to);

            // Check if a subject exist and if so decode it
            String subject = message.getSubject();
            if (subject != null) {
                subject = MessageUtils.decodeText(subject);
            }
            msg.setSubject(subject);

            // Add cc addresses
            Address[] ccArray = message.getRecipients(RecipientType.CC);
            ArrayList<String> cc = new ArrayList<String>();
            if (ccArray != null) {
                for (Address addr : ccArray) {
                    String mailCc = MessageUtils.decodeText(addr.toString());
                    cc.add(mailCc);
                }
            }
            msg.setCc(cc);

            userPreferences.addContact(from);
            userPreferences.addContact(to);
            userPreferences.addContact(replyto);
            userPreferences.addContact(cc);

            // Using sentDate since received date is not useful in the view when
            // using fetchmail
            msg.setReceivedDate(message.getSentDate());

            // Add flags
            ArrayList<IMAPFlag> iFlags = JavamailUtil.convert(message.getFlags());

            ArrayList<Tag> tags = new ArrayList<Tag>();
            for (String flag : message.getFlags().getUserFlags()) {
                if (flag.startsWith(TagImpl.PREFIX)) {
                    tags.add(new TagImpl(flag.substring(TagImpl.PREFIX.length())));
                }
            }

            msg.setUid(folder.getUID(message));
            msg.setFlags(iFlags);
            msg.setTags(tags);
            try {
                msg.setHasAttachments(hasAttachment(message));
            } catch (MessagingException e) {
                logger.debug("Unable to identify attachments in message UID:" + msg.getUid() + " subject:"
                        + msg.getSubject() + " cause:" + e.getMessage());
                logger.info("");
            }
            mList.add(0, msg);

        }
        return mList;
    }


    protected List<org.apache.hupa.shared.domain.Message> convert(int offset, com.sun.mail.imap.IMAPFolder folder, Message[] messages) throws MessagingException {
        List<org.apache.hupa.shared.domain.Message> mList = new ArrayList<org.apache.hupa.shared.domain.Message>();
        // Setup fetchprofile to limit the stuff which is fetched
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.ENVELOPE);
        fp.add(FetchProfile.Item.FLAGS);
        fp.add(FetchProfile.Item.CONTENT_INFO);
        fp.add(UIDFolder.FetchProfileItem.UID);
        folder.fetch(messages, fp);

        // loop over the fetched messages
        for (int i = 0; i < messages.length && i < offset; i++) {
            org.apache.hupa.shared.domain.Message msg = new org.apache.hupa.shared.data.MessageImpl();
            Message m = messages[i];
            String from = null;
            if (m.getFrom() != null && m.getFrom().length >0 ) {
                from = MessageUtils.decodeText(m.getFrom()[0].toString());
            }
            msg.setFrom(from);

            String replyto = null;
            if (m.getReplyTo() != null && m.getReplyTo().length >0 ) {
                replyto = MessageUtils.decodeText(m.getReplyTo()[0].toString());
            }
            msg.setReplyto(replyto);

            ArrayList<String> to = new ArrayList<String>();
            // Add to addresses
            Address[] toArray = m.getRecipients(RecipientType.TO);
            if (toArray != null) {
                for (Address addr : toArray) {
                    String mailTo = MessageUtils.decodeText(addr.toString());
                    to.add(mailTo);
                }
            }
            msg.setTo(to);

            // Check if a subject exist and if so decode it
            String subject = m.getSubject();
            if (subject != null) {
                subject = MessageUtils.decodeText(subject);
            }
            msg.setSubject(subject);

            // Add cc addresses
            Address[] ccArray = m.getRecipients(RecipientType.CC);
            ArrayList<String> cc = new ArrayList<String>();
            if (ccArray != null) {
                for (Address addr : ccArray) {
                    String mailCc = MessageUtils.decodeText(addr.toString());
                    cc.add(mailCc);
                }
            }
            msg.setCc(cc);

            userPreferences.addContact(from);
            userPreferences.addContact(to);
            userPreferences.addContact(replyto);
            userPreferences.addContact(cc);

            // Using sentDate since received date is not useful in the view when using fetchmail
            msg.setReceivedDate(m.getSentDate());

            // Add flags
            ArrayList<IMAPFlag> iFlags = JavamailUtil.convert(m.getFlags());

            ArrayList<Tag> tags = new ArrayList<Tag>();
            for (String flag : m.getFlags().getUserFlags()) {
                if (flag.startsWith(TagImpl.PREFIX)) {
                    tags.add(new TagImpl(flag.substring(TagImpl.PREFIX.length())));
                }
            }

            msg.setUid(folder.getUID(m));
            msg.setFlags(iFlags);
            msg.setTags(tags);
            try {
                msg.setHasAttachments(hasAttachment(m));
            } catch (MessagingException e) {
                logger.debug("Unable to identify attachments in message UID:" + msg.getUid() + " subject:" + msg.getSubject() + " cause:" + e.getMessage());
                logger.info("");
            }
            mList.add(0, msg);

        }
        return mList;
    }


    private boolean hasAttachment(Message message) throws MessagingException {
        if (message.getContentType().startsWith("multipart/")) {
            try {
                Object content;

                content = message.getContent();

                if (content instanceof Multipart) {
                    Multipart mp = (Multipart) content;
                    if (mp.getCount() > 1) {
                        for (int i = 0; i < mp.getCount(); i++) {
                            String disp = mp.getBodyPart(i).getDisposition();
                            if (disp != null && disp.equalsIgnoreCase(Part.ATTACHMENT)) {
                                return true;
                            }
                        }
                    }

                }
            } catch (IOException e) {
                logger.error("Error while get content of message " + message.getMessageNumber());
            }

        }
        return false;
    }


    private boolean hasAttachment(Message message) throws MessagingException {
        if (message.getContentType().startsWith("multipart/")) {
            try {
                Object content;

                content = message.getContent();

                if (content instanceof Multipart) {
                    Multipart mp = (Multipart) content;
                    if (mp.getCount() > 1) {
                        for (int i = 0; i < mp.getCount(); i++) {
                            String disp = mp.getBodyPart(i).getDisposition();
                            if (disp != null
                                    && disp.equalsIgnoreCase(Part.ATTACHMENT)) {
                                return true;
                            }
                        }
                    }

                }
            } catch (IOException e) {
                logger.error("Error while get content of message " + message.getMessageNumber());
            }

        }
        return false;
    }


    public static String decodeText(String s) {
        String ret = s;
        try {
            ret = MimeUtility.decodeText(s);
        } catch (UnsupportedEncodingException e) {
            System.out.println(e.getMessage());
        }
        ret =  ret
          // Remove quotes around names in email addresses
          .replaceFirst("^[<\"' ]+([^\"<>]*)[>\"' ]+<", "$1 <");
        return ret;
    }


    public static String encodeTexts(String s) {
        String ret = s;
        if (s != null) {
            try {
                ret = MimeUtility.encodeText(s, "ISO-8859-1", null);
            } catch (UnsupportedEncodingException e) {
            }
        }
        return ret;
    }


    private static int getIntSetting(String name, int defaultValue) {
        String s = getProperty(name);
        if (s != null) {
            try {
                return Integer.decode(s).intValue();
            } catch (NumberFormatException e) {
                // ignore
            }
        }
        return defaultValue;
    }


    private static boolean getBooleanSetting(String name, boolean defaultValue) {
        String s = getProperty(name);
        if (s != null) {
            try {
                return Boolean.valueOf(s).booleanValue();
            } catch (NumberFormatException e) {
                // ignore
            }
        }
        return defaultValue;
    }


        private float getNodeBoost(Node config) {
            Node boost = config.getAttributes().getNamedItem("boost");
            if (boost != null) {
                try {
                    return Float.parseFloat(boost.getNodeValue());
                } catch (NumberFormatException e) {
                    // return default boost
                }
            }
            return DEFAULT_BOOST;
        }


                public int getDepth(Path path, PathResolver resolver) {
                    String depthStr = getProperty(PROP_DEFAULT_DEPTH);
                    if (depthStr != null) {
                        try {
                            return Integer.parseInt(depthStr);
                        } catch (Exception e) {
                            // ignore
                        }
                    }
                    return 4;
                }


    public Enumeration getAttributeNames() {
        return new Enumeration() {
            Iterator it = attributeMap.keySet().iterator();
            public boolean hasMoreElements() {
                return it.hasNext();
            }

            public Object nextElement() {
                return it.next();
            }

        };
    }


    public Iterator iterator() {
        return new Iterator() {
            Iterator i = names.iterator();

            public boolean hasNext() {
                return i.hasNext();
            }

            public Object next() {
                return i.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }


    public HandlerRegistration addValueChangeHandler(ValueChangeHandler<ColorPicker> handler) {
        assert changeHandler == null : "Change handler is already defined";
        changeHandler = handler;
        return new HandlerRegistration() {
            public void removeHandler() {
                changeHandler = null;
            }
        };
    }


    public HandlerRegistration addValueChangeHandler(ValueChangeHandler<FontPicker> handler) {
        assert changeHandler == null : "Change handler is already defined";
        changeHandler = handler;
        return new HandlerRegistration() {
            public void removeHandler() {
                changeHandler = null;
            }
        };
    }


    private void addSendingDisableds() {
        reply.addStyleName(style.disabledButton());
        replyAllGroup.addStyleName(style.disabledButton());
        replyAll.addStyleName(style.disabledButton());
        forwardGroup.addStyleName(style.disabledButton());
        forward.addStyleName(style.disabledButton());
        replyAllTip.addStyleName(style.disabledButton());
        forwardTip.addStyleName(style.disabledButton());
        raw.addStyleName(style.disabledButton());
    }


    private void removeSendingDisableds() {
        reply.removeStyleName(style.disabledButton());
        replyAllGroup.removeStyleName(style.disabledButton());
        replyAll.removeStyleName(style.disabledButton());
        forwardGroup.removeStyleName(style.disabledButton());
        forward.removeStyleName(style.disabledButton());
        replyAllTip.removeStyleName(style.disabledButton());
        forwardTip.removeStyleName(style.disabledButton());
        raw.removeStyleName(style.disabledButton());
    }


    public LabelListView(final HupaRequestFactory rf) {
        initWidget(binder.createAndBindUi(this));
        data = new ImapLabelListDataProvider();
        cellList = new CellList<LabelNode>(new LabelCell(), Resources.INSTANCE);
        cellList.setPageSize(100);// assume one's labels are under one hundred, otherwise we need a pager
        cellList.setSelectionModel(selectionModel);
        selectionModel.addSelectionChangeHandler(new SelectionChangeEvent.Handler() {
            public void onSelectionChange(SelectionChangeEvent event) {
                labelProperties.cascade(selectionModel.getSelectedObject(), data.getDataList(), CASCADE_TYPE_RENAME);
            }
        });
        thisView.setWidget(cellList);
    }


    public ContactsListView(final HupaRequestFactory rf) {
        initWidget(binder.createAndBindUi(this));
        data = new ImapLabelListDataProvider(rf);
        CellList<LabelNode> cellList = new CellList<LabelNode>(new LabelCell(), Resources.INSTANCE);
        cellList.setPageSize(100);// assume one's labels are under one hundred, otherwise we need a pager
        cellList.setSelectionModel(selectionModel);
        selectionModel.addSelectionChangeHandler(new SelectionChangeEvent.Handler() {
            public void onSelectionChange(SelectionChangeEvent event) {
            }
        });
        data.addDataDisplay(cellList);
        thisView.setWidget(cellList);
    }


        protected void onRangeChanged(HasData<LabelNode> display) {
            hupaStorage
                .gettingFolders()
                .done(new Function(){public void f() {
                    List<ImapFolder> response = arguments(0);
                    folderNodes.clear();
                    for (ImapFolder folder : response) {
                        fillCellList(folderNodes, folder, LabelNode.ROOT, "");
                    }
                    // For some reason removing a row does not update the display correctly
                    updateRowCount(folderNodes.size(), true);
                    updateRowData(0, folderNodes);
                 }});
        }


        protected void onRangeChanged(HasData<LabelNode> display, boolean skipCache) {
            hupaStorage
                .gettingFolders(skipCache)
                .done(new Function(){public void f() {
                    List<ImapFolder> response = arguments(0);
                    folderNodes.clear();
                    for (ImapFolder folder : response) {
                        fillCellList(folderNodes, folder, LabelNode.ROOT, "");
                    }
                    // For some reason removing a row does not update the display correctly
                    updateRowCount(folderNodes.size(), true);
                    updateRowData(0, folderNodes);
                 }});
        }


        private void fillCellList(List<LabelNode> folderNodes, ImapFolder curFolder, LabelNode parent, String intents) {
            LabelNode labelNode = new LabelNode();
            labelNode.setFolder(curFolder);
            labelNode.setName(curFolder.getName());
            labelNode.setNameForDisplay(intents + curFolder.getName());
            labelNode.setParent(parent);
            labelNode.setPath(curFolder.getFullName());
            folderNodes.add(labelNode);
            if (curFolder.getHasChildren()) {
                for (ImapFolder subFolder : curFolder.getChildren()) {
                    // FIXME: don't use intents, it will be much better user experience to use cellTree
                    fillCellList(folderNodes, subFolder, labelNode, intents + "&nbsp;&nbsp;&nbsp;&nbsp;");
                }
            }
        }


        private void fillCellList(List<LabelNode> folderNodes, ImapFolder curFolder, LabelNode parent, String intents) {
            LabelNode labelNode = new LabelNode();
            labelNode.setFolder(curFolder);
            labelNode.setName(curFolder.getName());
            labelNode.setNameForDisplay(intents + curFolder.getName());
            labelNode.setParent(parent);
            labelNode.setPath(curFolder.getFullName());
            folderNodes.add(labelNode);
            if (curFolder.getHasChildren()) {
                for (ImapFolder subFolder : curFolder.getChildren()) {
                    // FIXME: don't use intents, it will be much better user experience to use cellTree
                    fillCellList(folderNodes, subFolder, labelNode, intents + "&nbsp;&nbsp;&nbsp;&nbsp;");
                }
            }
        }


    public void render(com.google.gwt.cell.client.Cell.Context context, LabelNode value, SafeHtmlBuilder sb) {
        if (value == null) {
            return;
        }

        if (value.getFolder().getSubscribed()) {
            sb.appendHtmlConstant(value.getNameForDisplay());
        } else {
            sb.appendHtmlConstant("<span style='color:gray;'>");
            sb.appendHtmlConstant(value.getNameForDisplay());
            sb.appendHtmlConstant("</span>");
        }
    }


        public void render(com.google.gwt.cell.client.Cell.Context context, LabelNode value, SafeHtmlBuilder sb) {
            if (value == null) {
                return;
            }

            if (value.getFolder().getSubscribed()) {
                sb.appendHtmlConstant(value.getNameForDisplay());
            } else {
                sb.appendHtmlConstant("<span style='color:gray;'>");
                sb.appendHtmlConstant(value.getNameForDisplay());
                sb.appendHtmlConstant("</span>");
            }
        }


    protected Column<Message, SafeHtml> getFromColumn () {
        return new Column<Message, SafeHtml>(new SafeHtmlCell()) {
            @Override
            public SafeHtml getValue(Message object) {
                SafeHtmlBuilder sb = new SafeHtmlBuilder();
                sb.append(SafeHtmlUtils.fromString(object.getFrom() == null ? "" : object.getFrom()));
                return sb.toSafeHtml();
            }
        };
    }


    protected Column<Message, SafeHtml> getSubjectColumn () {
        return new Column<Message, SafeHtml>(new SafeHtmlCell()) {
            @Override
            public SafeHtml getValue(Message object) {
                SafeHtmlBuilder sb = new SafeHtmlBuilder();
                sb.append(SafeHtmlUtils.fromString(object.getSubject() == null ? "" : object.getSubject()));
                return sb.toSafeHtml();
            }
        };
    }


    public CachingToolBarActivityMapper(ToolBarActivityMapper toolBarActivityMapper) {

        FilteredActivityMapper.Filter filter = new FilteredActivityMapper.Filter() {
            @Override
            public Place filter(Place place) {
                return place instanceof MessagePlace ? Place.NOWHERE : place;
            }
        };

        CachingActivityMapper cachingActivityMapper = new CachingActivityMapper(toolBarActivityMapper);
        filteredActivityMapper = new FilteredActivityMapper(filter, cachingActivityMapper);
    }


    public CachingMessageListActivityMapper(MessageListActivityMapper messageListActivityMapper) {

        FilteredActivityMapper.Filter filter = new FilteredActivityMapper.Filter() {
            @Override
            public Place filter(Place place) {
                return place instanceof MessagePlace ? new FolderPlace(((MessagePlace) place).getTokenWrapper()
                        .getFolder()) : place;
            }
        };

        filteredActivityMapper = new FilteredActivityMapper(filter,
                new CachingActivityMapper(messageListActivityMapper));
    }


    public CachingTopBarActivityMapper(TopBarActivityMapper topBarActivityMapper) {

        FilteredActivityMapper.Filter filter = new FilteredActivityMapper.Filter() {
            @Override
            public Place filter(Place place) {
                return place;
            }
        };

        CachingActivityMapper cachingActivityMapper = new CachingActivityMapper(topBarActivityMapper);
        filteredActivityMapper = new FilteredActivityMapper(filter, cachingActivityMapper);
    }


    public Activity getActivity(Place place) {
        if(place instanceof DefaultPlace) return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return searchBoxActivityProvider.get();
            }
        };
    }


    protected Activity asyncLoadActivity(final Place place) {
        if (!(place instanceof SettingPlace))
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return labelListActivityProvider.get();
            }
        };

    }


    protected Activity asyncLoadActivity(final Place place) {
        if (!(place instanceof ComposePlace))
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return addressListActivityProvider.get();
            }
        };

    }


    protected Activity asyncLoadActivity(final Place place) {
        if (!(place instanceof ContactPlace))
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return contactsListActivityProvider.get();
            }
        };

    }


    public Activity getActivity(Place place) {
        if (!(place instanceof SettingPlace))
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return labelPropertiesActivityProvider.get();
            }
        };
    }


    public Activity getActivity(Place place) {
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return loginActivityProvider.get();
            }
        };
    }


    protected Activity asyncLoadActivity(final Place place) {
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return topBarActivityProvider.get();
            }
        };
    }


    public Activity asyncLoadActivity(Place place) {
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return notificationActivityProvider.get();
            }
        };
    }


    public Activity asyncLoadActivity(Place place) {
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return logoActivityProvider.get();
            }
        };
    }


    protected Activity asyncLoadActivity(Place place) {
        if(place instanceof DefaultPlace) return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return settingNavActivityProvider.get();
            }
        };
    }


    protected Activity lazyLoadActivity(Place place) {return new ActivityAsyncProxy() {
        @Override
        protected void doAsync(RunAsyncCallback callback) {
            GWT.runAsync(callback);
        }

        @Override
        protected Activity createInstance() {
            return messageListFooterActivityProvider.get();
        }
    };}


    public Activity getActivity(Place place) {
        if (!(place instanceof ContactPlace))
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return contactPropertiesActivityProvider.get();
            }
        };
    }


    protected Activity lazyLoadActivity(final Place place) {
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                if (place instanceof MessagePlace) {
                    return messageContentActivityProvider.get().with(((MessagePlace) place).getTokenWrapper());
                }
                return messageContentActivityProvider.get();
            }
        };
    }


    public Activity getActivity(Place place) {
        if(place instanceof DefaultPlace) return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return statusActivityProvider.get();
            }
        };
    }


    public Activity getActivity(Place place) {
        if(place instanceof DefaultPlace) return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return navigationActivityProvider.get();
            }
        };
    }


    public Activity getActivity(Place place) {
        if (!(place instanceof ComposePlace))
            return null;
        final ComposePlace here = (ComposePlace) place;
        if (!"new".equals(here.getToken()) && here.getParameters() == null)
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return composeToolBarActivityProvider.get().with(here);
            }
        };
    }


    protected Activity asyncLoadActivity(final Place place) {
        if (place instanceof SettingPlace)
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return folderListActivityProvider.get();
            }
        };

    }


    public Activity getActivity(final Place place) {
        if (!(place instanceof ComposePlace))
            return null;
        final ComposePlace here = (ComposePlace) place;
        if (!"new".equals(here.getToken()) && here.getParameters() == null)
            return null;
        return new ActivityAsyncProxy() {
            @Override
            protected void doAsync(RunAsyncCallback callback) {
                GWT.runAsync(callback);
            }

            @Override
            protected Activity createInstance() {
                return composeActivityProvider.get().with(here);
            }
        };
    }


    private void bindTo(final EventBus eventBus) {
        this.registerHandler(display.getDelete().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(ClickEvent event) {
                if (Window.confirm("Are you sure?")) {
                    eventBus.fireEvent(new DeleteFolderEvent());
                }
            }
        }));
        eventBus.addHandler(DeleteFolderEvent.TYPE, new DeleteFolderEventHandler() {
            @Override
            public void onDeleteFolderEvent(DeleteFolderEvent event) {
                deleteSelected();
            }
        });
        eventBus.addHandler(RefreshLabelListEvent.TYPE, new RefreshLabelListEventHandler(){
            @Override
            public void onRefreshEvent(RefreshLabelListEvent event) {
                display.refresh();
            }
        });
    }


    private void bindTo(final EventBus eventBus) {
        this.registerHandler(display.getDelete().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(ClickEvent event) {
                if (Window.confirm("Are you sure?")) {
                    eventBus.fireEvent(new DeleteFolderEvent());
                }
            }
        }));
        eventBus.addHandler(DeleteFolderEvent.TYPE, new DeleteFolderEventHandler() {
            @Override
            public void onDeleteFolderEvent(DeleteFolderEvent event) {
                deleteSelected();
            }
        });
        eventBus.addHandler(RefreshLabelListEvent.TYPE, new RefreshLabelListEventHandler(){
            @Override
            public void onRefreshEvent(RefreshLabelListEvent event) {
                display.refresh();
            }
        });
    }


    public void deleteSelected() {
        hupaController.showTopLoading("Deleting...");
        SingleSelectionModel<LabelNode> selectionModel = display.getSelectionModel();
        LabelNode labelNode = selectionModel.getSelectedObject();
        DeleteFolderRequest req = rf.deleteFolderRequest();
        DeleteFolderAction action = req.create(DeleteFolderAction.class);
        final ImapFolder f = req.create(ImapFolder.class);
        f.setFullName(labelNode.getFolder().getFullName());
        action.setFolder(f);
        req.delete(action).fire(new Receiver<GenericResult>() {
            @Override
            public void onSuccess(GenericResult response) {
                hupaController.hideTopLoading();
                display.refresh();
                hupaController.showNotice("The label \"" + f.getFullName() + "\" was deleted.", 10000);
            }
            @Override
            public void onFailure(ServerFailure error) {
                hupaController.hideTopLoading();
                hupaController.showNotice(error.getMessage(), 10000);
            }
        });
    }


    public void deleteSelected() {
        hupaController.showTopLoading("Deleting...");
        SingleSelectionModel<LabelNode> selectionModel = display.getSelectionModel();
        LabelNode labelNode = selectionModel.getSelectedObject();
        DeleteFolderRequest req = rf.deleteFolderRequest();
        DeleteFolderAction action = req.create(DeleteFolderAction.class);
        final ImapFolder f = req.create(ImapFolder.class);
        f.setFullName(labelNode.getFolder().getFullName());
        action.setFolder(f);
        req.delete(action).fire(new Receiver<GenericResult>() {
            @Override
            public void onSuccess(GenericResult response) {
                hupaController.hideTopLoading();
                display.refresh();
                hupaController.showNotice("The label \"" + f.getFullName() + "\" was deleted.", 10000);
            }
            @Override
            public void onFailure(ServerFailure error) {
                hupaController.hideTopLoading();
                hupaController.showNotice(error.getMessage(), 10000);
            }
        });
    }


    protected ArrayList<String> removeEmailFromList(List<String> list, String email) {
        ArrayList<String> ret = new ArrayList<String>();
        String regex = ".*<?\\s*" + email.trim() + "\\s*>?\\s*";
        for (String e : list) {
            if (!e.matches(regex)) {
                ret.add(e);
            }
        }
        return ret;
    }


    private <T extends BaseProxy> ArrayList<String> getIds(Collection<T> proxies) {
        ArrayList<String> ids = new ArrayList<String>();
        for (T i : proxies) {
            String id = getKey(i);
            if (id != null) {
                ids.add(id);
            }
        }
        return ids;
    }


    public <T extends BaseProxy> List<T> restoreProxies(Class<T> clz, String key, boolean crypt) {
        ArrayList<T> ret = new ArrayList<T>();
        for (String i : getStoredIdsByIdx(key)) {
            T proxy = restoreProxy(clz, i, crypt);
            if (proxy != null) {
                ret.add(proxy);
            }
        }
        return ret;
    }


    public Set<XmlSerializable> getValue() {
        Set<XmlSerializable> rTypes = new HashSet<XmlSerializable>();
        for (int resourceType : resourceTypes) {
            TypeName n = NAMES.get(resourceType);
            if (n != null) {
                rTypes.add(n);
            }
        }
        return rTypes;
    }


    public static Operation create(PropertyState propState, QValue[] qValues,
                                   int valueType) throws RepositoryException {
        // compact array (purge null entries)
        List<QValue> list = new ArrayList<QValue>();
        for (QValue qValue : qValues) {
            if (qValue != null) {
                list.add(qValue);
            }
        }
        QValue[] cleanValues = list.toArray(new QValue[list.size()]);
        SetPropertyValue sv = new SetPropertyValue(propState, valueType, cleanValues);
        return sv;
    }


    public Promise gettingFolders(final boolean skipCache) {
        return GQuery
        .when(waitingForLogin())
        .then(new Function() {
            public Object f(Object... args) {
                List<ImapFolder> t = skipCache ? null: cache.restoreProxies(ImapFolder.class, KEY_CACHE_FOLDERS);
                if (t != null && !t.isEmpty()) {
                    return GQuery.Deferred().resolve(t).promise();
                } else {
                    return new PromiseRF(rf.fetchFoldersRequest().fetch(null, Boolean.TRUE))
                    .done(new Function(){public void f() {
                        List<ImapFolder> folderNodes = arguments(0);
                        cache.storeProxies(KEY_CACHE_FOLDERS, folderNodes);
                    }});
                }
            }
        });
    }


    public Promise gettingSettings(final boolean skipCache) {
        return GQuery
        .when(waitingForLogin())
        .then(new Function() {
            public Object f(Object... args) {
                List<ImapFolder> t = skipCache ? null: cache.restoreProxies(ImapFolder.class, KEY_CACHE_FOLDERS);
                if (t != null && !t.isEmpty()) {
                    return GQuery.Deferred().resolve(t).promise();
                } else {
                    return new PromiseRF(rf.fetchFoldersRequest().fetch(null, Boolean.TRUE))
                    .done(new Function(){public void f() {
                        List<ImapFolder> folderNodes = arguments(0);
                        cache.storeProxies(KEY_CACHE_FOLDERS, folderNodes);
                    }});
                }
            }
        });
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        boolean deep = Boolean.valueOf((String) ctx.get(this.deepKey))
            .booleanValue();
        boolean sessionScoped = Boolean.valueOf(
            (String) ctx.get(this.sessionScopedKey)).booleanValue();
        if (log.isDebugEnabled()) {
            log.debug("locking node at " + path + " deep=" + deep
                    + " sessionScoped=" + sessionScoped);
        }
        CommandHelper.getNode(ctx, path).lock(deep, sessionScoped);
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        String srcWorkspace = (String) ctx.get(this.srcWorkspaceKey);
        boolean bestEffort = Boolean.valueOf(
            (String) ctx.get(this.bestEffortKey)).booleanValue();
        if (log.isDebugEnabled()) {
            log.debug("merging node at " + path + " from workspace "
                    + srcWorkspace + " besteffort=" + bestEffort);
        }
        CommandHelper.getNode(ctx, path).merge(srcWorkspace, bestEffort);
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        String versionLabel = (String) ctx.get(this.labelKey);
        boolean removeExisting = Boolean.valueOf(
            (String) ctx.get(this.removeExistingKey)).booleanValue();
        if (log.isDebugEnabled()) {
            log.debug("restoring node at " + path + " to version label "
                    + versionLabel + " removeexisting=" + removeExisting);
        }
        CommandHelper.getNode(ctx, path).restoreByLabel(versionLabel,
            removeExisting);
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        String versionName = (String) ctx.get(this.versionKey);
        boolean removeExisting = Boolean.valueOf(
            (String) ctx.get(this.removeExistingKey)).booleanValue();
        if (log.isDebugEnabled()) {
            log.debug("restoring node at " + path + " to version "
                    + versionName + " removeexisting=" + removeExisting);
        }
        CommandHelper.getNode(ctx, path).restore(versionName, removeExisting);
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        String versionName = (String) ctx.get(this.versionKey);
        boolean moveLabel = Boolean
            .valueOf((String) ctx.get(this.moveLabelKey)).booleanValue();
        String versionLabel = (String) ctx.get(this.labelKey);
        if (log.isDebugEnabled()) {
            log.debug("Add label " + versionLabel + " to version  "
                    + versionName + " of node at " + path);
        }
        CommandHelper.getNode(ctx, path).getVersionHistory().addVersionLabel(
            versionName, versionLabel, moveLabel);
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String parentPath = (String) ctx.get(this.parentPathKey);
        Node n = CommandHelper.getNode(ctx, parentPath);

        String srcChildPath = (String) ctx.get(this.srcChildKey);
        String destChildPath = (String) ctx.get(this.destChildKey);

        if (log.isDebugEnabled()) {
            log
                .debug("ordering before. from " + n.getPath() + "/"
                        + srcChildPath + " to " + n.getPath() + "/"
                        + destChildPath);
        }

        n.orderBefore(srcChildPath, destChildPath);

        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        InputStream value = (InputStream) ctx.get(this.valueKey);
        String name = (String) ctx.get(this.nameKey);
        String parent = (String) ctx.get(this.parentPathKey);

        Node node = CommandHelper.getNode(ctx, parent);
        if (log.isDebugEnabled()) {
            log.debug("setting property to node at " + node.getPath()
                    + ". property=" + name + " value=" + value);
        }

        node.setProperty(name, value);

        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String value = (String) ctx.get(this.valueKey);
        String name = (String) ctx.get(this.nameKey);
        String propertyType = (String) ctx.get(this.typeKey);
        String parent = (String) ctx.get(this.parentPathKey);

        Node node = CommandHelper.getNode(ctx, parent);
        if (log.isDebugEnabled()) {
            log.debug("setting property to node at " + node.getPath()
                    + ". property=" + name + " value=" + value);
        }
        if (propertyType == null) {
            node.setProperty(name, value);
        } else {
            node.setProperty(name, value, PropertyType
                .valueFromName(propertyType));
        }
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String regExp = (String) ctx.get(this.regExpKey);
        String value = (String) ctx.get(this.valueKey);
        String name = (String) ctx.get(this.nameKey);
        String type = (String) ctx.get(this.typeKey);
        String parent = (String) ctx.get(this.parentPathKey);

        Node node = CommandHelper.getNode(ctx, parent);

        if (log.isDebugEnabled()) {
            log.debug("setting multivalue property from node at "
                    + node.getPath() + ". regexp=" + regExp + " value=" + value
                    + " property=" + name);
        }

        String[] values = value.split(regExp);

        if (type == null) {
            node.setProperty(name, values);
        } else {
            node.setProperty(name, values, PropertyType.valueFromName(type));
        }

        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String path = (String) ctx.get(this.pathKey);
        String label = (String) ctx.get(this.labelKey);
        if (log.isDebugEnabled()) {
            log.debug("Remove version with label " + label + " from node "
                    + path);
        }
        VersionHistory vh = CommandHelper.getNode(ctx, path)
            .getVersionHistory();
        Version v = vh.getVersionByLabel(label);
        vh.removeVersion(v.getName());
        return false;
    }


    public boolean execute(Context ctx) throws Exception {
        String config = (String) ctx.get(this.configKey);
        String home = (String) ctx.get(this.homeKey);
        if (log.isDebugEnabled()) {
            log
                    .debug("starting jackrabbit. config=" + config + " home="
                            + home);
        }
        RepositoryConfig conf = RepositoryConfig.create(config, home);
        Repository repo = RepositoryImpl.create(conf);
        CommandHelper.setRepository(ctx, repo, "local " + home);
        return false;
    }


    public Collection getRequiredArguments() {
        Predicate p = new Predicate() {
            public boolean evaluate(Object o) {
                Argument arg = (Argument) o;
                return arg.isRequired();
            }
        };
        return CollectionUtils.select(this.arguments.values(), p);
    }


    public Collection getRequiredOptions() {
        Predicate p = new Predicate() {
            public boolean evaluate(Object o) {
                Option opt = (Option) o;
                return opt.isRequired();
            }
        };
        return CollectionUtils.select(this.options.values(), p);
    }


    protected void setUp() throws Exception {
        this.uri = URI.create(System.getProperty("webdav.test.url"));
        this.root = this.uri.toASCIIString();
        if (!this.root.endsWith("/")) {
            this.root += "/";
        }
        this.username = System.getProperty(("webdav.test.username"), "");
        this.password = System.getProperty(("webdav.test.password"), "");
        this.client = new HttpClient();
        this.client.getState().setCredentials(
                new AuthScope(this.uri.getHost(), this.uri.getPort()),
                new UsernamePasswordCredentials(this.username, this.password));
        super.setUp();
    }


    protected void setUp() throws Exception {
        this.uri = URI.create(System.getProperty("webdav.test.url"));
        this.root = this.uri.toASCIIString();
        if (!this.root.endsWith("/")) {
            this.root += "/";
        }
        this.username = System.getProperty(("webdav.test.username"), "");
        this.password = System.getProperty(("webdav.test.password"), "");
        this.client = new HttpClient();
        this.client.getState().setCredentials(
                new AuthScope(this.uri.getHost(), this.uri.getPort()),
                new UsernamePasswordCredentials(this.username, this.password));
        super.setUp();
    }


    protected void setUp() throws Exception {
        this.uri = URI.create(System.getProperty("webdav.test.url"));
        this.root = this.uri.toASCIIString();
        if (!this.root.endsWith("/")) {
            this.root += "/";
        }
        this.username = System.getProperty(("webdav.test.username"), "");
        this.password = System.getProperty(("webdav.test.password"), "");
        this.client = new HttpClient();
        this.client.getState().setCredentials(
                new AuthScope(this.uri.getHost(), this.uri.getPort()),
                new UsernamePasswordCredentials(this.username, this.password));
        super.setUp();
    }


    protected void setUp() throws Exception {
        this.uri = URI.create(System.getProperty("webdav.test.url"));
        this.root = this.uri.toASCIIString();
        if (!this.root.endsWith("/")) {
            this.root += "/";
        }
        this.username = System.getProperty(("webdav.test.username"), "");
        this.password = System.getProperty(("webdav.test.password"), "");
        this.client = new HttpClient();
        this.client.getState().setCredentials(
                new AuthScope(this.uri.getHost(), this.uri.getPort()),
                new UsernamePasswordCredentials(this.username, this.password));
        super.setUp();
    }


    private URI getResourceId(String uri) throws IOException, DavException, URISyntaxException {
        DavPropertyNameSet names = new DavPropertyNameSet();
        names.add(BindConstants.RESOURCEID);
        PropFindMethod propfind = new PropFindMethod(uri, names, 0);
        int status = this.client.executeMethod(propfind);
        assertEquals(207, status);
        MultiStatus multistatus = propfind.getResponseBodyAsMultiStatus();
        MultiStatusResponse[] responses = multistatus.getResponses();
        assertEquals(1, responses.length);
        DavProperty resourceId = responses[0].getProperties(200).get(BindConstants.RESOURCEID);
        assertNotNull(resourceId);
        assertTrue(resourceId.getValue() instanceof Element);
        Element href = (Element)resourceId.getValue();
        assertEquals("href", href.getLocalName());
        String text = getUri(href);
        URI resid = new URI(text);
        return resid;
    }


    private DavProperty getParentSet(String uri) throws IOException, DavException, URISyntaxException {
        DavPropertyNameSet names = new DavPropertyNameSet();
        names.add(BindConstants.PARENTSET);
        PropFindMethod propfind = new PropFindMethod(uri, names, 0);
        int status = this.client.executeMethod(propfind);
        assertEquals(207, status);
        MultiStatus multistatus = propfind.getResponseBodyAsMultiStatus();
        MultiStatusResponse[] responses = multistatus.getResponses();
        assertEquals(1, responses.length);
        DavProperty parentset = responses[0].getProperties(200).get(BindConstants.PARENTSET);
        assertNotNull(parentset);
        return parentset;
    }


    public void testSimpleBind() throws Exception {
        String testcol = this.root + "testSimpleBind/";
        String subcol1 = testcol + "bindtest1/";
        String testres1 = subcol1 + "res1";
        String subcol2 = testcol + "bindtest2/";
        String testres2 = subcol2 + "res2";
        int status;
        try {
            MkColMethod mkcol = new MkColMethod(testcol);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol1);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol2);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);

            //create new resource R with path bindtest1/res1
            PutMethod put = new PutMethod(testres1);
            put.setRequestEntity(new StringRequestEntity("foo", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            //create new binding of R with path bindtest2/res2
            DavMethodBase bind = new BindMethod(subcol2, new BindInfo(testres1, "res2"));
            status = this.client.executeMethod(bind);
            assertEquals(201, status);
            //check if both bindings report the same DAV:resource-id
            assertEquals(this.getResourceId(testres1), this.getResourceId(testres2));

            //compare representations retrieved with both paths
            GetMethod get = new GetMethod(testres1);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());
            get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());

            //modify R using the new path
            put = new PutMethod(testres2);
            put.setRequestEntity(new StringRequestEntity("bar", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertTrue("status: " + status, status == 200 || status == 204);

            //compare representations retrieved with both paths
            get = new GetMethod(testres1);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("bar", get.getResponseBodyAsString());
            get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("bar", get.getResponseBodyAsString());
        } finally {
            DeleteMethod delete = new DeleteMethod(testcol);
            status = this.client.executeMethod(delete);
            assertTrue("status: " + status, status == 200 || status == 204);
        }
    }


    public void testUnbind() throws Exception {
        String testcol = this.root + "testUnbind/";
        String subcol1 = testcol + "bindtest1/";
        String testres1 = subcol1 + "res1";
        String subcol2 = testcol + "bindtest2/";
        String testres2 = subcol2 + "res2";
        int status;
        try {
            MkColMethod mkcol = new MkColMethod(testcol);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol1);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol2);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);

            //create new resource R with path testSimpleBind/bindtest1/res1
            PutMethod put = new PutMethod(testres1);
            put.setRequestEntity(new StringRequestEntity("foo", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            //create new binding of R with path testSimpleBind/bindtest2/res2
            DavMethodBase bind = new BindMethod(subcol2, new BindInfo(testres1, "res2"));
            status = this.client.executeMethod(bind);
            assertEquals(201, status);
            //check if both bindings report the same DAV:resource-id
            assertEquals(this.getResourceId(testres1), this.getResourceId(testres2));

            //remove new path
            UnbindMethod unbind = new UnbindMethod(subcol2, new UnbindInfo("res2"));
            status = this.client.executeMethod(unbind);
            assertTrue("status: " + status, status == 200 || status == 204);

            //verify that the new binding is gone
            HeadMethod head = new HeadMethod(testres2);
            status = this.client.executeMethod(head);
            assertEquals(404, status);

            //verify that the initial binding is still there
            head = new HeadMethod(testres1);
            status = this.client.executeMethod(head);
            assertEquals(200, status);
        } finally {
            DeleteMethod delete = new DeleteMethod(testcol);
            status = this.client.executeMethod(delete);
            assertTrue("status: " + status, status == 200 || status == 204);
        }
    }


    public void testRebindOverwrite() throws Exception {
        String testcol = this.root + "testSimpleBind/";
        String subcol1 = testcol + "bindtest1/";
        String testres1 = subcol1 + "res1";
        String subcol2 = testcol + "bindtest2/";
        String testres2 = subcol2 + "res2";
        int status;
        try {
            MkColMethod mkcol = new MkColMethod(testcol);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol1);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol2);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);

            //create new resource R with path testSimpleBind/bindtest1/res1
            PutMethod put = new PutMethod(testres1);
            put.setRequestEntity(new StringRequestEntity("foo", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            // enabling version control always makes the resource referenceable
            VersionControlMethod versioncontrol = new VersionControlMethod(testres1);
            status = this.client.executeMethod(versioncontrol);
            assertTrue("status: " + status, status == 200 || status == 201);

            //create new resource R' with path testSimpleBind/bindtest2/res2
            put = new PutMethod(testres2);
            put.setRequestEntity(new StringRequestEntity("bar", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            //try rebind R with path testSimpleBind/bindtest2/res2 and Overwrite:F
            RebindMethod rebind = new RebindMethod(subcol2, new RebindInfo(testres1, "res2"));
            rebind.addRequestHeader(new Header("Overwrite", "F"));
            status = this.client.executeMethod(rebind);
            assertEquals(412, status);

            //verify that testSimpleBind/bindtest2/res2 still points to R'
            GetMethod get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("bar", get.getResponseBodyAsString());

            //rebind R with path testSimpleBind/bindtest2/res2
            rebind = new RebindMethod(subcol2, new RebindInfo(testres1, "res2"));
            status = this.client.executeMethod(rebind);
            assertTrue("status: " + status, status == 200 || status == 204);

            //verify that testSimpleBind/bindtest2/res2 now points to R
            get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());

            //verify that the initial binding is gone
            HeadMethod head = new HeadMethod(testres1);
            status = this.client.executeMethod(head);
            assertEquals(404, status);
        } finally {
            DeleteMethod delete = new DeleteMethod(testcol);
            status = this.client.executeMethod(delete);
            assertTrue("status: " + status, status == 200 || status == 204);
        }
    }


    public void testBindOverwrite() throws Exception {
        String testcol = this.root + "testSimpleBind/";
        String subcol1 = testcol + "bindtest1/";
        String testres1 = subcol1 + "res1";
        String subcol2 = testcol + "bindtest2/";
        String testres2 = subcol2 + "res2";
        int status;
        try {
            MkColMethod mkcol = new MkColMethod(testcol);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol1);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol2);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);

            //create new resource R with path bindtest1/res1
            PutMethod put = new PutMethod(testres1);
            put.setRequestEntity(new StringRequestEntity("foo", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            //create new resource R' with path bindtest2/res2
            put = new PutMethod(testres2);
            put.setRequestEntity(new StringRequestEntity("bar", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            //try to create new binding of R with path bindtest2/res2 and Overwrite:F
            DavMethodBase bind = new BindMethod(subcol2, new BindInfo(testres1, "res2"));
            bind.addRequestHeader(new Header("Overwrite", "F"));
            status = this.client.executeMethod(bind);
            assertEquals(412, status);

            //verify that bindtest2/res2 still points to R'
            GetMethod get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("bar", get.getResponseBodyAsString());

            //create new binding of R with path bindtest2/res2
            bind = new BindMethod(subcol2, new BindInfo(testres1, "res2"));
            status = this.client.executeMethod(bind);
            assertTrue("status: " + status, status == 200 || status == 204);

            //verify that bindtest2/res2 now points to R
            get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());

            //verify that the initial binding is still there
            HeadMethod head = new HeadMethod(testres1);
            status = this.client.executeMethod(head);
            assertEquals(200, status);
        } finally {
            DeleteMethod delete = new DeleteMethod(testcol);
            status = this.client.executeMethod(delete);
            assertTrue("status: " + status, status == 200 || status == 204);
        }
    }


    public void testRebind() throws Exception {
        String testcol = this.root + "testRebind/";
        String subcol1 = testcol + "bindtest1/";
        String testres1 = subcol1 + "res1";
        String subcol2 = testcol + "bindtest2/";
        String testres2 = subcol2 + "res2";
        int status;
        try {
            MkColMethod mkcol = new MkColMethod(testcol);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol1);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);
            mkcol = new MkColMethod(subcol2);
            status = this.client.executeMethod(mkcol);
            assertEquals(201, status);

            //create new resource R with path bindtest1/res1
            PutMethod put = new PutMethod(testres1);
            put.setRequestEntity(new StringRequestEntity("foo", "text/plain", "UTF-8"));
            status = this.client.executeMethod(put);
            assertEquals(201, status);

            // enabling version control always makes the resource referenceable
            VersionControlMethod versioncontrol = new VersionControlMethod(testres1);
            status = this.client.executeMethod(versioncontrol);
            assertTrue("status: " + status, status == 200 || status == 201);

            URI r1 = this.getResourceId(testres1);

            GetMethod get = new GetMethod(testres1);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());

            //rebind R with path bindtest2/res2
            DavMethodBase rebind = new RebindMethod(subcol2, new RebindInfo(testres1, "res2"));
            status = this.client.executeMethod(rebind);
            assertEquals(201, status);

            URI r2 = this.getResourceId(testres2);

            get = new GetMethod(testres2);
            status = this.client.executeMethod(get);
            assertEquals(200, status);
            assertEquals("foo", get.getResponseBodyAsString());

            //make sure that rebind did not change the resource-id
            assertEquals(r1, r2);

            //verify that the initial binding is gone
            HeadMethod head = new HeadMethod(testres1);
            status = this.client.executeMethod(head);
            assertEquals(404, status);
        } finally {
            DeleteMethod delete = new DeleteMethod(testcol);
            status = this.client.executeMethod(delete);
            assertTrue("status: " + status, status == 200 || status == 204);
        }
    }


    private static void testValid(CSRFUtil util, Collection<String> validURLs, String method, Set<String> contentTypes) {
        if (null == contentTypes) {
            for (String url : validURLs) {
                assertTrue(url, util.isValidRequest(createRequest(url, method, noContentType)));
            }
        } else {
            for (String contentType : contentTypes) {
                for (String url : validURLs) {
                    assertTrue(url, util.isValidRequest(createRequest(url, method, contentType)));
                }
            }
        }
    }


    private static void testInvalid(CSRFUtil util, Collection<String> invalidURLs, String method, Set<String> contentTypes) {
        if (null == contentTypes) {
            for (String url : validURLs) {
                assertFalse(url, util.isValidRequest(createRequest(url, method, noContentType)));
            }
        } else {
            for (String contentType : contentTypes) {
                for (String url : invalidURLs) {
                    assertFalse(url, util.isValidRequest(createRequest(url, method, contentType)));
                }
            }
        }
    }


    public Position(String type) {
        if (!VALID_TYPES.contains(type)) {
            throw new IllegalArgumentException("Invalid type: " + type);
        }
        if (!(XML_FIRST.equals(type) || XML_LAST.equals(type))) {
            throw new IllegalArgumentException("If type is other than 'first' or 'last' a segment must be specified");
        }
        this.type = type;
        this.segment = null;
    }


    public Position(String type, String segment) {
        if (!VALID_TYPES.contains(type)) {
            throw new IllegalArgumentException("Invalid type: " + type);
        }
        if ((XML_AFTER.equals(type) || XML_BEFORE.equals(type)) && (segment == null || "".equals(segment))) {
            throw new IllegalArgumentException("If type is other than 'first' or 'last' a segment must be specified");
        }
        this.type = type;
        this.segment = segment;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof Scope) {
            Scope other = (Scope) obj;
            return localName.equals(other.localName) && namespace.equals(other.namespace);
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof DavResourceLocatorImpl) {
                DavResourceLocatorImpl other = (DavResourceLocatorImpl) obj;
                return hashCode() == other.hashCode();
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof QPropertyDefinition) {
            QPropertyDefinition other = (QPropertyDefinition) obj;

            return super.equals(obj)
                    && requiredType == other.getRequiredType()
                    && multiple == other.isMultiple()
                    && fullTextSearchable == other.isFullTextSearchable()
                    && queryOrderable == other.isQueryOrderable()
                    && ((valueConstraints == null || other.getValueConstraints() == null) ? (valueConstraints == other.getValueConstraints())
                        : new HashSet(Arrays.asList(valueConstraints)).equals(new HashSet(Arrays.asList(other.getValueConstraints()))))
                    && ((defaultValues == null || other.getDefaultValues() == null) ? (defaultValues == other.getDefaultValues())
                        : new HashSet(Arrays.asList(defaultValues)).equals(new HashSet(Arrays.asList(other.getDefaultValues()))))
                    && new HashSet(Arrays.asList(availableQueryOperators)).equals(new HashSet(Arrays.asList(other.getAvailableQueryOperators())));
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof RetentionPolicyImpl) {
            RetentionPolicyImpl other = (RetentionPolicyImpl) obj;
            return name.equals(other.name) && ((nodeId == null) ? other.nodeId == null : nodeId.equals(other.nodeId));
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof QNodeDefinitionId) {
                QNodeDefinitionId other = (QNodeDefinitionId) obj;
                return declaringNodeType.equals(other.declaringNodeType)
                        && name.equals(other.name);
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof QNodeTypeDefinitionImpl) {
            QNodeTypeDefinitionImpl other = (QNodeTypeDefinitionImpl) obj;
            return (name == null ? other.name == null : name.equals(other.name))
                    && (primaryItemName == null ? other.primaryItemName == null : primaryItemName.equals(other.primaryItemName))
                    && new HashSet(Arrays.asList(getSupertypes())).equals(new HashSet(Arrays.asList(other.getSupertypes())))
                    && isMixin == other.isMixin
                    && hasOrderableChildNodes == other.hasOrderableChildNodes
                    && isAbstract == other.isAbstract
                    && isQueryable == other.isQueryable
                    && propertyDefs.equals(other.propertyDefs)
                    && childNodeDefs.equals(other.childNodeDefs);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof Principal) {
            String otherName = ((Principal)obj).getName();
            return (name == null) ? otherName == null : name.equals(otherName);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof QItemDefinition) {
            QItemDefinition other = (QItemDefinition) obj;
            return (declaringNodeType == null
                    ? other.getDeclaringNodeType() == null
                    : declaringNodeType.equals(other.getDeclaringNodeType()))
                    && (name == null ? other.getName() == null : name.equals(other.getName()))
                    && autoCreated == other.isAutoCreated()
                    && onParentVersion == other.getOnParentVersion()
                    && writeProtected == other.isProtected()
                    && mandatory == other.isMandatory();
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof QPropertyDefinitionId) {
                QPropertyDefinitionId other = (QPropertyDefinitionId) obj;
                return declaringNodeType.equals(other.declaringNodeType)
                        && name.equals(other.name);
            }
            return false;
        }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof BinaryQValue) {
                BinaryQValue other = (BinaryQValue) obj;
                return ((file == null ? other.file == null : file.equals(other.file))
                    && Arrays.equals(buffer, other.buffer));
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof Type) {
            Type other = (Type) obj;
            return localName.equals(other.localName) && namespace.equals(other.namespace);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof ACLTemplate) {
            ACLTemplate acl = (ACLTemplate) obj;
            return principal.equals(acl.principal) &&
                   path.equals(acl.path) && entries.equals(acl.entries);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof BLOBInTempFile) {
            BLOBInTempFile other = (BLOBInTempFile) obj;
            return (file == other.file) || (length == other.length && file != null && file.equals(other.file));
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof PrincipalSearchProperty) {
                PrincipalSearchProperty other = (PrincipalSearchProperty)obj;
                // ignore the optional description/language
                return hashCode == other.hashCode;
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof QNodeDefinition) {
            QNodeDefinition other = (QNodeDefinition) obj;
            return super.equals(obj)
                    && requiredPrimaryTypes.equals(new HashSet<Name>(
                            Arrays.asList(other.getRequiredPrimaryTypes())))
                    && (defaultPrimaryType == null
                            ? other.getDefaultPrimaryType() == null
                            : defaultPrimaryType.equals(other.getDefaultPrimaryType()))
                    && allowsSameNameSiblings == other.allowsSameNameSiblings();
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof UnmodifiableAccessControlList) {
            UnmodifiableAccessControlList acl = (UnmodifiableAccessControlList) obj;
            return ((path == null) ? acl.path == null : path.equals(acl.path)) &&
                    Arrays.equals(accessControlEntries, acl.accessControlEntries) &&
                    restrictions.equals(acl.restrictions);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof HoldImpl) {
            HoldImpl other = (HoldImpl) obj;
            return isDeep == other.isDeep && name.equals(other.name) && nodeId.equals(other.nodeId);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof PropertyId) {
            PropertyId other = (PropertyId) obj;
            return parentId.equals(other.parentId)
                    && propName.equals(other.propName);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof FileSystemResource) {
            FileSystemResource other = (FileSystemResource) obj;
            return (path == null ? other.path == null : path.equals(other.path))
                    && (fs == null ? other.fs == null : fs.equals(other.fs));
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof DbFileSystem) {
            DbFileSystem other = (DbFileSystem) obj;
            if (((driver != null) ? driver.equals(other.driver) : other.driver == null)
                    && ((url != null) ? url.equals(other.url) : other.url == null)
                    && ((user != null) ? user.equals(other.user) : other.user == null)
                    && ((password != null) ? password.equals(other.password) : other.password == null)
                    && super.equals(other)) {
                return true;
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof Entry) {
            Entry other = (Entry) obj;
            return principalName.equals(other.principalName) &&
                   privilegeBits.equals(other.privilegeBits) &&
                   isAllow == other.isAllow &&
                   pattern.equals(other.pattern);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof InternalVersionImpl) {
            InternalVersionImpl v = (InternalVersionImpl) obj;
            return v.getId().equals(getId());
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof AccessControlEntryImpl) {
            AccessControlEntryImpl other = (AccessControlEntryImpl) obj;
            return principal.getName().equals(other.principal.getName()) &&
                   privilegeBits.equals(other.privilegeBits) &&
                   allow == other.allow &&
                   restrictions.equals(other.restrictions);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof EventState) {
            EventState other = (EventState) obj;
            return this.type == other.type
                    && this.parentId.equals(other.parentId)
                    && this.childRelPath.equals(other.childRelPath)
                    && this.session.equals(other.session)
                    && this.info.equals(other.info);
        }
        return false;
    }


    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof ChildInfoImpl) {
            ChildInfoImpl ci = (ChildInfoImpl) object;
            boolean sameUID = (uniqueId == null) ? ci.uniqueId == null : uniqueId.equals(ci.uniqueId);
            return sameUID && name.equals(ci.name) && index == ci.index;
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof AccessControlEntryImpl) {
            AccessControlEntryImpl other = (AccessControlEntryImpl) obj;
            return principal.getName().equals(other.principal.getName()) &&
                    isAllow == other.isAllow &&
                    restrictions.equals(other.restrictions) &&
                    mvRestrictions.equals(other.mvRestrictions) &&
                    getPrivilegesHashCode() == other.getPrivilegesHashCode();
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof UserPrincipal) {
            UserPrincipal other = (UserPrincipal) obj;
            return name.equals(other.name);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof ChildNodeEntries) {
            ChildNodeEntries other = (ChildNodeEntries) obj;
            return (nameMap.equals(other.nameMap)
                    && entries.equals(other.entries)
                    && shared == other.shared);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof PrivilegeImpl) {
            PrivilegeImpl other = (PrivilegeImpl) obj;
            return definition.equals(other.definition);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof ChildNodeEntry) {
            ChildNodeEntry other = (ChildNodeEntry) obj;
            return (name.equals(other.name) && id.equals(other.id)
                    && index == other.index);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof BLOBInMemory) {
            BLOBInMemory other = (BLOBInMemory) obj;
            return Arrays.equals(data, other.data);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        } else if (obj == null) {
            return false;
        }

        if (obj instanceof Privilege) {
            return getName().equals(((Privilege) obj).getName());
        }

        return false;
    }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof GlobPattern) {
            GlobPattern other = (GlobPattern) obj;
            return nodePath.equals(other.nodePath) &&
                    ((restriction == null) ? other.restriction == null : restriction.equals(other.restriction));
        }
        return false;
    }


        public boolean equals(Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Result) {
                Result other = (Result) object;
                return allows == other.allows &&
                       denies == other.denies &&
                       allowPrivileges.equals(other.allowPrivileges) &&
                       denyPrivileges.equals(other.denyPrivileges);
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof ACLTemplate) {
            ACLTemplate acl = (ACLTemplate) obj;
            return path.equals(acl.path) && entries.equals(acl.entries);
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof WeightedKey) {
                WeightedKey other = (WeightedKey) obj;
                // ignore weight
                return Arrays.equals(names, other.names);
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof NamespaceMapping) {
            NamespaceMapping other = (NamespaceMapping) obj;
            return this.getPrefixToURIMapping().equals(other.getPrefixToURIMapping())
                   && this.getURIToPrefixMapping().equals(other.getURIToPrefixMapping());
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof BLOBInResource) {
            BLOBInResource other = (BLOBInResource) obj;
            return length == other.length && fsResource.equals(other.fsResource);
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof ItemId) {
                ItemId other = (ItemId) obj;
                return equals(other);
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof AccessControlListImpl) {
            AccessControlListImpl acl = (AccessControlListImpl) obj;
            return jcrPath.equals(acl.jcrPath) && entries.equals(acl.entries);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof EventConsumer) {
            EventConsumer other = (EventConsumer) obj;
            return session.equals(other.session)
                    && listener.equals(other.listener);
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof PrivilegeImpl) {
                PrivilegeImpl other = (PrivilegeImpl) obj;
                return definition.equals(other.definition);
            }
            return false;
        }


        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof Definition) {
                Definition other = (Definition) obj;
                return bits.equals(other.bits) && super.equals(other);
            }
            return false;
        }


    public boolean isSame(Item otherItem) throws RepositoryException {
        // check state of this instance
        sanityCheck();

        if (this == otherItem) {
            return true;
        }
        if (otherItem instanceof ItemImpl) {
            ItemImpl other = (ItemImpl) otherItem;
            return id.equals(other.id)
                    && getSession().getWorkspace().getName().equals(
                            other.getSession().getWorkspace().getName());
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof EventImpl) {
            EventImpl other = (EventImpl) obj;
            return this.eventState.equals(other.eventState)
                    && this.session.equals(other.session)
                    && this.timestamp == other.timestamp
                    && equals(this.userData, other.userData);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof StringValue) {
            StringValue other = (StringValue) obj;
            if (text == other.text) {
                return true;
            } else if (text != null && other.text != null) {
                return text.equals(other.text);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof WeakReferenceValue) {
            WeakReferenceValue other = (WeakReferenceValue) obj;
            if (uuid == other.uuid) {
                return true;
            } else if (uuid != null && other.uuid != null) {
                return uuid.equals(other.uuid);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof NameValue) {
            NameValue other = (NameValue) obj;
            if (name == other.name) {
                return true;
            } else if (name != null && other.name != null) {
                return name.equals(other.name);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof LongValue) {
            LongValue other = (LongValue) obj;
            if (lNumber == other.lNumber) {
                return true;
            } else if (lNumber != null && other.lNumber != null) {
                return lNumber.equals(other.lNumber);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof LocalFileSystem) {
            LocalFileSystem other = (LocalFileSystem) obj;
            if (root == null) {
                return other.root == null;
            } else {
                return root.equals(other.root);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof DoubleValue) {
            DoubleValue other = (DoubleValue) obj;
            if (dblNumber == other.dblNumber) {
                return true;
            } else if (dblNumber != null && other.dblNumber != null) {
                return dblNumber.equals(other.dblNumber);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof DecimalValue) {
            DecimalValue other = (DecimalValue) obj;
            if (number == other.number) {
                return true;
            } else if (number != null && other.number != null) {
                return number.compareTo(other.number) == 0;
            }
        }
        return false;
    }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof NameImpl) {
                NameImpl other = (NameImpl) obj;
                // we can use == operator for namespaceURI since it is internalized
                return namespaceURI == other.namespaceURI && localName.equals(other.localName);
            }
            // some other Name implementation
            if (obj instanceof Name) {
                Name other = (Name) obj;
                return namespaceURI.equals(other.getNamespaceURI()) && localName.equals(other.getLocalName());
            }
            return false;
        }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof ReferenceValue) {
            ReferenceValue other = (ReferenceValue) obj;
            if (uuid == other.uuid) {
                return true;
            } else if (uuid != null && other.uuid != null) {
                return uuid.equals(other.uuid);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof BinaryValue) {
            BinaryValue other = (BinaryValue) obj;
            if (text == other.text && stream == other.stream
                    && bin == other.bin) {
                return true;
            }
            return (text != null && text.equals(other.text))
                    || (bin != null && bin.equals(other.bin));
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof DateValue) {
            DateValue other = (DateValue) obj;
            if (date == other.date) {
                return true;
            } else if (date != null && other.date != null) {
                return ISO8601.format(date).equals(ISO8601.format(other.date));
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof BooleanValue) {
            BooleanValue other = (BooleanValue) obj;
            if (bool == other.bool) {
                return true;
            } else if (bool != null && other.bool != null) {
                return bool.equals(other.bool);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof AbstractQValue) {
            AbstractQValue other = (AbstractQValue) obj;
            if (type != other.type) {
                return false;
            }
            return val.equals(other.val);
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof PathValue) {
            PathValue other = (PathValue) obj;
            if (path == other.path) {
                return true;
            } else if (path != null && other.path != null) {
                return path.equals(other.path);
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof URIValue) {
            URIValue other = (URIValue) obj;
            if (uri == other.uri) {
                return true;
            } else if (uri != null && other.uri != null) {
                return uri.equals(other.uri);
            }
        }
        return false;
    }


    public static Scope createFromXml(Element lockScope) {
        if (lockScope != null && DavConstants.XML_LOCKSCOPE.equals(lockScope.getLocalName())) {
            // we have the parent element and must retrieve the scope first
            lockScope = DomUtil.getFirstChildElement(lockScope);
        }
        if (lockScope == null) {
            throw new IllegalArgumentException("'null' is not a valid lock scope entry.");
        }
        Namespace namespace = Namespace.getNamespace(lockScope.getPrefix(), lockScope.getNamespaceURI());
        return create(lockScope.getLocalName(), namespace);
    }


    public static Type createFromXml(Element lockType) {
        if (lockType != null && DavConstants.XML_LOCKTYPE.equals(lockType.getLocalName())) {
            // we have the parent element and must retrieve the type first
            lockType = DomUtil.getFirstChildElement(lockType);
        }
        if (lockType == null) {
            throw new IllegalArgumentException("'null' is not valid lock type entry.");
        }
        Namespace namespace = Namespace.getNamespace(lockType.getPrefix(), lockType.getNamespaceURI());
        return create(lockType.getLocalName(), namespace);
    }


    public static Scope create(String localName, Namespace namespace) {
        String key = DomUtil.getExpandedName(localName, namespace);
        if (scopes.containsKey(key)) {
            return scopes.get(key);
        } else {
            Scope scope = new Scope(localName, namespace);
            scopes.put(key, scope);
            return scope;
        }
    }


    public static Type create(String localName, Namespace namespace) {
        String key = DomUtil.getExpandedName(localName, namespace);
        if (types.containsKey(key)) {
            return types.get(key);
        } else {
            Type type = new Type(localName, namespace);
            types.put(key, type);
            return type;
        }
    }


    public static EventType create(String localName, Namespace namespace) {
        if (localName == null || "".equals(localName)) {
            throw new IllegalArgumentException("null and '' are not valid local names of an event type.");
        }
        String key = DomUtil.getExpandedName(localName, namespace);
        if (eventTypes.containsKey(key)) {
            return eventTypes.get(key);
        } else {
            EventType type = new DefaultEventType(localName, namespace);
            eventTypes.put(key, type);
            return type;
        }
    }


    protected void doBind(WebdavRequest request, WebdavResponse response,
                          DavResource resource) throws IOException, DavException {

        if (!resource.exists()) {
            response.sendError(DavServletResponse.SC_NOT_FOUND);
        }
        BindInfo bindInfo = request.getBindInfo();
        DavResource oldBinding = getResourceFactory().createResource(request.getHrefLocator(bindInfo.getHref()), request, response);
        if (!(oldBinding instanceof BindableResource)) {
            response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);
            return;
        }
        DavResource newBinding = getResourceFactory().createResource(request.getMemberLocator(bindInfo.getSegment()), request, response);
        int status = validateDestination(newBinding, request, false);
        if (status > DavServletResponse.SC_NO_CONTENT) {
            response.sendError(status);
            return;
        }
        ((BindableResource) oldBinding).bind(resource, newBinding);
        response.setStatus(status);
    }


    protected void doRebind(WebdavRequest request, WebdavResponse response,
                            DavResource resource) throws IOException, DavException {

        if (!resource.exists()) {
            response.sendError(DavServletResponse.SC_NOT_FOUND);
        }
        RebindInfo rebindInfo = request.getRebindInfo();
        DavResource oldBinding = getResourceFactory().createResource(request.getHrefLocator(rebindInfo.getHref()), request, response);
        if (!(oldBinding instanceof BindableResource)) {
            response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);
            return;
        }
        DavResource newBinding = getResourceFactory().createResource(request.getMemberLocator(rebindInfo.getSegment()), request, response);
        int status = validateDestination(newBinding, request, false);
        if (status > DavServletResponse.SC_NO_CONTENT) {
            response.sendError(status);
            return;
        }
        ((BindableResource) oldBinding).rebind(resource, newBinding);
        response.setStatus(status);
    }


    protected int validateDestination(DavResource destResource, WebdavRequest request, boolean checkHeader)
            throws DavException {

        if (checkHeader) {
            String destHeader = request.getHeader(HEADER_DESTINATION);
            if (destHeader == null || "".equals(destHeader)) {
                return DavServletResponse.SC_BAD_REQUEST;
            }
        }
        if (destResource.getLocator().equals(request.getRequestLocator())) {
            return DavServletResponse.SC_FORBIDDEN;
        }

        int status;
        if (destResource.exists()) {
            if (request.isOverwrite()) {
                // matching if-header required for existing resources
                if (!request.matchesIfHeader(destResource)) {
                    return DavServletResponse.SC_PRECONDITION_FAILED;
                } else {
                    // overwrite existing resource
                    destResource.getCollection().removeMember(destResource);
                    status = DavServletResponse.SC_NO_CONTENT;
                }
            } else {
                // cannot copy/move to an existing item, if overwrite is not forced
                return DavServletResponse.SC_PRECONDITION_FAILED;
            }
        } else {
            // destination does not exist >> copy/move can be performed
            status = DavServletResponse.SC_CREATED;
        }
        return status;
    }


    protected int validateDestination(DavResource destResource, WebdavRequest request, boolean checkHeader)
            throws DavException {

        if (checkHeader) {
            String destHeader = request.getHeader(HEADER_DESTINATION);
            if (destHeader == null || "".equals(destHeader)) {
                return DavServletResponse.SC_BAD_REQUEST;
            }
        }
        if (destResource.getLocator().equals(request.getRequestLocator())) {
            return DavServletResponse.SC_FORBIDDEN;
        }

        int status;
        if (destResource.exists()) {
            if (request.isOverwrite()) {
                // matching if-header required for existing resources
                if (!request.matchesIfHeader(destResource)) {
                    return DavServletResponse.SC_PRECONDITION_FAILED;
                } else {
                    // overwrite existing resource
                    destResource.getCollection().removeMember(destResource);
                    status = DavServletResponse.SC_NO_CONTENT;
                }
            } else {
              /* NO overwrite header:

                 but, instead of return the 412 Precondition-Failed code required
                 by the WebDAV specification(s) leave the validation to the
                 JCR repository.
               */
                status = DavServletResponse.SC_CREATED;
            }

        } else {
            // destination does not exist >> copy/move can be performed
            status = DavServletResponse.SC_CREATED;
        }
        return status;
    }


    protected void doOrderPatch(WebdavRequest request,
                                WebdavResponse response,
                                DavResource resource)
            throws IOException, DavException {

        if (!(resource instanceof OrderingResource)) {
            response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);
            return;
        }

        OrderPatch op = request.getOrderPatch();
        if (op == null) {
            response.sendError(DavServletResponse.SC_BAD_REQUEST);
            return;
        }
        // perform reordering of internal members
        ((OrderingResource) resource).orderMembers(op);
        response.setStatus(DavServletResponse.SC_OK);
    }


    protected void doSubscribe(WebdavRequest request,
                               WebdavResponse response,
                               DavResource resource)
            throws IOException, DavException {

        if (!(resource instanceof ObservationResource)) {
            response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);
            return;
        }

        SubscriptionInfo info = request.getSubscriptionInfo();
        if (info == null) {
            response.sendError(DavServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);
            return;
        }
        Subscription subs = ((ObservationResource) resource).subscribe(info, request.getSubscriptionId());
        response.sendSubscriptionResponse(subs);
    }


    protected void doAcl(WebdavRequest request, WebdavResponse response,
                         DavResource resource) throws DavException, IOException {
        if (!(resource instanceof AclResource)) {
            response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);
            return;
        }
        Document doc = request.getRequestDocument();
        if (doc == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "ACL request requires a DAV:acl body.");
        }
        AclProperty acl = AclProperty.createFromXml(doc.getDocumentElement());
        ((AclResource)resource).alterAcl(acl);
    }


    private static boolean needsXmlnsAttributes() {
        try {
            StringWriter writer = new StringWriter();
            TransformerHandler probe = FACTORY.newTransformerHandler();
            probe.setResult(new StreamResult(writer));
            probe.startDocument();
            probe.startPrefixMapping("p", "uri");
            probe.startElement("uri", "e", "p:e", new AttributesImpl());
            probe.endElement("uri", "e", "p:e");
            probe.endPrefixMapping("p");
            probe.endDocument();
            return writer.toString().indexOf("xmlns") == -1;
        } catch (Exception e) {
            throw new UnsupportedOperationException("XML serialization fails");
        }
    }


    private static boolean needsXmlnsAttributes() {
        try {
            StringWriter writer = new StringWriter();
            TransformerHandler probe = FACTORY.newTransformerHandler();
            probe.setResult(new StreamResult(writer));
            probe.startDocument();
            probe.startPrefixMapping("p", "uri");
            probe.startElement("uri", "e", "p:e", new AttributesImpl());
            probe.endElement("uri", "e", "p:e");
            probe.endPrefixMapping("p");
            probe.endDocument();
            return writer.toString().indexOf("xmlns") == -1;
        } catch (Exception e) {
            throw new UnsupportedOperationException("XML serialization fails");
        }
    }


    private static boolean needsXmlnsAttributes() {
        try {
            StringWriter writer = new StringWriter();
            TransformerHandler probe = FACTORY.newTransformerHandler();
            probe.setResult(new StreamResult(writer));
            probe.startDocument();
            probe.startPrefixMapping("p", "uri");
            probe.startElement("uri", "e", "p:e", new AttributesImpl());
            probe.endElement("uri", "e", "p:e");
            probe.endPrefixMapping("p");
            probe.endDocument();
            return writer.toString().indexOf("xmlns") == -1;
        } catch (Exception e) {
            throw new UnsupportedOperationException("XML serialization fails");
        }
    }


    public static Result getResult(Result result) throws SAXException {
        try {
            TransformerHandler handler = FACTORY.newTransformerHandler();
            handler.setResult(result);

            // Specify the output properties to avoid surprises especially in
            // character encoding or the output method (might be html for some
            // documents!)
            Transformer transformer = handler.getTransformer();
            transformer.setOutputProperty(OutputKeys.METHOD, "xml");
            transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            transformer.setOutputProperty(OutputKeys.INDENT, "no");

            if (NEEDS_XMLNS_ATTRIBUTES) {
                // The serializer does not output xmlns declarations,
                // so we need to do it explicitly with this wrapper
                return new SAXResult(new SerializingContentHandler(handler));
            } else {
                return result;
            }
        } catch (TransformerConfigurationException e) {
            throw new SAXException("Failed to initialize XML serializer", e);
        }
    }


    public static DefaultHandler getSerializer(Result result)
            throws SAXException {
        try {
            TransformerHandler handler = FACTORY.newTransformerHandler();
            handler.setResult(result);

            // Specify the output properties to avoid surprises especially in
            // character encoding or the output method (might be html for some
            // documents!)
            Transformer transformer = handler.getTransformer();
            transformer.setOutputProperty(OutputKeys.METHOD, "xml");
            transformer.setOutputProperty(OutputKeys.ENCODING, ENCODING);
            transformer.setOutputProperty(OutputKeys.INDENT, "no");

            if (NEEDS_XMLNS_ATTRIBUTES) {
                // The serializer does not output xmlns declarations,
                // so we need to do it explicitly with this wrapper
                return new SerializingContentHandler(handler);
            } else {
                return new DefaultContentHandler(handler);
            }
        } catch (TransformerConfigurationException e) {
            throw new SAXException("Failed to initialize XML serializer", e);
        }
    }


    public static DefaultHandler getSerializer(Result result)
            throws SAXException {
        try {
            TransformerHandler handler = FACTORY.newTransformerHandler();
            handler.setResult(result);

            // Specify the output properties to avoid surprises especially in
            // character encoding or the output method (might be html for some
            // documents!)
            Transformer transformer = handler.getTransformer();
            transformer.setOutputProperty(OutputKeys.METHOD, "xml");
            transformer.setOutputProperty(OutputKeys.ENCODING, ENCODING);
            transformer.setOutputProperty(OutputKeys.INDENT, "no");

            if (NEEDS_XMLNS_ATTRIBUTES) {
                // The serializer does not output xmlns declarations,
                // so we need to do it explicitly with this wrapper
                return new SerializingContentHandler(handler);
            } else {
                return new DefaultContentHandler(handler);
            }
        } catch (TransformerConfigurationException e) {
            throw new SAXException("Failed to initialize XML serializer", e);
        }
    }


        public void startPrefixMapping(String prefix, String uri) throws SAXException {
            // Store the mappings to reconstitute xmlns:attributes
            // except prefixes starting with "xml": these are reserved
            // VG: (uri != null) fixes NPE in startElement
            if (uri != null && !prefix.startsWith("xml")) {
                this.hasMappings = true;
                this.prefixList.add(prefix);
                this.uriList.add(uri);

                // append the prefix colon now, in order to save concatenations later, but
                // only for non-empty prefixes.
                if (prefix.length() > 0) {
                    this.uriToPrefixMap.put(uri, prefix + ":");
                } else {
                    this.uriToPrefixMap.put(uri, prefix);
                }

                this.prefixToUriMap.put(prefix, uri);
            }
            
            handler.startPrefixMapping(prefix, uri);
        }


    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        // Store the mappings to reconstitute xmlns:attributes
        // except prefixes starting with "xml": these are reserved
        // VG: (uri != null) fixes NPE in startElement
        if (uri != null && !prefix.startsWith("xml")) {
            this.hasMappings = true;
            this.prefixList.add(prefix);
            this.uriList.add(uri);

            // append the prefix colon now, in order to save concatenations later, but
            // only for non-empty prefixes.
            if (prefix.length() > 0) {
                this.uriToPrefixMap.put(uri, prefix + ":");
            } else {
                this.uriToPrefixMap.put(uri, prefix);
            }

            this.prefixToUriMap.put(prefix, uri);
        }
        super.startPrefixMapping(prefix, uri);
    }


    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        // Store the mappings to reconstitute xmlns:attributes
        // except prefixes starting with "xml": these are reserved
        // VG: (uri != null) fixes NPE in startElement
        if (uri != null && !prefix.startsWith("xml")) {
            this.hasMappings = true;
            this.prefixList.add(prefix);
            this.uriList.add(uri);

            // append the prefix colon now, in order to save concatenations later, but
            // only for non-empty prefixes.
            if (prefix.length() > 0) {
                this.uriToPrefixMap.put(uri, prefix + ":");
            } else {
                this.uriToPrefixMap.put(uri, prefix);
            }

            this.prefixToUriMap.put(prefix, uri);
        }
        super.startPrefixMapping(prefix, uri);
    }


        private void checkPrefixMapping(String uri, String qname)
                throws SAXException {
            // Only add the prefix mapping if the URI is not already known
            if (uri != null && uri.length() > 0 && !uri.startsWith("xml")
                    && !uriToPrefixMap.containsKey(uri)) {
                // Get the prefix
                String prefix = "ns";
                if (qname != null && qname.length() > 0) {
                    int colon = qname.indexOf(':');
                    if (colon != -1) {
                        prefix = qname.substring(0, colon);
                    }
                }

                // Make sure that the prefix is unique
                String base = prefix;
                for (int i = 2; prefixToUriMap.containsKey(prefix); i++) {
                    prefix = base + i;
                }

                int last = addedPrefixMappings.size() - 1;
                List prefixes = (List) addedPrefixMappings.get(last);
                if (prefixes == null) {
                    prefixes = new ArrayList();
                    addedPrefixMappings.set(last, prefixes);
                }
                prefixes.add(prefix);

                startPrefixMapping(prefix, uri);
            }
        }


    private void checkPrefixMapping(String uri, String qname)
            throws SAXException {
        // Only add the prefix mapping if the URI is not already known
        if (uri != null && uri.length() > 0 && !uri.startsWith("xml")
                && !uriToPrefixMap.containsKey(uri)) {
            // Get the prefix
            String prefix = "ns";
            if (qname != null && qname.length() > 0) {
                int colon = qname.indexOf(':');
                if (colon != -1) {
                    prefix = qname.substring(0, colon);
                }
            }

            // Make sure that the prefix is unique
            String base = prefix;
            for (int i = 2; prefixToUriMap.containsKey(prefix); i++) {
                prefix = base + i;
            }

            int last = addedPrefixMappings.size() - 1;
            List prefixes = (List) addedPrefixMappings.get(last);
            if (prefixes == null) {
                prefixes = new ArrayList();
                addedPrefixMappings.set(last, prefixes);
            }
            prefixes.add(prefix);

            startPrefixMapping(prefix, uri);
        }
    }


    private void checkPrefixMapping(String uri, String qname)
            throws SAXException {
        // Only add the prefix mapping if the URI is not already known
        if (uri != null && uri.length() > 0 && !uri.startsWith("xml")
                && !uriToPrefixMap.containsKey(uri)) {
            // Get the prefix
            String prefix = "ns";
            if (qname != null && qname.length() > 0) {
                int colon = qname.indexOf(':');
                if (colon != -1) {
                    prefix = qname.substring(0, colon);
                }
            }

            // Make sure that the prefix is unique
            String base = prefix;
            for (int i = 2; prefixToUriMap.containsKey(prefix); i++) {
                prefix = base + i;
            }

            int last = addedPrefixMappings.size() - 1;
            List prefixes = (List) addedPrefixMappings.get(last);
            if (prefixes == null) {
                prefixes = new ArrayList();
                addedPrefixMappings.set(last, prefixes);
            }
            prefixes.add(prefix);

            startPrefixMapping(prefix, uri);
        }
    }


        public void startElement(
                String eltUri, String eltLocalName, String eltQName, Attributes attrs)
                throws SAXException {
            // JCR-1767: Generate extra prefix mapping calls where needed
            addedPrefixMappings.add(null);
            checkPrefixMapping(eltUri, eltQName);
            for (int i = 0; i < attrs.getLength(); i++) {
                checkPrefixMapping(attrs.getURI(i), attrs.getQName(i));
            }

            // try to restore the qName. The map already contains the colon
            if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
                eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
            }
            if (this.hasMappings) {
                // Add xmlns* attributes where needed

                // New Attributes if we have to add some.
                AttributesImpl newAttrs = null;

                int mappingCount = this.prefixList.size();
                int attrCount = attrs.getLength();

                for (int mapping = 0; mapping < mappingCount; mapping++) {

                    // Build infos for this namespace
                    String uri = (String) this.uriList.get(mapping);
                    String prefix = (String) this.prefixList.get(mapping);
                    String qName = prefix.equals("") ? "xmlns" : ("xmlns:" + prefix);

                    // Search for the corresponding xmlns* attribute
                    boolean found = false;
                    for (int attr = 0; attr < attrCount; attr++) {
                        if (qName.equals(attrs.getQName(attr))) {
                            // Check if mapping and attribute URI match
                            if (!uri.equals(attrs.getValue(attr))) {
                                throw new SAXException("URI in prefix mapping and attribute do not match");
                            }
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        // Need to add this namespace
                        if (newAttrs == null) {
                            // Need to test if attrs is empty or we go into an infinite loop...
                            // Well know SAX bug which I spent 3 hours to remind of :-(
                            if (attrCount == 0) {
                                newAttrs = new AttributesImpl();
                            } else {
                                newAttrs = new AttributesImpl(attrs);
                            }
                        }

                        if (prefix.equals("")) {
                            newAttrs.addAttribute(XML, qName, qName, "CDATA", uri);
                        } else {
                            newAttrs.addAttribute(XML, prefix, qName, "CDATA", uri);
                        }
                    }
                } // end for mapping

                // Cleanup for the next element
                clearMappings();

                // Start element with new attributes, if any
                handler.startElement(eltUri, eltLocalName, eltQName, newAttrs == null ? attrs : newAttrs);                
            } else {
                // Normal job
                handler.startElement(eltUri, eltLocalName, eltQName, attrs);
            }
        }


    public void startElement(
            String eltUri, String eltLocalName, String eltQName, Attributes attrs)
            throws SAXException {
        // JCR-1767: Generate extra prefix mapping calls where needed
        addedPrefixMappings.add(null);
        checkPrefixMapping(eltUri, eltQName);
        for (int i = 0; i < attrs.getLength(); i++) {
            checkPrefixMapping(attrs.getURI(i), attrs.getQName(i));
        }

        // try to restore the qName. The map already contains the colon
        if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
            eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
        }
        if (this.hasMappings) {
            // Add xmlns* attributes where needed

            // New Attributes if we have to add some.
            AttributesImpl newAttrs = null;

            int mappingCount = this.prefixList.size();
            int attrCount = attrs.getLength();

            for (int mapping = 0; mapping < mappingCount; mapping++) {

                // Build infos for this namespace
                String uri = (String) this.uriList.get(mapping);
                String prefix = (String) this.prefixList.get(mapping);
                String qName = prefix.equals("") ? "xmlns" : ("xmlns:" + prefix);

                // Search for the corresponding xmlns* attribute
                boolean found = false;
                for (int attr = 0; attr < attrCount; attr++) {
                    if (qName.equals(attrs.getQName(attr))) {
                        // Check if mapping and attribute URI match
                        if (!uri.equals(attrs.getValue(attr))) {
                            throw new SAXException("URI in prefix mapping and attribute do not match");
                        }
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    // Need to add this namespace
                    if (newAttrs == null) {
                        // Need to test if attrs is empty or we go into an infinite loop...
                        // Well know SAX bug which I spent 3 hours to remind of :-(
                        if (attrCount == 0) {
                            newAttrs = new AttributesImpl();
                        } else {
                            newAttrs = new AttributesImpl(attrs);
                        }
                    }

                    if (prefix.equals("")) {
                        newAttrs.addAttribute(XML, qName, qName, "CDATA", uri);
                    } else {
                        newAttrs.addAttribute(XML, prefix, qName, "CDATA", uri);
                    }
                }
            } // end for mapping

            // Cleanup for the next element
            clearMappings();

            // Start element with new attributes, if any
            super.startElement(eltUri, eltLocalName, eltQName, newAttrs == null ? attrs : newAttrs);
        } else {
            // Normal job
            super.startElement(eltUri, eltLocalName, eltQName, attrs);
        }
    }


    public void startElement(
            String eltUri, String eltLocalName, String eltQName, Attributes attrs)
            throws SAXException {
        // JCR-1767: Generate extra prefix mapping calls where needed
        addedPrefixMappings.add(null);
        checkPrefixMapping(eltUri, eltQName);
        for (int i = 0; i < attrs.getLength(); i++) {
            checkPrefixMapping(attrs.getURI(i), attrs.getQName(i));
        }

        // try to restore the qName. The map already contains the colon
        if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
            eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
        }
        if (this.hasMappings) {
            // Add xmlns* attributes where needed

            // New Attributes if we have to add some.
            AttributesImpl newAttrs = null;

            int mappingCount = this.prefixList.size();
            int attrCount = attrs.getLength();

            for (int mapping = 0; mapping < mappingCount; mapping++) {

                // Build infos for this namespace
                String uri = (String) this.uriList.get(mapping);
                String prefix = (String) this.prefixList.get(mapping);
                String qName = prefix.equals("") ? "xmlns" : ("xmlns:" + prefix);

                // Search for the corresponding xmlns* attribute
                boolean found = false;
                for (int attr = 0; attr < attrCount; attr++) {
                    if (qName.equals(attrs.getQName(attr))) {
                        // Check if mapping and attribute URI match
                        if (!uri.equals(attrs.getValue(attr))) {
                            throw new SAXException("URI in prefix mapping and attribute do not match");
                        }
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    // Need to add this namespace
                    if (newAttrs == null) {
                        // Need to test if attrs is empty or we go into an infinite loop...
                        // Well know SAX bug which I spent 3 hours to remind of :-(
                        if (attrCount == 0) {
                            newAttrs = new AttributesImpl();
                        } else {
                            newAttrs = new AttributesImpl(attrs);
                        }
                    }

                    if (prefix.equals("")) {
                        newAttrs.addAttribute(XML, qName, qName, "CDATA", uri);
                    } else {
                        newAttrs.addAttribute(XML, prefix, qName, "CDATA", uri);
                    }
                }
            } // end for mapping

            // Cleanup for the next element
            clearMappings();

            // Start element with new attributes, if any
            super.startElement(eltUri, eltLocalName, eltQName, newAttrs == null ? attrs : newAttrs);
        } else {
            // Normal job
            super.startElement(eltUri, eltLocalName, eltQName, attrs);
        }
    }


        public void endElement(String eltUri, String eltLocalName, String eltQName) throws SAXException {
            // try to restore the qName. The map already contains the colon
            if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
                eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
            }

            handler.endElement(eltUri, eltLocalName, eltQName);
            
            // JCR-1767: Generate extra prefix un-mapping calls where needed
            int last = addedPrefixMappings.size() - 1;
            List prefixes = (List) addedPrefixMappings.remove(last);
            if (prefixes != null) {
                Iterator iterator = prefixes.iterator();
                while (iterator.hasNext()) {
                    endPrefixMapping((String) iterator.next());
                }
            }
        }


    public void endElement(String eltUri, String eltLocalName, String eltQName) throws SAXException {
        // try to restore the qName. The map already contains the colon
        if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
            eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
        }

        super.endElement(eltUri, eltLocalName, eltQName);

        // JCR-1767: Generate extra prefix un-mapping calls where needed
        int last = addedPrefixMappings.size() - 1;
        List prefixes = (List) addedPrefixMappings.remove(last);
        if (prefixes != null) {
            Iterator iterator = prefixes.iterator();
            while (iterator.hasNext()) {
                endPrefixMapping((String) iterator.next());
            }
        }
    }


    public void endElement(String eltUri, String eltLocalName, String eltQName) throws SAXException {
        // try to restore the qName. The map already contains the colon
        if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
            eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
        }

        super.endElement(eltUri, eltLocalName, eltQName);

        // JCR-1767: Generate extra prefix un-mapping calls where needed
        int last = addedPrefixMappings.size() - 1;
        List prefixes = (List) addedPrefixMappings.remove(last);
        if (prefixes != null) {
            Iterator iterator = prefixes.iterator();
            while (iterator.hasNext()) {
                endPrefixMapping((String) iterator.next());
            }
        }
    }


        public void endPrefixMapping(String prefix) throws SAXException {
            // remove mappings for xalan-bug-workaround.
            // Unfortunately, we're not passed the uri, but the prefix here,
            // so we need to maintain maps in both directions.
            if (this.prefixToUriMap.containsKey(prefix)) {
                this.uriToPrefixMap.remove(this.prefixToUriMap.get(prefix));
                this.prefixToUriMap.remove(prefix);
            }

            if (hasMappings) {
                // most of the time, start/endPrefixMapping calls have an element event between them,
                // which will clear the hasMapping flag and so this code will only be executed in the
                // rather rare occasion when there are start/endPrefixMapping calls with no element
                // event in between. If we wouldn't remove the items from the prefixList and uriList here,
                // the namespace would be incorrectly declared on the next element following the
                // endPrefixMapping call.
                int pos = prefixList.lastIndexOf(prefix);
                if (pos != -1) {
                    prefixList.remove(pos);
                    uriList.remove(pos);
                }
            }

            handler.endPrefixMapping(prefix);
        }


    public void endPrefixMapping(String prefix) throws SAXException {
        // remove mappings for xalan-bug-workaround.
        // Unfortunately, we're not passed the uri, but the prefix here,
        // so we need to maintain maps in both directions.
        if (this.prefixToUriMap.containsKey(prefix)) {
            this.uriToPrefixMap.remove(this.prefixToUriMap.get(prefix));
            this.prefixToUriMap.remove(prefix);
        }

        if (hasMappings) {
            // most of the time, start/endPrefixMapping calls have an element event between them,
            // which will clear the hasMapping flag and so this code will only be executed in the
            // rather rare occasion when there are start/endPrefixMapping calls with no element
            // event in between. If we wouldn't remove the items from the prefixList and uriList here,
            // the namespace would be incorrectly declared on the next element following the
            // endPrefixMapping call.
            int pos = prefixList.lastIndexOf(prefix);
            if (pos != -1) {
                prefixList.remove(pos);
                uriList.remove(pos);
            }
        }

        super.endPrefixMapping(prefix);
    }


    public void endPrefixMapping(String prefix) throws SAXException {
        // remove mappings for xalan-bug-workaround.
        // Unfortunately, we're not passed the uri, but the prefix here,
        // so we need to maintain maps in both directions.
        if (this.prefixToUriMap.containsKey(prefix)) {
            this.uriToPrefixMap.remove(this.prefixToUriMap.get(prefix));
            this.prefixToUriMap.remove(prefix);
        }

        if (hasMappings) {
            // most of the time, start/endPrefixMapping calls have an element event between them,
            // which will clear the hasMapping flag and so this code will only be executed in the
            // rather rare occasion when there are start/endPrefixMapping calls with no element
            // event in between. If we wouldn't remove the items from the prefixList and uriList here,
            // the namespace would be incorrectly declared on the next element following the
            // endPrefixMapping call.
            int pos = prefixList.lastIndexOf(prefix);
            if (pos != -1) {
                prefixList.remove(pos);
                uriList.remove(pos);
            }
        }

        super.endPrefixMapping(prefix);
    }


    public static String getAttribute(Element parent, String localName, Namespace namespace) {
        if (parent == null) {
            return null;
        }
        Attr attribute;
        if (namespace == null) {
            attribute = parent.getAttributeNode(localName);
        } else {
            attribute = parent.getAttributeNodeNS(namespace.getURI(), localName);
        }
        if (attribute != null) {
            return attribute.getValue();
        } else {
            return null;
        }
    }


    public static String getAttribute(Element parent, String localName, String namespaceURI) {
        if (parent == null) {
            return null;
        }
        Attr attribute;
        if (namespaceURI == null) {
            attribute = parent.getAttributeNode(localName);
        } else {
            attribute = parent.getAttributeNodeNS(namespaceURI, localName);
        }
        if (attribute != null) {
            return attribute.getValue();
        } else {
            return null;
        }
    }


    public static String getText(Element element) {
        StringBuffer content = new StringBuffer();
        if (element != null) {
            NodeList nodes = element.getChildNodes();
            for (int i = 0; i < nodes.getLength(); i++) {
                Node child = nodes.item(i);
                if (isText(child)) {
                    // cast to super class that contains Text and CData
                    content.append(((CharacterData) child).getData());
                }
            }
        }
        return (content.length()==0) ? null : content.toString();
    }


    public static String getText(Element element) {
        StringBuilder content = new StringBuilder();
        if (element != null) {
            NodeList nodes = element.getChildNodes();
            for (int i = 0; i < nodes.getLength(); i++) {
                Node child = nodes.item(i);
                if (isText(child)) {
                    // cast to super class that contains Text and CData
                    content.append(((CharacterData) child).getData());
                }
            }
        }
        return (content.length()==0) ? null : content.toString();
    }


    public static Element getFirstChildElement(Node parent) {
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (isElement(child)) {
                    return (Element)child;
                }
            }
        }
        return null;
    }


    public static boolean hasContent(Node parent) {
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (isAcceptedNode(child)) {
                    return true;
                }
            }
        }
        return false;
    }


    public static List<Node> getContent(Node parent) {
        List<Node> content = new ArrayList<Node>();
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (isAcceptedNode(child)) {
                    content.add(child);
                }
            }
        }
        return content;
    }


    public static Element getChildElement(Node parent, QName childName) {
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (isElement(child) && matches(child, childName)) {
                    return (Element)child;
                }
            }
        }
        return null;
    }


    public static Element getChildElement(Node parent, String childLocalName, Namespace childNamespace) {
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (isElement(child) && matches(child, childLocalName, childNamespace)) {
                    return (Element)child;
                }
            }
        }
        return null;
    }


    public static Element getChildElement(Node parent, String childLocalName, String childNamespaceURI) {
        if (parent != null) {
            NodeList children = parent.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (child.getNodeType() == Node.ELEMENT_NODE && childLocalName.equals(child.getLocalName()) && childNamespaceURI.equals(child.getNamespaceURI())) {
                    return (Element)child;
                }
            }
        }
        return null;
    }


    private static String escape(String string, char escape, boolean isPath) {
        try {
            BitSet validChars = isPath ? URISaveEx : URISave;
            byte[] bytes = string.getBytes("utf-8");
            StringBuffer out = new StringBuffer(bytes.length);
            for (byte aByte : bytes) {
                int c = aByte & 0xff;
                if (validChars.get(c) && c != escape) {
                    out.append((char) c);
                } else {
                    out.append(escape);
                    out.append(hexTable[(c >> 4) & 0x0f]);
                    out.append(hexTable[(c) & 0x0f]);
                }
            }
            return out.toString();
        } catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    public static String escape(String string, char escape, boolean isPath) {
        try {
            BitSet validChars = isPath ? URISaveEx : URISave;
            byte[] bytes = string.getBytes("utf-8");
            StringBuilder out = new StringBuilder(bytes.length);
            for (byte aByte : bytes) {
                int c = aByte & 0xff;
                if (validChars.get(c) && c != escape) {
                    out.append((char) c);
                } else {
                    out.append(escape);
                    out.append(hexTable[(c >> 4) & 0x0f]);
                    out.append(hexTable[(c) & 0x0f]);
                }
            }
            return out.toString();
        } catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    public static String escape(String string, char escape, boolean isPath) {
        try {
            BitSet validChars = isPath ? URISaveEx : URISave;
            byte[] bytes = string.getBytes("utf-8");
            StringBuffer out = new StringBuffer(bytes.length);
            for (int i = 0; i < bytes.length; i++) {
                int c = bytes[i] & 0xff;
                if (validChars.get(c) && c != escape) {
                    out.append((char) c);
                } else {
                    out.append(escape);
                    out.append(hexTable[(c >> 4) & 0x0f]);
                    out.append(hexTable[(c) & 0x0f]);
                }
            }
            return out.toString();
        } catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    private static String unescape(String string, char escape)  {
        try {
            byte[] utf8 = string.getBytes("utf-8");

            // Check whether escape occurs at invalid position
            if ((utf8.length >= 1 && utf8[utf8.length - 1] == escape) ||
                (utf8.length >= 2 && utf8[utf8.length - 2] == escape)) {
                throw new IllegalArgumentException("Premature end of escape sequence at end of input");
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream(utf8.length);
            for (int k = 0; k < utf8.length; k++) {
                byte b = utf8[k];
                if (b == escape) {
                    out.write((decodeDigit(utf8[++k]) << 4) + decodeDigit(utf8[++k]));
                }
                else {
                    out.write(b);
                }
            }

            return new String(out.toByteArray(), "utf-8");
        }
        catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    public static String unescape(String string, char escape)  {
        try {
            byte[] utf8 = string.getBytes("utf-8");

            // Check whether escape occurs at invalid position
            if ((utf8.length >= 1 && utf8[utf8.length - 1] == escape) ||
                (utf8.length >= 2 && utf8[utf8.length - 2] == escape)) {
                throw new IllegalArgumentException("Premature end of escape sequence at end of input");
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream(utf8.length);
            for (int k = 0; k < utf8.length; k++) {
                byte b = utf8[k];
                if (b == escape) {
                    out.write((decodeDigit(utf8[++k]) << 4) + decodeDigit(utf8[++k]));
                }
                else {
                    out.write(b);
                }
            }

            return new String(out.toByteArray(), "utf-8");
        }
        catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    public static String unescape(String string, char escape)  {
        try {
            byte[] utf8 = string.getBytes("utf-8");

            // Check whether escape occurs at invalid position
            if ((utf8.length >= 1 && utf8[utf8.length - 1] == escape) ||
                (utf8.length >= 2 && utf8[utf8.length - 2] == escape)) {
                throw new IllegalArgumentException("Premature end of escape sequence at end of input");
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream(utf8.length);
            for (int k = 0; k < utf8.length; k++) {
                byte b = utf8[k];
                if (b == escape) {
                    out.write((decodeDigit(utf8[++k]) << 4) + decodeDigit(utf8[++k]));
                }
                else {
                    out.write(b);
                }
            }

            return new String(out.toByteArray(), "utf-8");
        }
        catch (UnsupportedEncodingException e) {
            throw new InternalError(e.toString());
        }
    }


    private static byte decodeDigit(byte b) {
        if (b >= 0x30 && b <= 0x39) {
            return (byte) (b - 0x30);
        }
        else if (b >= 0x41 && b <= 0x46) {
            return (byte) (b - 0x37);
        }
        else if (b >= 0x61 && b <= 0x66) {
            return (byte) (b - 0x57);
        }
        else {
            throw new IllegalArgumentException("Escape sequence is not hexadecimal: " + (char)b);
        }
    }


    private static byte decodeDigit(byte b) {
        if (b >= 0x30 && b <= 0x39) {
            return (byte) (b - 0x30);
        }
        else if (b >= 0x41 && b <= 0x46) {
            return (byte) (b - 0x37);
        }
        else if (b >= 0x61 && b <= 0x66) {
            return (byte) (b - 0x57);
        }
        else {
            throw new IllegalArgumentException("Escape sequence is not hexadecimal: " + (char)b);
        }
    }


    private static byte decodeDigit(byte b) {
        if (b >= 0x30 && b <= 0x39) {
            return (byte) (b - 0x30);
        }
        else if (b >= 0x41 && b <= 0x46) {
            return (byte) (b - 0x37);
        }
        else if (b >= 0x61 && b <= 0x66) {
            return (byte) (b - 0x57);
        }
        else {
            throw new IllegalArgumentException("Escape sequence is not hexadecimal: " + (char)b);
        }
    }


    public CurrentUserPrivilegeSetProperty(DavProperty<?> xmlDavProperty) throws DavException {
        super(xmlDavProperty.getName(), true);
        if (!SecurityConstants.CURRENT_USER_PRIVILEGE_SET.equals(getName())) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "DAV:current-user-privilege-set expected.");
        }
        privileges = new HashSet<Privilege>();

        // parse property value
        Object value = xmlDavProperty.getValue();
        if (value != null) {
            if (value instanceof Element) {
                privileges.add(Privilege.getPrivilege((Element)value));
            } else if (value instanceof Collection) {
                for (Object entry : ((Collection<?>) value)) {
                    if (entry instanceof Element) {
                        privileges.add(Privilege.getPrivilege((Element) entry));
                    }
                }
            }
        }
    }


    public SupportedPrivilegeSetProperty(DavProperty<?> p) throws DavException {
        super(SecurityConstants.SUPPORTED_PRIVILEGE_SET, true);
        if (!SecurityConstants.SUPPORTED_PRIVILEGE_SET.equals(getName())) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "DAV:supported-privilege-set expected.");
        }

        List<SupportedPrivilege> supportedPrivs = new ArrayList<SupportedPrivilege>();
        
        for (Object obj : Collections.singletonList(p.getValue())) {
            if (obj instanceof Element) {
                supportedPrivs.add(SupportedPrivilege.getSupportedPrivilege((Element) obj));
            } else if (obj instanceof Collection) {
                for (Object entry : ((Collection<?>) obj)) {
                    if (entry instanceof Element) {
                        supportedPrivs.add(SupportedPrivilege.getSupportedPrivilege((Element) entry));
                    }
                }
            }
        }
        supportedPrivileges = supportedPrivs.toArray(new SupportedPrivilege[supportedPrivs.size()]);
    }


    public void init(DavResource resource, ReportInfo info) throws DavException {
        if (resource == null || info == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Unable to run report: WebDAV Resource and ReportInfo must not be null.");
        }
        if (!getType().isRequestedReportType(info)) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Expected report type: '" + getType().getReportName() + "', found: '" + info.getReportName() + ";" + "'.");
        }
        if (info.getDepth() > DavConstants.DEPTH_0) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Invalid Depth header: " + info.getDepth());
        }
    }


    public void init(DavResource resource, ReportInfo info) throws DavException {
        if (resource == null || info == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Unable to run report: WebDAV Resource and ReportInfo must not be null.");
        }
        if (!getType().isRequestedReportType(info)) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Expected report type: '" + getType().getReportName() + "', found: '" + info.getReportName() + ";" + "'.");
        }
        if (info.getDepth() > DavConstants.DEPTH_0) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Invalid Depth header: " + info.getDepth());
        }
    }


    public OrderPatch getOrderPatch() throws DavException {
        OrderPatch op = null;
        Document requestDocument = getRequestDocument();
        if (requestDocument != null) {
            Element root = requestDocument.getDocumentElement();
            op = OrderPatch.createFromXml(root);
        } else {
            log.error("Error while building xml document from ORDERPATH request body.");
        }
        return op;
    }


    public LabelInfo getLabelInfo() throws DavException {
        LabelInfo lInfo = null;
        Document requestDocument = getRequestDocument();
        if (requestDocument != null) {
            Element root = requestDocument.getDocumentElement();
            int depth = getDepth(DEPTH_0);
            lInfo = new LabelInfo(root, depth);
        }
        return lInfo;
    }


    public LockDiscovery getResponseAsLockDiscovery() throws IOException, DavException {
        checkUsed();
        // lockDiscovery has been build while processing the response body.
        // if its still null, this indicates that either the method failed
        // or that the response body could not be parsed.
        // in either case this is an error and will be reported to the caller.
        if (lockDiscovery != null) {
            return lockDiscovery;
        } else {
            DavException dx = getResponseException();
            if (dx != null) {
                throw dx;
            } else {
                throw new DavException(getStatusCode(), getName() + " resulted with unexpected status: " + getStatusLine());
            }
        }
    }


    public SubscriptionDiscovery getResponseAsSubscriptionDiscovery() throws IOException, DavException {
        checkUsed();
        if (subscriptionDiscovery != null) {
            return subscriptionDiscovery;
        } else {
            DavException dx = getResponseException();
            if (dx != null) {
                throw dx;
            } else {
                throw new DavException(getStatusCode(), getName() + " resulted with unexpected status: " + getStatusLine());
            }
        }
    }


    public MultiStatus getResponseBodyAsMultiStatus() throws IOException, DavException {
        checkUsed();
        if (multiStatus != null) {
            return multiStatus;
        } else {
            DavException dx = getResponseException();
            if (dx != null) {
                throw dx;
            } else {
                throw new DavException(getStatusCode(), getName() + " resulted with unexpected status: " + getStatusLine());
            }
        }
    }


    public EventDiscovery getResponseAsEventDiscovery() throws IOException, DavException {
        checkUsed();
        if (eventDiscovery != null) {
            return eventDiscovery;
        } else {
            DavException dx = getResponseException();
            if (dx != null) {
                throw dx;
            } else {
                throw new DavException(getStatusCode(), getName() + " resulted with unexpected status: " + getStatusLine());
            }
        }
    }


    protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
        // in case of successful response code -> parse xml body into lockDiscovery.
        if (getSuccess()) {
            try {
                setSuccess(buildDiscoveryFromRoot(getRootElement()));
            } catch (IOException e) {
                log.error("Error while parsing multistatus response: " + e);
                setSuccess(false);
            }
        }
    }


    protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
        // in case of successful response code -> parse xml body discovery object
        if (getSuccess()) {
            try {
                setSuccess(buildDiscoveryFromRoot(getRootElement()));
            } catch (IOException e) {
                log.error("Error while parsing multistatus response: " + e);
                setSuccess(false);
            }
        }
    }


     protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
         // in case of successful response code -> parse xml body discovery object
         if (getSuccess()) {
             try {
                 setSuccess(buildDiscoveryFromRoot(getRootElement()));
             } catch (IOException e) {
                 log.error("Error while parsing multistatus response: " + e);
                 setSuccess(false);
             }
         }
     }


    public static String concatComplianceClasses(String[] complianceClasses) {
        StringBuffer b = new StringBuffer();
        for (int i = 0; i < complianceClasses.length; i++) {
            if (i > 0) {
                b.append(",");
            }
            b.append(complianceClasses[i]);
        }
        return b.toString();
    }


    public static String implode(String[] arr, String delim) {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) {
                buf.append(delim);
            }
            buf.append(arr[i]);
        }
        return buf.toString();
    }


    public static String implode(String[] arr, String delim) {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) {
                buf.append(delim);
            }
            buf.append(arr[i]);
        }
        return buf.toString();
    }


    public static BindInfo createFromXml(Element root) throws DavException {
        if (!DomUtil.matches(root, BindConstants.XML_BIND, BindConstants.NAMESPACE)) {
            log.warn("DAV:bind element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        String href = null;
        String segment = null;
        ElementIterator it = DomUtil.getChildren(root);
        while (it.hasNext()) {
            Element elt = it.nextElement();
            if (DomUtil.matches(elt, BindConstants.XML_SEGMENT, BindConstants.NAMESPACE)) {
                if (segment == null) {
                    segment = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:segment element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else if (DomUtil.matches(elt, BindConstants.XML_HREF, BindConstants.NAMESPACE)) {
                if (href == null) {
                    href = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:href element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else  {
                log.warn("unexpected element " + elt.getLocalName());
                throw new DavException(DavServletResponse.SC_BAD_REQUEST);
            }
        }
        if (href == null) {
            log.warn("DAV:href element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        if (segment == null) {
            log.warn("DAV:segment element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        return new BindInfo(href, segment);
    }


    public static ParentElement createFromXml(Element root) throws DavException {
        if (!DomUtil.matches(root, BindConstants.XML_PARENT, BindConstants.NAMESPACE)) {
            log.warn("DAV:paret element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        String href = null;
        String segment = null;
        ElementIterator it = DomUtil.getChildren(root);
        while (it.hasNext()) {
            Element elt = it.nextElement();
            if (DomUtil.matches(elt, BindConstants.XML_SEGMENT, BindConstants.NAMESPACE)) {
                if (segment == null) {
                    segment = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:segment element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else if (DomUtil.matches(elt, BindConstants.XML_HREF, BindConstants.NAMESPACE)) {
                if (href == null) {
                    href = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:href element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else  {
                log.warn("unexpected element " + elt.getLocalName());
                throw new DavException(DavServletResponse.SC_BAD_REQUEST);
            }
        }
        if (href == null) {
            log.warn("DAV:href element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        if (segment == null) {
            log.warn("DAV:segment element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        return new ParentElement(href, segment);
    }


    public static RebindInfo createFromXml(Element root) throws DavException {
        if (!DomUtil.matches(root, BindConstants.XML_REBIND, BindConstants.NAMESPACE)) {
            log.warn("DAV:rebind element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        String href = null;
        String segment = null;
        ElementIterator it = DomUtil.getChildren(root);
        while (it.hasNext()) {
            Element elt = it.nextElement();
            if (DomUtil.matches(elt, BindConstants.XML_SEGMENT, BindConstants.NAMESPACE)) {
                if (segment == null) {
                    segment = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:segment element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else if (DomUtil.matches(elt, BindConstants.XML_HREF, BindConstants.NAMESPACE)) {
                if (href == null) {
                    href = DomUtil.getText(elt);
                } else {
                    log.warn("unexpected multiple occurrence of DAV:href element");
                    throw new DavException(DavServletResponse.SC_BAD_REQUEST);
                }
            } else  {
                log.warn("unexpected element " + elt.getLocalName());
                throw new DavException(DavServletResponse.SC_BAD_REQUEST);
            }
        }
        if (href == null) {
            log.warn("DAV:href element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        if (segment == null) {
            log.warn("DAV:segment element expected");
            throw new DavException(DavServletResponse.SC_BAD_REQUEST);
        }
        return new RebindInfo(href, segment);
    }


    public Repository getRepository() throws RepositoryException {
        String name = servlet.getInitParameter(Repository.class.getName());
        if (name == null) {
            name = Repository.class.getName();
        }

        ServletContext context = servlet.getServletContext();
        Object repository = context.getAttribute(name);
        if (repository instanceof Repository) {
            return (Repository) repository;
        } else if (repository != null) {
            throw new RepositoryException(
                    "Invalid repository: Attribute " + name
                    + " in servlet context " + context.getServletContextName()
                    + " is an instance of " + repository.getClass().getName());
        } else {
            throw new RepositoryException(
                    "Repository not found: Attribute " + name
                    + " does not exist in servlet context "
                    + context.getServletContextName());
        }
    }


    public Repository getRepository() throws RepositoryException {
        String name = config.getInitParameter(Repository.class.getName());
        if (name == null) {
            name = Repository.class.getName();
        }

        ServletContext context = config.getServletContext();
        Object repository = context.getAttribute(name);
        if (repository instanceof Repository) {
            return (Repository) repository;
        } else if (repository != null) {
            throw new RepositoryException(
                    "Invalid repository: Attribute " + name
                    + " in servlet context " + context.getServletContextName()
                    + " is an instance of " + repository.getClass().getName());
        } else {
            throw new RepositoryException(
                    "Repository not found: Attribute " + name
                    + " does not exist in servlet context "
                    + context.getServletContextName());
        }
    }


    public void init() throws ServletException {
        try {
            Hashtable environment = new Hashtable();
            Enumeration names = getInitParameterNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                if (name.equals("location")) {
                    location = getInitParameter(name);
                } else if (!name.equals(Repository.class.getName())
                        && !name.equals(RemoteAdapterFactory.class.getName())) {
                    environment.put(name, getInitParameter(name));
                }
            }
            context =  new InitialContext(environment);
            context.bind(location, getRemoteRepository());
        } catch (NamingException e) {
            throw new ServletException(
                    "Failed to bind remote repository to JNDI: " + location, e);
        }
    }


    public void init() throws ServletException {
        try {
            Hashtable environment = new Hashtable();
            Enumeration names = getInitParameterNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                if (name.equals("location")) {
                    location = getInitParameter(name);
                } else if (!name.equals(Repository.class.getName())) {
                    environment.put(name, getInitParameter(name));
                }
            }
            context =  new InitialContext(environment);
            context.bind(location, new ServletRepository(this));
        } catch (NamingException e) {
            throw new ServletException(
                    "Failed to bind repository to JNDI: " + location, e);
        }
    }


    protected Repository getRepository() throws RepositoryException {
        try {
            String location = Repository.class.getName().replace('.', '/');
            Hashtable environment = new Hashtable();
            Enumeration names = getInitParameterNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                if (name.equals("location")) {
                    location = getInitParameter(name);
                } else if (!name.equals(Repository.class.getName())) {
                    environment.put(name, getInitParameter(name));
                }
            }
            return new JNDIRepositoryFactory(
                    new InitialContext(environment), location).getRepository();
        } catch (NamingException e) {
            throw new RepositoryException(
                    "Repository not found: Invalid JNDI context", e);
        }
    }


    protected Repository getRepository() throws RepositoryException {
        String location =
            "//localhost/" + RemoteRepository.class.getName().replace('.', '/');
        try {
            Hashtable environment = new Hashtable();
            Enumeration names = getInitParameterNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                if (name.equals("location")) {
                    location = getInitParameter(name);
                } else if (!name.equals(Repository.class.getName())
                        && !name.equals(LocalAdapterFactory.class.getName())) {
                    environment.put(name, getInitParameter(name));
                }
            }
            return new JNDIRemoteRepositoryFactory(
                    getLocalAdapterFactory(),
                    new InitialContext(environment), location).getRepository();
        } catch (NamingException e) {
            throw new RepositoryException(
                    "Repository not found: Invalid JNDI context", e);
        }
    }


    public void init(Properties props) throws ServletException {
        Iterator iter = props.keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            String mapName = toMapName(name, '.');
            try {
                if (map.containsKey(mapName)) {
                    map.put(mapName, props.getProperty(name));
                }
            } catch (Exception e) {
                throw new ServletExceptionWithCause(
                        "Invalid configuration property: " + name, e);
            }
        }
    }


    public void init(ServletConfig ctx) throws ServletException {
        Enumeration names = ctx.getInitParameterNames();
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();
            String mapName = toMapName(name, '-');
            try {
                if (map.containsKey(mapName)) {
                    map.put(mapName, ctx.getInitParameter(name));
                }
            } catch (Exception e) {
                throw new ServletExceptionWithCause(
                        "Invalid servlet configuration option: " + name, e);
            }
        }
    }


    private boolean configure() throws ServletException {
        // check if there is a loadable bootstrap config
        Properties bootstrapProps = new Properties();
        String bstrp = bootstrapOverride;
        if (bstrp == null) {
            bstrp = getServletConfig().getInitParameter(INIT_PARAM_BOOTSTRAP_CONFIG);
        }
        if (bstrp != null) {
            // check if it's a web-resource
            InputStream in = getServletContext().getResourceAsStream(bstrp);
            if (in == null) {
                // check if it's a file
                bootstrapConfigFile = new File(bstrp);
                if (bootstrapConfigFile.canRead()) {
                    try {
                        in = new FileInputStream(bootstrapConfigFile);
                    } catch (FileNotFoundException e) {
                        throw new ServletExceptionWithCause(
                                "Bootstrap configuration not found: " + bstrp, e);
                    }
                }
            }
            if (in != null) {
                try {
                    bootstrapProps.load(in);
                } catch (IOException e) {
                    throw new ServletException(
                            "Bootstrap configuration failure: " + bstrp, e);
                } finally {
                    try {
                        in.close();
                    } catch (IOException e) {
                        // ignore
                    }
                }
            }
        }

        // read bootstrap config
        config = new BootstrapConfig();
        config.init(getServletConfig());
        config.init(bootstrapProps);
        config.validate();
        if (!config.isValid()
                || config.getRepositoryHome() == null) {
            if (bstrp == null) {
                log.error("Repository startup configuration is not valid.");
            } else {
                log.error("Repository startup configuration is not valid but a bootstrap config is specified.");
                log.error("Either create the {} file or", bstrp);
                log.error("use the '/config/index.jsp' for easy configuration.");
            }
            return false;
        } else {
            config.logInfos();
            return true;
        }
    }


    private BootstrapConfig getConfig() throws ServletException {
        if (config == null) {
            // check if there is a loadable bootstrap config
            Properties bootstrapProps = new Properties();
            String bstrp = bootstrapOverride;
            if (bstrp == null) {
                bstrp = getServletConfig().getInitParameter(INIT_PARAM_BOOTSTRAP_CONFIG);
            }
            if (bstrp != null) {
                // check if it's a web-resource
                InputStream in = getServletContext().getResourceAsStream(bstrp);
                if (in == null) {
                    // check if it's a file
                    File file = new File(bstrp);
                    if (file.canRead()) {
                        try {
                            in = new FileInputStream(file);
                        } catch (FileNotFoundException e) {
                            throw new ServletExceptionWithCause(
                                    "Bootstrap configuration not found: " + bstrp, e);
                        }
                    }
                }
                if (in != null) {
                    try {
                        bootstrapProps.load(in);
                    } catch (IOException e) {
                        throw new ServletExceptionWithCause(
                                "Bootstrap configuration failure: " + bstrp, e);
                    } finally {
                        try {
                            in.close();
                        } catch (IOException e) {
                            // ignore
                        }
                    }
                }
            }

            // read bootstrap config
            BootstrapConfig tmpConfig = new BootstrapConfig();
            tmpConfig.init(getServletConfig());
            tmpConfig.init(bootstrapProps);
            tmpConfig.validate();
            if (!tmpConfig.isValid()) {
                throw new ServletException(
                        "Repository access configuration is not valid.");
            }
            tmpConfig.logInfos();
            config = tmpConfig;
        }
        return config;
    }


    public void init(Properties props) throws ServletException {
        super.init(props);
        // add all props whose name starts with 'java.namming.' to the env
        Iterator iter = props.keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            if (name.startsWith("java.naming.")) {
                jndiEnv.put(name, props.getProperty(name));
            }
        }
    }


    public void init(ServletConfig ctx) throws ServletException  {
        super.init(ctx);
        // add all params whose name starts with 'java.namming.' to the env
        Enumeration names = ctx.getInitParameterNames();
        while (names.hasMoreElements()) {
            String name = (String) names.nextElement();
            if (name.startsWith("java.naming.")) {
                jndiEnv.put(name, ctx.getInitParameter(name));
            }
        }
        // enable jndi if url is specified
        jndiEnabled = jndiEnv.containsKey("java.naming.provider.url");
    }


    public void testMax() {
        max = new TimeSeriesMax();

        // initial values
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // no changes in first second
        max.recordOneSecond();
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // 2 seconds
        max.recordValue(42);
        max.recordOneSecond();
        assertValues(max.getValuePerSecond(), 42);
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // no changes in 3rd second
        max.recordOneSecond();
        assertValues(max.getValuePerSecond(), 0, 42);
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // 4th second
        max.recordValue(99);
        max.recordOneSecond();
        assertValues(max.getValuePerSecond(), 99, 0, 42);
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // one minute later
        for (int i = 0; i < 60; i++) {
            max.recordOneSecond();
        }
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute(), 99);
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // another minute later
        for (int i = 0; i < 60; i++) {
            max.recordOneSecond();
        }
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute(), 0, 99);
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek());

        // one hour
        for (int i = 0; i < 60 * 60; i++) {
            max.recordOneSecond();
        }
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour(), 99);
        assertValues(max.getValuePerWeek());

        // one week
        for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
            max.recordOneSecond();
        }
        assertValues(max.getValuePerSecond());
        assertValues(max.getValuePerMinute());
        assertValues(max.getValuePerHour());
        assertValues(max.getValuePerWeek(), 99);
    }


    public void testCounter() {
        recorder = new TimeSeriesRecorder(RepositoryStatistics.Type.SESSION_READ_COUNTER);
        AtomicLong counter = recorder.getCounter();

        // initial values
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // no changes in first second
        recorder.recordOneSecond();
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // one increment in second
        counter.incrementAndGet();
        recorder.recordOneSecond();
        assertValues(recorder.getValuePerSecond(), 1);
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // two increments in second
        counter.incrementAndGet();
        counter.incrementAndGet();
        recorder.recordOneSecond();
        assertValues(recorder.getValuePerSecond(), 2, 1);
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // no changes in a second
        recorder.recordOneSecond();
        assertValues(recorder.getValuePerSecond(), 0, 2, 1);
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // ten increments in a second
        counter.addAndGet(10);
        recorder.recordOneSecond();
        assertValues(recorder.getValuePerSecond(), 10, 0, 2, 1);
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // one minute
        for (int i = 0; i < 60; i++) {
            recorder.recordOneSecond();
        }
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute(), 13);
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // second minute
        for (int i = 0; i < 60; i++) {
            recorder.recordOneSecond();
        }
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute(), 0, 13);
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek());

        // one hour
        for (int i = 0; i < 60 * 60; i++) {
            recorder.recordOneSecond();
        }
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour(), 13);
        assertValues(recorder.getValuePerWeek());

        // one week
        for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
            recorder.recordOneSecond();
        }
        assertValues(recorder.getValuePerSecond());
        assertValues(recorder.getValuePerMinute());
        assertValues(recorder.getValuePerHour());
        assertValues(recorder.getValuePerWeek(), 13);
    }


    public void testAverage() {
        TimeSeriesRecorder values = new TimeSeriesRecorder(true);
        TimeSeriesRecorder counts = new TimeSeriesRecorder(true);
        avg = new TimeSeriesAverage(values, counts);
        AtomicLong value = values.getCounter();
        AtomicLong count = counts.getCounter();

        // initial values
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // no changes in first second
        values.recordOneSecond();
        counts.recordOneSecond();
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // 2 seconds
        value.set(42);
        count.set(2);
        values.recordOneSecond();
        counts.recordOneSecond();
        assertValues(avg.getValuePerSecond(), 21);
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // no changes in 3rd second
        values.recordOneSecond();
        counts.recordOneSecond();
        assertValues(avg.getValuePerSecond(), 0, 21);
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // one minute later
        for (int i = 0; i < 60; i++) {
            values.recordOneSecond();
            counts.recordOneSecond();
        }
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute(), 21);
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // another minute later
        for (int i = 0; i < 60; i++) {
            values.recordOneSecond();
            counts.recordOneSecond();
        }
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute(), 0, 21);
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek());

        // one hour
        for (int i = 0; i < 60 * 60; i++) {
            values.recordOneSecond();
            counts.recordOneSecond();
        }
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour(), 21);
        assertValues(avg.getValuePerWeek());

        // one week
        for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
            values.recordOneSecond();
            counts.recordOneSecond();
        }
        assertValues(avg.getValuePerSecond());
        assertValues(avg.getValuePerMinute());
        assertValues(avg.getValuePerHour());
        assertValues(avg.getValuePerWeek(), 21);
    }


    public void testMaxWithMissing() {
        for (long m : new long[]{-42, 42}) {
            max = new TimeSeriesMax(m);

            // initial values
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // no changes in first second
            max.recordOneSecond();
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // 2 seconds
            max.recordValue(42);
            max.recordOneSecond();
            assertValues(max.getValuePerSecond(), 42);
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // no changes in 3rd second
            max.recordOneSecond();
            assertValues(max.getValuePerSecond(), max.getMissingValue(), 42);
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // 4th second
            max.recordValue(99);
            max.recordOneSecond();
            assertValues(max.getValuePerSecond(), 99, max.getMissingValue(), 42);
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // one minute later
            for (int i = 0; i < 60; i++) {
                max.recordOneSecond();
            }
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute(), 99);
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // another minute later
            for (int i = 0; i < 60; i++) {
                max.recordOneSecond();
            }
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute(), max.getMissingValue(), 99);
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek());

            // one hour
            for (int i = 0; i < 60 * 60; i++) {
                max.recordOneSecond();
            }
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour(), 99);
            assertValues(max.getValuePerWeek());

            // one week
            for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
                max.recordOneSecond();
            }
            assertValues(max.getValuePerSecond());
            assertValues(max.getValuePerMinute());
            assertValues(max.getValuePerHour());
            assertValues(max.getValuePerWeek(), 99);
        }
    }


    public void testAverageWithMissing() {
        for (long m : new long[]{-42, 42}) {
            TimeSeriesRecorder values = new TimeSeriesRecorder(true);
            TimeSeriesRecorder counts = new TimeSeriesRecorder(true);
            avg = new TimeSeriesAverage(values, counts, m);
            AtomicLong value = values.getCounter();
            AtomicLong count = counts.getCounter();

            // initial values
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // no changes in first second
            values.recordOneSecond();
            counts.recordOneSecond();
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // 2 seconds
            value.set(42);
            count.set(2);
            values.recordOneSecond();
            counts.recordOneSecond();
            assertValues(avg.getValuePerSecond(), 21);
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // no changes in 3rd second
            values.recordOneSecond();
            counts.recordOneSecond();
            assertValues(avg.getValuePerSecond(), avg.getMissingValue(), 21);
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // Division by 0 reported as missing
            value.set(1);
            count.set(0);
            values.recordOneSecond();
            counts.recordOneSecond();

            // one minute later
            for (int i = 0; i < 60; i++) {
                values.recordOneSecond();
                counts.recordOneSecond();
            }
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute(), 21);
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // another minute later
            for (int i = 0; i < 60; i++) {
                values.recordOneSecond();
                counts.recordOneSecond();
            }
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute(), avg.getMissingValue(), 21);
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek());

            // one hour
            for (int i = 0; i < 60 * 60; i++) {
                values.recordOneSecond();
                counts.recordOneSecond();
            }
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour(), 21);
            assertValues(avg.getValuePerWeek());

            // one week
            for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
                values.recordOneSecond();
                counts.recordOneSecond();
            }
            assertValues(avg.getValuePerSecond());
            assertValues(avg.getValuePerMinute());
            assertValues(avg.getValuePerHour());
            assertValues(avg.getValuePerWeek(), 21);
        }
    }


    public void testCounterWithMissing() {
        for (long m : new long[]{-42, 42}) {
            recorder = new TimeSeriesRecorder(true, m);
            AtomicLong counter = recorder.getCounter();

            // initial values
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // no changes in first second
            recorder.recordOneSecond();
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // one increment in second
            counter.set(0);
            counter.incrementAndGet();
            recorder.recordOneSecond();
            assertValues(recorder.getValuePerSecond(), 1);
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // two increments in second
            counter.set(0);
            counter.incrementAndGet();
            counter.incrementAndGet();
            recorder.recordOneSecond();
            assertValues(recorder.getValuePerSecond(), 2, 1);
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // no changes in a second
            recorder.recordOneSecond();
            assertValues(recorder.getValuePerSecond(), recorder.getMissingValue(), 2, 1);
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // ten increments in a second
            counter.set(0);
            counter.addAndGet(10);
            recorder.recordOneSecond();
            assertValues(recorder.getValuePerSecond(), 10, recorder.getMissingValue(), 2, 1);
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // one minute
            for (int i = 0; i < 60; i++) {
                recorder.recordOneSecond();
            }
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute(), 13);
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // second minute
            for (int i = 0; i < 60; i++) {
                recorder.recordOneSecond();
            }
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute(), recorder.getMissingValue(), 13);
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek());

            // one hour
            for (int i = 0; i < 60 * 60; i++) {
                recorder.recordOneSecond();
            }
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour(), 13);
            assertValues(recorder.getValuePerWeek());

            // one week
            for (int i = 0; i < 7 * 24 * 60 * 60; i++) {
                recorder.recordOneSecond();
            }
            assertValues(recorder.getValuePerSecond());
            assertValues(recorder.getValuePerMinute());
            assertValues(recorder.getValuePerHour());
            assertValues(recorder.getValuePerWeek(), 13);
        }
    }


    private void assertValues(long[] values, long... expected) {
        for (int i = 0; i < expected.length; i++) {
            assertEquals(expected[i], values[values.length - i - 1]);
        }
        for (int i = expected.length; i < values.length; i++) {
            assertEquals(max.getMissingValue(), values[values.length - i - 1]);
        }
    }


    private void assertValues(long[] values, long... expected) {
        for (int i = 0; i < expected.length; i++) {
            assertEquals(expected[i], values[values.length - i - 1]);
        }
        for (int i = expected.length; i < values.length; i++) {
            assertEquals(avg.getMissingValue(), values[values.length - i - 1]);
        }
    }


    private void assertValues(long[] values, long... expected) {
        for (int i = 0; i < expected.length; i++) {
            assertEquals(expected[i], values[values.length - i - 1]);
        }
        for (int i = expected.length; i < values.length; i++) {
            assertEquals(recorder.getMissingValue(), values[values.length - i - 1]);
        }
    }


    public void testSerializingContentHandler() throws Exception {
        StringWriter writer = new StringWriter();

        ContentHandler handler =
            SerializingContentHandler.getSerializer(writer);
        handler.startDocument();
        handler.startPrefixMapping("p", "uri");
        handler.startElement("uri", "a", "p:a", new AttributesImpl());
        AttributesImpl attributes = new AttributesImpl();
        attributes.addAttribute("uri", "foo", "p:foo", "CDATA", "bar");
        handler.startElement(null, "b", "b", attributes);
        handler.characters("abc".toCharArray(), 0, 3);
        handler.endElement(null, "b", "b");
        handler.startElement(null, "c", "c", new AttributesImpl());
        handler.endElement(null, "c", "c");
        handler.characters("xyz".toCharArray(), 0, 3);
        handler.endElement("uri", "a", "p:a");
        handler.endPrefixMapping("p");
        handler.endDocument();

        String xml = writer.toString();
        assertContains(xml, "<p:a");
        assertContains(xml, "xmlns:p");
        assertContains(xml, "=");
        assertContains(xml, "uri");
        assertContains(xml, ">");
        assertContains(xml, "<b");
        assertContains(xml, "p:foo");
        assertContains(xml, "bar");
        assertContains(xml, "abc");
        assertContains(xml, "</b>");
        assertContains(xml, "<c/>");
        assertContains(xml, "xyz");
        assertContains(xml, "</p:a>");
    }


    public void testNoPrefixMappingCalls() throws Exception {
        StringWriter writer = new StringWriter();

        ContentHandler handler =
            SerializingContentHandler.getSerializer(writer);
        handler.startDocument();
        handler.startElement("uri", "a", "p:a", new AttributesImpl());
        AttributesImpl attributes = new AttributesImpl();
        attributes.addAttribute("uri", "foo", "p:foo", "CDATA", "bar");
        handler.startElement(null, "b", "b", attributes);
        handler.characters("abc".toCharArray(), 0, 3);
        handler.endElement(null, "b", "b");
        handler.startElement(null, "c", "c", new AttributesImpl());
        handler.endElement(null, "c", "c");
        handler.characters("xyz".toCharArray(), 0, 3);
        handler.endElement("uri", "a", "p:a");
        handler.endDocument();

        String xml = writer.toString();
        assertContains(xml, "<p:a");
        assertContains(xml, "xmlns:p");
        assertContains(xml, "=");
        assertContains(xml, "uri");
        assertContains(xml, ">");
        assertContains(xml, "<b");
        assertContains(xml, "p:foo");
        assertContains(xml, "bar");
        assertContains(xml, "abc");
        assertContains(xml, "</b>");
        assertContains(xml, "<c/>");
        assertContains(xml, "xyz");
        assertContains(xml, "</p:a>");
    }


    public void testBoolean() throws RepositoryException {
        Value value = factory.createValue(true);

        assertEquals(PropertyType.BOOLEAN, value.getType());
        assertEquals(value, factory.createValue(true));

        assertTrue(value.getBoolean());
        try { value.getDate(); fail(); } catch (ValueFormatException e) {}
        try { value.getDecimal(); fail(); } catch (ValueFormatException e) {}
        try { value.getDouble(); fail(); } catch (ValueFormatException e) {}
        try { value.getLong(); fail(); } catch (ValueFormatException e) {}
        assertEquals(Boolean.TRUE.toString(), value.getString());

        // TODO: binary representation
    }


    public void testString() throws RepositoryException {
        String a = "test";
        Value value = factory.createValue(a);

        assertEquals(PropertyType.STRING, value.getType());
        assertEquals(value, factory.createValue(a));

        assertFalse(value.getBoolean());
        try { value.getDate(); fail(); } catch (ValueFormatException e) {}
        try { value.getDecimal(); fail(); } catch (ValueFormatException e) {}
        try { value.getDouble(); fail(); } catch (ValueFormatException e) {}
        try { value.getLong(); fail(); } catch (ValueFormatException e) {}
        assertEquals(a, value.getString());

        // TODO: binary representation
    }


    public void testDouble() throws RepositoryException {
        double a = 123456789.0;
        Value value = factory.createValue(a);

        assertEquals(PropertyType.DOUBLE, value.getType());
        assertEquals(value, factory.createValue(a));

        try { value.getBoolean(); fail(); } catch (ValueFormatException e) {}
        assertEquals((long) a, value.getDate().getTimeInMillis());
        assertEquals(new BigDecimal(a), value.getDecimal());
        assertEquals(a, value.getDouble());
        assertEquals((long) a, value.getLong());
        assertEquals(Double.toString(a), value.getString());

        // TODO: binary representation
    }


    public void testLong() throws RepositoryException {
        long a = 1234567890;
        Value value = factory.createValue(a);

        assertEquals(PropertyType.LONG, value.getType());
        assertEquals(value, factory.createValue(a));

        try { value.getBoolean(); fail(); } catch (ValueFormatException e) {}
        assertEquals(a, value.getDate().getTimeInMillis());
        assertEquals(new BigDecimal(a), value.getDecimal());
        assertEquals((double) a, value.getDouble());
        assertEquals(a, value.getLong());
        assertEquals(Long.toString(a), value.getString());

        // TODO: binary representation
    }


    public void testMatchAll() {
        RangeIterator iterator = new FilteredRangeIterator(LIST.iterator());
        assertEquals(3, iterator.getSize());

        assertEquals(0, iterator.getPosition());
        assertTrue(iterator.hasNext());
        assertEquals("x", iterator.next());

        assertEquals(1, iterator.getPosition());
        assertTrue(iterator.hasNext());
        assertEquals("y", iterator.next());

        assertEquals(2, iterator.getPosition());
        assertTrue(iterator.hasNext());
        assertEquals("z", iterator.next());

        assertEquals(3, iterator.getPosition());
        assertFalse(iterator.hasNext());
    }


    public void testSkip() {
        RangeIterator iterator = new FilteredRangeIterator(LIST.iterator());
        assertEquals(3, iterator.getSize());

        assertEquals(0, iterator.getPosition());
        assertTrue(iterator.hasNext());
        assertEquals("x", iterator.next());

        iterator.skip(1);

        assertEquals(2, iterator.getPosition());
        assertTrue(iterator.hasNext());
        assertEquals("z", iterator.next());

        assertEquals(3, iterator.getPosition());
        assertFalse(iterator.hasNext());
    }


    public void testParseBooleanValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("boolean", true);

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("boolean", key);
            }
            public void value(String value) {
                fail();
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                assertEquals(true, value);
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringWithUnicode() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "abc\u2345ab\u00EB\u0633c");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("abc\u2345ab\u00EB\u0633c", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringWithUnicode2() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "\u00EB");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("\u00EB", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testParseLongValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("long", 123456);

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("long", key);
            }
            public void value(String value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
            public void value(long value) {
                assertEquals(123456, value);
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "abc");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("abc", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringWithBackSlashValue2() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "\'abc\\\\x\\'abc");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("\'abc\\\\x\\'abc", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringWithBackSlashValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "abc\\abc");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("abc\\abc", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testDoubleValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("double", 1235674.342424);

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("double", key);
            }
            public void value(String value) {
                fail();
            }
            public void value(long value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
            public void value(double value) {
                assertEquals(new Double(1235674.342424), new Double(value));
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testStringWithQuoteValue() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("string", "abc\"abc");

        JsonHandler handler = new DummyJsonHandler() {
            public void key(String key) {
                assertEquals("string", key);
            }
            public void value(String value) {
                assertEquals("abc\"abc", value);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testArray() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("array", Arrays.asList(new String[] {"a", "b", "c"}));

        JsonHandler handler = new DummyJsonHandler() {
            boolean arrayStarted = false;
            int index = 0;

            public void key(String key) {
                assertEquals("array", key);
            }
            public void array() {
                assertFalse(arrayStarted);
                arrayStarted = true;
            }
            public void endArray() {
                assertTrue(arrayStarted);
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
            public void value(String value) {
                assertTrue(arrayStarted);
                switch (index) {
                    case 0: assertEquals("a", value); break;
                    case 1: assertEquals("b", value); break;
                    case 2: assertEquals("c", value); break;
                    default: fail();
                }
                index++;
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testLongArray() throws Exception {
        JSONObject obj = new JSONObject();
        obj.put("longarray", Arrays.asList(new Long[] {new Long(123), new Long(3456), new Long(45367)}));

        JsonHandler handler = new DummyJsonHandler() {
            boolean arrayStarted = false;
            int index = 0;

            public void key(String key) {
                assertEquals("longarray", key);
            }
            public void array() {
                assertFalse(arrayStarted);
                arrayStarted = true;
            }
            public void endArray() {
                assertTrue(arrayStarted);
            }
            public void value(long value) {
                assertTrue(arrayStarted);
                switch (index) {
                    case 0: assertEquals(123, value); break;
                    case 1: assertEquals(3456, value); break;
                    case 2: assertEquals(45367, value); break;
                    default: fail();
                }
                index++;
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
            public void value(String value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse(obj.toString());
    }


    public void testParseEmptyObject() throws Exception {
        JsonHandler handler = new DummyJsonHandler() {
            private int objectCnt = 0;
            public void object() {
                objectCnt++;
            }
            public void endObject() {
                assertEquals(1, objectCnt);
            }
            public void array() {
                fail();
            }
            public void endArray() {
                fail();
            }
            public void key(String key) {
                fail();
            }
            public void value(String value) {
                fail();
            }
            public void value(long value) {
                fail();
            }
            public void value(double value) {
                fail();
            }
            public void value(boolean value) {
                fail();
            }
        };
        JsonParser parser = new JsonParser(handler);
        parser.parse("{}");
    }


    public void testParseEmptyObjectValue() throws Exception {

        List l = new ArrayList();
        l.add("{\"a\":{},\"b\":{},\"c\":{}}");
        l.add("{\"a\":{\"b\":{\"c\":{}}}}");
        l.add("{\"a\":{},\"b\":{\"c\":{}}}");
        l.add("{\"a\":{\"b\":{},\"c\":{}}}");
        
        for (Iterator it = l.iterator(); it.hasNext();) {
            JsonHandler handler = new DummyJsonHandler() {
                private int objectCnt = 0;
                public void object() {
                    objectCnt++;
                }
                public void endObject() {
                    assertFalse(objectCnt > 4);
                }
                public void array() {
                    fail();
                }
                public void endArray() {
                    fail();
                }
                public void value(String value) {
                    fail();
                }
                public void value(long value) {
                    fail();
                }
                public void value(double value) {
                    fail();
                }
                public void value(boolean value) {
                    fail();
                }
            };

            JsonParser parser = new JsonParser(handler);
            parser.parse(it.next().toString());
        }
    }


    public Value createValue(InputStream value) {
        try {
            return new BinaryValue(value);
        } finally {
            // JCR-2903
            try { value.close(); } catch (IOException ignore) {}
        }
    }


    public static void encode(InputStream in, OutputStream out)
            throws IOException {
        Writer writer = new BufferedWriter(new OutputStreamWriter(out, CHARSET));
        try {
            encode(in, writer);
        } finally {
            try {
                writer.flush();
            } catch (IOException ignore) {
            }
        }
    }


    public Binary createBinary(InputStream stream) throws RepositoryException {
        try {
            return new BinaryImpl(stream);
        } catch (IOException e) {
            throw new RepositoryException("failed to create Binary instance", e);
        } finally {
            // JCR-2903
            try { stream.close(); } catch (IOException ignore) {}
        }
    }


    public String getInternalString()
            throws ValueFormatException, RepositoryException {
        // build text value if necessary
        if (text == null) {
            try {
                byte[] bytes = new byte[(int) bin.getSize()];
                bin.read(bytes, 0);
                text = new String(bytes, DEFAULT_ENCODING);
            } catch (UnsupportedEncodingException e) {
                throw new RepositoryException(DEFAULT_ENCODING
                        + " not supported on this platform", e);
            } catch (IOException e) {
                throw new RepositoryException("failed to retrieve binary data", e);
            }
        }

        return text;
    }


    public Binary getBinary()
            throws ValueFormatException, IllegalStateException,
            RepositoryException {

        if (bin == null) {
            try {
                bin = new BinaryImpl(new ByteArrayInputStream(text.getBytes(DEFAULT_ENCODING)));
            } catch (UnsupportedEncodingException e) {
                throw new RepositoryException(DEFAULT_ENCODING
                        + " not supported on this platform", e);
            } catch (IOException e) {
                throw new RepositoryException("failed to retrieve binary data", e);
            }
        }

        return bin;
    }


    public static ReferenceValue valueOf(String s) throws ValueFormatException {
        if (s != null) {
            try {
                UUID.fromString(s);
            } catch (IllegalArgumentException iae) {
                throw new ValueFormatException("not a valid UUID format: " + s);
            }
            return new ReferenceValue(s);
        } else {
            throw new ValueFormatException("not a valid UUID format: " + s);
        }
    }


    public static WeakReferenceValue valueOf(String s) throws ValueFormatException {
        if (s != null) {
            try {
                UUID.fromString(s);
            } catch (IllegalArgumentException iae) {
                throw new ValueFormatException("not a valid UUID format: " + s);
            }
            return new WeakReferenceValue(s);
        } else {
            throw new ValueFormatException("not a valid UUID format: " + s);
        }
    }


    public BinaryImpl(InputStream in) throws IOException {
        byte[] spoolBuffer = new byte[0x2000];
        int read;
        int len = 0;
        OutputStream out = null;
        File spoolFile = null;
        try {
            while ((read = in.read(spoolBuffer)) > 0) {
                if (out != null) {
                    // spool to temp file
                    out.write(spoolBuffer, 0, read);
                    len += read;
                } else if (len + read > MAX_BUFFER_SIZE) {
                    // threshold for keeping data in memory exceeded;
                    // create temp file and spool buffer contents
                    TransientFileFactory fileFactory = TransientFileFactory.getInstance();
                    spoolFile = fileFactory.createTransientFile("bin", null, null);
                    out = new FileOutputStream(spoolFile);
                    out.write(buffer, 0, len);
                    out.write(spoolBuffer, 0, read);
                    buffer = null;
                    len += read;
                } else {
                    // reallocate new buffer and spool old buffer contents
                    byte[] newBuffer = new byte[len + read];
                    System.arraycopy(buffer, 0, newBuffer, 0, len);
                    System.arraycopy(spoolBuffer, 0, newBuffer, len, read);
                    buffer = newBuffer;
                    len += read;
                }
            }
        } finally {
            if (out != null) {
                out.close();
            }
        }

        // init fields
        tmpFile = spoolFile;
    }


        private void init(InputStream in, boolean temp) throws IOException {
            byte[] spoolBuffer = new byte[0x2000];
            int read;
            int len = 0;
            OutputStream out = null;
            File spoolFile = null;
            try {
                while ((read = in.read(spoolBuffer)) > 0) {
                    if (out != null) {
                        // spool to temp file
                        out.write(spoolBuffer, 0, read);
                        len += read;
                    } else if (len + read > BinaryQValue.MAX_BUFFER_SIZE) {
                        // threshold for keeping data in memory exceeded;
                        // create temp file and spool buffer contents
                        TransientFileFactory fileFactory = TransientFileFactory.getInstance();
                        spoolFile = fileFactory.createTransientFile("bin", null, null);
                        out = new FileOutputStream(spoolFile);
                        out.write(buffer, 0, len);
                        out.write(spoolBuffer, 0, read);
                        buffer = null;
                        len += read;
                    } else {
                        // reallocate new buffer and spool old buffer contents
                        if (buffer == null) {
                            buffer = EMPTY_BYTE_ARRAY;
                        }
                        byte[] newBuffer = new byte[len + read];
                        System.arraycopy(buffer, 0, newBuffer, 0, len);
                        System.arraycopy(spoolBuffer, 0, newBuffer, len, read);
                        buffer = newBuffer;
                        len += read;
                    }
                }
            } finally {
                in.close();
                if (out != null) {
                    out.close();
                }
            }

            if (spoolFile == null && buffer == null) {
                // input stream was empty -> initialize an empty binary value
                this.temp = false;
                buffer = EMPTY_BYTE_ARRAY;
            } else {
                // init vars
                file = spoolFile;
                this.temp = temp;
            }
            initialized = true;
        }


        private BinaryQValue(InputStream in, boolean temp) throws IOException {
            super(DUMMY_VALUE, PropertyType.BINARY);
            byte[] spoolBuffer = new byte[0x2000];
            int read;
            int len = 0;
            OutputStream out = null;
            File spoolFile = null;
            try {
                while ((read = in.read(spoolBuffer)) > 0) {
                    if (out != null) {
                        // spool to temp file
                        out.write(spoolBuffer, 0, read);
                        len += read;
                    } else if (len + read > BinaryQValue.MAX_BUFFER_SIZE) {
                        // threshold for keeping data in memory exceeded;
                        // create temp file and spool buffer contents
                        TransientFileFactory fileFactory = TransientFileFactory.getInstance();
                        spoolFile = fileFactory.createTransientFile("bin", null, null);
                        out = new FileOutputStream(spoolFile);
                        out.write(buffer, 0, len);
                        out.write(spoolBuffer, 0, read);
                        buffer = null;
                        len += read;
                    } else {
                        // reallocate new buffer and spool old buffer contents
                        byte[] newBuffer = new byte[len + read];
                        System.arraycopy(buffer, 0, newBuffer, 0, len);
                        System.arraycopy(spoolBuffer, 0, newBuffer, len, read);
                        buffer = newBuffer;
                        len += read;
                    }
                }
            } finally {
                in.close();
                if (out != null) {
                    out.close();
                }
            }

            // init vars
            file = spoolFile;
            this.temp = temp;
            // buffer is EMPTY_BYTE_ARRAY (default value)
        }


    public InputStream getStream() throws RepositoryException {
        if (tmpFile != null) {
            try {
                // this instance is backed by a temp file
                return new FileInputStream(tmpFile);
            } catch (FileNotFoundException e) {
                throw new RepositoryException("already disposed");
            }
        } else {
            // this instance is backed by an in-memory buffer
            return new ByteArrayInputStream(buffer);
        }
    }


        public InputStream getStream() throws RepositoryException {
            // always return a 'fresh' stream
            if (file != null) {
                // this instance is backed by a 'real' file
                try {
                    return new FileInputStream(file);
                } catch (FileNotFoundException fnfe) {
                    throw new RepositoryException("file backing binary value not found",
                        fnfe);
                }
            } else {
                return new ByteArrayInputStream(buffer);
            }
        }


    public long getSize() throws RepositoryException {
        if (tmpFile != null) {
            // this instance is backed by a temp file
            if (tmpFile.exists()) {
                return tmpFile.length();
            } else {
                return -1;
            }
        } else {
            // this instance is backed by an in-memory buffer
            return buffer.length;
        }
    }


        public long getLength() {
            if (file != null) {
                // this instance is backed by a 'real' file
                if (file.exists()) {
                    return file.length();
                } else {
                    return -1;
                }
            } else {
                // this instance is backed by an in-memory buffer
                return buffer.length;
            }
        }


        public long getLength() {
            if (file != null) {
                // this instance is backed by a 'real' file
                if (file.exists()) {
                    return file.length();
                } else {
                    return -1;
                }
            } else if (buffer != null) {
                // this instance is backed by an in-memory buffer
                return buffer.length;
            } else {
                // value has not yet been read from the server.
                return length;
            }
        }


    public static Value[] convert(String[] srcValues, int targetType, ValueFactory factory)
            throws ValueFormatException, IllegalArgumentException {
        if (srcValues == null) {
            return null;
        }
        Value[] newValues = new Value[srcValues.length];
        for (int i = 0; i < srcValues.length; i++) {
            newValues[i] = convert(srcValues[i], targetType, factory);
        }
        return newValues;
    }


        public String[] listAll() throws IOException {
            File[] files = directory.getDirectory().listFiles(FILTER);
            if (files == null) {
                return null;
            }
            String[] names = new String[files.length];
            for (int i = 0; i < names.length; i++) {
                names[i] = files[i].getName();
            }
            return names;
        }


    private String[] getJCRNames(Name[] names) throws NamespaceException {
        if (names == null) {
            return null;
        }
        String[] ret = new String[names.length];
        for (int i=0; i<names.length; i++) {
            ret[i] = resolver.getJCRName(names[i]);
        }
        return ret;
    }


    protected HrefProperty getHrefProperty(DavPropertyName name, Node[] values,
                                           boolean isProtected, boolean isCollection) {
        if (values == null) {
            return null;
        }
        String[] pHref = new String[values.length];
        for (int i = 0; i < values.length; i++) {
            pHref[i] = getLocatorFromNode(values[i]).getHref(isCollection);
        }
        return new HrefProperty(name, pHref, isProtected);
    }


    private Value[] createValues(QValue[] qv) {
        if (qv == null){
            return null;
        }
        Value[] ret = new Value[qv.length];
        for (int i=0; i<ret.length; i++) {
            ret[i] = new QValueValue(qv[i], resolver);
        }
        return ret;
    }


    public static Value[] convert(InputStream[] srcValues, int targetType,
                                  ValueFactory factory)
            throws ValueFormatException, IllegalArgumentException {
        if (srcValues == null) {
            return null;
        }
        Value[] newValues = new Value[srcValues.length];
        for (int i = 0; i < srcValues.length; i++) {
            newValues[i] = convert(srcValues[i], targetType, factory);
        }
        return newValues;
    }


    public static Value[] copy(Value[] srcValues, ValueFactory factory)
            throws IllegalStateException {
        if (srcValues == null) {
            return null;
        }

        Value[] newValues = new Value[srcValues.length];
        for (int i = 0; i < srcValues.length; i++) {
            newValues[i] = copy(srcValues[i], factory);
        }
        return newValues;
    }


    public static InternalValue[] create(QValue[] values)
            throws RepositoryException {
        if (values == null) {
            return null;
        }
        InternalValue[] tmp = new InternalValue[values.length];
        for (int i = 0; i < values.length; i++) {
            tmp[i] = InternalValue.create(values[i]);
        }
        return tmp;
    }


    private static Privilege[] getPrivileges(String[] privNames, AccessControlManager acMgr) throws RepositoryException {
        if (privNames == null || privNames.length == 0) {
            return new Privilege[0];
        }
        Privilege[] privileges = new Privilege[privNames.length];
        for (int i = 0; i < privNames.length; i++) {
            privileges[i] = acMgr.privilegeFromName(privNames[i]);
        }
        return privileges;
    }


    public static ValueConstraint[] create(int type, String jcrDefinition[], NamePathResolver resolver)
            throws InvalidConstraintException {
        if (jcrDefinition == null || jcrDefinition.length == 0) {
            return ValueConstraint.EMPTY_ARRAY;
        }
        ValueConstraint[] ret = new ValueConstraint[jcrDefinition.length];
        for (int i=0; i<ret.length; i++) {
            ret[i] = ValueConstraint.create(type, jcrDefinition[i], resolver);
        }
        return ret;
    }


    public static ValueConstraint[] create(int type, String[] definition)
            throws InvalidConstraintException {
        if (definition == null || definition.length == 0) {
            return ValueConstraint.EMPTY_ARRAY;
        }
        ValueConstraint[] ret = new ValueConstraint[definition.length];
        for (int i=0; i<ret.length; i++) {
            ret[i] = ValueConstraint.create(type, definition[i]);
        }
        return ret;
    }


    public Object with(Node lockable, boolean isDeep, long timeout, boolean isSessionScoped)
            throws UnsupportedRepositoryOperationException, RepositoryException, InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout must be >= 0");
        }

        Session session = lockable.getSession();

        EventListener listener = null;
        try {
            // check whether the lockable can be locked at all
            String mix = session.getNamespacePrefix(MIX);
            if (!lockable.isNodeType(mix + ":lockable")) {
                throw new IllegalArgumentException("Node is not lockable");
            }

            Lock lock = tryLock(lockable, isDeep, timeout, isSessionScoped);
            if (lock != null) {
                return runAndUnlock(lock);
            }

            if (timeout == 0) {
                return TIMED_OUT;
            }

            long timelimit;
            if (timeout == Long.MAX_VALUE) {
                timelimit = Long.MAX_VALUE;
            } else {
                timelimit = System.currentTimeMillis() + timeout;
            }

            // node is locked by other session -> register event listener if possible
            if (isObservationSupported(session)) {
                ObservationManager om = session.getWorkspace().getObservationManager();
                listener = new EventListener() {
                    public void onEvent(EventIterator events) {
                        synchronized (Locked.this) {
                            Locked.this.notify();
                        }
                    }
                };
                om.addEventListener(listener, Event.PROPERTY_REMOVED,
                        lockable.getPath(), false, null, null, true);
            }

            // now keep trying to acquire the lock
            // using 'this' as a monitor allows the event listener to notify
            // the current thread when the lockable node is possibly unlocked
            for (; ;) {
                synchronized (this) {
                    lock = tryLock(lockable, isDeep, timeout, isSessionScoped);
                    if (lock != null) {
                        return runAndUnlock(lock);
                    } else {
                        // check timeout
                        if (System.currentTimeMillis() > timelimit) {
                            return TIMED_OUT;
                        }
                        if (listener != null) {
                            // event listener *should* wake us up, however
                            // there is a chance that removal of the lockOwner
                            // property is notified before the node is acutally
                            // unlocked. therefore we use a safety net to wait
                            // at most 1000 millis.
                            this.wait(Math.min(1000, timeout));
                        } else {
                            // repository does not support observation
                            // wait at most 50 millis then retry
                            this.wait(Math.min(50, timeout));
                        }
                    }
                }
            }
        } finally {
            if (listener != null) {
                session.getWorkspace().getObservationManager().removeEventListener(listener);
            }
        }
    }


    public Object with(Node lockable, boolean isDeep, long timeout)
            throws UnsupportedRepositoryOperationException, RepositoryException, InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout must be >= 0");
        }

        Session session = lockable.getSession();
        NamePathResolver resolver = new DefaultNamePathResolver(session);

        Lock lock;
        EventListener listener = null;
        try {
            // check whether the lockable can be locked at all
            if (!lockable.isNodeType(resolver.getJCRName(NameConstants.MIX_LOCKABLE))) {
                throw new IllegalArgumentException("Node is not lockable");
            }

            lock = tryLock(lockable, isDeep);
            if (lock != null) {
                return runAndUnlock(lock);
            }

            if (timeout == 0) {
                return TIMED_OUT;
            }

            long timelimit;
            if (timeout == Long.MAX_VALUE) {
                timelimit = Long.MAX_VALUE;
            } else {
                timelimit = System.currentTimeMillis() + timeout;
            }

            // node is locked by other session -> register event listener if possible
            if (isObservationSupported(session)) {
                ObservationManager om = session.getWorkspace().getObservationManager();
                listener = new EventListener() {
                    public void onEvent(EventIterator events) {
                        synchronized (this) {
                            this.notify();
                        }
                    }
                };
                om.addEventListener(listener, Event.PROPERTY_REMOVED,
                        lockable.getPath(), false, null, null, true);
            }

            // now keep trying to aquire the lock
            // using 'this' as a monitor allows the event listener to notify
            // the current thread when the lockable node is possibly unlocked
            for (; ;) {
                synchronized (this) {
                    lock = tryLock(lockable, isDeep);
                    if (lock != null) {
                        return runAndUnlock(lock);
                    } else {
                        // check timeout
                        if (System.currentTimeMillis() > timelimit) {
                            return TIMED_OUT;
                        }
                        if (listener != null) {
                            // event listener *should* wake us up, however
                            // there is a chance that removal of the lockOwner
                            // property is notified before the node is acutally
                            // unlocked. therefore we use a safety net to wait
                            // at most 1000 millis.
                            this.wait(Math.min(1000, timeout));
                        } else {
                            // repository does not support observation
                            // wait at most 50 millis then retry
                            this.wait(Math.min(50, timeout));
                        }
                    }
                }
            }
        } catch (NameException e) {
            throw new RepositoryException(e);
        } finally {
            if (listener != null) {
                session.getWorkspace().getObservationManager().removeEventListener(listener);
            }
        }
    }


    public static String digest(String algorithm, byte[] data)
            throws NoSuchAlgorithmException {

        MessageDigest md = MessageDigest.getInstance(algorithm);
        byte[] digest = md.digest(data);
        StringBuilder res = new StringBuilder(digest.length * 2);
        for (byte b : digest) {
            res.append(hexTable[(b >> 4) & 15]);
            res.append(hexTable[b & 15]);
        }
        return res.toString();
    }


    public static String digest(String algorithm, byte[] data)
            throws NoSuchAlgorithmException {

        MessageDigest md = MessageDigest.getInstance(algorithm);
        byte[] digest = md.digest(data);
        StringBuffer res = new StringBuffer(digest.length * 2);
        for (int i = 0; i < digest.length; i++) {
            byte b = digest[i];
            res.append(hexTable[(b >> 4) & 15]);
            res.append(hexTable[b & 15]);
        }
        return res.toString();
    }


    public static String[] explode(String str, int ch, boolean respectEmpty) {
        if (str == null || str.length() == 0) {
            return new String[0];
        }

        ArrayList<String> strings = new ArrayList<String>();
        int pos;
        int lastpos = 0;

        // add snipples
        while ((pos = str.indexOf(ch, lastpos)) >= 0) {
            if (pos - lastpos > 0 || respectEmpty) {
                strings.add(str.substring(lastpos, pos));
            }
            lastpos = pos + 1;
        }
        // add rest
        if (lastpos < str.length()) {
            strings.add(str.substring(lastpos));
        } else if (respectEmpty && lastpos == str.length()) {
            strings.add("");
        }

        // return string array
        return strings.toArray(new String[strings.size()]);
    }


    public static String[] explode(String str, int ch, boolean respectEmpty) {
        if (str == null || str.length() == 0) {
            return new String[0];
        }

        List<String> strings = new ArrayList<String>();
        int pos;
        int lastpos = 0;

        // add snipples
        while ((pos = str.indexOf(ch, lastpos)) >= 0) {
            if (pos - lastpos > 0 || respectEmpty) {
                strings.add(str.substring(lastpos, pos));
            }
            lastpos = pos + 1;
        }
        // add rest
        if (lastpos < str.length()) {
            strings.add(str.substring(lastpos));
        } else if (respectEmpty && lastpos == str.length()) {
            strings.add("");
        }

        // return stringarray
        return strings.toArray(new String[strings.size()]);
    }


    public static String replace(String text, String oldString, String newString) {
        if (text == null || oldString == null || newString == null) {
            throw new IllegalArgumentException("null argument");
        }
        int pos = text.indexOf(oldString);
        if (pos == -1) {
            return text;
        }
        int lastPos = 0;
        StringBuilder sb = new StringBuilder(text.length());
        while (pos != -1) {
            sb.append(text.substring(lastPos, pos));
            sb.append(newString);
            lastPos = pos + oldString.length();
            pos = text.indexOf(oldString, lastPos);
        }
        if (lastPos < text.length()) {
            sb.append(text.substring(lastPos));
        }
        return sb.toString();
    }


    public static String replace(String text, String oldString, String newString) {
        if (text == null || oldString == null || newString == null) {
            throw new IllegalArgumentException("null argument");
        }
        int pos = text.indexOf(oldString);
        if (pos == -1) {
            return text;
        }
        int lastPos = 0;
        StringBuffer sb = new StringBuffer(text.length());
        while (pos != -1) {
            sb.append(text.substring(lastPos, pos));
            sb.append(newString);
            lastPos = pos + oldString.length();
            pos = text.indexOf(oldString, lastPos);
        }
        if (lastPos < text.length()) {
            sb.append(text.substring(lastPos));
        }
        return sb.toString();
    }


    private static String encodeMarkupCharacters(String text, boolean isHtml) {
        if (text == null) {
            throw new IllegalArgumentException("null argument");
        }
        StringBuilder buf = null;
        int length = text.length();
        int pos = 0;
        for (int i = 0; i < length; i++) {
            int ch = text.charAt(i);
            switch (ch) {
                case '<':
                case '>':
                case '&':
                case '"':
                case '\'':
                    if (buf == null) {
                        buf = new StringBuilder();
                    }
                    if (i > 0) {
                        buf.append(text.substring(pos, i));
                    }
                    pos = i + 1;
                    break;
                default:
                    continue;
            }
            if (ch == '<') {
                buf.append("&lt;");
            } else if (ch == '>') {
                buf.append("&gt;");
            } else if (ch == '&') {
                buf.append("&amp;");
            } else if (ch == '"') {
                buf.append("&quot;");
            } else if (ch == '\'') {
                buf.append(isHtml ? "&#39;" : "&apos;");
            }
        }
        if (buf == null) {
            return text;
        } else {
            if (pos < length) {
                buf.append(text.substring(pos));
            }
            return buf.toString();
        }
    }


    public static String encodeIllegalXMLCharacters(String text) {
        if (text == null) {
            throw new IllegalArgumentException("null argument");
        }
        StringBuffer buf = null;
        int length = text.length();
        int pos = 0;
        for (int i = 0; i < length; i++) {
            int ch = text.charAt(i);
            switch (ch) {
                case '<':
                case '>':
                case '&':
                case '"':
                case '\'':
                    if (buf == null) {
                        buf = new StringBuffer();
                    }
                    if (i > 0) {
                        buf.append(text.substring(pos, i));
                    }
                    pos = i + 1;
                    break;
                default:
                    continue;
            }
            if (ch == '<') {
                buf.append("&lt;");
            } else if (ch == '>') {
                buf.append("&gt;");
            } else if (ch == '&') {
                buf.append("&amp;");
            } else if (ch == '"') {
                buf.append("&quot;");
            } else if (ch == '\'') {
                buf.append("&apos;");
            }
        }
        if (buf == null) {
            return text;
        } else {
            if (pos < length) {
                buf.append(text.substring(pos));
            }
            return buf.toString();
        }
    }


    private static String escapeIllegalChars(String name, String illegal) {
        StringBuilder buffer = new StringBuilder(name.length() * 2);
        for (int i = 0; i < name.length(); i++) {
            char ch = name.charAt(i);
            if (illegal.indexOf(ch) != -1
                    || (ch == '.' && name.length() < 3)
                    || (ch == ' ' && (i == 0 || i == name.length() - 1))) {
                buffer.append('%');
                buffer.append(Character.toUpperCase(Character.forDigit(ch / 16, 16)));
                buffer.append(Character.toUpperCase(Character.forDigit(ch % 16, 16)));
            } else {
                buffer.append(ch);
            }
        }
        return buffer.toString();
    }


    public static String escapeIllegalJcrChars(String name) {
        StringBuffer buffer = new StringBuffer(name.length() * 2);
        for (int i = 0; i < name.length(); i++) {
            char ch = name.charAt(i);
            if (ch == '%' || ch == '/' || ch == ':' || ch == '[' || ch == ']'
                || ch == '*' || ch == '\'' || ch == '"' || ch == '|'
                || (ch == '.' && name.length() < 3)
                || (ch == ' ' && (i == 0 || i == name.length() - 1))
                || ch == '\t' || ch == '\r' || ch == '\n') {
                buffer.append('%');
                buffer.append(Character.toUpperCase(Character.forDigit(ch / 16, 16)));
                buffer.append(Character.toUpperCase(Character.forDigit(ch % 16, 16)));
            } else {
                buffer.append(ch);
            }
        }
        return buffer.toString();
    }


    public static String escapeIllegalXpathSearchChars(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s.substring(0, (s.length() - 1)));
        char c = s.charAt(s.length() - 1);
        // NOTE: keep this in sync with _ESCAPED_CHAR below!
        if (c == '!' || c == '(' || c == ':' || c == '^'
            || c == '[' || c == ']' || c == '{' || c == '}' || c == '?') {
            sb.append('\\');
        }
        sb.append(c);
        return sb.toString();
    }


    public static String escapeIllegalXpathSearchChars(String s) {
        StringBuffer sb = new StringBuffer();
        sb.append(s.substring(0, (s.length() - 1)));
        char c = s.charAt(s.length() - 1);
        // NOTE: keep this in sync with _ESCAPED_CHAR below!
        if (c == '!' || c == '(' || c == ':' || c == '^'
            || c == '[' || c == ']' || c == '\"' || c == '{'
            || c == '}' || c == '?') {
            sb.append('\\');
        }
        sb.append(c);
        return sb.toString();
    }


    public static String unescapeIllegalJcrChars(String name) {
        StringBuilder buffer = new StringBuilder(name.length());
        int i = name.indexOf('%');
        while (i > -1 && i + 2 < name.length()) {
            buffer.append(name.toCharArray(), 0, i);
            int a = Character.digit(name.charAt(i + 1), 16);
            int b = Character.digit(name.charAt(i + 2), 16);
            if (a > -1 && b > -1) {
                buffer.append((char) (a * 16 + b));
                name = name.substring(i + 3);
            } else {
                buffer.append('%');
                name = name.substring(i + 1);
            }
            i = name.indexOf('%');
        }
        buffer.append(name);
        return buffer.toString();
    }


    public static String unescapeIllegalJcrChars(String name) {
        StringBuffer buffer = new StringBuffer(name.length());
        int i = name.indexOf('%');
        while (i > -1 && i + 2 < name.length()) {
            buffer.append(name.toCharArray(), 0, i);
            int a = Character.digit(name.charAt(i + 1), 16);
            int b = Character.digit(name.charAt(i + 2), 16);
            if (a > -1 && b > -1) {
                buffer.append((char) (a * 16 + b));
                name = name.substring(i + 3);
            } else {
                buffer.append('%');
                name = name.substring(i + 1);
            }
            i = name.indexOf('%');
        }
        buffer.append(name);
        return buffer.toString();
    }


    public static String getRelativeParent(String path, int level) {
        int idx = path.length();
        while (level > 0) {
            idx = path.lastIndexOf('/', idx - 1);
            if (idx < 0) {
                return "";
            }
            level--;
        }
        return (idx == 0) ? "/" : path.substring(0, idx);
    }


    public static String getRelativeParent(String path, int level) {
        int idx = path.length();
        while (level > 0) {
            idx = path.lastIndexOf('/', idx - 1);
            if (idx < 0) {
                return "";
            }
            level--;
        }
        return (idx == 0) ? "/" : path.substring(0, idx);
    }


    public static String getAbsoluteParent(String path, int level) {
        int idx = 0;
        int len = path.length();
        while (level >= 0 && idx < len) {
            idx = path.indexOf('/', idx + 1);
            if (idx < 0) {
                idx = len;
            }
            level--;
        }
        return level >= 0 ? "" : path.substring(0, idx);
    }


    public static String getAbsoluteParent(String path, int level) {
        int idx = 0;
        int len = path.length();
        while (level >= 0 && idx < len) {
            idx = path.indexOf('/', idx + 1);
            if (idx < 0) {
                idx = len;
            }
            level--;
        }
        return level >= 0 ? "" : path.substring(0, idx);
    }


    public static String replaceVariables(Properties variables, String value,
                                          boolean ignoreMissing)
            throws IllegalArgumentException {
        StringBuilder result = new StringBuilder();

        // Value:
        // +--+-+--------+-+-----------------+
        // |  |p|-->     |q|-->              |
        // +--+-+--------+-+-----------------+
        int p = 0, q = value.indexOf("${");                // Find first ${
        while (q != -1) {
            result.append(value.substring(p, q));          // Text before ${
            p = q;
            q = value.indexOf("}", q + 2);                 // Find }
            if (q != -1) {
                String variable = value.substring(p + 2, q);
                String replacement = variables.getProperty(variable);
                if (replacement == null) {
                    if (ignoreMissing) {
                        replacement = "";
                    } else {
                        throw new IllegalArgumentException(
                                "Replacement not found for ${" + variable + "}.");
                    }
                }
                result.append(replacement);
                p = q + 1;
                q = value.indexOf("${", p);                // Find next ${
            }
        }
        result.append(value.substring(p, value.length())); // Trailing text

        return result.toString();
    }


    public static String replaceVariables(Properties variables, String value,
                                          boolean ignoreMissing)
            throws IllegalArgumentException {
        StringBuffer result = new StringBuffer();

        // Value:
        // +--+-+--------+-+-----------------+
        // |  |p|-->     |q|-->              |
        // +--+-+--------+-+-----------------+
        int p = 0, q = value.indexOf("${");                // Find first ${
        while (q != -1) {
            result.append(value.substring(p, q));          // Text before ${
            p = q;
            q = value.indexOf("}", q + 2);                 // Find }
            if (q != -1) {
                String variable = value.substring(p + 2, q);
                String replacement = variables.getProperty(variable);
                if (replacement == null) {
                    if (ignoreMissing) {
                        replacement = "";
                    } else {
                        throw new IllegalArgumentException(
                                "Replacement not found for ${" + variable + "}.");
                    }
                }
                result.append(replacement);
                p = q + 1;
                q = value.indexOf("${", p);                // Find next ${
            }
        }
        result.append(value.substring(p, value.length())); // Trailing text

        return result.toString();
    }


    public static void encode(byte[] data, int off, int len, Writer writer)
            throws IOException {
        if (len == 0) {
            return;
        }
        if (len < 0 || off >= data.length
                || len + off > data.length) {
            throw new IllegalArgumentException();
        }
        char[] enc = new char[4];
        while (len >= 3) {
            int i = ((data[off] & 0xff) << 16)
                    + ((data[off + 1] & 0xff) << 8)
                    + (data[off + 2] & 0xff);
            enc[0] = BASE64CHARS[i >> 18];
            enc[1] = BASE64CHARS[(i >> 12) & 0x3f];
            enc[2] = BASE64CHARS[(i >> 6) & 0x3f];
            enc[3] = BASE64CHARS[i & 0x3f];
            writer.write(enc, 0, 4);
            off += 3;
            len -= 3;
        }
        // add padding if necessary
        if (len == 1) {
            int i = data[off] & 0xff;
            enc[0] = BASE64CHARS[i >> 2];
            enc[1] = BASE64CHARS[(i << 4) & 0x3f];
            enc[2] = BASE64PAD;
            enc[3] = BASE64PAD;
            writer.write(enc, 0, 4);
        } else if (len == 2) {
            int i = ((data[off] & 0xff) << 8) + (data[off + 1] & 0xff);
            enc[0] = BASE64CHARS[i >> 10];
            enc[1] = BASE64CHARS[(i >> 4) & 0x3f];
            enc[2] = BASE64CHARS[(i << 2) & 0x3f];
            enc[3] = BASE64PAD;
            writer.write(enc, 0, 4);
        }
    }


    public static void encode(byte[] data, int off, int len, Writer writer)
            throws IOException {
        if (len == 0) {
            return;
        }
        if (len < 0 || off >= data.length
                || len + off > data.length) {
            throw new IllegalArgumentException();
        }
        char[] enc = new char[4];
        while (len >= 3) {
            int i = ((data[off] & 0xff) << 16)
                    + ((data[off + 1] & 0xff) << 8)
                    + (data[off + 2] & 0xff);
            enc[0] = BASE64CHARS[i >> 18];
            enc[1] = BASE64CHARS[(i >> 12) & 0x3f];
            enc[2] = BASE64CHARS[(i >> 6) & 0x3f];
            enc[3] = BASE64CHARS[i & 0x3f];
            writer.write(enc, 0, 4);
            off += 3;
            len -= 3;
        }
        // add padding if necessary
        if (len == 1) {
            int i = data[off] & 0xff;
            enc[0] = BASE64CHARS[i >> 2];
            enc[1] = BASE64CHARS[(i << 4) & 0x3f];
            enc[2] = BASE64PAD;
            enc[3] = BASE64PAD;
            writer.write(enc, 0, 4);
        } else if (len == 2) {
            int i = ((data[off] & 0xff) << 8) + (data[off + 1] & 0xff);
            enc[0] = BASE64CHARS[i >> 10];
            enc[1] = BASE64CHARS[(i >> 4) & 0x3f];
            enc[2] = BASE64CHARS[(i << 2) & 0x3f];
            enc[3] = BASE64PAD;
            writer.write(enc, 0, 4);
        }
    }


    public static void decode(char[] chars, int off, int len, OutputStream out)
            throws IOException {
        if (len == 0) {
            return;
        }
        if (len < 0 || off >= chars.length
                || len + off > chars.length) {
            throw new IllegalArgumentException();
        }
        char[] chunk = new char[4];
        byte[] dec = new byte[3];
        int posChunk = 0;
        // decode in chunks of 4 characters
        for (int i = off; i < (off + len); i++) {
            char c = chars[i];
            if (c < DECODETABLE.length && DECODETABLE[c] != 0x7f
                    || c == BASE64PAD) {
                chunk[posChunk++] = c;
                if (posChunk == chunk.length) {
                    int b0 = DECODETABLE[chunk[0]];
                    int b1 = DECODETABLE[chunk[1]];
                    int b2 = DECODETABLE[chunk[2]];
                    int b3 = DECODETABLE[chunk[3]];
                    if (chunk[3] == BASE64PAD && chunk[2] == BASE64PAD) {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        out.write(dec, 0, 1);
                    } else if (chunk[3] == BASE64PAD) {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
                        out.write(dec, 0, 2);
                    } else {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
                        dec[2] = (byte) (b2 << 6 & 0xc0 | b3 & 0x3f);
                        out.write(dec, 0, 3);
                    }
                    posChunk = 0;
                }
            } else if (!Character.isWhitespace(c)) {
                throw new IllegalArgumentException("specified data is not base64 encoded");
            }
        }
    }


    public static void decode(char[] chars, int off, int len, OutputStream out) throws IOException {
        if (len == 0) {
            return;
        }
        if (len < 0 || off >= chars.length
                || len + off > chars.length) {
            throw new IllegalArgumentException();
        }
        char[] chunk = new char[4];
        byte[] dec = new byte[3];
        int posChunk = 0;
        // decode in chunks of 4 characters
        for (int i = off; i < (off + len); i++) {
            char c = chars[i];
            if (c < DECODETABLE.length && DECODETABLE[c] != 0x7f
                    || c == BASE64PAD) {
                chunk[posChunk++] = c;
                if (posChunk == chunk.length) {
                    int b0 = DECODETABLE[chunk[0]];
                    int b1 = DECODETABLE[chunk[1]];
                    int b2 = DECODETABLE[chunk[2]];
                    int b3 = DECODETABLE[chunk[3]];
                    if (chunk[3] == BASE64PAD && chunk[2] == BASE64PAD) {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        out.write(dec, 0, 1);
                    } else if (chunk[3] == BASE64PAD) {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
                        out.write(dec, 0, 2);
                    } else {
                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
                        dec[2] = (byte) (b2 << 6 & 0xc0 | b3 & 0x3f);
                        out.write(dec, 0, 3);
                    }
                    posChunk = 0;
                }
            } else {
                throw new IllegalArgumentException("specified data is not base64 encoded");
            }
        }
    }


    public static String encode(String name) {
        // quick check for root node name
        if (name.length() == 0) {
            return name;
        }
        if (XMLChar.isValidName(name) && name.indexOf("_x") < 0) {
            // already valid
            return name;
        } else {
            // encode
            StringBuffer encoded = new StringBuffer();
            for (int i = 0; i < name.length(); i++) {
                if (i == 0) {
                    // first character of name
                    if (XMLChar.isNameStart(name.charAt(i))) {
                        if (needsEscaping(name, i)) {
                            // '_x' must be encoded
                            encode('_', encoded);
                        } else {
                            encoded.append(name.charAt(i));
                        }
                    } else {
                        // not valid as first character -> encode
                        encode(name.charAt(i), encoded);
                    }
                } else if (!XMLChar.isName(name.charAt(i))) {
                    encode(name.charAt(i), encoded);
                } else {
                    if (needsEscaping(name, i)) {
                        // '_x' must be encoded
                        encode('_', encoded);
                    } else {
                        encoded.append(name.charAt(i));
                    }
                }
            }
            return encoded.toString();
        }
    }


    public static String encode(String name) {
        // quick check for root node name
        if (name.length() == 0) {
            return name;
        }
        if (XMLChar.isValidName(name) && name.indexOf("_x") < 0) {
            // already valid
            return name;
        } else {
            // encode
            StringBuffer encoded = new StringBuffer();
            for (int i = 0; i < name.length(); i++) {
                if (i == 0) {
                    // first character of name
                    if (XMLChar.isNameStart(name.charAt(i))) {
                        if (needsEscaping(name, i)) {
                            // '_x' must be encoded
                            encode('_', encoded);
                        } else {
                            encoded.append(name.charAt(i));
                        }
                    } else {
                        // not valid as first character -> encode
                        encode(name.charAt(i), encoded);
                    }
                } else if (!XMLChar.isName(name.charAt(i))) {
                    encode(name.charAt(i), encoded);
                } else {
                    if (needsEscaping(name, i)) {
                        // '_x' must be encoded
                        encode('_', encoded);
                    } else {
                        encoded.append(name.charAt(i));
                    }
                }
            }
            return encoded.toString();
        }
    }


    public static String encodePath(String path) {
        String[] names = Text.explode(path, '/', true);
        StringBuffer encoded = new StringBuffer(path.length());
        for (int i = 0; i < names.length; i++) {
            // detect index
            String index = null;
            int idx = names[i].indexOf('[');
            if (idx != -1) {
                index = names[i].substring(idx);
                names[i] = names[i].substring(0, idx);
            }
            encoded.append(encode(names[i]));
            if (index != null) {
                encoded.append(index);
            }
            if (i < names.length - 1) {
                encoded.append('/');
            }
        }
        return encoded.toString();
    }


    public static String encodePath(String path) {
        String[] names = Text.explode(path, '/', true);
        StringBuffer encoded = new StringBuffer(path.length());
        for (int i = 0; i < names.length; i++) {
            // detect index
            String index = null;
            int idx = names[i].indexOf('[');
            if (idx != -1) {
                index = names[i].substring(idx);
                names[i] = names[i].substring(0, idx);
            }
            encoded.append(encode(names[i]));
            if (index != null) {
                encoded.append(index);
            }
            if (i < names.length - 1) {
                encoded.append('/');
            }
        }
        return encoded.toString();
    }


    public static String decode(String name) {
        // quick check
        if (name.indexOf("_x") < 0) {
            // not encoded
            return name;
        }
        StringBuffer decoded = new StringBuffer();
        Matcher m = ENCODE_PATTERN.matcher(name);
        while (m.find()) {
            char ch = (char) Integer.parseInt(m.group().substring(2, 6), 16);
            if (ch == '$' || ch == '\\') {
                m.appendReplacement(decoded, "\\" + ch);
            } else {
                m.appendReplacement(decoded, Character.toString(ch));
            }
        }
        m.appendTail(decoded);
        return decoded.toString();
    }


    public static String decode(String name) {
        // quick check
        if (name.indexOf("_x") < 0) {
            // not encoded
            return name;
        }
        StringBuffer decoded = new StringBuffer();
        Matcher m = ENCODE_PATTERN.matcher(name);
        while (m.find()) {
            char ch = (char) Integer.parseInt(m.group().substring(2, 6), 16);
            if (ch == '$' || ch == '\\') {
                m.appendReplacement(decoded, "\\" + ch);
            } else {
                m.appendReplacement(decoded, Character.toString(ch));
            }
        }
        m.appendTail(decoded);
        return decoded.toString();
    }


    protected void entering(Node node, int level)
            throws RepositoryException {
        if (level > 0 && collectNodes) {
            if (namePattern != null) {
                if (matches(node.getName(), namePattern)) {
                    children.add(node);
                }
            } else {
                if (matches(node.getName(), nameGlobs)) {
                    children.add(node);
                }
            }
        }
    }


    protected void entering(Property property, int level)
            throws RepositoryException {
        if (level > 0 && collectProperties) {
            if (namePattern != null) {
                if (matches(property.getName(), namePattern)) {
                    children.add(property);
                }
            } else {
                if (matches(property.getName(), nameGlobs)) {
                    children.add(property);
                }
            }
        }
    }


    public static Calendar parse(String text) {
        if (text == null) {
            throw new IllegalArgumentException("argument can not be null");
        }

        // check optional leading sign
        char sign;
        int start;
        if (text.startsWith("-")) {
            sign = '-';
            start = 1;
        } else if (text.startsWith("+")) {
            sign = '+';
            start = 1;
        } else {
            sign = '+'; // no sign specified, implied '+'
            start = 0;
        }

        /**
         * the expected format of the remainder of the string is:
         * YYYY-MM-DDThh:mm:ss.SSSTZD
         *
         * note that we cannot use java.text.SimpleDateFormat for
         * parsing because it can't handle years <= 0 and TZD's
         */

        int year, month, day, hour, min, sec, ms;
        TimeZone tz;
        try {
            // year (YYYY)
            year = Integer.parseInt(text.substring(start, start + 4));
            start += 4;
            // delimiter '-'
            if (text.charAt(start) != '-') {
                return null;
            }
            start++;
            // month (MM)
            month = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter '-'
            if (text.charAt(start) != '-') {
                return null;
            }
            start++;
            // day (DD)
            day = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter 'T'
            if (text.charAt(start) != 'T') {
                return null;
            }
            start++;
            // hour (hh)
            hour = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (text.charAt(start) != ':') {
                return null;
            }
            start++;
            // minute (mm)
            min = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (text.charAt(start) != ':') {
                return null;
            }
            start++;
            // second (ss)
            sec = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter '.'
            if (text.charAt(start) != '.') {
                return null;
            }
            start++;
            // millisecond (SSS)
            ms = Integer.parseInt(text.substring(start, start + 3));
            start += 3;
            // time zone designator (Z or +00:00 or -00:00)
            String tzid = text.substring(start);
            tz = TZS.get(tzid);
            if (tz == null) {
                // offset to UTC specified in the format +00:00/-00:00
                tzid = "GMT" + tzid;
                tz = TimeZone.getTimeZone(tzid);
                // verify id of returned time zone (getTimeZone defaults to "GMT")
                if (!tz.getID().equals(tzid)) {
                    // invalid time zone
                    return null;
                }
            }
        } catch (IndexOutOfBoundsException e) {
            return null;
        } catch (NumberFormatException e) {
            return null;
        }

        // initialize Calendar object
        Calendar cal = Calendar.getInstance(tz);
        cal.setLenient(false);
        // year and era
        if (sign == '-' || year == 0) {
            // not CE, need to set era (BCE) and adjust year
            cal.set(Calendar.YEAR, year + 1);
            cal.set(Calendar.ERA, GregorianCalendar.BC);
        } else {
            cal.set(Calendar.YEAR, year);
            cal.set(Calendar.ERA, GregorianCalendar.AD);
        }
        // month (0-based!)
        cal.set(Calendar.MONTH, month - 1);
        // day of month
        cal.set(Calendar.DAY_OF_MONTH, day);
        // hour
        cal.set(Calendar.HOUR_OF_DAY, hour);
        // minute
        cal.set(Calendar.MINUTE, min);
        // second
        cal.set(Calendar.SECOND, sec);
        // millisecond
        cal.set(Calendar.MILLISECOND, ms);

        try {
            /**
             * the following call will trigger an IllegalArgumentException
             * if any of the set values are illegal or out of range
             */
            cal.getTime();
            /**
             * in addition check the validity of the year
             */
            getYear(cal);
        } catch (IllegalArgumentException e) {
            return null;
        }

        return cal;
    }


    public Calendar getDate() throws ValueFormatException {
        // check optional leading sign
        char sign = '+';
        int start = 0;
        if (value.startsWith("-")) {
            sign = '-';
            start = 1;
        } else if (value.startsWith("+")) {
            sign = '+';
            start = 1;
        }

        // note that we cannot use java.text.SimpleDateFormat for
        // parsing because it can't handle years <= 0 and TZD's
        int year, month, day, hour, min, sec, ms;
        String tzID;
        try {
            // year (YYYY)
            year = Integer.parseInt(value.substring(start, start + 4));
            start += 4;
            // delimiter '-'
            if (value.charAt(start) != '-') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // month (MM)
            month = Integer.parseInt(value.substring(start, start + 2));
            start += 2;
            // delimiter '-'
            if (value.charAt(start) != '-') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // day (DD)
            day = Integer.parseInt(value.substring(start, start + 2));
            start += 2;
            // delimiter 'T'
            if (value.charAt(start) != 'T') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // hour (hh)
            hour = Integer.parseInt(value.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (value.charAt(start) != ':') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // minute (mm)
            min = Integer.parseInt(value.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (value.charAt(start) != ':') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // second (ss)
            sec = Integer.parseInt(value.substring(start, start + 2));
            start += 2;
            // delimiter '.'
            if (value.charAt(start) != '.') {
                throw new ValueFormatException("Not a date: " + value);
            }
            start++;
            // millisecond (SSS)
            ms = Integer.parseInt(value.substring(start, start + 3));
            start += 3;
            // time zone designator (Z or +00:00 or -00:00)
            if (value.charAt(start) == '+' || value.charAt(start) == '-') {
                // offset to UTC specified in the format +00:00/-00:00
                tzID = "GMT" + value.substring(start);
            } else if (value.substring(start).equals("Z")) {
                tzID = "GMT";
            } else {
                throw new ValueFormatException(
                        "Invalid time zone in a date: " + value);
            }
        } catch (IndexOutOfBoundsException e) {
            throw new ValueFormatException("Not a date: " + value, e);
        } catch (NumberFormatException e) {
            throw new ValueFormatException("Not a date: " + value, e);
        }

        TimeZone tz = TimeZone.getTimeZone(tzID);
        // verify id of returned time zone (getTimeZone defaults to "GMT")
        if (!tz.getID().equals(tzID)) {
            throw new ValueFormatException(
                    "Invalid time zone in a date: " + value);
        }

        // initialize Calendar object
        Calendar cal = Calendar.getInstance(tz);
        cal.setLenient(false);
        // year and era
        if (sign == '-' || year == 0) {
            // not CE, need to set era (BCE) and adjust year
            cal.set(Calendar.YEAR, year + 1);
            cal.set(Calendar.ERA, GregorianCalendar.BC);
        } else {
            cal.set(Calendar.YEAR, year);
            cal.set(Calendar.ERA, GregorianCalendar.AD);
        }
        // month (0-based!)
        cal.set(Calendar.MONTH, month - 1);
        // day of month
        cal.set(Calendar.DAY_OF_MONTH, day);
        // hour
        cal.set(Calendar.HOUR_OF_DAY, hour);
        // minute
        cal.set(Calendar.MINUTE, min);
        // second
        cal.set(Calendar.SECOND, sec);
        // millisecond
        cal.set(Calendar.MILLISECOND, ms);

        try {
            // the following call will trigger an IllegalArgumentException
            // if any of the set values are illegal or out of range
            cal.getTime();
        } catch (IllegalArgumentException e) {
            throw new ValueFormatException("Not a date: " + value, e);
        }

        return cal;
    }


    public static Calendar parse(String text) {
        if (text == null) {
            throw new IllegalArgumentException("argument can not be null");
        }

        // check optional leading sign
        char sign;
        int start;
        if (text.startsWith("-")) {
            sign = '-';
            start = 1;
        } else if (text.startsWith("+")) {
            sign = '+';
            start = 1;
        } else {
            sign = '+'; // no sign specified, implied '+'
            start = 0;
        }

        /**
         * the expected format of the remainder of the string is:
         * YYYY-MM-DDThh:mm:ss.SSSTZD
         *
         * note that we cannot use java.text.SimpleDateFormat for
         * parsing because it can't handle years <= 0 and TZD's
         */

        int year, month, day, hour, min, sec, ms;
        String tzID;
        try {
            // year (YYYY)
            year = Integer.parseInt(text.substring(start, start + 4));
            start += 4;
            // delimiter '-'
            if (text.charAt(start) != '-') {
                return null;
            }
            start++;
            // month (MM)
            month = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter '-'
            if (text.charAt(start) != '-') {
                return null;
            }
            start++;
            // day (DD)
            day = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter 'T'
            if (text.charAt(start) != 'T') {
                return null;
            }
            start++;
            // hour (hh)
            hour = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (text.charAt(start) != ':') {
                return null;
            }
            start++;
            // minute (mm)
            min = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter ':'
            if (text.charAt(start) != ':') {
                return null;
            }
            start++;
            // second (ss)
            sec = Integer.parseInt(text.substring(start, start + 2));
            start += 2;
            // delimiter '.'
            if (text.charAt(start) != '.') {
                return null;
            }
            start++;
            // millisecond (SSS)
            ms = Integer.parseInt(text.substring(start, start + 3));
            start += 3;
            // time zone designator (Z or +00:00 or -00:00)
            if (text.charAt(start) == '+' || text.charAt(start) == '-') {
                // offset to UTC specified in the format +00:00/-00:00
                tzID = "GMT" + text.substring(start);
            } else if (text.substring(start).equals("Z")) {
                tzID = "GMT";
            } else {
                // invalid time zone designator
                return null;
            }
        } catch (IndexOutOfBoundsException e) {
            return null;
        } catch (NumberFormatException e) {
            return null;
        }

        TimeZone tz = TimeZone.getTimeZone(tzID);
        // verify id of returned time zone (getTimeZone defaults to "GMT")
        if (!tz.getID().equals(tzID)) {
            // invalid time zone
            return null;
        }

        // initialize Calendar object
        Calendar cal = Calendar.getInstance(tz);
        cal.setLenient(false);
        // year and era
        if (sign == '-' || year == 0) {
            // not CE, need to set era (BCE) and adjust year
            cal.set(Calendar.YEAR, year + 1);
            cal.set(Calendar.ERA, GregorianCalendar.BC);
        } else {
            cal.set(Calendar.YEAR, year);
            cal.set(Calendar.ERA, GregorianCalendar.AD);
        }
        // month (0-based!)
        cal.set(Calendar.MONTH, month - 1);
        // day of month
        cal.set(Calendar.DAY_OF_MONTH, day);
        // hour
        cal.set(Calendar.HOUR_OF_DAY, hour);
        // minute
        cal.set(Calendar.MINUTE, min);
        // second
        cal.set(Calendar.SECOND, sec);
        // millisecond
        cal.set(Calendar.MILLISECOND, ms);

        try {
            /**
             * the following call will trigger an IllegalArgumentException
             * if any of the set values are illegal or out of range
             */
            cal.getTime();
            /**
             * in addition check the validity of the year
             */
            getYear(cal);
        } catch (IllegalArgumentException e) {
            return null;
        }

        return cal;
    }


    public static String format(Calendar cal) throws IllegalArgumentException {
        if (cal == null) {
            throw new IllegalArgumentException("argument can not be null");
        }

        /**
         * the format of the date/time string is:
         * YYYY-MM-DDThh:mm:ss.SSSTZD
         *
         * note that we cannot use java.text.SimpleDateFormat for
         * formatting because it can't handle years <= 0 and TZD's
         */
        StringBuilder buf = new StringBuilder();
        // year ([-]YYYY)
        appendZeroPaddedInt(buf, getYear(cal), 4);
        buf.append('-');
        // month (MM)
        appendZeroPaddedInt(buf, cal.get(Calendar.MONTH) + 1, 2);
        buf.append('-');
        // day (DD)
        appendZeroPaddedInt(buf, cal.get(Calendar.DAY_OF_MONTH), 2);
        buf.append('T');
        // hour (hh)
        appendZeroPaddedInt(buf, cal.get(Calendar.HOUR_OF_DAY), 2);
        buf.append(':');
        // minute (mm)
        appendZeroPaddedInt(buf, cal.get(Calendar.MINUTE), 2);
        buf.append(':');
        // second (ss)
        appendZeroPaddedInt(buf, cal.get(Calendar.SECOND), 2);
        buf.append('.');
        // millisecond (SSS)
        appendZeroPaddedInt(buf, cal.get(Calendar.MILLISECOND), 3);
        // time zone designator (Z or +00:00 or -00:00)
        TimeZone tz = cal.getTimeZone();
        // determine offset of timezone from UTC (incl. daylight saving)
        int offset = tz.getOffset(cal.getTimeInMillis());
        if (offset != 0) {
            int hours = Math.abs((offset / (60 * 1000)) / 60);
            int minutes = Math.abs((offset / (60 * 1000)) % 60);
            buf.append(offset < 0 ? '-' : '+');
            appendZeroPaddedInt(buf, hours, 2);
            buf.append(':');
            appendZeroPaddedInt(buf, minutes, 2);
        } else {
            buf.append('Z');
        }
        return buf.toString();
    }


    public static String format(Calendar cal) throws IllegalArgumentException {
        if (cal == null) {
            throw new IllegalArgumentException("argument can not be null");
        }

        /**
         * the format of the date/time string is:
         * YYYY-MM-DDThh:mm:ss.SSSTZD
         *
         * note that we cannot use java.text.SimpleDateFormat for
         * formatting because it can't handle years <= 0 and TZD's
         */
        StringBuffer buf = new StringBuffer();
        // year ([-]YYYY)
        appendZeroPaddedInt(buf, getYear(cal), 4);
        buf.append('-');
        // month (MM)
        appendZeroPaddedInt(buf, cal.get(Calendar.MONTH) + 1, 2);
        buf.append('-');
        // day (DD)
        appendZeroPaddedInt(buf, cal.get(Calendar.DAY_OF_MONTH), 2);
        buf.append('T');
        // hour (hh)
        appendZeroPaddedInt(buf, cal.get(Calendar.HOUR_OF_DAY), 2);
        buf.append(':');
        // minute (mm)
        appendZeroPaddedInt(buf, cal.get(Calendar.MINUTE), 2);
        buf.append(':');
        // second (ss)
        appendZeroPaddedInt(buf, cal.get(Calendar.SECOND), 2);
        buf.append('.');
        // millisecond (SSS)
        appendZeroPaddedInt(buf, cal.get(Calendar.MILLISECOND), 3);
        // time zone designator (Z or +00:00 or -00:00)
        TimeZone tz = cal.getTimeZone();
        // determine offset of timezone from UTC (incl. daylight saving)
        int offset = tz.getOffset(cal.getTimeInMillis());
        if (offset != 0) {
            int hours = Math.abs((offset / (60 * 1000)) / 60);
            int minutes = Math.abs((offset / (60 * 1000)) % 60);
            buf.append(offset < 0 ? '-' : '+');
            appendZeroPaddedInt(buf, hours, 2);
            buf.append(':');
            appendZeroPaddedInt(buf, minutes, 2);
        } else {
            buf.append('Z');
        }
        return buf.toString();
    }


    public static int getYear(Calendar cal) throws IllegalArgumentException {
        // determine era and adjust year if necessary
        int year = cal.get(Calendar.YEAR);
        if (cal.isSet(Calendar.ERA)
                && cal.get(Calendar.ERA) == GregorianCalendar.BC) {
            /**
             * calculate year using astronomical system:
             * year n BCE => astronomical year -n + 1
             */
            year = 0 - year + 1;
        }

        if (year > 9999 || year < -9999) {
            throw new IllegalArgumentException("Calendar has more than four " +
                    "year digits, cannot be formatted as ISO8601: " + year);
        }
        return year;
    }


    public static int getYear(Calendar cal) throws IllegalArgumentException {
        // determine era and adjust year if necessary
        int year = cal.get(Calendar.YEAR);
        if (cal.isSet(Calendar.ERA)
                && cal.get(Calendar.ERA) == GregorianCalendar.BC) {
            /**
             * calculate year using astronomical system:
             * year n BCE => astronomical year -n + 1
             */
            year = 0 - year + 1;
        }

        if (year > 9999 || year < -9999) {
            throw new IllegalArgumentException("Calendar has more than four " +
                    "year digits, cannot be formatted as ISO8601: " + year);
        }
        return year;
    }


    private static void appendZeroPaddedInt(StringBuilder buf, int n, int precision) {
        if (n < 0) {
            buf.append('-');
            n = -n;
        }

        for (int exp = precision - 1; exp > 0; exp--) {
            if (n < Math.pow(10, exp)) {
                buf.append('0');
            } else {
                break;
            }
        }
        buf.append(n);
    }


    private static void appendZeroPaddedInt(StringBuffer buf, int n, int precision) {
        if (n < 0) {
            buf.append('-');
            n = -n;
        }

        for (int exp = precision - 1; exp > 0; exp--) {
            if (n < Math.pow(10, exp)) {
                buf.append('0');
            } else {
                break;
            }
        }
        buf.append(n);
    }


    public static boolean isValidName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if( isNameStart(ch) == false)
           return false;
        for (int i = 1; i < name.length(); i++ ) {
           ch = name.charAt(i);
           if( isName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidNCName(String ncName) {
        if (ncName.length() == 0)
            return false;
        char ch = ncName.charAt(0);
        if( isNCNameStart(ch) == false)
           return false;
        for (int i = 1; i < ncName.length(); i++ ) {
           ch = ncName.charAt(i);
           if( isNCName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidNCName(String):boolean


    public static boolean isValidName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if( isNameStart(ch) == false)
           return false;
        for (int i = 1; i < name.length(); i++ ) {
           ch = name.charAt(i);
           if( isName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidNCName(String ncName) {
        if (ncName.length() == 0)
            return false;
        char ch = ncName.charAt(0);
        if( isNCNameStart(ch) == false)
           return false;
        for (int i = 1; i < ncName.length(); i++ ) {
           ch = ncName.charAt(i);
           if( isNCName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidNCName(String):boolean


    public static boolean isValidName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if( isNameStart(ch) == false)
           return false;
        for (int i = 1; i < name.length(); i++ ) {
           ch = name.charAt(i);
           if( isName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidNCName(String ncName) {
        if (ncName.length() == 0)
            return false;
        char ch = ncName.charAt(0);
        if( isNCNameStart(ch) == false)
           return false;
        for (int i = 1; i < ncName.length(); i++ ) {
           ch = ncName.charAt(i);
           if( isNCName( ch ) == false ){
              return false;
           }
        }
        return true;
    } // isValidNCName(String):boolean


    public static boolean isValidNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++ ) {
           char ch = nmtoken.charAt(i);
           if(  ! isName( ch ) ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++ ) {
           char ch = nmtoken.charAt(i);
           if(  ! isName( ch ) ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++ ) {
           char ch = nmtoken.charAt(i);
           if(  ! isName( ch ) ){
              return false;
           }
        }
        return true;
    } // isValidName(String):boolean


    public static boolean isValidIANAEncoding(String ianaEncoding) {
        if (ianaEncoding != null) {
            int length = ianaEncoding.length();
            if (length > 0) {
                char c = ianaEncoding.charAt(0);
                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                    for (int i = 1; i < length; i++) {
                        c = ianaEncoding.charAt(i);
                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                            (c < '0' || c > '9') && c != '.' && c != '_' &&
                            c != '-') {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public static boolean isValidJavaEncoding(String javaEncoding) {
        if (javaEncoding != null) {
            int length = javaEncoding.length();
            if (length > 0) {
                for (int i = 1; i < length; i++) {
                    char c = javaEncoding.charAt(i);
                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                        (c < '0' || c > '9') && c != '.' && c != '_' &&
                        c != '-') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public static boolean isValidJavaEncoding(String javaEncoding) {
        if (javaEncoding != null) {
            int length = javaEncoding.length();
            if (length > 0) {
                for (int i = 1; i < length; i++) {
                    char c = javaEncoding.charAt(i);
                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                        (c < '0' || c > '9') && c != '.' && c != '_' &&
                        c != '-') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public static boolean isValidIANAEncoding(String ianaEncoding) {
        if (ianaEncoding != null) {
            int length = ianaEncoding.length();
            if (length > 0) {
                char c = ianaEncoding.charAt(0);
                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                    for (int i = 1; i < length; i++) {
                        c = ianaEncoding.charAt(i);
                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                            (c < '0' || c > '9') && c != '.' && c != '_' &&
                            c != '-') {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public static boolean isValidJavaEncoding(String javaEncoding) {
        if (javaEncoding != null) {
            int length = javaEncoding.length();
            if (length > 0) {
                for (int i = 1; i < length; i++) {
                    char c = javaEncoding.charAt(i);
                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                        (c < '0' || c > '9') && c != '.' && c != '_' &&
                        c != '-') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public static boolean isValidIANAEncoding(String ianaEncoding) {
        if (ianaEncoding != null) {
            int length = ianaEncoding.length();
            if (length > 0) {
                char c = ianaEncoding.charAt(0);
                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                    for (int i = 1; i < length; i++) {
                        c = ianaEncoding.charAt(i);
                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                            (c < '0' || c > '9') && c != '.' && c != '_' &&
                            c != '-') {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    } // isValidIANAEncoding(String):boolean


    public synchronized void recordOneSecond() {
        perSecond[seconds++] = max.getAndSetValue(missingValue);
        if (seconds == perSecond.length) {
            seconds = 0;
            perMinute[minutes++] = max(perSecond);
        }
        if (minutes == perMinute.length) {
            minutes = 0;
            perHour[hours++] = max(perMinute);
        }
        if (hours == perHour.length) {
            hours = 0;
            perWeek[weeks++] = max(perHour);
        }
        if (weeks == perWeek.length) {
            weeks = 0;
        }
    }


    public synchronized void recordOneSecond() {
        if (resetValueEachSecond) {
            valuePerSecond[seconds++] = counter.getAndSet(missingValue);
        } else {
            valuePerSecond[seconds++] = counter.get();
        }
        if (seconds == valuePerSecond.length) {
            seconds = 0;
            valuePerMinute[minutes++] = aggregate(valuePerSecond);
        }
        if (minutes == valuePerMinute.length) {
            minutes = 0;
            valuePerHour[hours++] = aggregate(valuePerMinute);
        }
        if (hours == valuePerHour.length) {
            hours = 0;
            valuePerWeek[weeks++] = aggregate(valuePerHour);
        }
        if (weeks == valuePerWeek.length) {
            weeks = 0;
        }
    }


    private void append(Constraint c)
            throws RepositoryException {
        if (c instanceof And) {
            append((And) c);
        } else if (c instanceof ChildNode) {
            append((ChildNode) c);
        } else if (c instanceof Comparison) {
            append((Comparison) c);
        } else if (c instanceof DescendantNode) {
            append((DescendantNode) c);
        } else if (c instanceof FullTextSearch) {
            append((FullTextSearch) c);
        } else if (c instanceof Not) {
            append((Not) c);
        } else if (c instanceof Or) {
            append((Or) c);
        } else if (c instanceof PropertyExistence) {
            append((PropertyExistence) c);
        } else {
            append((SameNode) c);
        }
    }


    private void append(DynamicOperand operand) {
        if (operand instanceof FullTextSearchScore) {
            append((FullTextSearchScore) operand);
        } else if (operand instanceof Length) {
            append((Length) operand);
        } else if (operand instanceof LowerCase) {
            append((LowerCase) operand);
        } else if (operand instanceof NodeLocalName) {
            append((NodeLocalName) operand);
        } else if (operand instanceof NodeName) {
            append((NodeName) operand);
        } else if (operand instanceof PropertyValue) {
            append((PropertyValue) operand);
        } else {
            append((UpperCase) operand);
        }
    }


    public void complete(Operation operation) throws RepositoryException {
        if (operation instanceof AddNode) {
            complete((AddNode) operation);
        } else if (operation instanceof AddProperty) {
            complete((AddProperty) operation);
        } else if (operation instanceof SetMixin) {
            complete((SetMixin) operation);
        } else if (operation instanceof SetPrimaryType) {
            complete((SetPrimaryType) operation);
        } else if (operation instanceof Remove) {
            complete((Remove) operation);
        } else if (operation instanceof ReorderNodes) {
            complete((ReorderNodes) operation);
        } else if (operation instanceof Move) {
            complete((Move) operation);
        } else {
            throw new IllegalArgumentException();
        }
    }


    private String resolvePropertyName(String name)
            throws RepositoryException {
        if (isPrefixed(name)) {
            return name;
        }
        if (propertyNames == null) {
            propertyNames = new HashMap<String, String>();
            if (session != null) {
                NodeTypeManager ntMgr = session.getWorkspace().getNodeTypeManager();
                NodeTypeIterator it = ntMgr.getAllNodeTypes();
                while (it.hasNext()) {
                    NodeType nt = it.nextNodeType();
                    PropertyDefinition[] defs = nt.getDeclaredPropertyDefinitions();
                    for (PropertyDefinition def : defs) {
                        String pn = def.getName();
                        if (!pn.equals("*")) {
                            String localName = pn;
                            int idx = pn.indexOf(':');
                            if (idx != -1) {
                                localName = pn.substring(idx + 1);
                            }
                            propertyNames.put(localName, pn);
                        }
                    }
                }
            }
        }
        String pn = propertyNames.get(name);
        if (pn != null) {
            return pn;
        } else {
            return name;
        }
    }


    private String resolveChildNodeName(String name)
            throws RepositoryException {
        if (isPrefixed(name)) {
            return name;
        }
        if (childNodeNames == null) {
            childNodeNames = new HashMap<String, String>();
            NodeTypeManager ntMgr = session.getWorkspace().getNodeTypeManager();
            NodeTypeIterator it = ntMgr.getAllNodeTypes();
            while (it.hasNext()) {
                NodeType nt = it.nextNodeType();
                NodeDefinition[] defs = nt.getDeclaredChildNodeDefinitions();
                for (NodeDefinition def : defs) {
                    String cnn = def.getName();
                    if (!cnn.equals("*")) {
                        String localName = cnn;
                        int idx = cnn.indexOf(':');
                        if (idx != -1) {
                            localName = cnn.substring(idx + 1);
                        }
                        childNodeNames.put(localName, cnn);
                    }
                }
            }
        }
        String cnn = childNodeNames.get(name);
        if (cnn != null) {
            return cnn;
        } else {
            return name;
        }
    }


    private Value[] getLengthValues(Length operand, Row row)
            throws RepositoryException {
        Property property = getProperty(operand.getPropertyValue(), row);
        if (property == null) {
            return new Value[0];
        } else if (property.isMultiple()) {
            long[] lengths = property.getLengths();
            Value[] values = new Value[lengths.length];
            for (int i = 0; i < lengths.length; i++) {
                values[i] = factory.createValue(lengths[i]);
            }
            return values;
        } else {
            long length = property.getLength();
            return new Value[] { factory.createValue(length) };
        }
    }


    private Value[] getLengthValues(Length operand, Node n)
            throws RepositoryException {
        Property property = getProperty(operand.getPropertyValue(), n);
        if (property == null) {
            return new Value[0];
        }
        if (property.isMultiple()) {
            long[] lengths = property.getLengths();
            Value[] values = new Value[lengths.length];
            for (int i = 0; i < lengths.length; i++) {
                values[i] = factory.createValue(lengths[i]);
            }
            return values;
        }
        long length = property.getLength();
        return new Value[] { factory.createValue(length) };
    }


    private Value[] getLowerCaseValues(LowerCase operand, Row row)
            throws RepositoryException {
        Value[] values = getValues(operand.getOperand(), row);
        for (int i = 0; i < values.length; i++) {
            String value = values[i].getString();
            String lower = value.toLowerCase(locale);
            if (!value.equals(lower)) {
                values[i] = factory.createValue(lower);
            }
        }
        return values;
    }


    private Value[] getUpperCaseValues(UpperCase operand, Node node)
            throws RepositoryException {
        Value[] values = getValues(operand.getOperand(), node);
        for (int i = 0; i < values.length; i++) {
            String value = values[i].getString();
            String upper = value.toUpperCase(locale);
            if (!value.equals(upper)) {
                values[i] = factory.createValue(upper);
            }
        }
        return values;
    }


    private Value[] getUpperCaseValues(UpperCase operand, Row row)
            throws RepositoryException {
        Value[] values = getValues(operand.getOperand(), row);
        for (int i = 0; i < values.length; i++) {
            String value = values[i].getString();
            String upper = value.toUpperCase(locale);
            if (!value.equals(upper)) {
                values[i] = factory.createValue(upper);
            }
        }
        return values;
    }


    private Value[] getLowerCaseValues(LowerCase operand, Node node)
            throws RepositoryException {
        Value[] values = getValues(operand.getOperand(), node);
        for (int i = 0; i < values.length; i++) {
            String value = values[i].getString();
            String lower = value.toLowerCase(locale);
            if (!value.equals(lower)) {
                values[i] = factory.createValue(lower);
            }
        }
        return values;
    }


    private Value[] getPropertyValues(PropertyValue operand, Row row)
            throws RepositoryException {
        Property property = getProperty(operand, row);
        if (property == null) {
            return new Value[0];
        } else if (property.isMultiple()) {
            return property.getValues();
        } else {
            return new Value[] { property.getValue() };
        }
    }


    private Value[] getPropertyValues(PropertyValue operand, Node node)
            throws RepositoryException {
        Property property = getProperty(operand, node);
        if (property == null) {
            return new Value[0];
        } else if (property.isMultiple()) {
            return property.getValues();
        } else {
            return new Value[] { property.getValue() };
        }
    }


    private Property getProperty(PropertyValue operand, Node node)
            throws RepositoryException {
        if (node == null) {
            return null;
        }
        try {
            return node.getProperty(operand.getPropertyName());
        } catch (PathNotFoundException e) {
            return null;
        }
    }


    protected String getJCRName(Name name) {
        if (name == null) {
            return null;
        }
        try {
            return resolver.getJCRName(name);
        } catch (NamespaceException e) {
            return name.toString();
        }
    }


    protected String getJCRPath(Path path) {
        if (path == null) {
            return null;
        }
        try {
            return resolver.getJCRPath(path);
        } catch (NamespaceException e) {
            return path.toString();
        }
    }


    private Name checkNodeTypeName(String nodeTypeName)
            throws RepositoryException {
        if (nodeTypeName == null) {
            throw new InvalidQueryException("nodeTypeName must not be null");
        }
        try {
            return resolver.getQName(nodeTypeName);
        } catch (NameException e) {
            throw new InvalidQueryException(e.getMessage());
        }
    }


    private Name checkSelectorName(String selectorName)
            throws RepositoryException {
        if (selectorName == null) {
            throw new InvalidQueryException("selectorName must not be null");
        }
        try {
            return resolver.getQName(selectorName);
        } catch (NameException e) {
            throw new InvalidQueryException(e.getMessage());
        }
    }


    private Path checkPath(String path) throws RepositoryException {
        if (path == null) {
            throw new InvalidQueryException("path must not be null");
        }
        try {
            return resolver.getQPath(path);
        } catch (NameException e) {
            throw new InvalidQueryException(e.getMessage());
        }
    }


    private Name checkPropertyName(String propertyName)
            throws RepositoryException {
        if (propertyName == null) {
            throw new InvalidQueryException("propertyName must not be null");
        }
        try {
            return resolver.getQName(propertyName);
        } catch (NameException e) {
            throw new InvalidQueryException(e.getMessage());
        }
    }


    public BindVariableValue bindVariable(String bindVariableName)
            throws InvalidQueryException, RepositoryException {
        if (bindVariableName == null) {
            throw new InvalidQueryException("bindVariableName must not be null");
        }
        try {
            return new BindVariableValueImpl(
                    resolver, resolver.getQName(bindVariableName));
        } catch (NameException e) {
            throw new InvalidQueryException(e.getMessage());
        }
    }


    private String getPrefix(String uri) {
        Iterator iterator = stack.iterator();
        while (iterator.hasNext()) {
            String prefix = (String) ((Map) iterator.next()).get(uri);
            if (prefix != null) {
                return prefix;
            }
        }
        return null;
    }


    public static Property searchSingleValuedProperty(Node node)
            throws RepositoryException, ValueFormatException {
        PropertyIterator props = node.getProperties();
        while (props.hasNext()) {
            Property p = props.nextProperty();
            if (!p.getDefinition().isMultiple()) {
                return p;
            }
        }
        // should never get here, since every Node must provide the jcr:primaryType
        // property, which is single valued.
        return null;
    }


    public static Iterable<Node> getSharedSet(final Node node)
            throws RepositoryException {
        final NodeIterator iterator = node.getSharedSet();
        return new Iterable<Node>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Node> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getSharedSet();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getReferences(final Node node)
            throws RepositoryException {
        final PropertyIterator iterator = node.getReferences();
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getReferences();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getProperties(
            final Node node, final String pattern) throws RepositoryException {
        final PropertyIterator iterator = node.getProperties(pattern);
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getProperties(pattern);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Row> getRows(final QueryResult result)
            throws RepositoryException {
        final RowIterator iterator = result.getRows();
        return new Iterable<Row>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Row> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return result.getRows();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Node> getChildNodes(
            final Node node, final String pattern) throws RepositoryException {
        final NodeIterator iterator = node.getNodes(pattern);
        return new Iterable<Node>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Node> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getNodes(pattern);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getWeakReferences(
            final Node node, final String name) throws RepositoryException {
        final PropertyIterator iterator = node.getWeakReferences(name);
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getWeakReferences(name);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Node> getNodes(final QueryResult result)
            throws RepositoryException {
        final NodeIterator iterator = result.getNodes();
        return new Iterable<Node>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Node> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return result.getNodes();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getWeakReferences(final Node node)
            throws RepositoryException {
        final PropertyIterator iterator = node.getWeakReferences();
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getWeakReferences();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getProperties(
            final Node node, final String[] globs) throws RepositoryException {
        final PropertyIterator iterator = node.getProperties(globs);
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getProperties(globs);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Node> getChildNodes(
            final Node node, final String[] globs) throws RepositoryException {
        final NodeIterator iterator = node.getNodes(globs);
        return new Iterable<Node>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Node> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getNodes(globs);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getProperties(final Node node)
            throws RepositoryException {
        final PropertyIterator iterator = node.getProperties();
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getProperties();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Property> getReferences(
            final Node node, final String name) throws RepositoryException {
        final PropertyIterator iterator = node.getReferences(name);
        return new Iterable<Property>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Property> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getReferences(name);
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public static Iterable<Node> getChildNodes(final Node node)
            throws RepositoryException {
        final NodeIterator iterator = node.getNodes();
        return new Iterable<Node>() {
            private boolean first = true;
            @Override @SuppressWarnings("unchecked")
            public synchronized Iterator<Node> iterator() {
                if (first) {
                    first = false;
                    return iterator;
                } else {
                    try {
                        return node.getNodes();
                    } catch (RepositoryException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };
    }


    public Node getNode() throws ValueFormatException, RepositoryException {
        String value = getString();

        switch (getType()) {
            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
                return getSession().getNodeByIdentifier(value);

            case PropertyType.PATH:
                try {
                    return (value.startsWith("/")) ? getSession().getNode(value) : getParent().getNode(value);
                } catch (PathNotFoundException e) {
                    throw new ItemNotFoundException(value);
                }

            case PropertyType.NAME:
                try {
                    return getParent().getNode(value);
                } catch (PathNotFoundException e) {
                    throw new ItemNotFoundException(value);
                }

            case PropertyType.STRING:
                try {
                    // interpret as identifier
                    Value refValue = getSession().getValueFactory().createValue(value, PropertyType.REFERENCE);
                    return getSession().getNodeByIdentifier(refValue.getString());
                } catch (ItemNotFoundException e) {
                    throw e;
                } catch (RepositoryException e) {
                    // try if STRING value can be interpreted as PATH value
                    Value pathValue = getSession().getValueFactory().createValue(value, PropertyType.PATH);
                    try {
                        return (value.startsWith("/")) ? getSession().getNode(pathValue.getString()) : getParent().getNode(pathValue.getString());
                    } catch (PathNotFoundException e1) {
                        throw new ItemNotFoundException(pathValue.getString());
                    }
                }

            default:
                throw new ValueFormatException("Property value cannot be converted to a PATH, REFERENCE or WEAKREFERENCE: " + value);
        }
    }


    public Node getNode() throws RepositoryException {
        String value = getString();

        switch (getType()) {
            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
                return getSession().getNodeByIdentifier(value);

            case PropertyType.PATH:
                try {
                    if (value.startsWith("/")) {
                        return getSession().getNode(value);
                    } else {
                        return getParent().getNode(value);
                    }
                } catch (PathNotFoundException e) {
                    throw new ItemNotFoundException(value);
                }

            case PropertyType.NAME:
                try {
                    return getParent().getNode(value);
                } catch (PathNotFoundException e) {
                    throw new ItemNotFoundException(value);
                }

            case PropertyType.STRING:
                try {
                    // interpret as identifier
                    Value refValue = getSession().getValueFactory().createValue(value, PropertyType.REFERENCE);
                    return getSession().getNodeByIdentifier(refValue.getString());
                } catch (ItemNotFoundException e) {
                    throw e;
                } catch (RepositoryException e) {
                    // try if STRING value can be interpreted as PATH value
                    Value pathValue = getSession().getValueFactory().createValue(value, PropertyType.PATH);
                    boolean absolute = value.startsWith("/");
                    try {
                        return (absolute) ? getSession().getNode(pathValue.getString()) : getParent().getNode(pathValue.getString());
                    } catch (PathNotFoundException e1) {
                        throw new ItemNotFoundException(pathValue.getString());
                    }
                }

            default:
                throw new ValueFormatException("Property value cannot be converted to a PATH, REFERENCE or WEAKREFERENCE: " + value);
        }
    }


    public void importXML(
            String parentAbsPath, InputStream in, int uuidBehavior)
            throws IOException, InvalidSerializedDataException,
            RepositoryException {
        try {
            ContentHandler handler =
                getImportContentHandler(parentAbsPath, uuidBehavior);
            new ParsingContentHandler(handler).parse(in);
        } catch (SAXException e) {
            Throwable exception = e.getException();
            if (exception instanceof RepositoryException) {
                throw (RepositoryException) exception;
            } else if (exception instanceof IOException) {
                throw (IOException) exception;
            } else {
                throw new InvalidSerializedDataException("XML parse error", e);
            }
        } finally {
            // JCR-2903
            if (in != null) {
                try { in.close(); } catch (IOException ignore) {}
            }
        }
    }


    public void importXML(
            String parentAbsPath, InputStream in, int uuidBehavior)
            throws IOException, InvalidSerializedDataException,
            RepositoryException {
        try {
            ContentHandler handler =
                getImportContentHandler(parentAbsPath, uuidBehavior);
            new ParsingContentHandler(handler).parse(in);
        } catch (SAXException e) {
            Throwable exception = e.getException();
            if (exception instanceof RepositoryException) {
                throw (RepositoryException) exception;
            } else if (exception instanceof IOException) {
                throw (IOException) exception;
            } else {
                throw new InvalidSerializedDataException("XML parse error", e);
            }
        } finally {
            // JCR-2903
            if (in != null) {
                try { in.close(); } catch (IOException ignore) {}
            }
        }
    }


    public void exportDocumentView(
            String absPath, OutputStream out,
            boolean skipBinary, boolean noRecurse)
            throws IOException, RepositoryException {
        try {
            ContentHandler handler = new ToXmlContentHandler(out);
            exportDocumentView(absPath, handler, skipBinary, noRecurse);
        } catch (SAXException e) {
            Exception exception = e.getException();
            if (exception instanceof RepositoryException) {
                throw (RepositoryException) exception;
            } else if (exception instanceof IOException) {
                throw (IOException) exception;
            } else {
                throw new RepositoryException(
                        "Error serializing document view XML", e);
            }
        }
    }


    public void exportSystemView(
            String absPath, OutputStream out,
            boolean skipBinary, boolean noRecurse)
            throws IOException, RepositoryException {
        try {
            ContentHandler handler = new ToXmlContentHandler(out);
            exportSystemView(absPath, handler, skipBinary, noRecurse);
        } catch (SAXException e) {
            Exception exception = e.getException();
            if (exception instanceof RepositoryException) {
                throw (RepositoryException) exception;
            } else if (exception instanceof IOException) {
                throw (IOException) exception;
            } else {
                throw new RepositoryException(
                        "Error serializing system view XML", e);
            }
        }
    }


    private Repository getRepository(String name, Hashtable environment)
            throws RepositoryException {
        try {
            Object value = new InitialContext(environment).lookup(name);
            if (value instanceof Repository) {
                return (Repository) value;
            } else {
                throw new RepositoryException(
                        "Invalid repository object " + value
                        + " found at " + name + " in JNDI environment "
                        + environment);
            }
        } catch (NamingException e) {
            throw new RepositoryException(
                    "Failed to look up " + name
                    + " from JNDI environment " + environment, e);
        }
    }


            protected RemoteRepository getRemoteRepository() throws RemoteException {
                try {
                    Object value = new InitialContext(environment).lookup(name);
                    if (value instanceof RemoteRepository) {
                        return (RemoteRepository) value;
                    } else {
                        throw new RemoteException("The JNDI resource " + name
                                + " is not a remote repository stub: " + value);
                    }
                } catch (NamingException e) {
                    throw new RemoteException(
                            "Failed to look up the JNDI resource " + name, e);
                }
            }


    private void doPropertyDefinition(AbstractPropertyDefinitionBuilder<T> pd, AbstractNodeTypeDefinitionBuilder<T> ntd)
            throws ParseException {

        try {
            pd.setName(currentToken);
        } catch (RepositoryException e) {
            lexer.fail("Invalid property name '" + currentToken, e);
        }
        nextToken();
        doPropertyType(pd);
        doPropertyDefaultValue(pd);
        doPropertyAttributes(pd, ntd);
        doPropertyValueConstraints(pd);
    }


    private void doChildNodeDefinition(AbstractNodeDefinitionBuilder<T> nd,
                                       AbstractNodeTypeDefinitionBuilder<T> ntd)
            throws ParseException {

        try {
            nd.setName(currentToken);
        } catch (RepositoryException e) {
            lexer.fail("Invalid child node name '" + currentToken, e);
        }
        nextToken();
        doChildNodeRequiredTypes(nd);
        doChildNodeDefaultType(nd);
        doChildNodeAttributes(nd, ntd);
    }


    private void doPropertyAttributes(AbstractPropertyDefinitionBuilder<T> pd,
                                      AbstractNodeTypeDefinitionBuilder<T> ntd) throws ParseException {

        try {
            while (currentTokenEquals(Lexer.PROP_ATTRIBUTE)) {
                if (currentTokenEquals(Lexer.PRIMARY)) {
                    ntd.setPrimaryItemName(pd.getName());
                } else if (currentTokenEquals(Lexer.AUTOCREATED)) {
                    pd.setAutoCreated(true);
                } else if (currentTokenEquals(Lexer.MANDATORY)) {
                    pd.setMandatory(true);
                } else if (currentTokenEquals(Lexer.PROTECTED)) {
                    pd.setProtected(true);
                } else if (currentTokenEquals(Lexer.MULTIPLE)) {
                    pd.setMultiple(true);
                } else if (currentTokenEquals(Lexer.COPY)) {
                    pd.setOnParentVersion(OnParentVersionAction.COPY);
                } else if (currentTokenEquals(Lexer.VERSION)) {
                    pd.setOnParentVersion(OnParentVersionAction.VERSION);
                } else if (currentTokenEquals(Lexer.INITIALIZE)) {
                    pd.setOnParentVersion(OnParentVersionAction.INITIALIZE);
                } else if (currentTokenEquals(Lexer.COMPUTE)) {
                    pd.setOnParentVersion(OnParentVersionAction.COMPUTE);
                } else if (currentTokenEquals(Lexer.IGNORE)) {
                    pd.setOnParentVersion(OnParentVersionAction.IGNORE);
                } else if (currentTokenEquals(Lexer.ABORT)) {
                    pd.setOnParentVersion(OnParentVersionAction.ABORT);
                } else if (currentTokenEquals(Lexer.NOFULLTEXT)) {
                    pd.setFullTextSearchable(false);
                } else if (currentTokenEquals(Lexer.NOQUERYORDER)) {
                    pd.setQueryOrderable(false);
                } else if (currentTokenEquals(Lexer.QUERYOPS)) {
                    doPropertyQueryOperators(pd);
                }
                nextToken();
            }
        } catch (RepositoryException e) {
            lexer.fail("Error setting property attribute of " + pd.getName() + " to " + currentToken, e);
        }
    }


    private void doChildNodeAttributes(AbstractNodeDefinitionBuilder<T> nd,
                                       AbstractNodeTypeDefinitionBuilder<T> ntd)
            throws ParseException {

        try {
            while (currentTokenEquals(Lexer.NODE_ATTRIBUTE)) {
                if (currentTokenEquals(Lexer.PRIMARY)) {
                    ntd.setPrimaryItemName(nd.getName());
                } else if (currentTokenEquals(Lexer.AUTOCREATED)) {
                    nd.setAutoCreated(true);
                } else if (currentTokenEquals(Lexer.MANDATORY)) {
                    nd.setMandatory(true);
                } else if (currentTokenEquals(Lexer.PROTECTED)) {
                    nd.setProtected(true);
                } else if (currentTokenEquals(Lexer.SNS)) {
                    nd.setAllowsSameNameSiblings(true);
                } else if (currentTokenEquals(Lexer.COPY)) {
                    nd.setOnParentVersion(OnParentVersionAction.COPY);
                } else if (currentTokenEquals(Lexer.VERSION)) {
                    nd.setOnParentVersion(OnParentVersionAction.VERSION);
                } else if (currentTokenEquals(Lexer.INITIALIZE)) {
                    nd.setOnParentVersion(OnParentVersionAction.INITIALIZE);
                } else if (currentTokenEquals(Lexer.COMPUTE)) {
                    nd.setOnParentVersion(OnParentVersionAction.COMPUTE);
                } else if (currentTokenEquals(Lexer.IGNORE)) {
                    nd.setOnParentVersion(OnParentVersionAction.IGNORE);
                } else if (currentTokenEquals(Lexer.ABORT)) {
                    nd.setOnParentVersion(OnParentVersionAction.ABORT);
                }
                nextToken();
            }
        } catch (RepositoryException e) {
            lexer.fail("Error setting child node attribute of " + nd.getName() + " to " + currentToken, e);
        }
    }


    private void doPropertyDefaultValue(AbstractPropertyDefinitionBuilder<T> pd)
            throws ParseException {

        if (!currentTokenEquals(Lexer.DEFAULT)) {
            return;
        }

        do {
            nextToken();
            try {
                pd.addDefaultValues(currentToken);
            } catch (RepositoryException e) {
                lexer.fail("Error adding default value for " + pd.getName() + " to " + currentToken, e);
            }
            nextToken();
        } while (currentTokenEquals(Lexer.LIST_DELIMITER));
    }


    private void doChildNodeRequiredTypes(AbstractNodeDefinitionBuilder<T> nd)
            throws ParseException {

        if (!currentTokenEquals(Lexer.BEGIN_TYPE)) {
            return;
        }

        do {
            nextToken();
            try {
                nd.addRequiredPrimaryType(currentToken);
            } catch (RepositoryException e) {
                lexer.fail("Error setting required primary type of " + nd.getName() + " to " + currentToken, e);
            }
            nextToken();
        } while (currentTokenEquals(Lexer.LIST_DELIMITER));
        nextToken();
    }


    private void doPropertyValueConstraints(AbstractPropertyDefinitionBuilder<T> pd)
            throws ParseException {

        if (!currentTokenEquals(Lexer.CONSTRAINT)) {
            return;
        }

        do {
            nextToken();
            try {
                pd.addValueConstraint(currentToken);
            } catch (RepositoryException e) {
                lexer.fail("Error adding value constraint for " + pd.getName() + " to " + currentToken, e);
            }
            nextToken();
        } while (currentTokenEquals(Lexer.LIST_DELIMITER));
    }


    private void doChildNodeDefaultType(AbstractNodeDefinitionBuilder<T> nd)
            throws ParseException {

        if (!currentTokenEquals(Lexer.DEFAULT)) {
            return;
        }
        nextToken();
        try {
            nd.setDefaultPrimaryType(currentToken);
        } catch (RepositoryException e) {
            lexer.fail("Error setting default primary type of " + nd.getName() + " to " + currentToken, e);
        }
        nextToken();
    }


    public static Value[] valuesFromXml(Object propValue, int defaultType, ValueFactory valueFactory) throws RepositoryException {
        Value[] jcrValues;
        // retrieve jcr-values from child 'value'-element(s)
        List<Element> valueElements = new ArrayList<Element>();
        if (propValue == null) {
            jcrValues = new Value[0];
        } else { /* not null propValue */
            if (isValueElement(propValue)) {
                valueElements.add((Element) propValue);
            } else if (propValue instanceof List) {
                for (Object el : ((List<?>) propValue)) {
                    /* make sure, only Elements with name 'value' are used for
                    * the 'value' field. any other content (other elements, text,
                    * comment etc.) is ignored. NO bad-request/conflict error is
                    * thrown.
                    */
                    if (isValueElement(el)) {
                        valueElements.add((Element) el);
                    }
                }
            }
            /* fill the 'value' with the valid 'value' elements found before */
            jcrValues = new Value[valueElements.size()];
            int i = 0;
            for (Element element : valueElements) {
                jcrValues[i] = getJcrValue(element, defaultType, valueFactory);
                i++;
            }
        }
        return jcrValues;
    }


    public static long[] lengthsFromXml(Object propValue) throws RepositoryException {
        long[] lengths;
        // retrieve jcr-values from child 'value'-element(s)
        List<Element> lengthElements = new ArrayList<Element>();
        if (propValue == null) {
            lengths = new long[0];
        } else { /* not null propValue */
            if (isLengthElement(propValue)) {
                lengthElements.add((Element) propValue);
            } else if (propValue instanceof List) {
                for (Object el : ((List<?>) propValue)) {
                    /* make sure, only Elements with name 'value' are used for
                    * the 'value' field. any other content (other elements, text,
                    * comment etc.) is ignored. NO bad-request/conflict error is
                    * thrown.
                    */
                    if (isLengthElement(el)) {
                        lengthElements.add((Element) el);
                    }
                }
            }
            /* fill the 'value' with the valid 'value' elements found before */
            lengths = new long[lengthElements.size()];
            int i = 0;
            for (Element element : lengthElements) {
                lengths[i] = Long.parseLong(XMLUtil.getText(element, "0"));
                i++;
            }
        }
        return lengths;
    }


    public static JackrabbitAccessControlList getAccessControlList(AccessControlManager accessControlManager, String absPath) throws RepositoryException {
        // try applicable (new) ACLs
        AccessControlPolicyIterator itr = accessControlManager.getApplicablePolicies(absPath);
        while (itr.hasNext()) {
            AccessControlPolicy policy = itr.nextAccessControlPolicy();
            if (policy instanceof JackrabbitAccessControlList) {
                return (JackrabbitAccessControlList) policy;
            }
        }

        // try if there is an acl that has been set before
        AccessControlPolicy[] pcls = accessControlManager.getPolicies(absPath);
        for (AccessControlPolicy policy : pcls) {
            if (policy instanceof JackrabbitAccessControlList) {
                return (JackrabbitAccessControlList) policy;
            }
        }

        // no policy found
        return null;
    }


    private ACLTemplate getPolicy(AccessControlManager acM, String path, Principal principal) throws RepositoryException,
            AccessDeniedException, NotExecutableException {
        // try applicable (new) ACLs first
        AccessControlPolicyIterator itr = acM.getApplicablePolicies(path);
        while (itr.hasNext()) {
            AccessControlPolicy policy = itr.nextAccessControlPolicy();
            if (policy instanceof ACLTemplate) {
                return (ACLTemplate) policy;
            }
        }
        // try if there is an acl that has been set before:
        AccessControlPolicy[] pcls = acM.getPolicies(path);
        for (AccessControlPolicy policy : pcls) {
            if (policy instanceof ACLTemplate) {
                return (ACLTemplate) policy;
            }
        }
        // no applicable or existing ACLTemplate to edit -> not executable.
        throw new NotExecutableException();
    }


    static JackrabbitAccessControlList getPolicy(AccessControlManager acM, String path, Principal principal) throws RepositoryException,
            AccessDeniedException, NotExecutableException {
        // try applicable (new) ACLs first
        AccessControlPolicyIterator itr = acM.getApplicablePolicies(path);
        while (itr.hasNext()) {
            AccessControlPolicy policy = itr.nextAccessControlPolicy();
            if (policy instanceof ACLTemplate) {
                return (ACLTemplate) policy;
            }
        }
        // try if there is an acl that has been set before:
        AccessControlPolicy[] pcls = acM.getPolicies(path);
        for (AccessControlPolicy policy : pcls) {
            if (policy instanceof ACLTemplate) {
                return (ACLTemplate) policy;
            }
        }
        // no applicable or existing ACLTemplate to edit -> not executable.
        throw new NotExecutableException();
    }


    static JackrabbitAccessControlList getPolicy(AccessControlManager acM,
                                                 String path,
                                                 Principal principal)
            throws RepositoryException, AccessDeniedException, NotExecutableException {
        if (acM instanceof JackrabbitAccessControlManager && path != null) {
            // first try applicable policies
            AccessControlPolicy[] policies = ((JackrabbitAccessControlManager) acM).getApplicablePolicies(principal);
            for (AccessControlPolicy policy : policies) {
                if (policy instanceof ACLTemplate) {
                    return (ACLTemplate) policy;
                }
            }

            // second existing policies
            policies = ((JackrabbitAccessControlManager) acM).getPolicies(principal);
            for (AccessControlPolicy policy : policies) {
                if (policy instanceof ACLTemplate) {
                    return (ACLTemplate) policy;
                }
            }
        }
        throw new NotExecutableException();
    }


    protected final Node getPredecessor(Node node, String key) throws RepositoryException {
        if (!node.hasNodes() || treeManager.isLeaf(node)) {
            return null;
        }

        // Shortcut for exact match
        try {
            return node.getNode(key);
        }
        catch (PathNotFoundException ignore) { }

        // Search for direct predecessor of key in the nodes children
        // todo performance: for ordered nodes use binary search
        NodeIterator childNodes = node.getNodes();
        Node p = null;
        while (childNodes.hasNext()) {
            Node n = childNodes.nextNode();
            String childKey = n.getName();
            if (order.compare(key, childKey) > 0 && (p == null || order.compare(childKey, p.getName()) > 0)) {
                p = n;
            }
        }

        return p;
    }


    protected final Node getSuccessor(Node node, String key) throws RepositoryException {
        if (!node.hasNodes() || treeManager.isLeaf(node)) {
            return null;
        }

        // Shortcut for exact match
        try {
            return node.getNode(key);
        }
        catch (PathNotFoundException ignore) { }

        // Search for direct successor of key in the nodes children
        // todo performance: for ordered nodes use binary search
        NodeIterator childNodes = node.getNodes();
        Node s = null;
        while (childNodes.hasNext()) {
            Node n = childNodes.nextNode();
            String childKey = n.getName();
            if (order.compare(key, childKey) < 0 && (s == null || order.compare(childKey, s.getName()) < 0)) {
                s = n;
            }
        }

        return s;
    }


        private Node getOrCreateParent(String key) throws RepositoryException {
            Node p = getParent(key);
            if (treeManager.isRoot(p)) {
                Node min = getMinimal();
                if (min != null) {
                    p = min.getParent();
                    renamePath(p, key);
                }
            }
            return p;
        }


        private Node getOrCreateParent(String key) throws RepositoryException {
            Node p = getParent(key);
            if (treeManager.isRoot(p)) {
                Node min = getMinimal();
                if (min != null) {
                    p = min;
                    renamePath(p, key);
                }
            }
            return p;
        }


    public void join(ItemSequence itemSequence, Node node, Node cause) throws RepositoryException {
        SizedIterator<Node> nodes = getNodes(node);
        long count = nodes.getSize();
        if (count < 0) {
            for (count = 0; nodes.hasNext(); count++) {
                nodes.next();
            }
        }

        if (count == 0) {
            removeRec(node);
        }
    }


    public void join(ItemSequence itemSequence, Node node, Property cause) throws RepositoryException {
        SizedIterator<Property> properties = getProperties(node);
        long count = properties.getSize();
        if (count < 0) {
            for (count = 0; properties.hasNext(); count++) {
                properties.next();
            }
        }

        if (count == 0) {
            removeRec(node);
        }
    }


    private Iterator<Property> filterProperties(Iterator<Property> properties) {
        return new FilterIterator<Property>(properties, new Predicate() {
            public boolean evaluate(Object object) {
                try {
                    Property p = (Property) object;
                    return !ignoredProperties.contains(p.getName());
                }
                catch (RepositoryException ignore) {
                    return true;
                }
            }
        });
    }


    private Iterator<Authorizable> unique(Iterator<Authorizable> authorizables) {
        final HashSet<String> seenAuthorizables = new HashSet<String>();
        return Iterators.filterIterator(authorizables,
                new org.apache.jackrabbit.spi.commons.iterator.Predicate<Authorizable>() {

            public boolean evaluate(Authorizable authorizable) {
                try {
                    return seenAuthorizables.add(authorizable.getID());
                }
                catch (RepositoryException e) {
                    log.warn("Could not determine id of " + authorizable, e);
                    return true;
                }
            }
        });
    }


        public boolean hasNext() {
            if ( this.nextItem != null ) {
                return true;
            }
            try {
                return this.checkForNextNode();
            } catch (RepositoryException e) {
                // if any error occurs, we stop iterating
                return false;
            }
        }


    public boolean hasNodeReferences(NodeId id) {
        if (virtualProvider != null && virtualProvider.hasNodeReferences(id)) {
            return true;
        }
        try {
            return getReferences(id).hasReferences();
        } catch (ItemStateException e) {
            return false;
        }
    }


    public boolean evaluate(Object item) {
        if ( item instanceof Item ) {
            try {
                final int depth = ((Item)item).getDepth();
                return depth >= minDepth && depth <= maxDepth && matches((Item)item);
            } catch (RepositoryException re) {
                return false;
            }
        }
        return false;
    }


    public boolean equals(Object obj) {
        if (obj instanceof AuthorizableImpl) {
            AuthorizableImpl otherAuth = (AuthorizableImpl) obj;
            try {
                return isGroup() == otherAuth.isGroup() && node.isSame(otherAuth.node);
            } catch (RepositoryException e) {
                // should not occur -> return false in this case.
            }
        }
        return false;
    }


    public boolean evaluate(Object item) {
        if ( item instanceof Item ) {
            try {
                return regex.matcher(((Item)item).getPath()).matches();
            } catch (RepositoryException re) {
                return false;
            }
        }
        return false;
    }


    public static Predicate and(final Predicate... predicates) {
        return new Predicate() {
            public boolean evaluate(Object object) {
                for (Predicate predicate : predicates) {
                    if (!predicate.evaluate(object)) {
                        return false;
                    }
                }
                return true;
            }
        };
    }


    public static Predicate or(final Predicate... predicates) {
        return new Predicate() {
            public boolean evaluate(Object object) {
                for (Predicate predicate : predicates) {
                    if (predicate.evaluate(object)) {
                        return true;
                    }
                }
                return false;
            }
        };
    }


    public Repository getRepository() throws RepositoryException {
        try {
            Object repository = context.lookup(name);
            if (repository instanceof Repository) {
                return (Repository) repository;
            } else if (repository == null) {
                throw new RepositoryException(
                        "Repository not found: The JNDI entry "
                        + name + " is null");
            } else {
                throw new RepositoryException(
                        "Invalid repository: The JNDI entry "
                        + name + " is an instance of "
                        + repository.getClass().getName());
            }
        } catch (NamingException e) {
            throw new RepositoryException(
                    "Repository not found: The JNDI entry " + name
                    + " could not be looked up", e);
        }
    }


    protected RemoteRepository getRemoteRepository()
            throws RepositoryException {
        try {
            Object remote = context.lookup(location);
            if (remote instanceof RemoteRepository) {
                return (RemoteRepository) remote;
            } else if (remote == null) {
                throw new RepositoryException(
                        "Remote repository not found: The JNDI entry "
                        + location + " is null");
            } else {
                throw new RepositoryException(
                        "Invalid remote repository: The JNDI entry "
                        + location + " is an instance of "
                        + remote.getClass().getName());
            }
        } catch (NamingException e) {
            throw new RepositoryException(
                    "Remote repository not found: The JNDI entry " + location
                    + " could not be looked up", e);
        }
    }


    public static Test suite() {

        TestSuite suite = new TestSuite("org.apache.jackrabbit.spi2davex tests");

        // spi tests
        suite.addTest(org.apache.jackrabbit.spi.TestAll.suite());

        // impl specific spi tests
        suite.addTestSuite(ConnectionTest.class);
        suite.addTestSuite(ReadTest.class);
        suite.addTestSuite(BatchTest.class);
        suite.addTestSuite(CopyTest.class);
        suite.addTestSuite(CloneTest.class);
        suite.addTestSuite(ExtensionTest.class);
        suite.addTestSuite(CreateFileTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("javax.jcr.lock tests");

        suite.addTestSuite(LockTest.class);
        suite.addTestSuite(SetValueLockExceptionTest.class);

        // JCR 2.0 tests
        
        suite.addTestSuite(DeepLockTest.class);
        suite.addTestSuite(LockManagerTest.class);
        suite.addTestSuite(OpenScopedLockTest.class);
        suite.addTestSuite(SessionScopedLockTest.class);
        
        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("Observation tests");

        suite.addTestSuite(ReorderTest.class);
        suite.addTestSuite(MixinTest.class);
        suite.addTestSuite(VersionEventsTest.class);
        suite.addTestSuite(MoveInPlaceTest.class);
        suite.addTestSuite(ShareableNodesTest.class);
        suite.addTestSuite(WarningOnSaveWithNotificationThreadTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("core.security.authentication tests");

        suite.addTestSuite(GuestLoginTest.class);
        suite.addTestSuite(NullLoginTest.class);
        suite.addTestSuite(SimpleCredentialsAuthenticationTest.class);
        suite.addTestSuite(CryptedSimpleCredentialsTest.class);
        suite.addTestSuite(LoginModuleTest.class);
        suite.addTestSuite(DefaultLoginModuleTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("javax.jcr.version.simple tests");

        suite.addTestSuite(BasicTest.class);
        suite.addTestSuite(CheckinTest.class);
        suite.addTestSuite(CheckoutTest.class);
        suite.addTestSuite(CopyTest.class);
        suite.addTestSuite(FrozenNodeTest.class);
        suite.addTestSuite(RestoreTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("core.security.authorization tests");

        suite.addTestSuite(PrivilegeRegistryTest.class);
        suite.addTestSuite(PrivilegeManagerImplTest.class);
        suite.addTestSuite(CustomPrivilegeTest.class);
        suite.addTestSuite(PrivilegeBitsTest.class);
        suite.addTestSuite(JackrabbitAccessControlListTest.class);
        suite.addTestSuite(GlobPatternTest.class);
        suite.addTestSuite(PermissionTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("Version tests");
        suite.addTestSuite(CheckinRemoveVersionTest.class);
        suite.addTestSuite(CopyFrozenUuidTest.class);
        suite.addTestSuite(InternalVersionHistoryImplTest.class);
        suite.addTestSuite(RemoveVersionLabelTest.class);
        suite.addTestSuite(RestoreTest.class);
        suite.addTestSuite(RestoreNodeWithSNSTest.class);
        suite.addTestSuite(VersionIteratorImplTest.class);
        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("jsr 283 security tests");

        suite.addTestSuite(AccessControlDiscoveryTest.class);
        suite.addTestSuite(AccessControlPolicyTest.class);
        suite.addTestSuite(AccessControlPolicyIteratorTest.class);
        suite.addTestSuite(AccessControlListTest.class);

        // tests with read only session:
        suite.addTestSuite(RSessionAccessControlDiscoveryTest.class);
        suite.addTestSuite(RSessionAccessControlPolicyTest.class);
        suite.addTestSuite(RSessionAccessControlTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("api.security.user tests");

        suite.addTestSuite(UserManagerTest.class);
        suite.addTestSuite(UserManagerCreateGroupTest.class);
        suite.addTestSuite(UserManagerCreateUserTest.class);

        suite.addTestSuite(AuthorizableTest.class);
        suite.addTestSuite(UserTest.class);
        suite.addTestSuite(GroupTest.class);
        suite.addTestSuite(NestedGroupTest.class);
        suite.addTestSuite(ImpersonationTest.class);
        suite.addTestSuite(UserManagerSearchTest.class);
        suite.addTestSuite(ConcurrentCreateUserTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("State tests");

        suite.addTestSuite(ChangeLogTest.class);
        suite.addTestSuite(DefaultISMLockingTest.class);
        suite.addTestSuite(DefaultISMLockingDeadlockTest.class);
        suite.addTestSuite(FineGrainedISMLockingTest.class);
        suite.addTestSuite(NameSetTest.class);
        suite.addTestSuite(NodeStateMergerTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("security.authorization.principalbased tests");

        suite.addTestSuite(ACLTemplateTest.class);
        suite.addTestSuite(EntryTest.class);

        suite.addTestSuite(WriteTest.class);
        suite.addTestSuite(LockTest.class);
        suite.addTestSuite(VersionTest.class);
        suite.addTestSuite(NodeTypeTest.class);
        suite.addTestSuite(EffectivePolicyTest.class);
        suite.addTestSuite(RepositoryOperationTest.class);

        return suite;
    }


    protected void setUp() throws Exception {
        super.setUp();

        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();
        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);

        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            rs.submit(b);
        }

        lastModified = rs.getQValueFactory().create(Calendar.getInstance());
        mimeType = rs.getQValueFactory().create("text/plain", PropertyType.STRING);
        enc = rs.getQValueFactory().create("utf-8", PropertyType.STRING);
    }


    protected void setUp() throws Exception {
        super.setUp();

        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();
        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);
        
        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            rs.submit(b);
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();
        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) throws NamespaceException {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) throws NamespaceException {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);

        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            rs.submit(b);
        }

        // todo: retrieve second wsp-name from config
        sInfo = rs.obtain(si, "test");
    }


    protected void setUp() throws Exception {
        super.setUp();

        repoURI = helper.getProperty(ServiceStubImpl.PROP_REPOSITORY_URI);

        rs = (RepositoryServiceImpl) helper.getRepositoryService();
        si = helper.getAdminSessionInfo();

        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);

        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            QValueFactory qvf = rs.getQValueFactory();
            b.addProperty(getNodeId("/test"), resolver.getQName("prop"), qvf.create("value", PropertyType.STRING));
            b.addProperty(getNodeId("/test"), resolver.getQName("propMV"), new QValue[] {qvf.create(1), qvf.create(2)});
            rs.submit(b);
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();
        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);

        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            rs.submit(b);
        }
    }


    protected void setUp() throws Exception {
        super.setUp();
        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();

        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);

        try {
            rs.getNodeInfo(si, getNodeId(testPath));
        } catch (RepositoryException e) {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.addNode(getNodeId("/"), resolver.getQName("test"), NameConstants.NT_UNSTRUCTURED, null);
            rs.submit(b);
        }
    }


    protected void tearDown() throws Exception {
        try {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.remove(getNodeId(testPath));
            rs.submit(b);
        } finally {
            rs.dispose(si);
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.remove(getNodeId(testPath));
            rs.submit(b);
        } finally {
            rs.dispose(si);
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.remove(getNodeId(testPath));
            rs.submit(b);
        } finally {
            rs.dispose(si);
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            Batch b = rs.createBatch(si, getNodeId("/"));
            b.remove(getNodeId(testPath));
            rs.submit(b);
        } finally {
            rs.dispose(si);
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            if (si != null) {
                Batch b = rs.createBatch(si, getNodeId("/"));
                b.remove(getNodeId(testPath));
                rs.submit(b);
            }
            if (sInfo != null && copiedId != null) {
                Batch b = rs.createBatch(sInfo, getNodeId("/"));
                b.remove(copiedId);
                rs.submit(b);
            }
        } catch (RepositoryException e) {
            // cleanup failed... ignore.
        } finally {
            if (sInfo != null) {
                rs.dispose(sInfo);
            }
            if (si != null) {
                rs.dispose(si);
            }
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            if (si != null) {
                Batch b = rs.createBatch(si, getNodeId("/"));
                b.remove(getNodeId(testPath));
                rs.submit(b);
            }
            if (sInfo != null && clonedId != null) {
                Batch b = rs.createBatch(sInfo, getNodeId("/"));
                b.remove(clonedId);
                rs.submit(b);
            }
        } catch (RepositoryException e) {
            // cleanup failed... ignore.
        } finally {
            if (sInfo != null) {
                rs.dispose(sInfo);                
            }
            if (si != null) {
                rs.dispose(si);
            }
            super.tearDown();
        }
    }


    public void testCopyAcrossWorkspaces() throws RepositoryException {
        // todo: retrieve second wsp-name from config
        sInfo = rs.obtain(si, "test");

        NodeId srcId = getNodeId(testPath);
        NodeId destParentId = getNodeId("/");
        rs.copy(sInfo, si.getWorkspaceName(), srcId, destParentId, resolver.getQName("destname"));

        copiedId = getNodeId("/destname");
        NodeInfo nInfo = rs.getNodeInfo(sInfo, copiedId);
        Iterator<? extends ItemInfo> it = rs.getItemInfos(sInfo, copiedId);

        assertTrue(it.hasNext());
        NodeInfo nInfo2 = (NodeInfo) it.next();
        assertEquals(nInfo.getId(), nInfo2.getId());
        assertEquals(nInfo.getNodetype(), nInfo2.getNodetype());
    }


    public void testClone() throws RepositoryException {
        NodeId srcId = getNodeId(testPath);
        NodeId destParentId = getNodeId("/");
        rs.clone(sInfo, si.getWorkspaceName(), srcId, destParentId, resolver.getQName("destname"), true);

        clonedId = getNodeId("/destname");
        NodeInfo nInfo = rs.getNodeInfo(sInfo, clonedId);
        Iterator<? extends ItemInfo> it = rs.getItemInfos(sInfo, clonedId);

        assertTrue(it.hasNext());
        NodeInfo nInfo2 = (NodeInfo) it.next();
        assertEquals(nInfo.getId(), nInfo2.getId());
        assertEquals(nInfo.getNodetype(), nInfo2.getNodetype());
    }


    public void testMove() throws RepositoryException {
        NodeId nid = getNodeId(testPath);

        Batch b = rs.createBatch(si, nid);
        b.addNode(nid, resolver.getQName("anyNode"), NameConstants.NT_UNSTRUCTURED, null);
        rs.submit(b);

        NodeId id = getNodeId(testPath + "/anyNode");

        b = rs.createBatch(si, nid);
        b.move(id, nid, resolver.getQName("moved"));
        rs.submit(b);

        try {
            rs.getItemInfos(si, id);
            fail();
        } catch (RepositoryException e) {
            // ok
        }

        rs.getNodeInfo(si, getNodeId(testPath + "/moved"));
    }


    public void testRemove() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        Batch b = rs.createBatch(si, nid);

        NodeId id = getNodeId(testPath + "/aTestNode");
        b.addNode(nid, resolver.getQName("aTestNode"), NameConstants.NT_UNSTRUCTURED, null);
        b.addProperty(id, resolver.getQName("aString"), rs.getQValueFactory().create("ba", PropertyType.STRING));
        rs.submit(b);

        PropertyId pid = getPropertyId(id, resolver.getQName("aString"));
        b = rs.createBatch(si, nid);
        b.remove(pid);
        rs.submit(b);

        try {
            rs.getPropertyInfo(si, pid);
            fail();
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testReorder() throws RepositoryException {
        NodeId nid = getNodeId(testPath);

        Batch b = rs.createBatch(si, nid);
        b.addNode(nid, resolver.getQName("1"), NameConstants.NT_UNSTRUCTURED, null);
        b.addNode(nid, resolver.getQName("3"), NameConstants.NT_UNSTRUCTURED, null);
        b.addNode(nid, resolver.getQName("2"), NameConstants.NT_UNSTRUCTURED, null);
        rs.submit(b);

        b = rs.createBatch(si, nid);
        b.reorderNodes(nid, getNodeId(testPath + "/3"), null);
        rs.submit(b);

        Iterator<ChildInfo> it = rs.getChildInfos(si, nid);
        int i = 1;
        while (it.hasNext()) {
            ChildInfo ci = it.next();
            assertEquals(i, Integer.parseInt(ci.getName().getLocalName()));
            i++;
        }
    }


    public void testReorder1() throws RepositoryException {
        NodeId nid = getNodeId(testPath);

        Batch b = rs.createBatch(si, nid);
        b.addNode(nid, resolver.getQName("2"), NameConstants.NT_UNSTRUCTURED, null);
        b.addNode(nid, resolver.getQName("3"), NameConstants.NT_UNSTRUCTURED, null);
        b.addNode(nid, resolver.getQName("1"), NameConstants.NT_UNSTRUCTURED, null);
        rs.submit(b);

        b = rs.createBatch(si, nid);
        b.reorderNodes(nid, getNodeId(testPath + "/1"), getNodeId(testPath + "/2"));
        rs.submit(b);

        Iterator<ChildInfo> it = rs.getChildInfos(si, nid);
        int i = 1;
        while (it.hasNext()) {
            ChildInfo ci = it.next();
            assertEquals(i, Integer.parseInt(ci.getName().getLocalName()));
            i++;
        }
    }


    public void testSetBinaryValues() throws RepositoryException, IOException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("binPropMV");

        Batch b = rs.createBatch(si, nid);
        QValue[] vs = new QValue[] {
                rs.getQValueFactory().create(new byte[] {'a', 'b', 'c'}),
                rs.getQValueFactory().create(new byte[] {'d', 'e', 'f'}),
                rs.getQValueFactory().create(new byte[] {'g', 'h', 'i'})
        };
        b.addProperty(nid, propName, vs);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertTrue(pi.isMultiValued());
        vs = pi.getValues();
        assertEquals("abc", vs[0].getString());
        assertEquals("def", vs[1].getString());
        assertEquals("ghi", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());

        pi = getPropertyInfo(nid, propName);
        vs = pi.getValues();
        assertEquals("abc", vs[0].getString());
        assertEquals("def", vs[1].getString());
        assertEquals("ghi", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());
    }


    public void testSetMixedBinaryValues() throws RepositoryException, IOException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("binPropMV");

        Batch b = rs.createBatch(si, nid);
        QValue[] vs = new QValue[] {
                rs.getQValueFactory().create(new byte[] {'a', 'b', 'c'}),
                rs.getQValueFactory().create(new byte[0]),
                rs.getQValueFactory().create(new byte[] {'g', 'h', 'i'})
        };
        b.addProperty(nid, propName, vs);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertTrue(pi.isMultiValued());
        vs = pi.getValues();
        assertEquals("abc", vs[0].getString());
        assertEquals("", vs[1].getString());
        assertEquals("ghi", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());

        pi = getPropertyInfo(nid, propName);
        vs = pi.getValues();
        assertEquals("abc", vs[0].getString());
        assertEquals("", vs[1].getString());
        assertEquals("ghi", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());
    }


    public void testSetEmptyBinaryValues() throws RepositoryException, IOException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("binPropMV");

        Batch b = rs.createBatch(si, nid);
        QValue[] vs = new QValue[] {
                rs.getQValueFactory().create(new byte[0]),
                rs.getQValueFactory().create(new byte[0]),
                rs.getQValueFactory().create(new byte[0])
        };
        b.addProperty(nid, propName, vs);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertTrue(pi.isMultiValued());
        vs = pi.getValues();
        assertEquals("", vs[0].getString());
        assertEquals("", vs[1].getString());
        assertEquals("", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());

        pi = getPropertyInfo(nid, propName);
        vs = pi.getValues();
        assertEquals("", vs[0].getString());
        assertEquals("", vs[1].getString());
        assertEquals("", vs[2].getString());
        assertEquals(PropertyType.BINARY, pi.getType());
    }


    public void testSetDoubleValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("doubleProp");

        QValue v = rs.getQValueFactory().create((double) 12);

        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.DOUBLE, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.DOUBLE, pi.getType());
    }


    public void testSetDateValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("dateProp");

        QValue v = rs.getQValueFactory().create(Calendar.getInstance());

        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.DATE, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.DATE, pi.getType());
    }


    public void testSetPathValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("pathProp");

        QValue v = rs.getQValueFactory().create(resolver.getQPath(testPath));
        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.PATH, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v.getPath(), pi.getValues()[0].getPath());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.PATH, pi.getType());
    }


    public void testSetLongValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        Name propName = resolver.getQName("doubleProp");

        QValue v = rs.getQValueFactory().create(234567);

        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.LONG, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v, pi.getValues()[0]);
        assertEquals(v.getString(), pi.getValues()[0].getString());
        assertEquals(PropertyType.LONG, pi.getType());
    }


    public void testSetReferenceValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        NodeInfo nInfo = rs.getNodeInfo(si, nid);
        if (!Arrays.asList(nInfo.getMixins()).contains(NameConstants.MIX_REFERENCEABLE)) {
            Batch b = rs.createBatch(si, nid);
            b.setMixins(nid, new Name[] {NameConstants.MIX_REFERENCEABLE});
            rs.submit(b);
        }

        String ref = rs.getNodeInfo(si, nid).getId().getUniqueID();
        Name propName = resolver.getQName("refProp");
        QValue v = rs.getQValueFactory().create(ref, PropertyType.REFERENCE);

        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.REFERENCE, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.REFERENCE, pi.getType());
    }


    public void testSetWeakReferenceValue() throws RepositoryException {
        NodeId nid = getNodeId(testPath);
        NodeInfo nInfo = rs.getNodeInfo(si, nid);
        if (!Arrays.asList(nInfo.getMixins()).contains(NameConstants.MIX_REFERENCEABLE)) {
            Batch b = rs.createBatch(si, nid);
            b.setMixins(nid, new Name[] {NameConstants.MIX_REFERENCEABLE});
            rs.submit(b);
        }

        String ref = rs.getNodeInfo(si, nid).getId().getUniqueID();
        Name propName = resolver.getQName("weakRefProp");
        QValue v = rs.getQValueFactory().create(ref, PropertyType.WEAKREFERENCE);

        Batch b = rs.createBatch(si, nid);
        b.addProperty(nid, propName, v);
        rs.submit(b);

        PropertyInfo pi = rs.getPropertyInfo(si, getPropertyId(nid, propName));
        assertFalse(pi.isMultiValued());
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.WEAKREFERENCE, pi.getType());

        pi = getPropertyInfo(nid, propName);
        assertEquals(v, pi.getValues()[0]);
        assertEquals(PropertyType.WEAKREFERENCE, pi.getType());
    }


    protected void setUp() throws Exception {
        super.setUp();
        rs = helper.getRepositoryService();
                NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);
    }


    protected void setUp() throws Exception {
        super.setUp();

        rs = helper.getRepositoryService();
        si = helper.getAdminSessionInfo();
        NamespaceResolver nsResolver = new AbstractNamespaceResolver() {
            public String getURI(String prefix) {
                return ("jcr".equals(prefix)) ? "http://www.jcp.org/jcr/1.0" : prefix;
            }
            public String getPrefix(String uri) {
                return ("http://www.jcp.org/jcr/1.0".equals(uri)) ? "jcr" : uri;
            }
        };
        resolver = new DefaultNamePathResolver(nsResolver);
    }


    public void testProperty() throws Exception {
        String uri = rs.getItemUri(getPropertyId(getNodeId("/test"), resolver.getQName("prop")), si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(PROPERTY_SET);
        expected.add(JCR_PARENT);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}length
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {DAV:}supportedlock
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {DAV:}supported-method-set
        {DAV:}iscollection
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}supported-report-set
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}path
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {http://www.day.com/jcr/webdav/1.0}type
        {http://www.day.com/jcr/webdav/1.0}value
         */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_LENGTH);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {DAV:}supportedlock
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}type
        {DAV:}resourcetype
        {DAV:}lockdiscovery
        {http://www.day.com/jcr/webdav/1.0}value
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_LENGTH);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testNode() throws Exception {
        String uri = rs.getItemUri(getNodeId("/test"), si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.add(OrderingConstants.ORDERING_TYPE);
        expected.add(JCR_PARENT);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}ordering-type
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(OrderingConstants.ORDERING_TYPE);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(OrderingConstants.ORDERING_TYPE);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testRootNode() throws Exception {
        String uri = rs.getItemUri(getNodeId("/"), si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.add(OrderingConstants.ORDERING_TYPE);
        /*
         Expected property names
         
        {DAV:}getlastmodified
        {DAV:}ordering-type
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}resourcetype
        {DAV:}lockdiscovery
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(OrderingConstants.ORDERING_TYPE);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(OrderingConstants.ORDERING_TYPE);        
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testMVProperty() throws Exception {
        String uri = rs.getItemUri(getPropertyId(getNodeId("/test"), resolver.getQName("propMV")), si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(PROPERTY_MV_SET);
        expected.add(JCR_PARENT);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}values
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {DAV:}supportedlock
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {DAV:}supported-method-set
        {DAV:}iscollection
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}supported-report-set
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}path
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {http://www.day.com/jcr/webdav/1.0}type
        {http://www.day.com/jcr/webdav/1.0}lengths
         */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_LENGTHS);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}values
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}parent
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}supportedlock
        {DAV:}displayname
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}type
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_LENGTHS);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testCheckedInVersionableNode() throws Exception {
        NodeId nid = getNodeId("/test");
        Batch b = rs.createBatch(si, nid);
        b.setMixins(nid, new Name[] {NameConstants.MIX_VERSIONABLE});
        rs.submit(b);
        rs.checkin(si, nid);

        String uri = rs.getItemUri(nid, si);
        
        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.addAll(VERSIONABLE_SET);
        expected.add(OrderingConstants.ORDERING_TYPE);
        expected.add(JCR_PARENT);
        expected.add(JCR_UUID);
        expected.add(VersionControlledResource.CHECKED_IN);

        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}ordering-type
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}uuid
        {DAV:}checked-in
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}version-history
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {DAV:}auto-version
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(OrderingConstants.ORDERING_TYPE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_UUID);
        expected.remove(VersionControlledResource.CHECKED_IN);
        expected.remove(VersionControlledResource.VERSION_HISTORY);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {DAV:}auto-version
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(OrderingConstants.ORDERING_TYPE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_UUID);
        props.add(VersionControlledResource.CHECKED_IN);
        props.add(VersionControlledResource.VERSION_HISTORY);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testCheckedOutVersionableNode() throws Exception {
        NodeId nid = getNodeId("/test");
        Batch b = rs.createBatch(si, nid);
        b.setMixins(nid, new Name[] {NameConstants.MIX_VERSIONABLE});
        rs.submit(b);

        String uri = rs.getItemUri(nid, si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.addAll(VERSIONABLE_SET);
        expected.add(OrderingConstants.ORDERING_TYPE);
        expected.add(JCR_PARENT);
        expected.add(JCR_UUID);
        expected.add(VersionControlledResource.CHECKED_OUT);        
        expected.add(VersionControlledResource.PREDECESSOR_SET);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}ordering-type
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}uuid
        {DAV:}predecessor-set
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}version-history
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {DAV:}auto-version
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {DAV:}checked-out
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(OrderingConstants.ORDERING_TYPE);        
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_UUID);
        expected.remove(VersionControlledResource.CHECKED_OUT);
        expected.remove(VersionControlledResource.VERSION_HISTORY);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {DAV:}predecessor-set
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}auto-version
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(OrderingConstants.ORDERING_TYPE);                
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_UUID);
        props.add(VersionControlledResource.CHECKED_OUT);
        props.add(VersionControlledResource.PREDECESSOR_SET);
        props.add(VersionControlledResource.VERSION_HISTORY);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testReferenceableNode() throws Exception {
        NodeId nid = getNodeId("/test");
        Batch b = rs.createBatch(si, nid);
        b.setMixins(nid, new Name[] {NameConstants.MIX_REFERENCEABLE});
        rs.submit(b);

        String uri = rs.getItemUri(nid, si);
        
        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.add(OrderingConstants.ORDERING_TYPE);
        expected.add(JCR_PARENT);
        expected.add(JCR_UUID);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}ordering-type
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}uuid
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(OrderingConstants.ORDERING_TYPE);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_UUID);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(OrderingConstants.ORDERING_TYPE);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_UUID);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testVersionHistory() throws Exception {
        NodeId nid = getNodeId("/test");
        Batch b = rs.createBatch(si, nid);
        b.setMixins(nid, new Name[] {NameConstants.MIX_VERSIONABLE});
        rs.submit(b);
        NodeId vID = rs.checkin(si, nid);

        String uri = Text.getRelativeParent(rs.getItemUri(vID, si), 1);
        DavPropertyNameSet set = doPropFindNames(uri);

        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.addAll(VERSIONHISTORY_SET);
        expected.add(JCR_PARENT);
        expected.add(JCR_UUID);

        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}root-version
        {DAV:}version-set
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}uuid
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {http://www.day.com/jcr/webdav/1.0}versionableuuid
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_UUID);
        expected.remove(VersionHistoryResource.ROOT_VERSION);
        expected.remove(VersionHistoryResource.VERSION_SET);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {http://www.day.com/jcr/webdav/1.0}versionableuuid
        {DAV:}iscollection
        {DAV:}getcontenttype
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}name
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_UUID);
        props.add(VersionHistoryResource.ROOT_VERSION);
        props.add(VersionHistoryResource.VERSION_SET);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testNodeWithPrimaryItem() throws Exception {
        // create file node
        NodeId nid = getNodeId("/test");
        Name fileName = resolver.getQName("test.txt");
        Batch b = rs.createBatch(si, nid);
        b.addNode(nid, fileName, NameConstants.NT_FILE, null);

        String filePath = testPath + "/" + fileName.getLocalName();
        NodeId fileID = getNodeId(filePath);
        b.addNode(fileID, NameConstants.JCR_CONTENT, NameConstants.NT_RESOURCE, null);

        NodeId content = getNodeId(filePath + "/" + NameConstants.JCR_CONTENT);

        QValue lastModified = rs.getQValueFactory().create(Calendar.getInstance());
        QValue mimeType = rs.getQValueFactory().create("text/plain", PropertyType.STRING);
        QValue enc = rs.getQValueFactory().create("utf-8", PropertyType.STRING);
        b.addProperty(content, resolver.getQName(JcrConstants.JCR_LASTMODIFIED), lastModified);
        b.addProperty(content, resolver.getQName(JcrConstants.JCR_MIMETYPE), mimeType);
        b.addProperty(content, resolver.getQName(JcrConstants.JCR_ENCODING), enc);

        InputStream data = new ByteArrayInputStream("\u0633\u0634".getBytes("UTF-8"));
        b.addProperty(content, resolver.getQName(JcrConstants.JCR_DATA), rs.getQValueFactory().create(data));

        rs.submit(b);

        // test properties of the file node
        String uri = rs.getItemUri(fileID, si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.add(JCR_PARENT);
        expected.add(JCR_PRIMARYITEM);
        /*
         Expected property names

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}resourcetype
        {DAV:}lockdiscovery
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}primaryitem
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_PRIMARYITEM);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_PRIMARYITEM);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public void testVersion() throws Exception {
        NodeId nid = getNodeId("/test");
        Batch b = rs.createBatch(si, nid);
        b.setMixins(nid, new Name[] {NameConstants.MIX_VERSIONABLE});
        rs.submit(b);
        NodeId vID = rs.checkin(si, nid);

        String uri = rs.getItemUri(vID, si);

        DavPropertyNameSet set = doPropFindNames(uri);
        DavPropertyNameSet expected = new DavPropertyNameSet(BASE_SET);
        expected.addAll(EXISTING_ITEM_BASE_SET);
        expected.addAll(NODE_SET);
        expected.addAll(VERSION_SET);
        expected.add(JCR_PARENT);
        expected.add(JCR_UUID);
        /*
         Expected property names

        {DAV:}getlastmodified
        {DAV:}version-name
        {http://www.day.com/jcr/webdav/1.0}definition
        {DAV:}comment
        {http://www.day.com/jcr/webdav/1.0}references
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {http://www.day.com/jcr/webdav/1.0}subscriptiondiscovery
        {http://www.day.com/jcr/webdav/1.0}uuid
        {DAV:}checkout-set
        {DAV:}predecessor-set
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}current-user-privilege-set
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}version-history
        {DAV:}successor-set
        {DAV:}lockdiscovery
        {DAV:}resourcetype
        {DAV:}workspace
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}index
        {DAV:}label-name-set
        {DAV:}supportedlock
        {DAV:}supported-method-set
        {DAV:}iscollection
        {http://www.day.com/jcr/webdav/1.0}weakreferences
        {DAV:}creator-displayname
        {DAV:}getcontenttype
        {DAV:}creationdate
        {DAV:}supported-report-set
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        */
        assertPropertyNames(expected, set);

        DavPropertyNameSet all = doPropFindAll(uri);
        expected.remove(DeltaVConstants.COMMENT);
        expected.remove(DeltaVConstants.CREATOR_DISPLAYNAME);
        expected.remove(DeltaVConstants.SUPPORTED_METHOD_SET);
        expected.remove(DeltaVConstants.SUPPORTED_REPORT_SET);
        expected.remove(DeltaVConstants.WORKSPACE);
        expected.remove(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        expected.remove(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        expected.remove(JCR_DEFINITION);
        expected.remove(JCR_INDEX);
        expected.remove(JCR_REFERENCES);
        expected.remove(JCR_WEAK_REFERENCES);
        expected.remove(JCR_UUID);
        expected.remove(VersionResource.VERSION_NAME);
        expected.remove(VersionResource.LABEL_NAME_SET);
        expected.remove(VersionResource.PREDECESSOR_SET);
        expected.remove(VersionResource.SUCCESSOR_SET);
        expected.remove(VersionResource.VERSION_HISTORY);
        expected.remove(VersionResource.CHECKOUT_SET);
        /*
        Expected all-props

        {DAV:}getlastmodified
        {http://www.day.com/jcr/webdav/1.0}depth
        {http://www.day.com/jcr/webdav/1.0}workspaceName
        {DAV:}displayname
        {http://www.day.com/jcr/webdav/1.0}parent
        {DAV:}supportedlock
        {DAV:}iscollection
        {DAV:}getcontenttype
        {http://www.day.com/jcr/webdav/1.0}name
        {DAV:}creationdate
        {http://www.day.com/jcr/webdav/1.0}mixinnodetypes
        {http://www.day.com/jcr/webdav/1.0}path
        {http://www.day.com/jcr/webdav/1.0}primarynodetype
        {DAV:}lockdiscovery
        {DAV:}resourcetype
         */
        assertPropertyNames(expected , all);

        DavPropertyNameSet props = new DavPropertyNameSet();
        props.add(DeltaVConstants.COMMENT);
        props.add(DeltaVConstants.CREATOR_DISPLAYNAME);
        props.add(DeltaVConstants.SUPPORTED_METHOD_SET);
        props.add(DeltaVConstants.SUPPORTED_REPORT_SET);
        props.add(DeltaVConstants.WORKSPACE);
        props.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
        props.add(ObservationConstants.SUBSCRIPTIONDISCOVERY);
        props.add(JCR_DEFINITION);
        props.add(JCR_INDEX);
        props.add(JCR_REFERENCES);
        props.add(JCR_WEAK_REFERENCES);
        props.add(JCR_UUID);
        props.add(VersionResource.VERSION_NAME);
        props.add(VersionResource.LABEL_NAME_SET);
        props.add(VersionResource.PREDECESSOR_SET);
        props.add(VersionResource.SUCCESSOR_SET);
        props.add(VersionResource.VERSION_HISTORY);
        props.add(VersionResource.CHECKOUT_SET);
        DavPropertyNameSet result = doPropFindByProp(uri, props);
        assertPropertyNames(props, result);
    }


    public synchronized Repository getRepository() throws RepositoryStubException {
        if (repository == null) {
            try {
                String url = environment.getProperty(PROP_REPOSITORY_URL);
                final RepositoryService service = createService(url);
                repository = RepositoryImpl.create(new AbstractRepositoryConfig() {
                    public RepositoryService getRepositoryService() {
                        return service;
                    }
                });
            } catch (Exception e) {
                throw new RepositoryStubException(e);
            }
        }
        return repository;
    }


    public Repository getRepository() throws RepositoryStubException {
        if (repo == null) {
            try {
                final RepositoryService service = getRepositoryService();
                repo = RepositoryImpl.create(new AbstractRepositoryConfig() {
                    public RepositoryService getRepositoryService() {
                        return service;
                    }
                });
            } catch (RepositoryException e) {
                throw new RepositoryStubException(e);
            }
        }
        return repo;
    }


    public void value(boolean value) throws IOException {
        if (expectingHintValue) {
            // there are currently no special boolean value hints:
            return;
        }
        try {
            value(vFactory.create(value));
        } catch (RepositoryException e) {
            throw new IOException(e.getMessage());
        }
    }


    public void value(double value) throws IOException {
        if (expectingHintValue) {
            // currently no special double value pair -> ignore
            return;
        }
        try {
            value(vFactory.create(value));
        } catch (RepositoryException e) {
            throw new IOException(e.getMessage());
        }
    }


    int loadType(String uri) throws RepositoryException, IOException {
        DavPropertyNameSet nameSet = new DavPropertyNameSet();
        nameSet.add(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);

        DavMethodBase method = null;
        try {
            method = new PropFindMethod(uri, nameSet, DavConstants.DEPTH_0);
            client.executeMethod(method);
            method.checkSuccess();

            MultiStatusResponse[] responses = method.getResponseBodyAsMultiStatus().getResponses();
            if (responses.length == 1) {
                DavPropertySet props = responses[0].getProperties(DavServletResponse.SC_OK);
                DavProperty<?> type = props.get(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);
                if (type != null) {
                    return PropertyType.valueFromName(type.getValue().toString());
                } else {
                    throw new RepositoryException("Internal error. Cannot retrieve property type at " + uri);
                }
            } else {
                throw new ItemNotFoundException("Internal error. Cannot retrieve property type at " + uri);
            }
        } catch (DavException e) {
            throw ExceptionConverter.generate(e);
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    private int loadType(String propertyURI, HttpClient client, PropertyId propertyId, SessionInfo sessionInfo, NamePathResolver resolver) throws IOException, DavException, RepositoryException {
        DavPropertyNameSet nameSet = new DavPropertyNameSet();
        nameSet.add(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);

        DavMethodBase method = null;
        try {
            method = new PropFindMethod(propertyURI, nameSet, DEPTH_0);
            client.executeMethod(method);
            method.checkSuccess();

            MultiStatusResponse[] responses = method.getResponseBodyAsMultiStatus().getResponses();
            if (responses.length == 1) {
                DavPropertySet props = responses[0].getProperties(DavServletResponse.SC_OK);
                DavProperty<?> type = props.get(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);
                if (type != null) {
                    return PropertyType.valueFromName(type.getValue().toString());
                } else {
                    throw new RepositoryException("Internal error. Cannot retrieve property type at " + saveGetIdString(propertyId, resolver));
                }
            } else {
                throw new ItemNotFoundException("Internal error. Cannot retrieve property type at " + saveGetIdString(propertyId, resolver));
            }
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


        public void discard() {
            if (!temp) {
                // do nothing if this instance is not backed by temporarily
                // allocated resource/buffer
                return;
            }
            if (file != null) {
                // this instance is backed by a temp file
                file.delete();
            } else if (buffer != null) {
                // this instance is backed by an in-memory buffer
                buffer = EMPTY_BYTE_ARRAY;
            }
        }


        public void reset() {
            if (!temp) {
                // do nothing if this instance is not backed by temporarily
                // allocated resource/buffer
                return;
            }
            if (file != null) {
                // this instance is backed by a temp file
                file.delete();
            }
            file = null;
            buffer = null;
            initialized = false;
        }


        public void discard() {
            if (!temp) {
                // do nothing if this instance is not backed by temporarily
                // allocated resource/buffer
                return;
            }
            if (file != null) {
                // this instance is backed by a temp file
                file.delete();
            } else if (buffer != null) {
                // this instance is backed by an in-memory buffer
                buffer = EMPTY_BYTE_ARRAY;
            }
        }


        private void writeObject(ObjectOutputStream out)
                throws IOException {
            out.defaultWriteObject();
            // write hasFile marker
            out.writeBoolean(file != null);
            // then write file if necessary
            if (file != null) {
                byte[] buffer = new byte[4096];
                int bytes;
                InputStream stream = new FileInputStream(file);
                while ((bytes = stream.read(buffer)) >= 0) {
                    // Write a segment of the input stream
                    if (bytes > 0) {
                        // just to ensure that no 0 is written
                        out.writeInt(bytes);
                        out.write(buffer, 0, bytes);
                    }
                }
                // Write the end of stream marker
                out.writeInt(0);
                // close stream
                stream.close();
            }
        }


        private void writeObject(ObjectOutputStream out)
                throws IOException {
            out.defaultWriteObject();
            // write hasFile marker
            out.writeBoolean(file != null);
            // then write file if necessary
            if (file != null) {
                byte[] buffer = new byte[4096];
                int bytes;
                InputStream stream = new FileInputStream(file);
                while ((bytes = stream.read(buffer)) >= 0) {
                    // Write a segment of the input stream
                    if (bytes > 0) {
                        // just to ensure that no 0 is written
                        out.writeInt(bytes);
                        out.write(buffer, 0, bytes);
                    }
                }
                // Write the end of stream marker
                out.writeInt(0);
                // close stream
                stream.close();
            }
        }


        private void readObject(ObjectInputStream in)
                throws IOException, ClassNotFoundException {
            in.defaultReadObject();
            boolean hasFile = in.readBoolean();
            if (hasFile) {
                file = File.createTempFile("binary-qvalue", "bin");

                OutputStream out = new FileOutputStream(file);
                byte[] buffer = new byte[4096];
                for (int bytes = in.readInt(); bytes > 0; bytes = in.readInt()) {
                    if (buffer.length < bytes) {
                        buffer = new byte[bytes];
                    }
                    in.readFully(buffer, 0, bytes);
                    out.write(buffer, 0, bytes);
                }
                out.close();
            }
            // deserialized value is always temp
            temp = true;
        }


        private void readObject(ObjectInputStream in)
                throws IOException, ClassNotFoundException {
            in.defaultReadObject();
            boolean hasFile = in.readBoolean();
            if (hasFile) {
                file = File.createTempFile("binary-qvalue", "bin");

                OutputStream out = new FileOutputStream(file);
                byte[] buffer = new byte[4096];
                for (int bytes = in.readInt(); bytes > 0; bytes = in.readInt()) {
                    if (buffer.length < bytes) {
                        buffer = new byte[bytes];
                    }
                    in.readFully(buffer, 0, bytes);
                    out.write(buffer, 0, bytes);
                }
                out.close();
            }
            // deserialized value is always temp
            temp = true;
        }


    public void copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, Name destName) throws RepositoryException {
        if (srcWorkspaceName.equals(sessionInfo.getWorkspaceName())) {
            super.copy(sessionInfo, srcWorkspaceName, srcNodeId, destParentNodeId, destName);
            return;
        }
        PostMethod method = null;
        try {
            method = new PostMethod(getWorkspaceURI(sessionInfo));
            NamePathResolver resolver = getNamePathResolver(sessionInfo);

            StringBuilder args = new StringBuilder();
            args.append(srcWorkspaceName);
            args.append(",");
            args.append(resolver.getJCRPath(getPath(srcNodeId, sessionInfo, srcWorkspaceName)));
            args.append(",");
            String destParentPath = resolver.getJCRPath(getPath(destParentNodeId, sessionInfo));
            String destPath = (destParentPath.endsWith("/") ?
                    destParentPath + resolver.getJCRName(destName) :
                    destParentPath + "/" + resolver.getJCRName(destName));
            args.append(destPath);

            method.addParameter(PARAM_COPY, args.toString());
            addIfHeader(sessionInfo, method);
            getClient(sessionInfo).executeMethod(method);

            method.checkSuccess();
        } catch (IOException e) {
            throw new RepositoryException(e);
        } catch (DavException e) {
            throw ExceptionConverter.generate(e, method);
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    public void clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, Name destName, boolean removeExisting) throws RepositoryException {
        PostMethod method = null;
        try {
            method = new PostMethod(getWorkspaceURI(sessionInfo));

            NamePathResolver resolver = getNamePathResolver(sessionInfo);
            StringBuilder args = new StringBuilder();
            args.append(srcWorkspaceName);
            args.append(",");
            args.append(resolver.getJCRPath(getPath(srcNodeId, sessionInfo, srcWorkspaceName)));
            args.append(",");
            String destParentPath = resolver.getJCRPath(getPath(destParentNodeId, sessionInfo));
            String destPath = (destParentPath.endsWith("/") ?
                    destParentPath + resolver.getJCRName(destName) :
                    destParentPath + "/" + resolver.getJCRName(destName));
            args.append(destPath);
            args.append(",");
            args.append(Boolean.toString(removeExisting));

            method.addParameter(PARAM_CLONE, args.toString());
            addIfHeader(sessionInfo, method);
            getClient(sessionInfo).executeMethod(method);

            method.checkSuccess();
            if (removeExisting) {
                clearItemUriCache(sessionInfo);
            }
        } catch (IOException e) {
            throw new RepositoryException(e);
        } catch (DavException e) {
            throw ExceptionConverter.generate(e, method);
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    private void execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
        try {
            initMethod(method, sessionInfo, !isUnLockMethod(method));

            getClient(sessionInfo).executeMethod(method);
            method.checkSuccess();

        } catch (IOException e) {
            throw new RepositoryException(e);
        } catch (DavException e) {
            throw ExceptionConverter.generate(e, method);
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    private void unsubscribe(String uri, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
        UnSubscribeMethod method = null;
        try {
            method = new UnSubscribeMethod(uri, subscriptionId);
            initMethod(method, sessionInfo);
            getClient(sessionInfo).executeMethod(method);
            method.checkSuccess();
        } catch (IOException e) {
            throw new RepositoryException(e);
        } catch (DavException e) {
            throw ExceptionConverter.generate(e);
        }  finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    public void deleteWorkspace(SessionInfo sessionInfo, String name) throws AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchWorkspaceException, RepositoryException {
        DeleteMethod method = null;
     	try {
             method = new DeleteMethod(uriResolver.getWorkspaceUri(name));
             initMethod(method, sessionInfo, true);
             getClient(sessionInfo).executeMethod(method);
             method.checkSuccess();
         } catch (IOException e) {
             throw new RepositoryException(e);
         } catch (DavException e) {
             throw ExceptionConverter.generate(e);
         } finally {
             if (method != null) {
                 method.releaseConnection();
             }
         }
    }


    public void registerNodeTypes(SessionInfo sessionInfo, QNodeTypeDefinition[] nodeTypeDefinitions, boolean allowUpdate) throws InvalidNodeTypeDefinitionException, NodeTypeExistsException, UnsupportedRepositoryOperationException, RepositoryException {
        PropPatchMethod method = null;
     	try {
             DavPropertySet setProperties = new DavPropertySet();
             setProperties.add(createRegisterNodeTypesProperty(sessionInfo, nodeTypeDefinitions, allowUpdate));
             String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
             method = new PropPatchMethod(uri, setProperties, new DavPropertyNameSet());
             initMethod(method, sessionInfo, true);
             getClient(sessionInfo).executeMethod(method);
             method.checkSuccess();
         } catch (IOException e) {
             throw new RepositoryException(e);
         } catch (DavException e) {
             throw ExceptionConverter.generate(e);
         } finally {
             if (method != null) {
                 method.releaseConnection();
             }
         }
    }


    public void unregisterNodeTypes(SessionInfo sessionInfo, Name[] nodeTypeNames) throws UnsupportedRepositoryOperationException, NoSuchNodeTypeException, RepositoryException {
        PropPatchMethod method = null;
     	try {
             DavPropertySet setProperties = new DavPropertySet();
             setProperties.add(createUnRegisterNodeTypesProperty(sessionInfo, nodeTypeNames));
             String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
             method = new PropPatchMethod(uri, setProperties, new DavPropertyNameSet());
             initMethod(method, sessionInfo, true);
             getClient(sessionInfo).executeMethod(method);
             method.checkSuccess();
         } catch (IOException e) {
             throw new RepositoryException(e);
         } catch (DavException e) {
             throw ExceptionConverter.generate(e);
         } finally {
             if (method != null) {
                 method.releaseConnection();
             }
         }
    }


    private void internalSetNamespaces(SessionInfo sessionInfo, Map<String, String> namespaces) throws NamespaceException, UnsupportedRepositoryOperationException, AccessDeniedException, RepositoryException {
        DavPropertySet setProperties = new DavPropertySet();
        setProperties.add(createNamespaceProperty(namespaces));

        PropPatchMethod method = null;
        try {
            String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());

            method = new PropPatchMethod(uri, setProperties, new DavPropertyNameSet());
            initMethod(method, sessionInfo, true);

            getClient(sessionInfo).executeMethod(method);
            method.checkSuccess();
        } catch (IOException e) {
            throw new RepositoryException(e);
        } catch (DavException e) {
            throw ExceptionConverter.generate(e);
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }


    public void createWorkspace(SessionInfo sessionInfo, String name, String srcWorkspaceName) throws AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchWorkspaceException, RepositoryException {
        if (srcWorkspaceName != null) {
            throw new UnsupportedOperationException("JCR-2003. Implementation missing");
        }

        MkWorkspaceMethod method = null;
     	try {
             method = new MkWorkspaceMethod(uriResolver.getWorkspaceUri(name));
             initMethod(method, sessionInfo, true);
             getClient(sessionInfo).executeMethod(method);
             method.checkSuccess();
         } catch (IOException e) {
             throw new RepositoryException(e);
         } catch (DavException e) {
             throw ExceptionConverter.generate(e);
         } finally {
             if (method != null) {
                 method.releaseConnection();
             }
         }
    }


    public void addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, Name label, boolean moveLabel) throws VersionException, RepositoryException {
        try {
            String uri = getItemUri(versionId, sessionInfo);
            String strLabel = getNamePathResolver(sessionInfo).getJCRName(label);
            LabelMethod method = new LabelMethod(uri, strLabel, (moveLabel) ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD);
            execute(method, sessionInfo);
        } catch (IOException e) {
            throw new RepositoryException(e);
        }
    }


    public void removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, Name label) throws VersionException, RepositoryException {
        try {
            String uri = getItemUri(versionId, sessionInfo);
            String strLabel = getNamePathResolver(sessionInfo).getJCRName(label);
            LabelMethod method = new LabelMethod(uri, strLabel, LabelInfo.TYPE_REMOVE);
            execute(method, sessionInfo);
        } catch (IOException e) {
            throw new RepositoryException(e);
        }
    }


    private static String obtainAbsolutePathFromUri(String uri) {
        try {
            java.net.URI u = new java.net.URI(uri);
            StringBuilder sb = new StringBuilder();
            sb.append(u.getRawPath());
            if (u.getRawQuery() != null) {
                sb.append("?").append(u.getRawQuery());
            }
            return sb.toString();
        }
        catch (java.net.URISyntaxException ex) {
            log.warn("parsing " + uri, ex);
            return uri;
        }
    }


    private static String obtainAbsolutePathFromUri(String uri) {
        try {
            java.net.URI u = new java.net.URI(uri);
            StringBuilder sb = new StringBuilder();
            sb.append(u.getRawPath());
            if (u.getRawQuery() != null) {
                sb.append("?").append(u.getRawQuery());
            }
            return sb.toString();
        }
        catch (java.net.URISyntaxException ex) {
            log.warn("parsing " + uri, ex);
            return uri;
        }
    }


    private static String obtainAbsolutePathFromUri(String uri) {
        try {
            java.net.URI u = new java.net.URI(uri);
            StringBuilder sb = new StringBuilder();
            sb.append(u.getRawPath());
            if (u.getRawQuery() != null) {
                sb.append("?").append(u.getRawQuery());
            }
            return sb.toString();
        }
        catch (java.net.URISyntaxException ex) {
            log.warn("parsing " + uri, ex);
            return uri;
        }
    }


    public NodeId getNodeId(String selectorName) {
        if (selectorName == null && scores.size() == 1) {
            return nodeIds.values().iterator().next();
        }

        NodeId id = nodeIds.get(selectorName);
        if (id == null && !nodeIds.containsKey(selectorName)) {
            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
        }
        return id;
    }


    public double getScore(String selectorName) {
        if (selectorName == null && scores.size() == 1) {
            return scores.values().iterator().next();
        }

        Double score = scores.get(selectorName);
        if (score == null && !nodeIds.containsKey(selectorName)) {
            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
        }
        return score;
    }


    public void testCurrent() {
        Path.Element currElem = factory.getCurrentElement();
        Name currName = currElem.getName();

        assertEquals(currElem, factory.createElement(currName));

        Path current = factory.create(new Path.Element[] {currElem});
        assertEquals(current, factory.create(currName));
        assertFalse(current.isAbsolute());
        assertTrue(current.isNormalized());

        try {
            factory.createElement(currName, 1);
            fail("Cannot create current element with an index.");
        } catch (IllegalArgumentException e) {
            // ok
        }
        try {
            factory.create(currName, 1);
            fail("Cannot create current path with an index.");
        } catch (IllegalArgumentException e) {
            // ok
        }
    }


    public void testParent() {
        Path.Element parentElem = factory.getParentElement();
        Name parentName = parentElem.getName();

        assertEquals(parentElem, factory.createElement(parentName));

        Path parent = factory.create(new Path.Element[] {parentElem});
        assertEquals(parent, factory.create(parentName));
        assertFalse(parent.isAbsolute());
        assertTrue(parent.isNormalized());

        try {
            factory.createElement(parentName, 1);
            fail("Cannot create parent element with an index.");
        } catch (IllegalArgumentException e) {
            // ok
        }
        try {
            factory.create(parentName, 1);
            fail("Cannot create parent path with an index.");
        } catch (IllegalArgumentException e) {
            // ok
        }
    }


    public void testAllPattern() {
        Pattern pattern = Pattern.all();
        MatchResult result = pattern.match(PATH1);
        assertTrue(errMsg(pattern, PATH1), result.isMatch());
        assertTrue(errMsg(pattern, PATH1), result.isFullMatch());
        assertTrue(errMsg(pattern, PATH1), Matcher.matches(pattern, PATH1));
        assertEquals(errMsg(pattern, PATH1), PATH1, result.getMatch());
        assertEquals(errMsg(pattern, PATH1), null, result.getRemainder());
        assertEquals(errMsg(pattern, PATH1), null, Matcher.match(pattern, PATH1));
    }


    public void testComplexPattern() {
        Pattern pattern = Pattern.sequence(
                Pattern.selection(
                        Pattern.path(PATH2),
                        Pattern.name("", "")),
                Pattern.selection(
                        Pattern.repeat(Pattern.repeat(Pattern.repeat(
                                Pattern.name(NAME_FACTORY.create("{}www"))))),
                        Pattern.sequence(
                                Pattern.path(PATH_FACTORY.create("{}www\t{}day")),
                                Pattern.all())));

        MatchResult result = pattern.match(PATH1);
        assertTrue(errMsg(pattern, PATH1), result.isMatch());
        assertTrue(errMsg(pattern, PATH1), result.isFullMatch());
        assertTrue(errMsg(pattern, PATH1), Matcher.matches(pattern, PATH1));
        assertEquals(errMsg(pattern, PATH1), PATH1, result.getMatch());
        assertEquals(errMsg(pattern, PATH1), null, result.getRemainder());
        assertEquals(errMsg(pattern, PATH1), null, Matcher.match(pattern, PATH1));
    }


    public void testNothingPattern() {
        Pattern pattern = Pattern.nothing();
        MatchResult result = pattern.match(PATH1);
        assertFalse(errMsg(pattern, PATH1), result.isMatch());
        assertFalse(errMsg(pattern, PATH1), result.isFullMatch());
        assertFalse(errMsg(pattern, PATH1), Matcher.matches(pattern, PATH1));
        assertEquals(errMsg(pattern, PATH1), null, result.getMatch());
        assertEquals(errMsg(pattern, PATH1), PATH1, result.getRemainder());
        assertEquals(errMsg(pattern, PATH1), PATH1, Matcher.match(pattern, PATH1));
    }


    public void testOptionalPattern() {
        Pattern pattern = Pattern.selection(
                Pattern.nothing(),
                Pattern.path(PATH1));

        MatchResult result = pattern.match(PATH1);
        assertTrue(errMsg(pattern, PATH1), result.isMatch());
        assertTrue(errMsg(pattern, PATH1), result.isFullMatch());
        assertTrue(errMsg(pattern, PATH1), Matcher.matches(pattern, PATH1));
        assertEquals(errMsg(pattern, PATH1), PATH1, result.getMatch());
        assertEquals(errMsg(pattern, PATH1), null, result.getRemainder());
        assertEquals(errMsg(pattern, PATH1), null, Matcher.match(pattern, PATH1));
    }


    public void testSelectPattern() {
        Pattern pattern = Pattern.selection(
                Pattern.path(PATH2),
                Pattern.path(PATH1));

        MatchResult result = pattern.match(PATH1);
        assertTrue(errMsg(pattern, PATH1), result.isMatch());
        assertTrue(errMsg(pattern, PATH1), result.isFullMatch());
        assertTrue(errMsg(pattern, PATH1), Matcher.matches(pattern, PATH1));
        assertEquals(errMsg(pattern, PATH1), PATH1, result.getMatch());
        assertEquals(errMsg(pattern, PATH1), null, result.getRemainder());
        assertEquals(errMsg(pattern, PATH1), null, Matcher.match(pattern, PATH1));
    }


    public void testBuilder() throws Exception {
        for (int i=0; i<tests.length; i++) {
            JcrPath t = tests[i];
            if (t.isValid()) {
                if (t.normalizedPath==null) {
                    // check just creation
                    Path p = build(t.path, false);
                    assertEquals("\"" + t.path + "\".create(false)", t.path,  pathResolver.getJCRPath(p));
                    assertEquals("\"" + t.path + "\".isNormalized()", t.isNormalized(), p.isNormalized());
                    assertEquals("\"" + t.path + "\".isAbsolute()", t.isAbsolute(), p.isAbsolute());
                } else {
                    // check with normalization
                    Path p = build(t.path, true);
                    assertEquals("\"" + t.path + "\".create(true)", t.normalizedPath, pathResolver.getJCRPath(p));
                    assertEquals("\"" + t.path + "\".isAbsolute()", t.isAbsolute(), p.isAbsolute());
                }
            }
        }
    }


    public void testBuilderReverse() throws Exception {
        for (int i=0; i<tests.length; i++) {
            JcrPath t = tests[i];
            if (t.isValid()) {
                if (t.normalizedPath==null) {
                    // check just creation
                    Path p = buildReverse(t.path, false);
                    assertEquals("\"" + t.path + "\".create(false)", t.path,  pathResolver.getJCRPath(p));
                    assertEquals("\"" + t.path + "\".isNormalized()", t.isNormalized(), p.isNormalized());
                    assertEquals("\"" + t.path + "\".isAbsolute()", t.isAbsolute(), p.isAbsolute());
                } else {
                    // check with normalization
                    Path p = buildReverse(t.path, true);
                    assertEquals("\"" + t.path + "\".create(true)", t.normalizedPath, pathResolver.getJCRPath(p));
                    assertEquals("\"" + t.path + "\".isAbsolute()", t.isAbsolute(), p.isAbsolute());
                }
            }
        }
    }


    private Path build(String path, boolean normalize)
            throws Exception {
        PathBuilder builder = new PathBuilder();
        String[] elems = explode(path, '/', false);
        if (path.startsWith("/")) {
            builder.addRoot();
        }
        for (int i=0; i<elems.length; i++) {
            int pos = elems[i].indexOf('[');
            String elem;
            Name name;
            int index;
            if (pos<0) {
                elem = elems[i];
                index = -1;
            } else {
                index = Integer.parseInt(elems[i].substring(pos+1, elems[i].length()-1));
                elem = elems[i].substring(0, pos);
            }
            if (".".equals(elem)) {
                builder.addLast(factory.getCurrentElement());
            } else if ("..".equals(elems[i])) {
                builder.addLast(factory.getParentElement());
            } else {
                name = NameParser.parse(elem, nsResolver, NameFactoryImpl.getInstance());
                if (index < 0) {
                    builder.addLast(name);
                } else {
                    builder.addLast(name, index);
                }
            }
        }
        return normalize ? builder.getPath().getNormalizedPath() : builder.getPath();
    }


    private Path buildReverse(String path, boolean normalize)
            throws Exception {
        PathBuilder builder = new PathBuilder();
        String[] elems = explode(path, '/', false);
        for (int i=elems.length-1; i>=0; i--) {
            int pos = elems[i].indexOf('[');
            String elem;
            Name name;
            int index;
            if (pos<0) {
                elem = elems[i];
                index = -1;
            } else {
                index = Integer.parseInt(elems[i].substring(pos+1, elems[i].length()-1));
                elem = elems[i].substring(0, pos);
            }
            if (".".equals(elem)) {
                builder.addFirst(factory.getCurrentElement());
            } else if ("..".equals(elems[i])) {
                builder.addFirst(factory.getParentElement());
            } else {
                name = NameParser.parse(elem, nsResolver, NameFactoryImpl.getInstance());
                if (index < 0) {
                    builder.addFirst(name);
                } else {
                    builder.addFirst(name, index);
                }
            }
        }
        if (path.startsWith("/")) {
            builder.addRoot();
        }
        return normalize ? builder.getPath().getNormalizedPath() : builder.getPath();
    }


    public void testGetAncestorAtDegreeDepth() throws RepositoryException {
        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path);

                int degree = p.getDepth();
                if (degree > 0) {
                    assertTrue(p.getAncestor(degree).denotesRoot());
                }
            }
        }
    }


    public void testCanonicalPaths() throws Exception {
        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path);
                if (!test.isNormalized()) {
                    p = p.getNormalizedPath();
                }
                assertTrue("Path must be canonical " + test.path, p.isCanonical());
            }
        }
    }


    public void testAbsolutePathIsDescendantOfRoot() throws RepositoryException {
        Path root = factory.getRootPath();
        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path).getNormalizedPath();
                if (!p.equals(root)) {
                    assertTrue(test.path + " must be decendant of the root path.", p.isDescendantOf(root));
                }
            }
        }
    }


    public void testRootIsAncestorOfAbsolutePath() throws RepositoryException {
        Path root = factory.getRootPath();
        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path).getNormalizedPath();
                if (!p.equals(root)) {
                    assertFalse(p.isAncestorOf(root));
                }
            }
        }
    }


    public void testIsDescendantOfThrowsIllegalArgumentException() throws RepositoryException {
        Path abs = factory.create(factory.getRootPath(), NameConstants.JCR_DATA, true);
        Path rel = factory.create(NameConstants.JCR_DATA);

        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path).getNormalizedPath();
                try {
                    if (p.isAbsolute()) {
                        p.isDescendantOf(rel);
                    } else {
                        p.isDescendantOf(abs);
                    }
                    fail("Path.isDescendantOf(Path) must throw IllegalArgumentException if Path.isAbsolute is not the same for both.");
                } catch (IllegalArgumentException e) {
                    // ok.
                }
            }
        }
    }


    public void testIsAncestorOfThrowsIllegalArgumentException() throws RepositoryException {
        Path abs = factory.create(factory.getRootPath(), NameConstants.JCR_DATA, true);
        Path rel = factory.create(NameConstants.JCR_DATA);

        JcrPath[] tests = JcrPath.getTests();
        for (JcrPath test : tests) {
            if (test.isValid() && test.isAbsolute()) {
                Path p = resolver.getQPath(test.path).getNormalizedPath();
                try {
                    if (p.isAbsolute()) {
                        p.isAncestorOf(rel);
                    } else {
                        p.isAncestorOf(abs);
                    }
                    fail("Path.isAncestorOf(Path) must throw IllegalArgumentException if Path.isAbsolute is not the same for both.");
                } catch (IllegalArgumentException e) {
                    // ok.
                }
            }
        }
    }


    public void testCurrentElement() {
        Element element = CurrentPath.CURRENT_PATH;
        assertTrue(element.denotesCurrent());
        assertFalse(element.denotesIdentifier());
        assertFalse(element.denotesName());
        assertFalse(element.denotesParent());
        assertFalse(element.denotesRoot());
        assertEquals(createName("."), element.getName());
        assertEquals(Path.INDEX_UNDEFINED, element.getIndex());
        assertEquals(Path.INDEX_DEFAULT, element.getNormalizedIndex());
        assertEquals(".", element.getString());
    }


    public void testParentElement() {
        Element element = ParentPath.PARENT_PATH;
        assertFalse(element.denotesCurrent());
        assertFalse(element.denotesIdentifier());
        assertFalse(element.denotesName());
        assertTrue(element.denotesParent());
        assertFalse(element.denotesRoot());
        assertEquals(createName(".."), element.getName());
        assertEquals(Path.INDEX_UNDEFINED, element.getIndex());
        assertEquals(Path.INDEX_DEFAULT, element.getNormalizedIndex());
        assertEquals("..", element.getString());
    }


    public void testIdentifierElement() {
        Element element = new IdentifierPath("test");
        assertFalse(element.denotesCurrent());
        assertTrue(element.denotesIdentifier());
        assertFalse(element.denotesName());
        assertFalse(element.denotesParent());
        assertFalse(element.denotesRoot());
        assertNull(element.getName());
        assertEquals(Path.INDEX_UNDEFINED, element.getIndex());
        assertEquals(Path.INDEX_DEFAULT, element.getNormalizedIndex());
        assertEquals("[test]", element.getString());
    }


    public void testNameElement() {
        Element element =
            new NamePath(null, createName("test"), Path.INDEX_UNDEFINED);
        assertFalse(element.denotesCurrent());
        assertFalse(element.denotesIdentifier());
        assertTrue(element.denotesName());
        assertFalse(element.denotesParent());
        assertFalse(element.denotesRoot());
        assertEquals(createName("test"), element.getName());
        assertEquals(Path.INDEX_UNDEFINED, element.getIndex());
        assertEquals(Path.INDEX_DEFAULT, element.getNormalizedIndex());
        assertEquals("{}test", element.getString());
    }


    public void testRootElement() {
        Element element = RootPath.ROOT_PATH;
        assertFalse(element.denotesCurrent());
        assertFalse(element.denotesIdentifier());
        assertFalse(element.denotesName());
        assertFalse(element.denotesParent());
        assertTrue(element.denotesRoot());
        assertEquals(createName(""), element.getName());
        assertEquals(Path.INDEX_UNDEFINED, element.getIndex());
        assertEquals(Path.INDEX_DEFAULT, element.getNormalizedIndex());
        assertEquals("{}", element.getString());
    }


    public void testNullDateValue() throws IOException, RepositoryException {
        try {
            factory.create((Calendar) null);
            fail();
        } catch (IllegalArgumentException e) {
            // ok
        }
        try {
            factory.create(null, PropertyType.DATE);
            fail();
        } catch (IllegalArgumentException e) {
            // ok
        }
    }


    public void testNullDateValue() throws IOException, RepositoryException {
        try {
            factory.create((Calendar) null);
            fail();
        } catch (IllegalArgumentException e) {
          // ok
        } catch (NullPointerException e) {
          // ok
        }
        try {
            factory.create(null, PropertyType.DATE);
            fail();
        } catch (IllegalArgumentException e) {
          // ok
        } catch (NullPointerException e) {
          // ok
        }
    }


    public void testNullDateValue() throws IOException, RepositoryException {
        try {
            factory.create((Calendar) null);
            fail();
        } catch (RuntimeException e) {
            // ok
        }
        try {
            factory.create(null, PropertyType.DATE);
            fail();
        } catch (RuntimeException e) {
            // ok
        }
    }


    public void testReadVersionInfo() throws RepositoryException, NotExecutableException {
        Node n = createVersionableNode(testRootNode);
        modifyPrivileges(VERSION_STORAGE_PATH, Privilege.JCR_READ, false);

        Node n2 = (Node) getTestSession().getItem(n.getPath());
        try {
            n2.getVersionHistory();
            fail();
        } catch (AccessDeniedException e) {
            // success
        } catch (ItemNotFoundException e) {
            // success as well
        }
        try {
            n2.getBaseVersion();
            fail();
        } catch (AccessDeniedException e) {
            // success
        } catch (ItemNotFoundException e) {
            // success as well
        }
    }


    public void testNullBinaryValue() throws IOException, RepositoryException {
        try {
            factory.create((byte[]) null);
            fail();
        } catch (IllegalArgumentException e) {
            // ok
        }
        try {
            factory.create((InputStream) null);
            fail();
        } catch (IllegalArgumentException e) {
            // ok
        }
        try {
            factory.create((File) null);
            fail();
        } catch (IllegalArgumentException e) {
            // ok
        }
    }


    public void testNullBinaryValue() throws IOException, RepositoryException {
        try {
            factory.create((byte[]) null);
            fail();
        } catch (RuntimeException e) {
            // ok
        }
        try {
            factory.create((InputStream) null);
            fail();
        } catch (RuntimeException e) {
            // ok
        }
        try {
            factory.create((File) null);
            fail();
        } catch (RuntimeException e) {
            // ok
        }
    }


    public void testNullBinaryValue() throws IOException, RepositoryException {
        try {
            factory.create((byte[]) null);
            fail();
        } catch (IllegalArgumentException e) {
          // ok
        } catch (NullPointerException e) {
          // ok
        }
        try {
            factory.create((InputStream) null);
            fail();
        } catch (IllegalArgumentException e) {
          // ok
        } catch (NullPointerException e) {
          // ok
        }
        try {
            factory.create((File) null);
            fail();
        } catch (IllegalArgumentException e) {
          // ok
        } catch (NullPointerException e) {
          // ok
        }
    }


    public void testBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[] {'a', 'b', 'c'});

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(3, v.getLength());

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    public void testBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[] {'a', 'b', 'c'});

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertValueLength(v, 3);

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    public void testBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[] {'a', 'b', 'c'});

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(3, v.getLength());

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[0]);

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(0, v.getLength());

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[0]);

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertValueLength(v, 0);

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromInputStream() throws RepositoryException, IOException {
        InputStream in = new ByteArrayInputStream(new byte[0]);

        QValue v = factory.create(in);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(0, v.getLength());

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(0, v.getLength());

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(0, v.getLength());

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testEmptyBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertValueLength(v, 0);

        assertEquals("", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("", new String(out.toByteArray()));
    }


    public void testBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();
        FileWriter fw = new FileWriter(f);
        fw.write("abc");
        fw.close();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(3, v.getLength());

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    public void testBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();
        FileWriter fw = new FileWriter(f);
        fw.write("abc");
        fw.close();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertValueLength(v, 3);

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    public void testBinaryFromFile() throws RepositoryException, IOException {
        File f = File.createTempFile("QValueFactoryImplTest", ".txt");
        f.deleteOnExit();
        FileWriter fw = new FileWriter(f);
        fw.write("abc");
        fw.close();

        QValue v = factory.create(f);

        assertEquals(PropertyType.BINARY, v.getType());
        assertEquals(3, v.getLength());

        assertEquals("abc", v.getString());

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        spool(out, v.getStream());
        assertEquals("abc", new String(out.toByteArray()));
    }


    private static void spool(OutputStream out, InputStream in) throws RepositoryException, IOException {
        try {
            byte[] buffer = new byte[0x2000];
            int read;
            while ((read = in.read(buffer)) > 0) {
                out.write(buffer, 0, read);
            }
        } finally {
            try {
                in.close();
            } catch (IOException ignore) {
            }
        }
    }


    private static void spool(OutputStream out, InputStream in) throws RepositoryException, IOException {
        try {
            byte[] buffer = new byte[0x2000];
            int read;
            while ((read = in.read(buffer)) > 0) {
                out.write(buffer, 0, read);
            }
        } finally {
            try {
                in.close();
            } catch (IOException ignore) {
            }
        }
    }


    private static void spool(OutputStream out, InputStream in) throws RepositoryException, IOException {
        try {
            byte[] buffer = new byte[0x2000];
            int read;
            while ((read = in.read(buffer)) > 0) {
                out.write(buffer, 0, read);
            }
        } finally {
            try {
                in.close();
            } catch (IOException ignore) {
            }
        }
    }


    public void testReadInputStream() throws Exception {
        InputStream in = getClass().getResourceAsStream("readtest.xml");

        PrivilegeDefinitionReader reader = new PrivilegeDefinitionReader(in, CONTENT_TYPE);

        Map<Name, PrivilegeDefinition> defs = new HashMap<Name, PrivilegeDefinition>();
        for (PrivilegeDefinition def: reader.getPrivilegeDefinitions()) {
            defs.put(def.getName(), def);
        }
        for (PrivilegeDefinition def: DEF_EXPECTED) {
            PrivilegeDefinition e = defs.remove(def.getName());
            assertNotNull("Definition " + def.getName() + " missing");
            assertEquals("Definition mismatch.", def,  e);
        }
        assertTrue("Not all definitions present", defs.isEmpty());

        // check for namespace
        String fooUri = reader.getNamespaces().get(TEST_PREFIX);
        assertEquals("Namespace included", TEST_URI, fooUri);
    }


    public void testReadReader() throws Exception {
        InputStream in = getClass().getResourceAsStream("readtest.xml");

        PrivilegeDefinitionReader reader = new PrivilegeDefinitionReader(new InputStreamReader(in), CONTENT_TYPE);

        Map<Name, PrivilegeDefinition> defs = new HashMap<Name, PrivilegeDefinition>();
        for (PrivilegeDefinition def: reader.getPrivilegeDefinitions()) {
            defs.put(def.getName(), def);
        }
        for (PrivilegeDefinition def: DEF_EXPECTED) {
            PrivilegeDefinition e = defs.remove(def.getName());
            assertNotNull("Definition " + def.getName() + " missing");
            assertEquals("Definition mismatch.", def,  e);
        }
        assertTrue("Not all definitions present", defs.isEmpty());

        // check for namespace
        String fooUri = reader.getNamespaces().get(TEST_PREFIX);
        assertEquals("Namespace included", TEST_URI, fooUri);
    }


    public void testWriteOutputStream() throws Exception {

        PrivilegeDefinitionWriter writer = new PrivilegeDefinitionWriter(CONTENT_TYPE);
        Map<String, String> namespaces = new HashMap<String, String>();
        namespaces.put(TEST_PREFIX, TEST_URI);
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        writer.writeDefinitions(out, DEF_EXPECTED, namespaces);

        String result = out.toString("utf-8").trim();

        PrivilegeDefinitionReader pdr = new PrivilegeDefinitionReader(new StringReader(result), CONTENT_TYPE);
        PrivilegeDefinition[] definitions = pdr.getPrivilegeDefinitions();
        assertTrue("Write", Arrays.equals(DEF_EXPECTED, definitions));
    }


    public void testWriteWriter() throws Exception {

        PrivilegeDefinitionWriter writer = new PrivilegeDefinitionWriter(CONTENT_TYPE);
        Map<String, String> namespaces = new HashMap<String, String>();
        namespaces.put(TEST_PREFIX, TEST_URI);
        Writer w = new StringWriter();
        writer.writeDefinitions(w, DEF_EXPECTED, namespaces);

        String result = w.toString();

        PrivilegeDefinitionReader pdr = new PrivilegeDefinitionReader(new StringReader(result), CONTENT_TYPE);
        PrivilegeDefinition[] definitions = pdr.getPrivilegeDefinitions();
        assertTrue("Write", Arrays.equals(DEF_EXPECTED, definitions));
    }


    public void testCheckFormat() throws Exception {
        for (JcrName t : tests) {
            long t1 = System.currentTimeMillis();
            for (int j = 0; j < NUM_TESTS; j++) {
                // check just creation
                boolean isValid = true;
                try {
                    NameParser.checkFormat(t.jcrName);
                } catch (IllegalNameException e) {
                    isValid = false;
                }
                assertEquals("\"" + t.jcrName + "\".checkFormat()", t.isValid(), isValid);
            }
            long t2 = System.currentTimeMillis();
            if (NUM_TESTS > 1) {
                System.out.println("testCheckFormat():\t" + t + "\t" + (t2 - t1) + "\tms");
            }
        }
    }


    public void testCheckFormat() throws Exception {
        for (JcrPath t : tests) {
            long t1 = System.currentTimeMillis();
            for (int j = 0; j < NUM_TESTS; j++) {
                if (t.normalizedPath == null) {
                    // check just creation
                    boolean isValid = true;
                    try {
                        PathParser.checkFormat(t.path);
                    } catch (MalformedPathException e) {
                        isValid = false;
                    }
                    assertEquals("\"" + t.path + "\".checkFormat()", t.isValid(), isValid);
                }
            }
            long t2 = System.currentTimeMillis();
            if (NUM_TESTS > 1) {
                System.out.println("testCheckFormat():\t" + t + "\t" + (t2 - t1) + "\tms");
            }
        }
    }


    public void testExpandedJcrNames() throws NamespaceException, IllegalNameException {
        NamespaceResolver resolver = new TestNamespaceResolver();

        List<String[]> valid = new ArrayList<String[]>();
        // valid qualified jcr-names:
        // String-array consisting of { jcrName , uri , localName }
        valid.add(new String[] {"abc:{c}", "abc", "{c}"});
        valid.add(new String[] {"abc:}c", "abc", "}c"});
        valid.add(new String[] {"abc:c}", "abc", "c}"});
        valid.add(new String[] {"{ab", "", "{ab"});
        valid.add(new String[] {"ab}", "", "ab}"});
        valid.add(new String[] {"a}bc", "", "a}bc"});
        valid.add(new String[] {"{", "", "{"});
        valid.add(new String[] {"}", "", "}"});
        valid.add(new String[] {"abc", "", "abc"});
        valid.add(new String[] {"abc{abc}", "", "abc{abc}"});
        valid.add(new String[] {"{{abc}", "", "{{abc}"});
        valid.add(new String[] {"{abc{abc}", "", "{abc{abc}"});
        valid.add(new String[] {"abc {", "", "abc {"});
        valid.add(new String[] {"abc { }", "", "abc { }"});
        valid.add(new String[] {"{ ab }", "", "{ ab }"});
        valid.add(new String[] {"{ }abc", "", "{ }abc"});
        // unknown uri -> but valid non-prefixed jcr-name
        valid.add(new String[] {"{test}abc", "", "{test}abc"});
        valid.add(new String[] {"{ab}", "", "{ab}"});
        valid.add(new String[] {".{.}", "", ".{.}"});

        // valid expanded jcr-names:
        // String-array consisting of { jcrName , uri , localName }
        valid.add(new String[] {"{http://jackrabbit.apache.org}abc", "http://jackrabbit.apache.org", "abc"});
        valid.add(new String[] {"{http://jackrabbit.apache.org:80}abc", "http://jackrabbit.apache.org:80", "abc"});
        valid.add(new String[] {"{http://jackrabbit.apache.org/info}abc", "http://jackrabbit.apache.org/info", "abc"});
        valid.add(new String[] {"{jcr:jackrabbit}abc", "jcr:jackrabbit", "abc"});
        valid.add(new String[] {"{abc:}def", "abc:", "def"});
        valid.add(new String[] {"{}abc", "", "abc"});

        for (Object aValid : valid) {
            String[] strs = (String[]) aValid;
            try {
                Name n = NameParser.parse(strs[0], resolver, factory);
                assertEquals("URI mismatch", strs[1], n.getNamespaceURI());
                assertEquals("Local name mismatch", strs[2], n.getLocalName());
            } catch (Exception e) {
                fail(e.getMessage() + " -> " + strs[0]);
            }
        }

        // invalid jcr-names (neither expanded nor qualified form)
        List<String> invalid = new ArrayList<String>();
        // invalid prefix
        invalid.add("{a:b");
        invalid.add("}a:b");
        invalid.add("a{b:c");
        invalid.add("a}b:c");
        // unknown uri -> but invalid local name with ':' and or '/'
        invalid.add("{http//test.apache.org}abc");
        invalid.add("{test/test/test}abc");
        // invalid local name containing '/'
        invalid.add("{http://jackrabbit.apache.org}abc/dfg");
        // invalid local name containing ':'
        invalid.add("{http://jackrabbit.apache.org}abc:dfg");
        // invalid local name containing ':' and '/'
        invalid.add("{{http://jackrabbit.apache.org}abc:dfg}");
        // invalid local name containing '/'
        invalid.add("/a/b/c");
        // known uri but local name missing -> must fail.
        invalid.add("{http://jackrabbit.apache.org}");
        invalid.add("{}");

        for (Object anInvalid : invalid) {
            String jcrName = (String) anInvalid;
            try {
                NameParser.parse(jcrName, resolver, factory);
                fail("Parsing '" + jcrName + "' should fail. Not a valid jcr name.");
            } catch (IllegalNameException e) {
                //ok
            }
        }
    }


    public void testCheckFormatOfExpandedNames() throws NamespaceException, IllegalNameException {
        List<String[]> valid = new ArrayList<String[]>();
        // valid qualified jcr-names:
        // String-array consisting of { jcrName , uri , localName }
        valid.add(new String[] {"abc:{c}", "abc", "{c}"});
        valid.add(new String[] {"abc:}c", "abc", "}c"});
        valid.add(new String[] {"abc:c}", "abc", "c}"});
        valid.add(new String[] {"{ab", "", "{ab"});
        valid.add(new String[] {"ab}", "", "ab}"});
        valid.add(new String[] {"a}bc", "", "a}bc"});
        valid.add(new String[] {"{", "", "{"});
        valid.add(new String[] {"}", "", "}"});
        valid.add(new String[] {"abc", "", "abc"});
        valid.add(new String[] {"abc{abc}", "", "abc{abc}"});
        valid.add(new String[] {"{{abc}", "", "{{abc}"});
        valid.add(new String[] {"{abc{abc}", "", "{abc{abc}"});
        valid.add(new String[] {"abc {", "", "abc {"});
        valid.add(new String[] {"abc { }", "", "abc { }"});
        valid.add(new String[] {"{ }abc", "", "{ }abc"});
        // unknown uri -> but valid non-prefixed jcr-name
        valid.add(new String[] {"{test}abc", "", "{test}abc"});

        // valid expanded jcr-names:
        // String-array consisting of { jcrName , uri , localName }
        valid.add(new String[] {"{http://jackrabbit.apache.org}abc", "http://jackrabbit.apache.org", "abc"});
        valid.add(new String[] {"{http://jackrabbit.apache.org:80}abc", "http://jackrabbit.apache.org:80", "abc"});
        valid.add(new String[] {"{http://jackrabbit.apache.org/info}abc", "http://jackrabbit.apache.org/info", "abc"});
        valid.add(new String[] {"{jcr:jackrabbit}abc", "jcr:jackrabbit", "abc"});
        valid.add(new String[] {"{abc}def", "abc", "def"});
        valid.add(new String[] {"{}abc", "", "abc"});

        for (Object aValid : valid) {
            String[] strs = (String[]) aValid;
            try {
                NameParser.checkFormat(strs[0]);
            } catch (Exception e) {
                fail(e.getMessage() + " -> " + strs[0]);
            }
        }

        // invalid jcr-names (neither expanded nor qualified form)
        List<String> invalid = new ArrayList<String>();
        // invalid prefix
        invalid.add("{a:b");
        invalid.add("}a:b");
        invalid.add("a{b:c");
        invalid.add("a}b:c");
        // invalid local name containing '/'
        invalid.add("{http://jackrabbit.apache.org}abc/dfg");
        // invalid local name containing ':'
        invalid.add("{http://jackrabbit.apache.org}abc:dfg");
        // invalid local name containing ':' and '/'
        invalid.add("{{http://jackrabbit.apache.org}abc:dfg}");
        // invalid local name containing '/'
        invalid.add("/a/b/c");
        // known uri but local name missing -> must fail.
        invalid.add("{http://jackrabbit.apache.org}");
        invalid.add("{}");
        // invalid URI part
        invalid.add("{/jackrabbit/a/b/c}abc");


        for (Object anInvalid : invalid) {
            String jcrName = (String) anInvalid;
            try {
                NameParser.checkFormat(jcrName);
                fail("Checking format of '" + jcrName + "' should fail. Not a valid jcr name.");
            } catch (IllegalNameException e) {
                //ok
            }
        }
    }


    public void testInvalidPropertyType() {
        try {
            tmpl.setRequiredType(-1);
            fail("-1 isn't a valid property type.");
        } catch (IllegalArgumentException e) {
            // success
        }
        try {
            tmpl.setRequiredType(Integer.MAX_VALUE);
            fail(Integer.MAX_VALUE + " isn't a valid property type.");
        } catch (IllegalArgumentException e) {
            // success
        }
    }


    public void testInvalidOPVFlag() {
        try {
            tmpl.setOnParentVersion(-1);
            fail("-1 isn't a valid OPV flag.");
        } catch (IllegalArgumentException e) {
            // success
        }
        try {
            tmpl.setOnParentVersion(Integer.MAX_VALUE);
            fail(Integer.MAX_VALUE + " isn't a valid OPV flag.");
        } catch (IllegalArgumentException e) {
            // success
        }
    }


    public void testInvalidOPVFlag() {
        try {
            tmpl.setOnParentVersion(-1);
            fail("-1 isn't a valid OPV flag.");
        } catch (IllegalArgumentException e) {
            // success
        }
        try {
            tmpl.setOnParentVersion(Integer.MAX_VALUE);
            fail(Integer.MAX_VALUE + " isn't a valid OPV flag.");
        } catch (IllegalArgumentException e) {
            // success
        }
    }


    public void testGetDefinition() throws RepositoryException {
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            String jcrConstraint = vc.getDefinition(resolver);
            assertNotNull(jcrConstraint);
            assertEquals(qDefs[i], jcrConstraint);
        }
    }


    public void testGetDefinition() throws RepositoryException {
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            String jcrConstraint = vc.getDefinition(resolver);

            assertFalse(qDefs[i].equals(jcrConstraint));
            assertEquals(resolver.getJCRName(ValueConstraint.NAME_FACTORY.create(qDefs[i])), jcrConstraint);
        }
    }


    public void testGetDefinition() throws RepositoryException {
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            String jcrConstraint = vc.getDefinition(resolver);

            assertFalse(qDefs[i].equals(jcrConstraint));
            assertTrue(getDefinitions()[i].equals(jcrConstraint));
        }
    }


    public void testGetDefinition() throws RepositoryException {
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            String jcrConstraint = vc.getDefinition(resolver);

            assertFalse(qDefs[i].equals(jcrConstraint));
            assertEquals(resolver.getJCRName(ValueConstraint.NAME_FACTORY.create(qDefs[i])), jcrConstraint);
        }
    }


    public void testCheckNullValue() throws RepositoryException {
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            try {
                vc.check(null);
                fail("ValueConstraint.check(null) should throw ConstraintViolationException.");
            } catch (ConstraintViolationException e) {
                //ok
            }
        }
    }


    public void testCheckWrongValueType() throws RepositoryException {
        QValue val = createOtherValueType();
        String[] qDefs = getQDefinitions();
        for (int i = 0; i < qDefs.length; i++) {
            ValueConstraint vc = createValueConstraint(qDefs[i]);
            try {
                vc.check(val);
                fail("ValueConstraint.check() with non-matching value should throw ConstraintViolationException.");
            } catch (RepositoryException e) {
                //ok
            }
        }
    }


    private static QValue[] convertValues(Value[] values,
                                          NamePathResolver resolver,
                                          QValueFactory factory)
            throws RepositoryException {
        if (values != null) {
            QValue[] defaultValues = new QValue[values.length];
            for (int i = 0; i < values.length; i++) {
                defaultValues[i] = ValueFormat.getQValue(values[i], resolver, factory);
            }
            return defaultValues;
        }  else {
            return null;
        }
    }


    private NodeDefinition[] getNodeDefArray(RemoteNodeDefinition[] remotes) {
        if (remotes != null) {
            NodeDefinition[] defs = new NodeDefinition[remotes.length];
            for (int i = 0; i < remotes.length; i++) {
                defs[i] = getFactory().getNodeDef(remotes[i]);
            }
            return defs;
        } else {
            return new NodeDefinition[0]; // for safety
        }
    }


    protected NodeType[] getNodeTypeArray(RemoteNodeType[] remotes) {
        if (remotes != null) {
            NodeType[] types = new NodeType[remotes.length];
            for (int i = 0; i < remotes.length; i++) {
                types[i] = factory.getNodeType(remotes[i]);
            }
            return types;
        } else {
            return new NodeType[0]; // for safety
        }
    }


    protected PropertyDefinition[] getPropertyDefArray(
            RemotePropertyDefinition[] remotes) {
        if (remotes != null) {
            PropertyDefinition[] defs = new PropertyDefinition[remotes.length];
            for (int i = 0; i < remotes.length; i++) {
                defs[i] = getFactory().getPropertyDef(remotes[i]);
            }
            return defs;
        } else {
            return new PropertyDefinition[0]; // for safety
        }
    }


    private Version[] getVersionArray(RemoteVersion[] remotes) {
        if (remotes != null) {
            Version[] versions = new Version[remotes.length];
            for (int i = 0; i < remotes.length; i++) {
                versions[i] = getFactory().getVersion(getSession(), remotes[i]);
            }
            return versions;
        } else {
            return new Version[0]; // for safety
        }
    }


    private RemoteVersion[] getRemoteVersionArray(Version[] versions)
            throws RemoteException {
        if (versions != null) {
            RemoteVersion[] remotes = new RemoteVersion[versions.length];
            for (int i = 0; i < remotes.length; i++) {
                remotes[i] = getFactory().getRemoteVersion(versions[i]);
            }
            return remotes;
        } else {
            return new RemoteVersion[0]; // for safety
        }
    }


    protected RemoteNodeType[] getRemoteNodeTypeArray(NodeType[] types)
            throws RemoteException {
        if (types != null) {
            RemoteNodeType[] remotes = new RemoteNodeType[types.length];
            for (int i = 0; i < types.length; i++) {
                remotes[i] = factory.getRemoteNodeType(types[i]);
            }
            return remotes;
        } else {
            return new RemoteNodeType[0]; // for safety
        }
    }


    private RemoteNodeDefinition[] getRemoteNodeDefArray(NodeDefinition[] defs)
            throws RemoteException {
        if (defs != null) {
            RemoteNodeDefinition[] remotes =
                new RemoteNodeDefinition[defs.length];
            for (int i = 0; i < defs.length; i++) {
                remotes[i] = getFactory().getRemoteNodeDefinition(defs[i]);
            }
            return remotes;
        } else {
            return new RemoteNodeDefinition[0]; // for safety
        }
    }


    private RemotePropertyDefinition[] getRemotePropertyDefArray(
            PropertyDefinition[] defs) throws RemoteException {
        if (defs != null) {
            RemotePropertyDefinition[] remotes =
                new RemotePropertyDefinition[defs.length];
            for (int i = 0; i < defs.length; i++) {
                remotes[i] = getFactory().getRemotePropertyDefinition(defs[i]);
            }
            return remotes;
        } else {
            return new RemotePropertyDefinition[0]; // for safety
        }
    }


    public InternalVersion[] getPredecessors() {
        InternalValue[] values = node.getPropertyValues(NameConstants.JCR_PREDECESSORS);
        if (values != null) {
            InternalVersion[] versions = new InternalVersion[values.length];
            for (int i = 0; i < values.length; i++) {
                versions[i] = versionHistory.getVersion(values[i].getNodeId());
            }
            return versions;
        } else {
            return new InternalVersion[0];
        }
    }


    private static Set<QPropertyDefinition> getSerializablePropertyDefs(
            QPropertyDefinition[] propDefs) {
        Set<QPropertyDefinition> defs = new HashSet<QPropertyDefinition>();
        for (QPropertyDefinition pd : propDefs) {
            if (pd instanceof Serializable) {
                defs.add(pd);
            } else {
                defs.add(new QPropertyDefinitionImpl(pd)); 
            }
        }
        return defs;
    }


    private static Set<QNodeDefinition> getSerializableNodeDefs(
            QNodeDefinition[] nodeDefs) {
        Set<QNodeDefinition> defs = new HashSet<QNodeDefinition>();
        for (QNodeDefinition nd : nodeDefs) {
            if (nd instanceof Serializable) {
                defs.add(nd);
            } else {
                defs.add(new QNodeDefinitionImpl(nd));
            }
        }
        return defs;
    }


    public final boolean equals(Object that) {
        if (this == that) {
            return true;
        } else if (that instanceof Path) {
            Path path = (Path) that;
            return path.denotesCurrent() && super.equals(that);
        } else {
            return false;
        }
    }


    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (obj instanceof DatabaseFileSystem) {
            DatabaseFileSystem other = (DatabaseFileSystem) obj;
            return equals(schema, other.schema)
                && equals(schemaObjectPrefix, other.schemaObjectPrefix);
        } else {
            return false;
        }
    }


    public final boolean equals(Object that) {
        if (this == that) {
            return true;
        } else if (that instanceof Path) {
            Path path = (Path) that;
            return path.denotesName()
                && name.equals(path.getName())
                && getNormalizedIndex() == path.getNormalizedIndex()
                && super.equals(that);
        } else {
            return false;
        }
    }


    public final boolean equals(Object that) {
        if (this == that) {
            return true;
        } else if (that instanceof Path) {
            Path path = (Path) that;
            return path.denotesParent() && super.equals(that);
        } else {
            return false;
        }
    }


    public final boolean equals(Object that) {
        if (this == that) {
            return true;
        } else if (that instanceof Path) {
            Path path = (Path) that;
            return path.denotesIdentifier()
                && identifier.equals(path.getIdentifier());
        } else {
            return false;
        }
    }


        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof ModifiableData) {
                ModifiableData d = (ModifiableData) o;
                return Arrays.equals(bits, d.bits);
            } else if (o instanceof UnmodifiableData) {
                return equalData((Data) o);
            } else {
                return false;
            }
        }


        public int hashCode() {
            // Name is immutable, we can store the computed hash code value
            int h = hash;
            if (h == 0) {
                h = 17;
                h = 37 * h + namespaceURI.hashCode();
                h = 37 * h + localName.hashCode();
                hash = h;
            }
            return h;
        }


    public int hashCode() {
        if (hashCode == 0) {
            int h = super.hashCode();
            h = 37 * h + (defaultPrimaryType == null ? 0 : defaultPrimaryType.hashCode());
            h = 37 * h + requiredPrimaryTypes.hashCode();
            h = 37 * h + (allowsSameNameSiblings ? 11 : 43);
            hashCode = h;
        }
        return hashCode;

    }


    public int hashCode() {
        // ChildNodeEntry is immutable, we can store the computed hash code value
        int h = hash;
        if (h == 0) {
            h = 17;
            h = 37 * h + name.hashCode();
            h = 37 * h + id.hashCode();
            h = 37 * h + index;
            hash = h;
        }
        return h;
    }


    public int hashCode() {
        if (hashCode == 0) {
            int h = 17;
            h = 37 * h + name.hashCode();
            h = 37 * h + nodeId.hashCode();
            h = 37 * h + Boolean.valueOf(isDeep).hashCode();
            hashCode = h;
        }
        return hashCode;
    }


        public int hashCode() {
            if (hashCode == -1) {
                int h = 17;
                h = 37 * h + allows;
                h = 37 * h + denies;
                h = 37 * h + allowPrivileges.hashCode();
                h = 37 * h + denyPrivileges.hashCode();
                hashCode = h;
            }
            return hashCode;
        }


    public int hashCode() {
        if (hashCode == -1) {
            int h = 17;
            h = 37 * h + principalName.hashCode();
            h = 37 * h + privilegeBits.hashCode();
            h = 37 * h + Boolean.valueOf(isAllow).hashCode();
            h = 37 * h + pattern.hashCode();
            hashCode = h;
        }
        return hashCode;
    }


    public Element<T> map(Path path, boolean exact) {
        Path.Element[] elements = path.getElements();
        Element<T> current = root;

        for (int i = 1; i < elements.length; i++) {
            Element<T> next = current.getChild(elements[i]);
            if (next == null) {
                if (exact) {
                    return null;
                }
                break;
            }
            current = next;
        }
        return current;
    }


        public Element<T> getDescendant(Path relPath, boolean exact) {
            Path.Element[] elements = relPath.getElements();
            Element<T> current = this;

            for (int i = 0; i < elements.length; i++) {
                Element<T> next = current.getChild(elements[i]);
                if (next == null) {
                    if (exact) {
                        return null;
                    }
                    break;
                }
                current = next;
            }
            return current;
        }


    public void put(Path path, Element<T> element) {
        Path.Element[] elements = path.getElements();
        Element<T> current = root;

        for (int i = 1; i < elements.length - 1; i++) {
            Element<T> next = current.getChild(elements[i]);
            if (next == null) {
                next = current.createChild(elements[i]);
            }
            current = next;
        }
        current.put(path.getNameElement(), element);
    }


    public Element<T> put(Path path) {
        Path.Element[] elements = path.getElements();
        Element<T> current = root;

        for (int i = 1; i < elements.length; i++) {
            Element<T> next = current.getChild(elements[i]);
            if (next == null) {
                next = current.createChild(elements[i]);
            }
            current = next;
        }
        return current;
    }


    public T get(T object) {
        int position = object.hashCode() & (array.length - 1);
        T previous = array[position];
        if (object.equals(previous)) {
            return previous;
        } else {
            array[position] = object;
            return object;
        }
    }


        public HashSet get(HashSet set) {
            int position = set.hashCode() & (SIZE_POWER_OF_2 - 1);
            HashSet previous = array[position];
            if (set.equals(previous)) {
                return previous;
            } else {
                array[position] = set;
                return set;
            }
        }


    public EventImpl(int type, Path path, ItemId itemId, NodeId parentId,
                     Name primaryNodeTypeName, Name[] mixinTypeNames,
                     String userId, String userData, long timestamp,
                     Map<Name, QValue> info) {
        this.type = type;
        this.path = path;
        this.itemId = itemId;
        this.parentId = parentId;
        this.primaryNodeTypeName = primaryNodeTypeName;
        this.mixinTypeNames = mixinTypeNames;
        this.userId = userId;

        this.userData = userData;
        this.info = new HashMap<Name, QValue>(info);
        this.timestamp = timestamp;
    }


    private LuceneQueryBuilder(QueryRootNode root,
                               SessionImpl session,
                               ItemStateManager sharedItemMgr,
                               HierarchyManager hmgr,
                               NamespaceMappings nsMappings,
                               Analyzer analyzer,
                               PropertyTypeRegistry propReg,
                               SynonymProvider synonymProvider,
                               IndexFormatVersion indexFormatVersion,
                               PerQueryCache cache) {
        this.root = root;
        this.session = session;
        this.sharedItemMgr = sharedItemMgr;
        this.hmgr = hmgr;
        this.nsMappings = nsMappings;
        this.analyzer = analyzer;
        this.propRegistry = propReg;
        this.synonymProvider = synonymProvider;
        this.indexFormatVersion = indexFormatVersion;
        this.cache = cache;

        this.resolver = NamePathResolverImpl.create(nsMappings);
    }


    public AMContext(File physicalHomeDir,
                     FileSystem fs,
                     Session session,
                     Subject subject,
                     HierarchyManager hierMgr,
                     PrivilegeManager privilegeMgr,
                     NamePathResolver resolver,
                     String workspaceName) {
        this.physicalHomeDir = physicalHomeDir;
        this.fs = fs;
        this.session = session;
        this.subject = subject;
        this.hierMgr = hierMgr;
        this.privilegeMgr = privilegeMgr;
        this.resolver = resolver;
        this.workspaceName = workspaceName;
    }


    public WorkspaceConfig(String home, String name, boolean clustered, FileSystemFactory fsf,
            PersistenceManagerConfig pmc, QueryHandlerFactory qhf, ISMLockingFactory ismLockingFactory,
            WorkspaceSecurityConfig workspaceSecurityConfig, ImportConfig importConfig, long defaultLockTimeout) {
        this.home = home;
        this.name = name;
        this.clustered = clustered;
        this.fsf = fsf;
        this.pmc = pmc;
        this.qhf = qhf;
        this.ismLockingFactory = ismLockingFactory;
        this.workspaceSecurityConfig = workspaceSecurityConfig;
        this.importConfig = importConfig;
        this.defaultLockTimeout = defaultLockTimeout;
    }


    EventFilter(SessionImpl session,
                long eventTypes,
                List<Path> paths,
                boolean isDeep,
                NodeId[] ids,
                NodeTypeImpl[] nodeTypes,
                boolean noLocal,
                boolean noExternal,
                boolean noInternal) {
        this.session = session;
        this.eventTypes = eventTypes;
        this.paths = paths;
        this.isDeep = isDeep;
        this.ids = ids;
        this.noLocal = noLocal;
        this.noExternal = noExternal;
        this.noInternal = noInternal;
        this.nodeTypes = nodeTypes;
    }


    public QueryImpl(Session session,
                     ManagerProvider mgrProvider,
                     ItemManager itemMgr,
                     WorkspaceManager wspManager,
                     String statement,
                     String language,
                     Node node)
            throws InvalidQueryException, RepositoryException {
        this.session = session;
        this.mgrProvider = mgrProvider;
        this.itemManager = itemMgr;
        this.statement = statement;
        this.language = language;
        this.wspManager = wspManager;
        this.varNames = Arrays.asList(this.wspManager.checkQueryStatement(
                statement, language, getNamespaceMappings()));
        this.node = node;
    }


    public QValue create(final InputStream value) throws RepositoryException, IOException {
        final String methodName = "create(InputStream)";
        final Object[] args = new Object[]{value};
        final IOException[] ex = new IOException[1];

        QValue result = (QValue) execute(new Callable() {
            public Object call() throws RepositoryException {
                try {
                    return qValueFactory.create(value);
                }
                catch (IOException e) {
                    ex[0] = e;
                    return null;
                }
            }}, methodName, args);

        if (ex[0] != null) {
            throw ex[0];
        }

        return result;
    }


    public EventBundle[] getEvents(final Subscription subscription, final long timeout)
            throws RepositoryException, InterruptedException {

        final String methodName = "getEvents(Subscription, long)";
        final Object[] args = new Object[]{subscription, timeout};
        final InterruptedException[] ex = new InterruptedException[1];

        EventBundle[] result = (EventBundle[]) execute(new Callable() {
            public Object call() throws RepositoryException {
                try {
                    return service.getEvents(subscription, timeout);
                } catch (InterruptedException e) {
                    writer.error(methodName, args, e);
                    ex[0] = e;
                    return null;
                }
            }
        }, methodName, args);

        if (ex[0] != null) {
            throw ex[0];
        }

        return result;
    }


    public QValue create(final File value) throws RepositoryException, IOException {
        final String methodName = "create(File)";
        final Object[] args = new Object[]{value};
        final IOException[] ex = new IOException[1];

        QValue result = (QValue) execute(new Callable() {
            public Object call() throws RepositoryException {
                try {
                    return qValueFactory.create(value);
                }
                catch (IOException e) {
                    ex[0] = e;
                    return null;
                }
            }}, methodName, args);

        if (ex[0] != null) {
            throw ex[0];
        }

        return result;
    }


    public static RepositoryService create(RepositoryService service, LogWriterProvider logWriterProvider) {
        if (service == null) {
            throw new IllegalArgumentException("Service must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(service);
        if (logWriter == null) {
            return service;
        }
        else {
            return new ServiceLogger(service, logWriterProvider, logWriter);
        }
    }


    public static QValueFactory create(QValueFactory qValueFactory, LogWriterProvider logWriterProvider) {
        if (qValueFactory == null) {
            throw new IllegalArgumentException("QValueFactory must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(qValueFactory);
        if (logWriter == null) {
            return qValueFactory;
        }
        else {
            return new QValueFactoryLogger(qValueFactory, logWriter);
        }
    }


    public static IdFactory create(IdFactory idFactory, LogWriterProvider logWriterProvider) {
        if (idFactory == null) {
            throw new IllegalArgumentException("IdFactory must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(idFactory);
        if (logWriter == null) {
            return idFactory;
        }
        else {
            return new IdFactoryLogger(idFactory, logWriter);
        }
    }


    public static PathFactory create(PathFactory pathFactory, LogWriterProvider logWriterProvider) {
        if (pathFactory == null) {
            throw new IllegalArgumentException("PathFactory must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(pathFactory);
        if (logWriter == null) {
            return pathFactory;
        }
        else {
            return new PathFactoryLogger(pathFactory, logWriter);
        }
    }


    public static Batch create(Batch batch, LogWriterProvider logWriterProvider) {
        if (batch == null) {
            throw new IllegalArgumentException("Batch must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(batch);
        if (logWriter == null) {
            return batch;
        }
        else {
            return new BatchLogger(batch, logWriter);
        }
    }


    public static NameFactory create(NameFactory nameFactory, LogWriterProvider logWriterProvider) {
        if (nameFactory == null) {
            throw new IllegalArgumentException("NameFactory must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(nameFactory);
        if (logWriter == null) {
            return nameFactory;
        }
        else {
            return new NameFactoryLogger(nameFactory, logWriter);
        }
    }


    public static SessionInfo create(SessionInfo sessionInfo, LogWriterProvider logWriterProvider) {
        if (sessionInfo == null) {
            throw new IllegalArgumentException("SessionInfo must not be null");
        }
        if (logWriterProvider == null) {
            throw new IllegalArgumentException("LogWriterProvider must not be null");
        }

        LogWriter logWriter = logWriterProvider.getLogWriter(sessionInfo);
        if (logWriter == null) {
            return sessionInfo;
        }
        else {
            return new SessionInfoLogger(sessionInfo, logWriter);
        }
    }


    public Object visit(LocationStepQueryNode node, Object data) throws RepositoryException {
        StringBuffer buffer = (StringBuffer) data;
        buffer.append(PADDING, 0, indent);
        buffer.append("+ LocationStepQueryNode: ");
        buffer.append(" NodeTest=");
        if (node.getNameTest() == null) {
            buffer.append("*");
        } else {
            buffer.append(node.getNameTest());
        }
        buffer.append(" Descendants=").append(node.getIncludeDescendants());
        buffer.append(" Index=");
        if (node.getIndex() == LocationStepQueryNode.NONE) {
            buffer.append("NONE");
        } else if (node.getIndex() == LocationStepQueryNode.LAST) {
            buffer.append("last()");
        } else {
            buffer.append(node.getIndex());
        }
        buffer.append("\n");
        traverse(node.getOperands(), buffer);
        return buffer;
    }


    public Object visit(DerefQueryNode node, Object data) throws RepositoryException {
        StringBuffer buffer = (StringBuffer) data;
        buffer.append(PADDING, 0, indent);
        buffer.append("+ DerefQueryNode: ");
        buffer.append(" NodeTest=");
        if (node.getNameTest() == null) {
            buffer.append("*");
        } else {
            buffer.append(node.getNameTest());
        }
        buffer.append(" Descendants=").append(node.getIncludeDescendants());
        buffer.append(" Index=");
        if (node.getIndex() == LocationStepQueryNode.NONE) {
            buffer.append("NONE");
        } else if (node.getIndex() == LocationStepQueryNode.LAST) {
            buffer.append("last()");
        } else {
            buffer.append(node.getIndex());
        }
        buffer.append("\n");
        traverse(node.getOperands(), buffer);
        return buffer;
    }


  public String getMessage() {
    if (!specialConstructor) {
      return super.getMessage();
    }
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append("...");
      }
      expected.append(eol).append("    ");
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + eol;
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting:" + eol + "    ";
    } else {
      retval += "Was expecting one of:" + eol + "    ";
    }
    retval += expected.toString();
    return retval;
  }


  public String getMessage() {
    if (!specialConstructor) {
      return super.getMessage();
    }
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append("...");
      }
      expected.append(eol).append("    ");
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + eol;
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting:" + eol + "    ";
    } else {
      retval += "Was expecting one of:" + eol + "    ";
    }
    retval += expected.toString();
    return retval;
  }


  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }


  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }


   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }


   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }


  protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];

     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos -= tokenBegin);
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }


     bufsize += 2048;
     available = bufsize;
     tokenBegin = 0;
  }


  protected void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];

     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos -= tokenBegin);
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }


     bufsize += 2048;
     available = bufsize;
     tokenBegin = 0;
  }


  protected void FillBuff() throws java.io.IOException
  {
     if (maxNextCharInd == available)
     {
        if (available == bufsize)
        {
           if (tokenBegin > 2048)
           {
              bufpos = maxNextCharInd = 0;
              available = tokenBegin;
           }
           else if (tokenBegin < 0)
              bufpos = maxNextCharInd = 0;
           else
              ExpandBuff(false);
        }
        else if (available > tokenBegin)
           available = bufsize;
        else if ((tokenBegin - available) < 2048)
           ExpandBuff(true);
        else
           available = tokenBegin;
     }

     int i;
     try {
        if ((i = inputStream.read(buffer, maxNextCharInd,
                                    available - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        --bufpos;
        backup(0);
        if (tokenBegin == -1)
           tokenBegin = bufpos;
        throw e;
     }
  }


  protected void FillBuff() throws java.io.IOException
  {
     if (maxNextCharInd == available)
     {
        if (available == bufsize)
        {
           if (tokenBegin > 2048)
           {
              bufpos = maxNextCharInd = 0;
              available = tokenBegin;
           }
           else if (tokenBegin < 0)
              bufpos = maxNextCharInd = 0;
           else
              ExpandBuff(false);
        }
        else if (available > tokenBegin)
           available = bufsize;
        else if ((tokenBegin - available) < 2048)
           ExpandBuff(true);
        else
           available = tokenBegin;
     }

     int i;
     try {
        if ((i = inputStream.read(buffer, maxNextCharInd,
                                    available - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        --bufpos;
        backup(0);
        if (tokenBegin == -1)
           tokenBegin = bufpos;
        throw e;
     }
  }


  protected void UpdateLineColumn(char c)
  {
     column++;

     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }

     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (tabSize - (column % tabSize));
           break;
        default :
           break;
     }

     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }


  protected void UpdateLineColumn(char c)
  {
     column++;

     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }

     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (tabSize - (column % tabSize));
           break;
        default :
           break;
     }

     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }


  public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        return buffer[bufpos];
     }

     if (++bufpos >= maxNextCharInd)
        FillBuff();

     char c = buffer[bufpos];

     UpdateLineColumn(c);
     return (c);
  }


  public char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;

        if (++bufpos == bufsize)
           bufpos = 0;

        return buffer[bufpos];
     }

     if (++bufpos >= maxNextCharInd)
        FillBuff();

     char c = buffer[bufpos];

     UpdateLineColumn(c);
     return (c);
  }


  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }


  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }


  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;

     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }

     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;

     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 

     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;

        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }

     line = bufline[j];
     column = bufcolumn[j];
  }


  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;

     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }

     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;

     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 

     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;

        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }

     line = bufline[j];
     column = bufcolumn[j];
  }


    public Object visit(OrQueryNode node, Object data) throws RepositoryException {
        StringBuffer sb = (StringBuffer) data;
        boolean bracket = false;
        if (node.getParent() instanceof AndQueryNode) {
            bracket = true;
        }
        if (bracket) {
            sb.append("(");
        }
        String or = "";
        QueryNode[] operands = node.getOperands();
        for (int i = 0; i < operands.length; i++) {
            sb.append(or);
            operands[i].accept(this, sb);
            or = " or ";
        }
        if (bracket) {
            sb.append(")");
        }
        return sb;
    }


    public Object visit(AndQueryNode node, Object data) throws RepositoryException {
        StringBuffer sb = (StringBuffer) data;
        boolean bracket = false;
        if (node.getParent() instanceof NotQueryNode) {
            bracket = true;
        }
        if (bracket) {
            sb.append("(");
        }
        String and = "";
        QueryNode[] operands = node.getOperands();
        for (int i = 0; i < operands.length; i++) {
            sb.append(and);
            int len = sb.length();
            operands[i].accept(this, sb);
            // check if something has been written at all
            // might have been a node type query node
            if (sb.length() - len > 0) {
                and = " AND ";
            } else {
                and = "";
            }
        }
        if (bracket) {
            sb.append(")");
        }
        return sb;
    }


    public Object visit(OrQueryNode node, Object data) throws RepositoryException {
        StringBuffer sb = (StringBuffer) data;
        boolean bracket = false;
        if (node.getParent() instanceof LocationStepQueryNode
                || node.getParent() instanceof AndQueryNode
                || node.getParent() instanceof NotQueryNode) {
            bracket = true;
        }
        if (bracket) {
            sb.append("(");
        }
        String or = "";
        QueryNode[] operands = node.getOperands();
        for (int i = 0; i < operands.length; i++) {
            sb.append(or);
            operands[i].accept(this, sb);
            or = " OR ";
        }
        if (bracket) {
            sb.append(")");
        }
        return sb;
    }


    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node[] c = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }


  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }


  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }


  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }


  final public SimpleNode XPath2() throws ParseException {
                 /*@bgen(jjtree) XPath2 */
  SimpleNode jjtn000 = new SimpleNode(this, JJTXPATH2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      QueryList();
      jj_consume_token(0);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      {if (true) throw (RuntimeException)jjte000;}
                    }
                    if (jjte000 instanceof ParseException) {
                      {if (true) throw (ParseException)jjte000;}
                    }
                    {if (true) throw (Error)jjte000;}
    } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
    }
    throw new Error("Missing return statement in function");
  }


  final public Name UpperFunction() throws ParseException {
 /*@bgen(jjtree) UpperFunction */
  ASTUpperFunction jjtn000 = new ASTUpperFunction(JJTUPPERFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Name identifier;
    try {
      jj_consume_token(UPPER);
      jj_consume_token(LEFT_PAREN);
      identifier = Identifier();
      jj_consume_token(RIGHT_PAREN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return identifier;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }


  final public void InstanceofExpr() throws ParseException {
 /*@bgen(jjtree) #InstanceofExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINSTANCEOFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      TreatExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Instanceof:
        jj_consume_token(Instanceof);
        SequenceType();
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void QueryBody() throws ParseException {
 /*@bgen(jjtree) QueryBody */
  SimpleNode jjtn000 = new SimpleNode(this, JJTQUERYBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ContentExpr() throws ParseException {
 /*@bgen(jjtree) ContentExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONTENTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AttributeDeclaration() throws ParseException {
 /*@bgen(jjtree) AttributeDeclaration */
  SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AttributeName();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void TreatExpr() throws ParseException {
 /*@bgen(jjtree) #TreatExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTREATEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      CastableExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TreatAs:
        jj_consume_token(TreatAs);
        SequenceType();
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public Name LowerFunction() throws ParseException {
 /*@bgen(jjtree) LowerFunction */
  ASTLowerFunction jjtn000 = new ASTLowerFunction(JJTLOWERFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Name identifier;
    try {
      jj_consume_token(LOWER);
      jj_consume_token(LEFT_PAREN);
      identifier = Identifier();
      jj_consume_token(RIGHT_PAREN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return identifier;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }


  final public void ElementDeclaration() throws ParseException {
 /*@bgen(jjtree) ElementDeclaration */
  SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ElementName();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderSpec() throws ParseException {
 /*@bgen(jjtree) OrderSpec */
  SimpleNode jjtn000 = new SimpleNode(this, JJTORDERSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExprSingle();
      OrderModifier();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Predicate() throws ParseException {
 /*@bgen(jjtree) #Predicate(> 0) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Lbrack);
      Expr();
      jj_consume_token(Rbrack);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
    }
    }
  }


  final public void MainModule() throws ParseException {
 /*@bgen(jjtree) MainModule */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMAINMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Prolog();
      QueryBody();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CastableExpr() throws ParseException {
 /*@bgen(jjtree) #CastableExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCASTABLEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      CastExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Castable:
        jj_consume_token(Castable);
        SingleType();
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void LibraryModule() throws ParseException {
 /*@bgen(jjtree) LibraryModule */
  SimpleNode jjtn000 = new SimpleNode(this, JJTLIBRARYMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ModuleDecl();
      Prolog();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void BracketExpression() throws ParseException {
 /*@bgen(jjtree) BracketExpression */
  ASTBracketExpression jjtn000 = new ASTBracketExpression(JJTBRACKETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFT_PAREN);
      SearchCondition();
      jj_consume_token(RIGHT_PAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void IfExpr() throws ParseException {
 /*@bgen(jjtree) IfExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTIFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IfLpar);
      Expr();
      jj_consume_token(Rpar);
      jj_consume_token(Then);
      ExprSingle();
      jj_consume_token(Else);
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public ASTQuery Query() throws ParseException {
 /*@bgen(jjtree) Query */
  ASTQuery jjtn000 = new ASTQuery(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SELECT);
      SelectList();
      TableExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ORDER:
        OrderByClause();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }


  final public void WhereClause() throws ParseException {
 /*@bgen(jjtree) WhereClause */
  ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(WHERE);
      SearchCondition();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void FromClause() throws ParseException {
 /*@bgen(jjtree) FromClause */
  ASTFromClause jjtn000 = new ASTFromClause(JJTFROMCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FROM);
      Identifier();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Identifier();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void PredicateList() throws ParseException {
 /*@bgen(jjtree) #PredicateList(> 0) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPREDICATELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Lbrack:
          ;
          break;
        default:
          jj_la1[98] = jj_gen;
          break label_23;
        }
        Predicate();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
    }
    }
  }


  final public void OrderByClause() throws ParseException {
 /*@bgen(jjtree) OrderByClause */
  ASTOrderByClause jjtn000 = new ASTOrderByClause(JJTORDERBYCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ORDER);
      jj_consume_token(BY);
      OrderSpec();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        OrderSpec();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Import() throws ParseException {
 /*@bgen(jjtree) Import */
  SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ImportSchemaToken:
        SchemaImport();
        break;
      case ImportModuleToken:
        ModuleImport();
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderSpecList() throws ParseException {
 /*@bgen(jjtree) OrderSpecList */
  SimpleNode jjtn000 = new SimpleNode(this, JJTORDERSPECLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      OrderSpec();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_12;
        }
        jj_consume_token(Comma);
        OrderSpec();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirectConstructor() throws ParseException {
 /*@bgen(jjtree) DirectConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRECTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case StartTagOpen:
      case StartTagOpenRoot:
        DirElemConstructor();
        break;
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
        DirCommentConstructor();
        break;
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
        DirPIConstructor();
        break;
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ParamList() throws ParseException {
 /*@bgen(jjtree) ParamList */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Param();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_7;
        }
        jj_consume_token(Comma);
        Param();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrExpression() throws ParseException {
    ASTOrExpression jjtn001 = new ASTOrExpression(JJTOREXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      AndExpression();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_3;
        }
        jj_consume_token(OR);
        AndExpression();
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void SingleType() throws ParseException {
 /*@bgen(jjtree) SingleType */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSINGLETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AtomicType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OccurrenceZeroOrOne:
        jj_consume_token(OccurrenceZeroOrOne);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTOCCURRENCEZEROORONE);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      default:
        jj_la1[139] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AndExpression() throws ParseException {
    ASTAndExpression jjtn001 = new ASTAndExpression(JJTANDEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    try {
      UnaryExpression();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_4;
        }
        jj_consume_token(AND);
        UnaryExpression();
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void CastExpr() throws ParseException {
 /*@bgen(jjtree) #CastExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCASTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      UnaryExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CastAs:
        jj_consume_token(CastAs);
                         SimpleNode jjtn001 = new SimpleNode(this, JJTCASTAS);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
        try {
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                        jjtn001.processToken(token);
        } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  true);
                         }
        }
        SingleType();
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void Expr() throws ParseException {
 /*@bgen(jjtree) Expr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExprSingle();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_8;
        }
        jj_consume_token(Comma);
        ExprSingle();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void TypeDeclaration() throws ParseException {
 /*@bgen(jjtree) TypeDeclaration */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(As);
        SimpleNode jjtn001 = new SimpleNode(this, JJTAS);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
      try {
        jjtree.closeNodeScope(jjtn001,  true);
        jjtc001 = false;
       jjtn001.processToken(token);
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  true);
        }
      }
      SequenceType();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void WhereClause() throws ParseException {
 /*@bgen(jjtree) WhereClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTWHERECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Where);
           SimpleNode jjtn001 = new SimpleNode(this, JJTWHERE);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
      try {
           jjtree.closeNodeScope(jjtn001,  true);
           jjtc001 = false;
          jjtn001.processToken(token);
      } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  true);
           }
      }
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderSpec() throws ParseException {
 /*@bgen(jjtree) OrderSpec */
  ASTOrderSpec jjtn000 = new ASTOrderSpec(JJTORDERSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
      case DESC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
          AscendingOrderSpec();
          break;
        case DESC:
          DescendingOrderSpec();
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Setter() throws ParseException {
 /*@bgen(jjtree) Setter */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSETTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DeclareXMLSpace:
        XMLSpaceDecl();
        break;
      case DeclareCollation:
        DefaultCollationDecl();
        break;
      case DeclareBaseURI:
        BaseURIDecl();
        break;
      case DeclareConstruction:
        ConstructionDecl();
        break;
      case DeclareOrdering:
        OrderingModeDecl();
        break;
      case DeclareDefaultOrderingEmpty:
        EmptyOrderingDecl();
        break;
      case DeclareInheritNamespaces:
        InheritNamespacesDecl();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void NameTest() throws ParseException {
 /*@bgen(jjtree) NameTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTNAMETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QName:
        jj_consume_token(QName);
            SimpleNode jjtn001 = new SimpleNode(this, JJTQNAME);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
        }
        break;
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
        Wildcard();
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ElementNameOrWildcard() throws ParseException {
 /*@bgen(jjtree) ElementNameOrWildcard */
  SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTNAMEORWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameForItemType:
        ElementName();
        break;
      case AnyName:
        jj_consume_token(AnyName);
                              SimpleNode jjtn001 = new SimpleNode(this, JJTANYNAME);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
        try {
                              jjtree.closeNodeScope(jjtn001,  true);
                              jjtc001 = false;
                             jjtn001.processToken(token);
        } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  true);
                              }
        }
        break;
      default:
        jj_la1[164] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AttribNameOrWildcard() throws ParseException {
 /*@bgen(jjtree) AttribNameOrWildcard */
  SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBNAMEORWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameForItemType:
        AttributeName();
        break;
      case AnyName:
        jj_consume_token(AnyName);
                                SimpleNode jjtn001 = new SimpleNode(this, JJTANYNAME);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
        try {
                                jjtree.closeNodeScope(jjtn001,  true);
                                jjtc001 = false;
                               jjtn001.processToken(token);
        } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  true);
                                }
        }
        break;
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ComputedConstructor() throws ParseException {
 /*@bgen(jjtree) ComputedConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPUTEDCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DocumentLbrace:
        CompDocConstructor();
        break;
      case ElementQNameLbrace:
      case ElementLbrace:
        CompElemConstructor();
        break;
      case AttributeQNameLbrace:
      case AttributeLbrace:
        CompAttrConstructor();
        break;
      case TextLbrace:
        CompTextConstructor();
        break;
      case CommentLbrace:
        CompCommentConstructor();
        break;
      case PINCNameLbrace:
      case PILbrace:
        CompPIConstructor();
        break;
      default:
        jj_la1[132] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Constructor() throws ParseException {
 /*@bgen(jjtree) Constructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
        DirectConstructor();
        break;
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case DocumentLbrace:
        ComputedConstructor();
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void QuotAttrValueContent() throws ParseException {
 /*@bgen(jjtree) QuotAttrValueContent */
  SimpleNode jjtn000 = new SimpleNode(this, JJTQUOTATTRVALUECONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QuotAttrContentChar:
        jj_consume_token(QuotAttrContentChar);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTQUOTATTRCONTENTCHAR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
        }
        break;
      case PredefinedEntityRef:
      case CharRef:
      case Lbrace:
      case LbraceExprEnclosure:
      case LCurlyBraceEscape:
      case RCurlyBraceEscape:
        CommonContent();
        break;
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AposAttrValueContent() throws ParseException {
 /*@bgen(jjtree) AposAttrValueContent */
  SimpleNode jjtn000 = new SimpleNode(this, JJTAPOSATTRVALUECONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AposAttrContentChar:
        jj_consume_token(AposAttrContentChar);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTAPOSATTRCONTENTCHAR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
        }
        break;
      case PredefinedEntityRef:
      case CharRef:
      case Lbrace:
      case LbraceExprEnclosure:
      case LCurlyBraceEscape:
      case RCurlyBraceEscape:
        CommonContent();
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderByClause() throws ParseException {
 /*@bgen(jjtree) OrderByClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTORDERBYCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OrderBy:
        jj_consume_token(OrderBy);
              SimpleNode jjtn001 = new SimpleNode(this, JJTORDERBY);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
        try {
              jjtree.closeNodeScope(jjtn001,  true);
              jjtc001 = false;
             jjtn001.processToken(token);
        } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  true);
              }
        }
        break;
      case OrderByStable:
        jj_consume_token(OrderByStable);
                                                                             SimpleNode jjtn002 = new SimpleNode(this, JJTORDERBYSTABLE);
                                                                             boolean jjtc002 = true;
                                                                             jjtree.openNodeScope(jjtn002);
        try {
                                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                                             jjtc002 = false;
                                                             jjtn002.processToken(token);
        } finally {
                                                                             if (jjtc002) {
                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                             }
        }
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OrderSpecList();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CompDocConstructor() throws ParseException {
 /*@bgen(jjtree) CompDocConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPDOCCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DocumentLbrace);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTDOCUMENTLBRACE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
      }
      Expr();
      jj_consume_token(Rbrace);
                                                                                        SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
                                                                                        boolean jjtc002 = true;
                                                                                        jjtree.openNodeScope(jjtn002);
      try {
                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                        jjtc002 = false;
                                                                 jjtn002.processToken(token);
      } finally {
                                                                                        if (jjtc002) {
                                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                                        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CompCommentConstructor() throws ParseException {
 /*@bgen(jjtree) CompCommentConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPCOMMENTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CommentLbrace);
                   SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTLBRACE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
      try {
                   jjtree.closeNodeScope(jjtn001,  true);
                   jjtc001 = false;
                  jjtn001.processToken(token);
      } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  true);
                   }
      }
      Expr();
      jj_consume_token(Rbrace);
                                                                                      SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
                                                                                      boolean jjtc002 = true;
                                                                                      jjtree.openNodeScope(jjtn002);
      try {
                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                      jjtc002 = false;
                                                                jjtn002.processToken(token);
      } finally {
                                                                                      if (jjtc002) {
                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                      }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void RangeExpr() throws ParseException {
 /*@bgen(jjtree) #RangeExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTRANGEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AdditiveExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case To:
        jj_consume_token(To);
          binaryTokenStack.push(token);
        AdditiveExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTRANGEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void CompTextConstructor() throws ParseException {
 /*@bgen(jjtree) CompTextConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPTEXTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TextLbrace);
                SimpleNode jjtn001 = new SimpleNode(this, JJTTEXTLBRACE);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
      try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
      } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
      }
      Expr();
      jj_consume_token(Rbrace);
                                                                                SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
                                                                                boolean jjtc002 = true;
                                                                                jjtree.openNodeScope(jjtn002);
      try {
                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                jjtc002 = false;
                                                             jjtn002.processToken(token);
      } finally {
                                                                                if (jjtc002) {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Param() throws ParseException {
 /*@bgen(jjtree) Param */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(VariableIndicator);
      jj_consume_token(VarName);
                                 SimpleNode jjtn001 = new SimpleNode(this, JJTVARNAME);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
      try {
                                 jjtree.closeNodeScope(jjtn001,  true);
                                 jjtc001 = false;
                                jjtn001.processToken(token);
      } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  true);
                                 }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case As:
        TypeDeclaration();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrExpr() throws ParseException {
 /*@bgen(jjtree) #OrExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AndExpr();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Or:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_15;
        }
        jj_consume_token(Or);
          binaryTokenStack.push(token);
        AndExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTOREXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void AndExpr() throws ParseException {
 /*@bgen(jjtree) #AndExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTANDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ComparisonExpr();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case And:
          ;
          break;
        default:
          jj_la1[61] = jj_gen;
          break label_16;
        }
        jj_consume_token(And);
          binaryTokenStack.push(token);
        ComparisonExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTANDEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void FLWORExpr() throws ParseException {
 /*@bgen(jjtree) FLWORExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFLWOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ForVariable:
          ForClause();
          break;
        case LetVariable:
          LetClause();
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ForVariable:
        case LetVariable:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_9;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Where:
        WhereClause();
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OrderBy:
      case OrderByStable:
        OrderByClause();
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      jj_consume_token(Return);
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void NodeTest() throws ParseException {
 /*@bgen(jjtree) NodeTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTNODETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
        KindTest();
        break;
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case QName:
        NameTest();
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirElemContent() throws ParseException {
 /*@bgen(jjtree) DirElemContent */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRELEMCONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
        DirectConstructor();
        break;
      case ElementContentChar:
        jj_consume_token(ElementContentChar);
                                               SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTCONTENTCHAR);
                                               boolean jjtc001 = true;
                                               jjtree.openNodeScope(jjtn001);
        try {
                                               jjtree.closeNodeScope(jjtn001,  true);
                                               jjtc001 = false;
                                              jjtn001.processToken(token);
        } finally {
                                               if (jjtc001) {
                                                 jjtree.closeNodeScope(jjtn001,  true);
                                               }
        }
        break;
      case CdataSectionStart:
      case CdataSectionStartForElementContent:
        CDataSection();
        break;
      case PredefinedEntityRef:
      case CharRef:
      case Lbrace:
      case LbraceExprEnclosure:
      case LCurlyBraceEscape:
      case RCurlyBraceEscape:
        CommonContent();
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void SchemaAttributeTest() throws ParseException {
 /*@bgen(jjtree) SchemaAttributeTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAATTRIBUTETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SchemaAttributeType:
        jj_consume_token(SchemaAttributeType);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTSCHEMAATTRIBUTETYPE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
        }
        break;
      case SchemaAttributeTypeForKindTest:
        jj_consume_token(SchemaAttributeTypeForKindTest);
                                                                                                                      SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAATTRIBUTETYPEFORKINDTEST);
                                                                                                                      boolean jjtc002 = true;
                                                                                                                      jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                      jjtc002 = false;
                                                                                          jjtn002.processToken(token);
        } finally {
                                                                                                                      if (jjtc002) {
                                                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                      }
        }
        break;
      default:
        jj_la1[159] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      AttributeDeclaration();
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ContainsExpression() throws ParseException {
 /*@bgen(jjtree) ContainsExpression */
  ASTContainsExpression jjtn000 = new ASTContainsExpression(JJTCONTAINSEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
  Name name = null;
    try {
      jj_consume_token(CONTAINS);
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      case PERIOD:
        jj_consume_token(PERIOD);
        break;
      case BY:
      case IN:
      case OR:
      case IS:
      case AND:
      case LIKE:
      case NULL:
      case FROM:
      case ORDER:
      case WHERE:
      case SELECT:
      case BETWEEN:
      case REGULAR_IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        name = Identifier();
                                                   jjtn000.setPropertyName(name);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(COMMA);
      t = jj_consume_token(CHAR_STRING_LITERAL);
                              jjtn000.setQuery(t.image.substring(1, t.image.length() - 1).replaceAll("''", "'"));
      jj_consume_token(RIGHT_PAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void SelectList() throws ParseException {
 /*@bgen(jjtree) SelectList */
  ASTSelectList jjtn000 = new ASTSelectList(JJTSELECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      case BY:
      case IN:
      case OR:
      case IS:
      case AND:
      case LIKE:
      case NULL:
      case FROM:
      case ORDER:
      case WHERE:
      case SELECT:
      case BETWEEN:
      case EXCERPT:
      case REGULAR_IDENTIFIER:
      case DELIMITED_IDENTIFIER:
        SelectItem();
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_1;
          }
          jj_consume_token(COMMA);
          SelectItem();
        }
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }


  final public void TypeswitchExpr() throws ParseException {
 /*@bgen(jjtree) TypeswitchExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTYPESWITCHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TypeswitchLpar);
      Expr();
      jj_consume_token(Rpar);
      label_14:
      while (true) {
        CaseClause();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Case:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_14;
        }
      }
      jj_consume_token(Default);
                                                             SimpleNode jjtn001 = new SimpleNode(this, JJTDEFAULT);
                                                             boolean jjtc001 = true;
                                                             jjtree.openNodeScope(jjtn001);
      try {
                                                             jjtree.closeNodeScope(jjtn001,  true);
                                                             jjtc001 = false;
                                                            jjtn001.processToken(token);
      } finally {
                                                             if (jjtc001) {
                                                               jjtree.closeNodeScope(jjtn001,  true);
                                                             }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VariableIndicator:
        jj_consume_token(VariableIndicator);
        jj_consume_token(VarName);
                                                                                                                                         SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
                                                                                                                                         boolean jjtc002 = true;
                                                                                                                                         jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                         jjtc002 = false;
                                                                                                                         jjtn002.processToken(token);
        } finally {
                                                                                                                                         if (jjtc002) {
                                                                                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                         }
        }
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(Return);
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CDataSection() throws ParseException {
 /*@bgen(jjtree) CDataSection */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCDATASECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CdataSectionStartForElementContent:
        jj_consume_token(CdataSectionStartForElementContent);
                                         SimpleNode jjtn001 = new SimpleNode(this, JJTCDATASECTIONSTARTFORELEMENTCONTENT);
                                         boolean jjtc001 = true;
                                         jjtree.openNodeScope(jjtn001);
        try {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                         jjtc001 = false;
                                        jjtn001.processToken(token);
        } finally {
                                         if (jjtc001) {
                                           jjtree.closeNodeScope(jjtn001,  true);
                                         }
        }
        break;
      case CdataSectionStart:
        jj_consume_token(CdataSectionStart);
                                                                                                                                       SimpleNode jjtn002 = new SimpleNode(this, JJTCDATASECTIONSTART);
                                                                                                                                       boolean jjtc002 = true;
                                                                                                                                       jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                                       jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                       jjtc002 = false;
                                                                                            jjtn002.processToken(token);
        } finally {
                                                                                                                                       if (jjtc002) {
                                                                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                       }
        }
        break;
      default:
        jj_la1[130] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      CDataSectionContents();
      jj_consume_token(CdataSectionEnd);
                                                                                                                                                                                                                                        SimpleNode jjtn003 = new SimpleNode(this, JJTCDATASECTIONEND);
                                                                                                                                                                                                                                        boolean jjtc003 = true;
                                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                        jjtc003 = false;
                                                                                                                                                                    jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                                                                        if (jjtc003) {
                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirCommentConstructor() throws ParseException {
 /*@bgen(jjtree) DirCommentConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRCOMMENTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XmlCommentStartForElementContent:
        jj_consume_token(XmlCommentStartForElementContent);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTXMLCOMMENTSTARTFORELEMENTCONTENT);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      case XmlCommentStart:
        jj_consume_token(XmlCommentStart);
                                                                                                                                 SimpleNode jjtn002 = new SimpleNode(this, JJTXMLCOMMENTSTART);
                                                                                                                                 boolean jjtc002 = true;
                                                                                                                                 jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                 jjtc002 = false;
                                                                                        jjtn002.processToken(token);
        } finally {
                                                                                                                                 if (jjtc002) {
                                                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                 }
        }
        break;
      default:
        jj_la1[124] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      DirCommentContents();
      jj_consume_token(XmlCommentEnd);
                                                                                                                                                                                                                            SimpleNode jjtn003 = new SimpleNode(this, JJTXMLCOMMENTEND);
                                                                                                                                                                                                                            boolean jjtc003 = true;
                                                                                                                                                                                                                            jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                                                            jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                            jjtc003 = false;
                                                                                                                                                            jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                                                            if (jjtc003) {
                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                            }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void EnclosedExpr() throws ParseException {
 /*@bgen(jjtree) EnclosedExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTENCLOSEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Lbrace:
        jj_consume_token(Lbrace);
             SimpleNode jjtn001 = new SimpleNode(this, JJTLBRACE);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
        try {
             jjtree.closeNodeScope(jjtn001,  true);
             jjtc001 = false;
            jjtn001.processToken(token);
        } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  true);
             }
        }
        break;
      case LbraceExprEnclosure:
        jj_consume_token(LbraceExprEnclosure);
                                                                                 SimpleNode jjtn002 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
                                                                                 boolean jjtc002 = true;
                                                                                 jjtree.openNodeScope(jjtn002);
        try {
                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                 jjtc002 = false;
                                                                  jjtn002.processToken(token);
        } finally {
                                                                                 if (jjtc002) {
                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                 }
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Expr();
      jj_consume_token(Rbrace);
                                                                                                                                                           SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                           boolean jjtc003 = true;
                                                                                                                                                           jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                           jjtc003 = false;
                                                                                                                 jjtn003.processToken(token);
      } finally {
                                                                                                                                                           if (jjtc003) {
                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                           }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ValidateExpr() throws ParseException {
 /*@bgen(jjtree) ValidateExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTVALIDATEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ValidateLbrace:
        jj_consume_token(ValidateLbrace);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTVALIDATELBRACE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
        try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
        } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
        }
        break;
      case ValidateSchemaMode:
        jj_consume_token(ValidateSchemaMode);
                                                                                                 SimpleNode jjtn002 = new SimpleNode(this, JJTVALIDATESCHEMAMODE);
                                                                                                 boolean jjtc002 = true;
                                                                                                 jjtree.openNodeScope(jjtn002);
        try {
                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 jjtc002 = false;
                                                                          jjtn002.processToken(token);
        } finally {
                                                                                                 if (jjtc002) {
                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 }
        }
        jj_consume_token(LbraceExprEnclosure);
                                                                                                                                                                               SimpleNode jjtn003 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
                                                                                                                                                                               boolean jjtc003 = true;
                                                                                                                                                                               jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               jjtc003 = false;
                                                                                                                              jjtn003.processToken(token);
        } finally {
                                                                                                                                                                               if (jjtc003) {
                                                                                                                                                                                 jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               }
        }
        break;
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Expr();
      jj_consume_token(Rbrace);
                                                                                                                                                                                                                                                          SimpleNode jjtn004 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                                                                                                          boolean jjtc004 = true;
                                                                                                                                                                                                                                                          jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                          jjtc004 = false;
                                                                                                                                                                              jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                                                          if (jjtc004) {
                                                                                                                                                                                                                                                            jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                          }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void UnaryExpr() throws ParseException {
 /*@bgen(jjtree) #UnaryExpr( keepUnary) */
 SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean keepUnary=false;
    try {
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UnaryMinus:
        case UnaryPlus:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_21;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UnaryMinus:
          jj_consume_token(UnaryMinus);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTUNARYMINUS);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
          try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                keepUnary=true;jjtn001.processToken(token);
          } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
          }
          break;
        case UnaryPlus:
          jj_consume_token(UnaryPlus);
                                                                                              SimpleNode jjtn002 = new SimpleNode(this, JJTUNARYPLUS);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
          try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                           keepUnary=true;jjtn002.processToken(token);
          } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
          }
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      ValueExpr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  keepUnary);
    }
    }
  }


  final public void CaseClause() throws ParseException {
 /*@bgen(jjtree) CaseClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCASECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Case);
          SimpleNode jjtn001 = new SimpleNode(this, JJTCASE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
      try {
          jjtree.closeNodeScope(jjtn001,  true);
          jjtc001 = false;
         jjtn001.processToken(token);
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  true);
          }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VariableIndicator:
        jj_consume_token(VariableIndicator);
        jj_consume_token(VarName);
                                                                                   SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
                                                                                   boolean jjtc002 = true;
                                                                                   jjtree.openNodeScope(jjtn002);
        try {
                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                   jjtc002 = false;
                                                                      jjtn002.processToken(token);
        } finally {
                                                                                   if (jjtc002) {
                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                   }
        }
        jj_consume_token(As);
                                                                                                                                     SimpleNode jjtn003 = new SimpleNode(this, JJTAS);
                                                                                                                                     boolean jjtc003 = true;
                                                                                                                                     jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                     jjtc003 = false;
                                                                                                         jjtn003.processToken(token);
        } finally {
                                                                                                                                     if (jjtc003) {
                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                     }
        }
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      SequenceType();
      jj_consume_token(Return);
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirCommentContents() throws ParseException {
 /*@bgen(jjtree) DirCommentContents */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRCOMMENTCONTENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CommentContentChar:
        case CommentContentCharDash:
          ;
          break;
        default:
          jj_la1[125] = jj_gen;
          break label_29;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CommentContentChar:
          jj_consume_token(CommentContentChar);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTCONTENTCHAR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
          try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
          } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
          }
          break;
        case CommentContentCharDash:
          jj_consume_token(CommentContentCharDash);
                                                                                                             SimpleNode jjtn002 = new SimpleNode(this, JJTCOMMENTCONTENTCHARDASH);
                                                                                                             boolean jjtc002 = true;
                                                                                                             jjtree.openNodeScope(jjtn002);
          try {
                                                                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                                                                             jjtc002 = false;
                                                                                  jjtn002.processToken(token);
          } finally {
                                                                                                             if (jjtc002) {
                                                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                                                             }
          }
          break;
        default:
          jj_la1[126] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void SchemaElementTest() throws ParseException {
 /*@bgen(jjtree) SchemaElementTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAELEMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SchemaElementType:
        jj_consume_token(SchemaElementType);
                        SimpleNode jjtn001 = new SimpleNode(this, JJTSCHEMAELEMENTTYPE);
                        boolean jjtc001 = true;
                        jjtree.openNodeScope(jjtn001);
        try {
                        jjtree.closeNodeScope(jjtn001,  true);
                        jjtc001 = false;
                       jjtn001.processToken(token);
        } finally {
                        if (jjtc001) {
                          jjtree.closeNodeScope(jjtn001,  true);
                        }
        }
        break;
      case SchemaElementTypeForKindTest:
        jj_consume_token(SchemaElementTypeForKindTest);
                                                                                                                SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAELEMENTTYPEFORKINDTEST);
                                                                                                                boolean jjtc002 = true;
                                                                                                                jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                jjtc002 = false;
                                                                                      jjtn002.processToken(token);
        } finally {
                                                                                                                if (jjtc002) {
                                                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                }
        }
        break;
      case SchemaElementTypeForDocumentTest:
        jj_consume_token(SchemaElementTypeForDocumentTest);
                                                                                                                                                                                                                       SimpleNode jjtn003 = new SimpleNode(this, JJTSCHEMAELEMENTTYPEFORDOCUMENTTEST);
                                                                                                                                                                                                                       boolean jjtc003 = true;
                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                       jjtc003 = false;
                                                                                                                                                         jjtn003.processToken(token);
        } finally {
                                                                                                                                                                                                                       if (jjtc003) {
                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                       }
        }
        break;
      default:
        jj_la1[165] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ElementDeclaration();
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #AdditiveExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      MultiplicativeExpr();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Minus:
        case Plus:
          ;
          break;
        default:
          jj_la1[65] = jj_gen;
          break label_17;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Plus:
          jj_consume_token(Plus);
          binaryTokenStack.push(token);
          break;
        case Minus:
          jj_consume_token(Minus);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        MultiplicativeExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTADDITIVEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void IntersectExceptExpr() throws ParseException {
 /*@bgen(jjtree) #IntersectExceptExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINTERSECTEXCEPTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      InstanceofExpr();
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Intersect:
        case Except:
          ;
          break;
        default:
          jj_la1[71] = jj_gen;
          break label_20;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Intersect:
          jj_consume_token(Intersect);
          binaryTokenStack.push(token);
          break;
        case Except:
          jj_consume_token(Except);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        InstanceofExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTINTERSECTEXCEPTEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void UnionExpr() throws ParseException {
 /*@bgen(jjtree) #UnionExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTUNIONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      IntersectExceptExpr();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Union:
        case Vbar:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_19;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Union:
          jj_consume_token(Union);
          binaryTokenStack.push(token);
          break;
        case Vbar:
          jj_consume_token(Vbar);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        IntersectExceptExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTUNIONEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void MultiplicativeExpr() throws ParseException {
 /*@bgen(jjtree) #MultiplicativeExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLICATIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      UnionExpr();
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Div:
        case Idiv:
        case Mod:
        case Multiply:
          ;
          break;
        default:
          jj_la1[67] = jj_gen;
          break label_18;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Multiply:
          jj_consume_token(Multiply);
          binaryTokenStack.push(token);
          break;
        case Div:
          jj_consume_token(Div);
          binaryTokenStack.push(token);
          break;
        case Idiv:
          jj_consume_token(Idiv);
          binaryTokenStack.push(token);
          break;
        case Mod:
          jj_consume_token(Mod);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[68] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        UnionExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTMULTIPLICATIVEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void SequenceType() throws ParseException {
 /*@bgen(jjtree) SequenceType */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSEQUENCETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Item:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case QNameForSequenceType:
      case QNameForAtomicType:
        ItemType();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OccurrenceZeroOrOne:
        case OccurrenceZeroOrMore:
        case OccurrenceOneOrMore:
          OccurrenceIndicator();
          break;
        default:
          jj_la1[140] = jj_gen;
          ;
        }
        break;
      case EmptyTok:
        jj_consume_token(EmptyTok);
                                                      SimpleNode jjtn001 = new SimpleNode(this, JJTEMPTYTOK);
                                                      boolean jjtc001 = true;
                                                      jjtree.openNodeScope(jjtn001);
        try {
                                                      jjtree.closeNodeScope(jjtn001,  true);
                                                      jjtc001 = false;
                                                     jjtn001.processToken(token);
        } finally {
                                                      if (jjtc001) {
                                                        jjtree.closeNodeScope(jjtn001,  true);
                                                      }
        }
        break;
      default:
        jj_la1[141] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DocumentTest() throws ParseException {
 /*@bgen(jjtree) DocumentTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDOCUMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DocumentLpar:
        jj_consume_token(DocumentLpar);
                   SimpleNode jjtn001 = new SimpleNode(this, JJTDOCUMENTLPAR);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
        try {
                   jjtree.closeNodeScope(jjtn001,  true);
                   jjtc001 = false;
                  jjtn001.processToken(token);
        } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  true);
                   }
        }
        break;
      case DocumentLparForKindTest:
        jj_consume_token(DocumentLparForKindTest);
                                                                                                 SimpleNode jjtn002 = new SimpleNode(this, JJTDOCUMENTLPARFORKINDTEST);
                                                                                                 boolean jjtc002 = true;
                                                                                                 jjtree.openNodeScope(jjtn002);
        try {
                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 jjtc002 = false;
                                                                            jjtn002.processToken(token);
        } finally {
                                                                                                 if (jjtc002) {
                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 }
        }
        break;
      default:
        jj_la1[147] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
      case SchemaElementType:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ElementType:
        case ElementTypeForKindTest:
        case ElementTypeForDocumentTest:
          ElementTest();
          break;
        case SchemaElementType:
        case SchemaElementTypeForKindTest:
        case SchemaElementTypeForDocumentTest:
          SchemaElementTest();
          break;
        default:
          jj_la1[148] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[149] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ModuleDecl() throws ParseException {
 /*@bgen(jjtree) ModuleDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMODULEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ModuleNamespace);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTMODULENAMESPACE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
      }
      jj_consume_token(NCNameForPrefix);
                                                                                            SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
                                                                                            boolean jjtc002 = true;
                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                            jjtc002 = false;
                                                                    jjtn002.processToken(token);
      } finally {
                                                                                            if (jjtc002) {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                            }
      }
      jj_consume_token(AssignEquals);
                                                                                                                                                                SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
                                                                                                                                                                boolean jjtc003 = true;
                                                                                                                                                                jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                jjtc003 = false;
                                                                                                                 jjtn003.processToken(token);
      } finally {
                                                                                                                                                                if (jjtc003) {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                }
      }
      jj_consume_token(URLLiteral);
                                                                                                                                                                                                                               SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
                                                                                                                                                                                                                               boolean jjtc004 = true;
                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                               jjtc004 = false;
                                                                                                                                                            jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                               if (jjtc004) {
                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                               }
      }
      Separator();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void VersionDecl() throws ParseException {
 /*@bgen(jjtree) VersionDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTVERSIONDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(XQueryVersion);
                   SimpleNode jjtn001 = new SimpleNode(this, JJTXQUERYVERSION);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
      try {
                   jjtree.closeNodeScope(jjtn001,  true);
                   jjtc001 = false;
                  jjtn001.processToken(token);
      } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  true);
                   }
      }
      jj_consume_token(StringLiteralForVersion);
                                                                                                SimpleNode jjtn002 = new SimpleNode(this, JJTSTRINGLITERALFORVERSION);
                                                                                                boolean jjtc002 = true;
                                                                                                jjtree.openNodeScope(jjtn002);
      try {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                                jjtc002 = false;
                                                                          jjtn002.processToken(token);
      } finally {
                                                                                                if (jjtc002) {
                                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                                }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XQueryEncoding:
        jj_consume_token(XQueryEncoding);
                                                                                                                                                                               SimpleNode jjtn003 = new SimpleNode(this, JJTXQUERYENCODING);
                                                                                                                                                                               boolean jjtc003 = true;
                                                                                                                                                                               jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               jjtc003 = false;
                                                                                                                          jjtn003.processToken(token);
        } finally {
                                                                                                                                                                               if (jjtc003) {
                                                                                                                                                                                 jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               }
        }
        jj_consume_token(StringLiteralForVersion);
                                                                                                                                                                                                                                                             SimpleNode jjtn004 = new SimpleNode(this, JJTSTRINGLITERALFORVERSION);
                                                                                                                                                                                                                                                             boolean jjtc004 = true;
                                                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                             jjtc004 = false;
                                                                                                                                                                                  jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                                             if (jjtc004) {
                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                             }
        }
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      Separator();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AttributeTest() throws ParseException {
 /*@bgen(jjtree) AttributeTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AttributeType:
        jj_consume_token(AttributeType);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTATTRIBUTETYPE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
        try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
        } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
        }
        break;
      case AttributeTypeForKindTest:
        jj_consume_token(AttributeTypeForKindTest);
                                                                                                    SimpleNode jjtn002 = new SimpleNode(this, JJTATTRIBUTETYPEFORKINDTEST);
                                                                                                    boolean jjtc002 = true;
                                                                                                    jjtree.openNodeScope(jjtn002);
        try {
                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    jjtc002 = false;
                                                                              jjtn002.processToken(token);
        } finally {
                                                                                                    if (jjtc002) {
                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    }
        }
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AnyName:
      case QNameForItemType:
        AttribNameOrWildcard();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CommaForKindTest:
          jj_consume_token(CommaForKindTest);
                                                                                                                                                                                                                SimpleNode jjtn003 = new SimpleNode(this, JJTCOMMAFORKINDTEST);
                                                                                                                                                                                                                boolean jjtc003 = true;
                                                                                                                                                                                                                jjtree.openNodeScope(jjtn003);
          try {
                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                jjtc003 = false;
                                                                                                                                                          jjtn003.processToken(token);
          } finally {
                                                                                                                                                                                                                if (jjtc003) {
                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                }
          }
          TypeName();
          break;
        default:
          jj_la1[156] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[157] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirPIConstructor() throws ParseException {
 /*@bgen(jjtree) DirPIConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRPICONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ProcessingInstructionStartForElementContent:
        jj_consume_token(ProcessingInstructionStartForElementContent);
                                                  SimpleNode jjtn001 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONSTARTFORELEMENTCONTENT);
                                                  boolean jjtc001 = true;
                                                  jjtree.openNodeScope(jjtn001);
        try {
                                                  jjtree.closeNodeScope(jjtn001,  true);
                                                  jjtc001 = false;
                                                 jjtn001.processToken(token);
        } finally {
                                                  if (jjtc001) {
                                                    jjtree.closeNodeScope(jjtn001,  true);
                                                  }
        }
        break;
      case ProcessingInstructionStart:
        jj_consume_token(ProcessingInstructionStart);
                                                                                                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONSTART);
                                                                                                                                                                  boolean jjtc002 = true;
                                                                                                                                                                  jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                  jjtc002 = false;
                                                                                                              jjtn002.processToken(token);
        } finally {
                                                                                                                                                                  if (jjtc002) {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                  }
        }
        break;
      default:
        jj_la1[127] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(PITarget);
                                                                                                                                                                                                                                              SimpleNode jjtn003 = new SimpleNode(this, JJTPITARGET);
                                                                                                                                                                                                                                              boolean jjtc003 = true;
                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                              jjtc003 = false;
                                                                                                                                                        jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                                                                              if (jjtc003) {
                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                              }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SForPI:
        jj_consume_token(SForPI);
                                                                                                                                                                                                                                                                                                      SimpleNode jjtn004 = new SimpleNode(this, JJTSFORPI);
                                                                                                                                                                                                                                                                                                      boolean jjtc004 = true;
                                                                                                                                                                                                                                                                                                      jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                                                                                      jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                      jjtc004 = false;
                                                                                                                                                                                                jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                      if (jjtc004) {
                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                      }
        }
        DirPIContents();
        break;
      default:
        jj_la1[128] = jj_gen;
        ;
      }
      jj_consume_token(ProcessingInstructionEnd);
                                                                                                                                                                                                                                                                                                                                                                                              SimpleNode jjtn005 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONEND);
                                                                                                                                                                                                                                                                                                                                                                                              boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                                                                              jjtc005 = false;
                                                                                                                                                                                                                                                                          jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                              if (jjtc005) {
                                                                                                                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                                                                              }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DefaultNamespaceDecl() throws ParseException {
 /*@bgen(jjtree) DefaultNamespaceDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTNAMESPACEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DeclareDefaultElement:
        jj_consume_token(DeclareDefaultElement);
                            SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREDEFAULTELEMENT);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
        try {
                            jjtree.closeNodeScope(jjtn001,  true);
                            jjtc001 = false;
                           jjtn001.processToken(token);
        } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  true);
                            }
        }
        break;
      case DeclareDefaultFunction:
        jj_consume_token(DeclareDefaultFunction);
                                                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTDECLAREDEFAULTFUNCTION);
                                                                                                                  boolean jjtc002 = true;
                                                                                                                  jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                  jjtc002 = false;
                                                                                    jjtn002.processToken(token);
        } finally {
                                                                                                                  if (jjtc002) {
                                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                  }
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(Namespace);
                                                                                                                                                                                           SimpleNode jjtn003 = new SimpleNode(this, JJTNAMESPACE);
                                                                                                                                                                                           boolean jjtc003 = true;
                                                                                                                                                                                           jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                           jjtc003 = false;
                                                                                                                               jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                           if (jjtc003) {
                                                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                           }
      }
      jj_consume_token(URLLiteral);
                                                                                                                                                                                                                                                       SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
                                                                                                                                                                                                                                                       boolean jjtc004 = true;
                                                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                       jjtc004 = false;
                                                                                                                                                                          jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                                                       if (jjtc004) {
                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                       }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CommonContent() throws ParseException {
 /*@bgen(jjtree) CommonContent */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMMONCONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PredefinedEntityRef:
        jj_consume_token(PredefinedEntityRef);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTPREDEFINEDENTITYREF);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
        }
        break;
      case CharRef:
        jj_consume_token(CharRef);
                                                                                               SimpleNode jjtn002 = new SimpleNode(this, JJTCHARREF);
                                                                                               boolean jjtc002 = true;
                                                                                               jjtree.openNodeScope(jjtn002);
        try {
                                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                                               jjtc002 = false;
                                                                   jjtn002.processToken(token);
        } finally {
                                                                                               if (jjtc002) {
                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                               }
        }
        break;
      case LCurlyBraceEscape:
        jj_consume_token(LCurlyBraceEscape);
                                                                                                                                                                  SimpleNode jjtn003 = new SimpleNode(this, JJTLCURLYBRACEESCAPE);
                                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                                  jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  jjtc003 = false;
                                                                                                                       jjtn003.processToken(token);
        } finally {
                                                                                                                                                                  if (jjtc003) {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  }
        }
        break;
      case RCurlyBraceEscape:
        jj_consume_token(RCurlyBraceEscape);
                                                                                                                                                                                                                                               SimpleNode jjtn004 = new SimpleNode(this, JJTRCURLYBRACEESCAPE);
                                                                                                                                                                                                                                               boolean jjtc004 = true;
                                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                               jjtc004 = false;
                                                                                                                                                                           jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                               if (jjtc004) {
                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                               }
        }
        break;
      case Lbrace:
      case LbraceExprEnclosure:
        EnclosedExpr();
        break;
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void SchemaImport() throws ParseException {
 /*@bgen(jjtree) SchemaImport */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ImportSchemaToken);
                       SimpleNode jjtn001 = new SimpleNode(this, JJTIMPORTSCHEMATOKEN);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
      try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
      } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Namespace:
      case DefaultElement:
        SchemaPrefix();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      jj_consume_token(URLLiteral);
                                                                                                            SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
                                                                                                            boolean jjtc002 = true;
                                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            jjtc002 = false;
                                                                                  jjtn002.processToken(token);
      } finally {
                                                                                                            if (jjtc002) {
                                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AtStringLiteral:
        jj_consume_token(AtStringLiteral);
                                                                                                                                                                               SimpleNode jjtn003 = new SimpleNode(this, JJTATSTRINGLITERAL);
                                                                                                                                                                               boolean jjtc003 = true;
                                                                                                                                                                               jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               jjtc003 = false;
                                                                                                                                   jjtn003.processToken(token);
        } finally {
                                                                                                                                                                               if (jjtc003) {
                                                                                                                                                                                 jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               }
        }
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_5;
          }
          jj_consume_token(Comma);
          jj_consume_token(StringLiteral);
                                                                                                                                                                                                                                                             SimpleNode jjtn004 = new SimpleNode(this, JJTSTRINGLITERAL);
                                                                                                                                                                                                                                                             boolean jjtc004 = true;
                                                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn004);
          try {
                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                             jjtc004 = false;
                                                                                                                                                                                          jjtn004.processToken(token);
          } finally {
                                                                                                                                                                                                                                                             if (jjtc004) {
                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                             }
          }
        }
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void VarDecl() throws ParseException {
 /*@bgen(jjtree) VarDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DefineVariable);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTDEFINEVARIABLE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
      }
      jj_consume_token(VarName);
                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
      try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                           jjtn002.processToken(token);
      } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case As:
        TypeDeclaration();
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ColonEquals:
        jj_consume_token(ColonEquals);
                                                                                                                                                                   SimpleNode jjtn003 = new SimpleNode(this, JJTCOLONEQUALS);
                                                                                                                                                                   boolean jjtc003 = true;
                                                                                                                                                                   jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                   jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                   jjtc003 = false;
                                                                                                                             jjtn003.processToken(token);
        } finally {
                                                                                                                                                                   if (jjtc003) {
                                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                   }
        }
        ExprSingle();
        break;
      case External:
        jj_consume_token(External);
                                                                                                                                                                                                                                               SimpleNode jjtn004 = new SimpleNode(this, JJTEXTERNAL);
                                                                                                                                                                                                                                               boolean jjtc004 = true;
                                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                               jjtc004 = false;
                                                                                                                                                                                      jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                               if (jjtc004) {
                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                               }
        }
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ElementTest() throws ParseException {
 /*@bgen(jjtree) ElementTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
        jj_consume_token(ElementType);
                  SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTTYPE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  true);
                  jjtc001 = false;
                 jjtn001.processToken(token);
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  true);
                  }
        }
        break;
      case ElementTypeForKindTest:
        jj_consume_token(ElementTypeForKindTest);
                                                                                              SimpleNode jjtn002 = new SimpleNode(this, JJTELEMENTTYPEFORKINDTEST);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
        try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                          jjtn002.processToken(token);
        } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
        }
        break;
      case ElementTypeForDocumentTest:
        jj_consume_token(ElementTypeForDocumentTest);
                                                                                                                                                                                         SimpleNode jjtn003 = new SimpleNode(this, JJTELEMENTTYPEFORDOCUMENTTEST);
                                                                                                                                                                                         boolean jjtc003 = true;
                                                                                                                                                                                         jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                                         jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                         jjtc003 = false;
                                                                                                                                       jjtn003.processToken(token);
        } finally {
                                                                                                                                                                                         if (jjtc003) {
                                                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                         }
        }
        break;
      default:
        jj_la1[160] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AnyName:
      case QNameForItemType:
        ElementNameOrWildcard();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CommaForKindTest:
          jj_consume_token(CommaForKindTest);
                                                                                                                                                                                                                                                                                                        SimpleNode jjtn004 = new SimpleNode(this, JJTCOMMAFORKINDTEST);
                                                                                                                                                                                                                                                                                                        boolean jjtc004 = true;
                                                                                                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn004);
          try {
                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                        jjtc004 = false;
                                                                                                                                                                                                                    jjtn004.processToken(token);
          } finally {
                                                                                                                                                                                                                                                                                                        if (jjtc004) {
                                                                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                        }
          }
          TypeName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Nillable:
            jj_consume_token(Nillable);
                                                                                                                                                                                                                                                                                                                                                                                     SimpleNode jjtn005 = new SimpleNode(this, JJTNILLABLE);
                                                                                                                                                                                                                                                                                                                                                                                     boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                                                                                     jjtree.openNodeScope(jjtn005);
            try {
                                                                                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                                                                     jjtc005 = false;
                                                                                                                                                                                                                                                                         jjtn005.processToken(token);
            } finally {
                                                                                                                                                                                                                                                                                                                                                                                     if (jjtc005) {
                                                                                                                                                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                                                                     }
            }
            break;
          default:
            jj_la1[161] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[162] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[163] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void LetClause() throws ParseException {
 /*@bgen(jjtree) LetClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTLETCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LetVariable);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTLETVARIABLE);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
      try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
      } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
      }
      jj_consume_token(VarName);
                                                                            SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
                                                                            boolean jjtc002 = true;
                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                            jjtc002 = false;
                                                        jjtn002.processToken(token);
      } finally {
                                                                            if (jjtc002) {
                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                            }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case As:
        TypeDeclaration();
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      jj_consume_token(ColonEquals);
                                                                                                                                                           SimpleNode jjtn003 = new SimpleNode(this, JJTCOLONEQUALS);
                                                                                                                                                           boolean jjtc003 = true;
                                                                                                                                                           jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                           jjtc003 = false;
                                                                                                                        jjtn003.processToken(token);
      } finally {
                                                                                                                                                           if (jjtc003) {
                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                           }
      }
      ExprSingle();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_11;
        }
        jj_consume_token(Comma);
        jj_consume_token(VariableIndicator);
        jj_consume_token(VarName);
                                                                                                                                                                                                                                                                SimpleNode jjtn004 = new SimpleNode(this, JJTVARNAME);
                                                                                                                                                                                                                                                                boolean jjtc004 = true;
                                                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                jjtc004 = false;
                                                                                                                                                                                                          jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                if (jjtc004) {
                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case As:
          TypeDeclaration();
          break;
        default:
          jj_la1[45] = jj_gen;
          ;
        }
        jj_consume_token(ColonEquals);
                                                                                                                                                                                                                                                                                                                                               SimpleNode jjtn005 = new SimpleNode(this, JJTCOLONEQUALS);
                                                                                                                                                                                                                                                                                                                                               boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                               jjtc005 = false;
                                                                                                                                                                                                                                                                          jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                               if (jjtc005) {
                                                                                                                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                                               }
        }
        ExprSingle();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void FunctionDecl() throws ParseException {
 /*@bgen(jjtree) FunctionDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTIONDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DefineFunction);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTDEFINEFUNCTION);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
      }
      jj_consume_token(QNameLpar);
                                                                                    SimpleNode jjtn002 = new SimpleNode(this, JJTQNAMELPAR);
                                                                                    boolean jjtc002 = true;
                                                                                    jjtree.openNodeScope(jjtn002);
      try {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                    jjtc002 = false;
                                                             jjtn002.processToken(token);
      } finally {
                                                                                    if (jjtc002) {
                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                    }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VariableIndicator:
        ParamList();
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      jj_consume_token(Rpar);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case As:
        jj_consume_token(As);
                                                                                                                                                                SimpleNode jjtn003 = new SimpleNode(this, JJTAS);
                                                                                                                                                                boolean jjtc003 = true;
                                                                                                                                                                jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                jjtc003 = false;
                                                                                                                        jjtn003.processToken(token);
        } finally {
                                                                                                                                                                if (jjtc003) {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                }
        }
        SequenceType();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Lbrace:
      case LbraceExprEnclosure:
        EnclosedExpr();
        break;
      case External:
        jj_consume_token(External);
                                                                                                                                                                                                                                                       SimpleNode jjtn004 = new SimpleNode(this, JJTEXTERNAL);
                                                                                                                                                                                                                                                       boolean jjtc004 = true;
                                                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                       jjtc004 = false;
                                                                                                                                                                                                     jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                                       if (jjtc004) {
                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                       }
        }
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ReverseAxis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisParent:
      jj_consume_token(AxisParent);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTAXISPARENT);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
      try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
      } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
      }
      break;
    case AxisAncestor:
      jj_consume_token(AxisAncestor);
                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTAXISANCESTOR);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
      try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                               jjtn002.processToken(token);
      } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
      }
      break;
    case AxisPrecedingSibling:
      jj_consume_token(AxisPrecedingSibling);
                                                                                                                                                             SimpleNode jjtn003 = new SimpleNode(this, JJTAXISPRECEDINGSIBLING);
                                                                                                                                                             boolean jjtc003 = true;
                                                                                                                                                             jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                             jjtc003 = false;
                                                                                                                      jjtn003.processToken(token);
      } finally {
                                                                                                                                                             if (jjtc003) {
                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                             }
      }
      break;
    case AxisPreceding:
      jj_consume_token(AxisPreceding);
                                                                                                                                                                                                                                         SimpleNode jjtn004 = new SimpleNode(this, JJTAXISPRECEDING);
                                                                                                                                                                                                                                         boolean jjtc004 = true;
                                                                                                                                                                                                                                         jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         jjtc004 = false;
                                                                                                                                                                      jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                                         if (jjtc004) {
                                                                                                                                                                                                                                           jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         }
      }
      break;
    case AxisAncestorOrSelf:
      jj_consume_token(AxisAncestorOrSelf);
                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn005 = new SimpleNode(this, JJTAXISANCESTORORSELF);
                                                                                                                                                                                                                                                                                                                   boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                   jjtc005 = false;
                                                                                                                                                                                                                           jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                   if (jjtc005) {
                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                   }
      }
      break;
    default:
      jj_la1[94] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void SchemaPrefix() throws ParseException {
 /*@bgen(jjtree) SchemaPrefix */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSCHEMAPREFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Namespace:
        jj_consume_token(Namespace);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTNAMESPACE);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
        try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
        } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
        }
        jj_consume_token(NCNameForPrefix);
                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
        try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                                jjtn002.processToken(token);
        } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
        }
        jj_consume_token(AssignEquals);
                                                                                                                                                      SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
                                                                                                                                                      boolean jjtc003 = true;
                                                                                                                                                      jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                      jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                      jjtc003 = false;
                                                                                                             jjtn003.processToken(token);
        } finally {
                                                                                                                                                      if (jjtc003) {
                                                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                      }
        }
        break;
      case DefaultElement:
        jj_consume_token(DefaultElement);
                                                                                                                                                                                                                             SimpleNode jjtn004 = new SimpleNode(this, JJTDEFAULTELEMENT);
                                                                                                                                                                                                                             boolean jjtc004 = true;
                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                             jjtc004 = false;
                                                                                                                                                                jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                             if (jjtc004) {
                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                             }
        }
        jj_consume_token(Namespace);
                                                                                                                                                                                                                                                                                             SimpleNode jjtn005 = new SimpleNode(this, JJTNAMESPACE);
                                                                                                                                                                                                                                                                                             boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                             jjtc005 = false;
                                                                                                                                                                                                          jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                             if (jjtc005) {
                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                             }
        }
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirAttributeList() throws ParseException {
 /*@bgen(jjtree) DirAttributeList */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRATTRIBUTELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          ;
          break;
        default:
          jj_la1[111] = jj_gen;
          break label_26;
        }
        jj_consume_token(S);
        SimpleNode jjtn001 = new SimpleNode(this, JJTS);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        try {
        jjtree.closeNodeScope(jjtn001,  true);
        jjtc001 = false;
       jjtn001.processToken(token);
        } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  true);
        }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TagQName:
          jj_consume_token(TagQName);
                                                           SimpleNode jjtn002 = new SimpleNode(this, JJTTAGQNAME);
                                                           boolean jjtc002 = true;
                                                           jjtree.openNodeScope(jjtn002);
          try {
                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                           jjtc002 = false;
                                                 jjtn002.processToken(token);
          } finally {
                                                           if (jjtc002) {
                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                           }
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            jj_consume_token(S);
                                                                                                              SimpleNode jjtn003 = new SimpleNode(this, JJTS);
                                                                                                              boolean jjtc003 = true;
                                                                                                              jjtree.openNodeScope(jjtn003);
            try {
                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                              jjtc003 = false;
                                                                                    jjtn003.processToken(token);
            } finally {
                                                                                                              if (jjtc003) {
                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                              }
            }
            break;
          default:
            jj_la1[112] = jj_gen;
            ;
          }
          jj_consume_token(ValueIndicator);
                                                                                                                                                                       SimpleNode jjtn004 = new SimpleNode(this, JJTVALUEINDICATOR);
                                                                                                                                                                       boolean jjtc004 = true;
                                                                                                                                                                       jjtree.openNodeScope(jjtn004);
          try {
                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                       jjtc004 = false;
                                                                                                                                    jjtn004.processToken(token);
          } finally {
                                                                                                                                                                       if (jjtc004) {
                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                       }
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case S:
            jj_consume_token(S);
                                                                                                                                                                                                                                SimpleNode jjtn005 = new SimpleNode(this, JJTS);
                                                                                                                                                                                                                                boolean jjtc005 = true;
                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn005);
            try {
                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                jjtc005 = false;
                                                                                                                                                                       jjtn005.processToken(token);
            } finally {
                                                                                                                                                                                                                                if (jjtc005) {
                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                }
            }
            break;
          default:
            jj_la1[113] = jj_gen;
            ;
          }
          DirAttributeValue();
          break;
        default:
          jj_la1[114] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void InheritNamespacesDecl() throws ParseException {
 /*@bgen(jjtree) InheritNamespacesDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINHERITNAMESPACESDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareInheritNamespaces);
                              SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREINHERITNAMESPACES);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  true);
                              jjtc001 = false;
                             jjtn001.processToken(token);
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  true);
                              }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Yes:
        jj_consume_token(Yes);
                                                                                                   SimpleNode jjtn002 = new SimpleNode(this, JJTYES);
                                                                                                   boolean jjtc002 = true;
                                                                                                   jjtree.openNodeScope(jjtn002);
        try {
                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                   jjtc002 = false;
                                                                  jjtn002.processToken(token);
        } finally {
                                                                                                   if (jjtc002) {
                                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                                   }
        }
        break;
      case No:
        jj_consume_token(No);
                                                                                                                                                   SimpleNode jjtn003 = new SimpleNode(this, JJTNO);
                                                                                                                                                   boolean jjtc003 = true;
                                                                                                                                                   jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                   jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                   jjtc003 = false;
                                                                                                       jjtn003.processToken(token);
        } finally {
                                                                                                                                                   if (jjtc003) {
                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                   }
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void EmptyOrderingDecl() throws ParseException {
 /*@bgen(jjtree) EmptyOrderingDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTYORDERINGDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareDefaultOrderingEmpty);
                                 SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREDEFAULTORDERINGEMPTY);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
      try {
                                 jjtree.closeNodeScope(jjtn001,  true);
                                 jjtc001 = false;
                                jjtn001.processToken(token);
      } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  true);
                                 }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EmptyGreatest:
        jj_consume_token(EmptyGreatest);
                                                                                                                   SimpleNode jjtn002 = new SimpleNode(this, JJTEMPTYGREATEST);
                                                                                                                   boolean jjtc002 = true;
                                                                                                                   jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                   jjtc002 = false;
                                                                               jjtn002.processToken(token);
        } finally {
                                                                                                                   if (jjtc002) {
                                                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                   }
        }
        break;
      case EmptyLeast:
        jj_consume_token(EmptyLeast);
                                                                                                                                                                                     SimpleNode jjtn003 = new SimpleNode(this, JJTEMPTYLEAST);
                                                                                                                                                                                     boolean jjtc003 = true;
                                                                                                                                                                                     jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                     jjtc003 = false;
                                                                                                                            jjtn003.processToken(token);
        } finally {
                                                                                                                                                                                     if (jjtc003) {
                                                                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                     }
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderingModeDecl() throws ParseException {
 /*@bgen(jjtree) OrderingModeDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTORDERINGMODEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareOrdering);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREORDERING);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Ordered:
        jj_consume_token(Ordered);
                                                                                     SimpleNode jjtn002 = new SimpleNode(this, JJTORDERED);
                                                                                     boolean jjtc002 = true;
                                                                                     jjtree.openNodeScope(jjtn002);
        try {
                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                     jjtc002 = false;
                                                             jjtn002.processToken(token);
        } finally {
                                                                                     if (jjtc002) {
                                                                                       jjtree.closeNodeScope(jjtn002,  true);
                                                                                     }
        }
        break;
      case Unordered:
        jj_consume_token(Unordered);
                                                                                                                                                SimpleNode jjtn003 = new SimpleNode(this, JJTUNORDERED);
                                                                                                                                                boolean jjtc003 = true;
                                                                                                                                                jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                jjtc003 = false;
                                                                                                         jjtn003.processToken(token);
        } finally {
                                                                                                                                                if (jjtc003) {
                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                }
        }
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void XMLSpaceDecl() throws ParseException {
 /*@bgen(jjtree) XMLSpaceDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTXMLSPACEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareXMLSpace);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREXMLSPACE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XMLSpacePreserve:
        jj_consume_token(XMLSpacePreserve);
                                                                                              SimpleNode jjtn002 = new SimpleNode(this, JJTXMLSPACEPRESERVE);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
        try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                      jjtn002.processToken(token);
        } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
        }
        break;
      case XMLSpaceStrip:
        jj_consume_token(XMLSpaceStrip);
                                                                                                                                                                      SimpleNode jjtn003 = new SimpleNode(this, JJTXMLSPACESTRIP);
                                                                                                                                                                      boolean jjtc003 = true;
                                                                                                                                                                      jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                      jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                      jjtc003 = false;
                                                                                                                      jjtn003.processToken(token);
        } finally {
                                                                                                                                                                      if (jjtc003) {
                                                                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                      }
        }
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Wildcard() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Star:
      jj_consume_token(Star);
           SimpleNode jjtn001 = new SimpleNode(this, JJTSTAR);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
      try {
           jjtree.closeNodeScope(jjtn001,  true);
           jjtc001 = false;
          jjtn001.processToken(token);
      } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  true);
           }
      }
      break;
    case NCNameColonStar:
      jj_consume_token(NCNameColonStar);
                                                                         SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMECOLONSTAR);
                                                                         boolean jjtc002 = true;
                                                                         jjtree.openNodeScope(jjtn002);
      try {
                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                         jjtc002 = false;
                                                            jjtn002.processToken(token);
      } finally {
                                                                         if (jjtc002) {
                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                         }
      }
      break;
    case StarColonNCName:
      jj_consume_token(StarColonNCName);
                                                                                                                                                  SimpleNode jjtn003 = new SimpleNode(this, JJTSTARCOLONNCNAME);
                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                  jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                  jjtc003 = false;
                                                                                                              jjtn003.processToken(token);
      } finally {
                                                                                                                                                  if (jjtc003) {
                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                  }
      }
      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void NumericLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
      jj_consume_token(IntegerLiteral);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTINTEGERLITERAL);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
      }
      break;
    case DecimalLiteral:
      jj_consume_token(DecimalLiteral);
                                                                                            SimpleNode jjtn002 = new SimpleNode(this, JJTDECIMALLITERAL);
                                                                                            boolean jjtc002 = true;
                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                            jjtc002 = false;
                                                                     jjtn002.processToken(token);
      } finally {
                                                                                            if (jjtc002) {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                            }
      }
      break;
    case DoubleLiteral:
      jj_consume_token(DoubleLiteral);
                                                                                                                                                                  SimpleNode jjtn003 = new SimpleNode(this, JJTDOUBLELITERAL);
                                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                                  jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  jjtc003 = false;
                                                                                                                     jjtn003.processToken(token);
      } finally {
                                                                                                                                                                  if (jjtc003) {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  }
      }
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void OccurrenceIndicator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OccurrenceZeroOrOne:
      jj_consume_token(OccurrenceZeroOrOne);
                          SimpleNode jjtn001 = new SimpleNode(this, JJTOCCURRENCEZEROORONE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
      try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
      } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
      }
      break;
    case OccurrenceZeroOrMore:
      jj_consume_token(OccurrenceZeroOrMore);
                                                                                                            SimpleNode jjtn002 = new SimpleNode(this, JJTOCCURRENCEZEROORMORE);
                                                                                                            boolean jjtc002 = true;
                                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            jjtc002 = false;
                                                                                jjtn002.processToken(token);
      } finally {
                                                                                                            if (jjtc002) {
                                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            }
      }
      break;
    case OccurrenceOneOrMore:
      jj_consume_token(OccurrenceOneOrMore);
                                                                                                                                                                                              SimpleNode jjtn003 = new SimpleNode(this, JJTOCCURRENCEONEORMORE);
                                                                                                                                                                                              boolean jjtc003 = true;
                                                                                                                                                                                              jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              jjtc003 = false;
                                                                                                                                      jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                              if (jjtc003) {
                                                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              }
      }
      break;
    default:
      jj_la1[142] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void AtomicType() throws ParseException {
 /*@bgen(jjtree) AtomicType */
  SimpleNode jjtn000 = new SimpleNode(this, JJTATOMICTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameForAtomicType:
        jj_consume_token(QNameForAtomicType);
                         SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORATOMICTYPE);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
        try {
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                        jjtn001.processToken(token);
        } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  true);
                         }
        }
        break;
      case QNameForSequenceType:
        jj_consume_token(QNameForSequenceType);
                                                                                                          SimpleNode jjtn002 = new SimpleNode(this, JJTQNAMEFORSEQUENCETYPE);
                                                                                                          boolean jjtc002 = true;
                                                                                                          jjtree.openNodeScope(jjtn002);
        try {
                                                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                                                          jjtc002 = false;
                                                                               jjtn002.processToken(token);
        } finally {
                                                                                                          if (jjtc002) {
                                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                                          }
        }
        break;
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void PITest() throws ParseException {
 /*@bgen(jjtree) PITest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPITEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ProcessingInstructionLpar:
        jj_consume_token(ProcessingInstructionLpar);
        break;
      case ProcessingInstructionLparForKindTest:
        jj_consume_token(ProcessingInstructionLparForKindTest);
                                                                         SimpleNode jjtn001 = new SimpleNode(this, JJTPROCESSINGINSTRUCTIONLPARFORKINDTEST);
                                                                         boolean jjtc001 = true;
                                                                         jjtree.openNodeScope(jjtn001);
        try {
                                                                         jjtree.closeNodeScope(jjtn001,  true);
                                                                         jjtc001 = false;
                                                                        jjtn001.processToken(token);
        } finally {
                                                                         if (jjtc001) {
                                                                           jjtree.closeNodeScope(jjtn001,  true);
                                                                         }
        }
        break;
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case StringLiteralForKindTest:
      case NCNameForPI:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NCNameForPI:
          jj_consume_token(NCNameForPI);
                                                                                                                                                                    SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPI);
                                                                                                                                                                    boolean jjtc002 = true;
                                                                                                                                                                    jjtree.openNodeScope(jjtn002);
          try {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                    jjtc002 = false;
                                                                                                                       jjtn002.processToken(token);
          } finally {
                                                                                                                                                                    if (jjtc002) {
                                                                                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                    }
          }
          break;
        case StringLiteralForKindTest:
          jj_consume_token(StringLiteralForKindTest);
                                                                                                                                                                                                                                                  SimpleNode jjtn003 = new SimpleNode(this, JJTSTRINGLITERALFORKINDTEST);
                                                                                                                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                                                                                                                  jjtree.openNodeScope(jjtn003);
          try {
                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                                  jjtc003 = false;
                                                                                                                                                                                  jjtn003.processToken(token);
          } finally {
                                                                                                                                                                                                                                                  if (jjtc003) {
                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                                                  }
          }
          break;
        default:
          jj_la1[153] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[154] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ComparisonExpr() throws ParseException {
 /*@bgen(jjtree) #ComparisonExpr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPARISONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      RangeExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Equals:
      case Is:
      case NotEquals:
      case LtEquals:
      case LtLt:
      case GtEquals:
      case GtGt:
      case FortranEq:
      case FortranNe:
      case FortranGt:
      case FortranGe:
      case FortranLt:
      case FortranLe:
      case Lt:
      case Gt:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FortranEq:
        case FortranNe:
        case FortranGt:
        case FortranGe:
        case FortranLt:
        case FortranLe:
          ValueComp();
          break;
        case Equals:
        case NotEquals:
        case LtEquals:
        case GtEquals:
        case Lt:
        case Gt:
          GeneralComp();
          break;
        case Is:
        case LtLt:
        case GtGt:
          NodeComp();
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        RangeExpr();
                  SimpleNode jjtn001 = new SimpleNode(this, JJTCOMPARISONEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }


  final public void NamespaceDecl() throws ParseException {
 /*@bgen(jjtree) NamespaceDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTNAMESPACEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareNamespace);
                      SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARENAMESPACE);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
      jj_consume_token(NCNameForPrefix);
                                                                                              SimpleNode jjtn002 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
      try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                     jjtn002.processToken(token);
      } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
      }
      jj_consume_token(AssignEquals);
                                                                                                                                                                  SimpleNode jjtn003 = new SimpleNode(this, JJTASSIGNEQUALS);
                                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                                  jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  jjtc003 = false;
                                                                                                                  jjtn003.processToken(token);
      } finally {
                                                                                                                                                                  if (jjtc003) {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  }
      }
      jj_consume_token(URLLiteral);
                                                                                                                                                                                                                                 SimpleNode jjtn004 = new SimpleNode(this, JJTURLLITERAL);
                                                                                                                                                                                                                                 boolean jjtc004 = true;
                                                                                                                                                                                                                                 jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                 jjtc004 = false;
                                                                                                                                                             jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                                 if (jjtc004) {
                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                 }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void OrderModifier() throws ParseException {
 /*@bgen(jjtree) OrderModifier */
  SimpleNode jjtn000 = new SimpleNode(this, JJTORDERMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Ascending:
      case Descending:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Ascending:
          jj_consume_token(Ascending);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTASCENDING);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
          try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
          } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
          }
          break;
        case Descending:
          jj_consume_token(Descending);
                                                                               SimpleNode jjtn002 = new SimpleNode(this, JJTDESCENDING);
                                                                               boolean jjtc002 = true;
                                                                               jjtree.openNodeScope(jjtn002);
          try {
                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                               jjtc002 = false;
                                                             jjtn002.processToken(token);
          } finally {
                                                                               if (jjtc002) {
                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                               }
          }
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EmptyGreatest:
      case EmptyLeast:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EmptyGreatest:
          jj_consume_token(EmptyGreatest);
                                                                                                                                                   SimpleNode jjtn003 = new SimpleNode(this, JJTEMPTYGREATEST);
                                                                                                                                                   boolean jjtc003 = true;
                                                                                                                                                   jjtree.openNodeScope(jjtn003);
          try {
                                                                                                                                                   jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                   jjtc003 = false;
                                                                                                               jjtn003.processToken(token);
          } finally {
                                                                                                                                                   if (jjtc003) {
                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                   }
          }
          break;
        case EmptyLeast:
          jj_consume_token(EmptyLeast);
                                                                                                                                                                                                                     SimpleNode jjtn004 = new SimpleNode(this, JJTEMPTYLEAST);
                                                                                                                                                                                                                     boolean jjtc004 = true;
                                                                                                                                                                                                                     jjtree.openNodeScope(jjtn004);
          try {
                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                     jjtc004 = false;
                                                                                                                                                            jjtn004.processToken(token);
          } finally {
                                                                                                                                                                                                                     if (jjtc004) {
                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                     }
          }
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Collation:
        jj_consume_token(Collation);
                                                                                                                                                                                                                                                                                    SimpleNode jjtn005 = new SimpleNode(this, JJTCOLLATION);
                                                                                                                                                                                                                                                                                    boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                    jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                    jjtc005 = false;
                                                                                                                                                                                                         jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                    if (jjtc005) {
                                                                                                                                                                                                                                                                                      jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                    }
        }
        jj_consume_token(StringLiteral);
                                                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn006 = new SimpleNode(this, JJTSTRINGLITERAL);
                                                                                                                                                                                                                                                                                                                                                   boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                   jjtc006 = false;
                                                                                                                                                                                                                                                       jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                   if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                   }
        }
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ForwardAxis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
      jj_consume_token(AxisChild);
                SimpleNode jjtn001 = new SimpleNode(this, JJTAXISCHILD);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
      try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
      } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
      }
      break;
    case AxisDescendant:
      jj_consume_token(AxisDescendant);
                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTAXISDESCENDANT);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
      try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                                jjtn002.processToken(token);
      } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
      }
      break;
    case AxisAttribute:
      jj_consume_token(AxisAttribute);
                                                                                                                                                        SimpleNode jjtn003 = new SimpleNode(this, JJTAXISATTRIBUTE);
                                                                                                                                                        boolean jjtc003 = true;
                                                                                                                                                        jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                        jjtc003 = false;
                                                                                                                jjtn003.processToken(token);
      } finally {
                                                                                                                                                        if (jjtc003) {
                                                                                                                                                          jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                        }
      }
      break;
    case AxisSelf:
      jj_consume_token(AxisSelf);
                                                                                                                                                                                                                        SimpleNode jjtn004 = new SimpleNode(this, JJTAXISSELF);
                                                                                                                                                                                                                        boolean jjtc004 = true;
                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                        jjtc004 = false;
                                                                                                                                                           jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                        if (jjtc004) {
                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                        }
      }
      break;
    case AxisDescendantOrSelf:
      jj_consume_token(AxisDescendantOrSelf);
                                                                                                                                                                                                                                                                                               SimpleNode jjtn005 = new SimpleNode(this, JJTAXISDESCENDANTORSELF);
                                                                                                                                                                                                                                                                                               boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                               jjtc005 = false;
                                                                                                                                                                                                                  jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                               if (jjtc005) {
                                                                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                               }
      }
      break;
    case AxisFollowingSibling:
      jj_consume_token(AxisFollowingSibling);
                                                                                                                                                                                                                                                                                                                                                                                  SimpleNode jjtn006 = new SimpleNode(this, JJTAXISFOLLOWINGSIBLING);
                                                                                                                                                                                                                                                                                                                                                                                  boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                                                  jjtree.openNodeScope(jjtn006);
      try {
                                                                                                                                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                  jjtc006 = false;
                                                                                                                                                                                                                                                                         jjtn006.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                  if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                  }
      }
      break;
    case AxisFollowing:
      jj_consume_token(AxisFollowing);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              SimpleNode jjtn007 = new SimpleNode(this, JJTAXISFOLLOWING);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn007);
      try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtc007 = false;
                                                                                                                                                                                                                                                                                                                         jjtn007.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
      }
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void QuantifiedExpr() throws ParseException {
 /*@bgen(jjtree) QuantifiedExpr */
  SimpleNode jjtn000 = new SimpleNode(this, JJTQUANTIFIEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Some:
        jj_consume_token(Some);
           SimpleNode jjtn001 = new SimpleNode(this, JJTSOME);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
        try {
           jjtree.closeNodeScope(jjtn001,  true);
           jjtc001 = false;
          jjtn001.processToken(token);
        } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  true);
           }
        }
        break;
      case Every:
        jj_consume_token(Every);
                                                               SimpleNode jjtn002 = new SimpleNode(this, JJTEVERY);
                                                               boolean jjtc002 = true;
                                                               jjtree.openNodeScope(jjtn002);
        try {
                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                               jjtc002 = false;
                                                  jjtn002.processToken(token);
        } finally {
                                                               if (jjtc002) {
                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                               }
        }
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(VarName);
                                                                                                                     SimpleNode jjtn003 = new SimpleNode(this, JJTVARNAME);
                                                                                                                     boolean jjtc003 = true;
                                                                                                                     jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                     jjtc003 = false;
                                                                                           jjtn003.processToken(token);
      } finally {
                                                                                                                     if (jjtc003) {
                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                     }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case As:
        TypeDeclaration();
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      jj_consume_token(In);
                                                                                                                                                                                           SimpleNode jjtn004 = new SimpleNode(this, JJTIN);
                                                                                                                                                                                           boolean jjtc004 = true;
                                                                                                                                                                                           jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                           jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                           jjtc004 = false;
                                                                                                                                                  jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                           if (jjtc004) {
                                                                                                                                                                                             jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                           }
      }
      ExprSingle();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[55] = jj_gen;
          break label_13;
        }
        jj_consume_token(Comma);
        jj_consume_token(VariableIndicator);
        jj_consume_token(VarName);
                                                                                                                                                                                                                                                                                       SimpleNode jjtn005 = new SimpleNode(this, JJTVARNAME);
                                                                                                                                                                                                                                                                                       boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                       jjtc005 = false;
                                                                                                                                                                                                                                    jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                       if (jjtc005) {
                                                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                       }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case As:
          TypeDeclaration();
          break;
        default:
          jj_la1[56] = jj_gen;
          ;
        }
        jj_consume_token(In);
                                                                                                                                                                                                                                                                                                                                                             SimpleNode jjtn006 = new SimpleNode(this, JJTIN);
                                                                                                                                                                                                                                                                                                                                                             boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                             jjtc006 = false;
                                                                                                                                                                                                                                                                                           jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                             if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                             }
        }
        ExprSingle();
      }
      jj_consume_token(Satisfies);
                                                                                                                                                                                                                                                                                                                                                                                                                                SimpleNode jjtn007 = new SimpleNode(this, JJTSATISFIES);
                                                                                                                                                                                                                                                                                                                                                                                                                                boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn007);
      try {
                                                                                                                                                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                jjtc007 = false;
                                                                                                                                                                                                                                                                                                                                                    jjtn007.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                }
      }
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ModuleImport() throws ParseException {
 /*@bgen(jjtree) ModuleImport */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMODULEIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ImportModuleToken);
                       SimpleNode jjtn001 = new SimpleNode(this, JJTIMPORTMODULETOKEN);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
      try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
      } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Namespace:
        jj_consume_token(Namespace);
                                                                                           SimpleNode jjtn002 = new SimpleNode(this, JJTNAMESPACE);
                                                                                           boolean jjtc002 = true;
                                                                                           jjtree.openNodeScope(jjtn002);
        try {
                                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                                           jjtc002 = false;
                                                                 jjtn002.processToken(token);
        } finally {
                                                                                           if (jjtc002) {
                                                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                                                           }
        }
        jj_consume_token(NCNameForPrefix);
                                                                                                                                                            SimpleNode jjtn003 = new SimpleNode(this, JJTNCNAMEFORPREFIX);
                                                                                                                                                            boolean jjtc003 = true;
                                                                                                                                                            jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                            jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                            jjtc003 = false;
                                                                                                                 jjtn003.processToken(token);
        } finally {
                                                                                                                                                            if (jjtc003) {
                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                            }
        }
        jj_consume_token(AssignEquals);
                                                                                                                                                                                                                                SimpleNode jjtn004 = new SimpleNode(this, JJTASSIGNEQUALS);
                                                                                                                                                                                                                                boolean jjtc004 = true;
                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                jjtc004 = false;
                                                                                                                                                              jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                if (jjtc004) {
                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                }
        }
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jj_consume_token(URLLiteral);
                                                                                                                                                                                                                                                                                                SimpleNode jjtn005 = new SimpleNode(this, JJTURLLITERAL);
                                                                                                                                                                                                                                                                                                boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                jjtc005 = false;
                                                                                                                                                                                                          jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                if (jjtc005) {
                                                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AtStringLiteral:
        jj_consume_token(AtStringLiteral);
                                                                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn006 = new SimpleNode(this, JJTATSTRINGLITERAL);
                                                                                                                                                                                                                                                                                                                                                                   boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                   jjtc006 = false;
                                                                                                                                                                                                                                                           jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                                   if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                   }
        }
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[22] = jj_gen;
            break label_6;
          }
          jj_consume_token(Comma);
          jj_consume_token(StringLiteral);
                                                                                                                                                                                                                                                                                                                                                                                                                                                 SimpleNode jjtn007 = new SimpleNode(this, JJTSTRINGLITERAL);
                                                                                                                                                                                                                                                                                                                                                                                                                                                 boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                 jjtree.openNodeScope(jjtn007);
          try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                 jjtc007 = false;
                                                                                                                                                                                                                                                                                                                  jjtn007.processToken(token);
          } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                 if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
          }
        }
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void BaseURIDecl() throws ParseException {
 /*@bgen(jjtree) BaseURIDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTBASEURIDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareBaseURI);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTDECLAREBASEURI);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
      }
      jj_consume_token(URLLiteral);
                                                                                     SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
                                                                                     boolean jjtc002 = true;
                                                                                     jjtree.openNodeScope(jjtn002);
      try {
                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                     jjtc002 = false;
                                                              jjtn002.processToken(token);
      } finally {
                                                                                     if (jjtc002) {
                                                                                       jjtree.closeNodeScope(jjtn002,  true);
                                                                                     }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ConstructionDecl() throws ParseException {
 /*@bgen(jjtree) ConstructionDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTIONDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareConstruction);
                         SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARECONSTRUCTION);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
      try {
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                        jjtn001.processToken(token);
      } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  true);
                         }
      }
      jj_consume_token(SchemaModeForDeclareConstruction);
                                                                                                                     SimpleNode jjtn002 = new SimpleNode(this, JJTSCHEMAMODEFORDECLARECONSTRUCTION);
                                                                                                                     boolean jjtc002 = true;
                                                                                                                     jjtree.openNodeScope(jjtn002);
      try {
                                                                                                                     jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                     jjtc002 = false;
                                                                                         jjtn002.processToken(token);
      } finally {
                                                                                                                     if (jjtc002) {
                                                                                                                       jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                     }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DefaultCollationDecl() throws ParseException {
 /*@bgen(jjtree) DefaultCollationDecl */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTCOLLATIONDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DeclareCollation);
                      SimpleNode jjtn001 = new SimpleNode(this, JJTDECLARECOLLATION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
      jj_consume_token(URLLiteral);
                                                                                         SimpleNode jjtn002 = new SimpleNode(this, JJTURLLITERAL);
                                                                                         boolean jjtc002 = true;
                                                                                         jjtree.openNodeScope(jjtn002);
      try {
                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                         jjtc002 = false;
                                                                jjtn002.processToken(token);
      } finally {
                                                                                         if (jjtc002) {
                                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                                         }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void PositionalVar() throws ParseException {
 /*@bgen(jjtree) PositionalVar */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPOSITIONALVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(AtWord);
            SimpleNode jjtn001 = new SimpleNode(this, JJTATWORD);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
      try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
      } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
      }
      jj_consume_token(VariableIndicator);
      jj_consume_token(VarName);
                                                                                      SimpleNode jjtn002 = new SimpleNode(this, JJTVARNAME);
                                                                                      boolean jjtc002 = true;
                                                                                      jjtree.openNodeScope(jjtn002);
      try {
                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                      jjtc002 = false;
                                                                       jjtn002.processToken(token);
      } finally {
                                                                                      if (jjtc002) {
                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                      }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CommentTest() throws ParseException {
 /*@bgen(jjtree) CommentTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CommentLpar:
        jj_consume_token(CommentLpar);
        break;
      case CommentLparForKindTest:
        jj_consume_token(CommentLparForKindTest);
                                             SimpleNode jjtn001 = new SimpleNode(this, JJTCOMMENTLPARFORKINDTEST);
                                             boolean jjtc001 = true;
                                             jjtree.openNodeScope(jjtn001);
        try {
                                             jjtree.closeNodeScope(jjtn001,  true);
                                             jjtc001 = false;
                                            jjtn001.processToken(token);
        } finally {
                                             if (jjtc001) {
                                               jjtree.closeNodeScope(jjtn001,  true);
                                             }
        }
        break;
      default:
        jj_la1[151] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void TextTest() throws ParseException {
 /*@bgen(jjtree) TextTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTEXTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TextLpar:
        jj_consume_token(TextLpar);
        break;
      case TextLparForKindTest:
        jj_consume_token(TextLparForKindTest);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTTEXTLPARFORKINDTEST);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      default:
        jj_la1[150] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AnyKindTest() throws ParseException {
 /*@bgen(jjtree) AnyKindTest */
  SimpleNode jjtn000 = new SimpleNode(this, JJTANYKINDTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NodeLpar:
        jj_consume_token(NodeLpar);
        break;
      case NodeLparForKindTest:
        jj_consume_token(NodeLparForKindTest);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTNODELPARFORKINDTEST);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      default:
        jj_la1[146] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirElemConstructor() throws ParseException {
 /*@bgen(jjtree) DirElemConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRELEMCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case StartTagOpenRoot:
        jj_consume_token(StartTagOpenRoot);
                       SimpleNode jjtn001 = new SimpleNode(this, JJTSTARTTAGOPENROOT);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
        try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
        } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
        }
        break;
      case StartTagOpen:
        jj_consume_token(StartTagOpen);
                                                                                              SimpleNode jjtn002 = new SimpleNode(this, JJTSTARTTAGOPEN);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
        try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                     jjtn002.processToken(token);
        } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
        }
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(TagQName);
                                                                                                                                                            SimpleNode jjtn003 = new SimpleNode(this, JJTTAGQNAME);
                                                                                                                                                            boolean jjtc003 = true;
                                                                                                                                                            jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                            jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                            jjtc003 = false;
                                                                                                               jjtn003.processToken(token);
      } finally {
                                                                                                                                                            if (jjtc003) {
                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                            }
      }
      DirAttributeList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EmptyTagClose:
        jj_consume_token(EmptyTagClose);
                                                                                                                                                                                                                                              SimpleNode jjtn004 = new SimpleNode(this, JJTEMPTYTAGCLOSE);
                                                                                                                                                                                                                                              boolean jjtc004 = true;
                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                              jjtc004 = false;
                                                                                                                                                                                 jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                              if (jjtc004) {
                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                              }
        }
        break;
      case StartTagClose:
        jj_consume_token(StartTagClose);
                                                                                                                                                                                                                                                                                                                    SimpleNode jjtn005 = new SimpleNode(this, JJTSTARTTAGCLOSE);
                                                                                                                                                                                                                                                                                                                    boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                    jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                    jjtc005 = false;
                                                                                                                                                                                                                                  jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                    if (jjtc005) {
                                                                                                                                                                                                                                                                                                                      jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                    }
        }
        label_25:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ProcessingInstructionStart:
          case ProcessingInstructionStartForElementContent:
          case CdataSectionStart:
          case CdataSectionStartForElementContent:
          case PredefinedEntityRef:
          case CharRef:
          case StartTagOpen:
          case StartTagOpenRoot:
          case Lbrace:
          case LbraceExprEnclosure:
          case LCurlyBraceEscape:
          case RCurlyBraceEscape:
          case ElementContentChar:
          case XmlCommentStart:
          case XmlCommentStartForElementContent:
            ;
            break;
          default:
            jj_la1[108] = jj_gen;
            break label_25;
          }
          DirElemContent();
        }
        jj_consume_token(EndTagOpen);
                                                                                                                                                                                                                                                                                                                                                                                                        SimpleNode jjtn006 = new SimpleNode(this, JJTENDTAGOPEN);
                                                                                                                                                                                                                                                                                                                                                                                                        boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                                        jjtc006 = false;
                                                                                                                                                                                                                                                                                                 jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                                                                        if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                                        }
        }
        jj_consume_token(TagQName);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn007 = new SimpleNode(this, JJTTAGQNAME);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn007);
        try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtc007 = false;
                                                                                                                                                                                                                                                                                                                                          jjtn007.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S:
          jj_consume_token(S);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      SimpleNode jjtn008 = new SimpleNode(this, JJTS);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      boolean jjtc008 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      jjtree.openNodeScope(jjtn008);
          try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      jjtree.closeNodeScope(jjtn008,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      jjtc008 = false;
                                                                                                                                                                                                                                                                                                                                                                             jjtn008.processToken(token);
          } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      if (jjtc008) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn008,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }
          }
          break;
        default:
          jj_la1[109] = jj_gen;
          ;
        }
        jj_consume_token(EndTagClose);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            SimpleNode jjtn009 = new SimpleNode(this, JJTENDTAGCLOSE);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            boolean jjtc009 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            jjtree.openNodeScope(jjtn009);
        try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            jjtree.closeNodeScope(jjtn009,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            jjtc009 = false;
                                                                                                                                                                                                                                                                                                                                                                                                                          jjtn009.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (jjtc009) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn009,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
        }
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DirAttributeValue() throws ParseException {
 /*@bgen(jjtree) DirAttributeValue */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRATTRIBUTEVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OpenQuot:
        jj_consume_token(OpenQuot);
                SimpleNode jjtn001 = new SimpleNode(this, JJTOPENQUOT);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
        try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
        } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
        }
        label_27:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PredefinedEntityRef:
          case CharRef:
          case Lbrace:
          case LbraceExprEnclosure:
          case LCurlyBraceEscape:
          case RCurlyBraceEscape:
          case EscapeQuot:
          case QuotAttrContentChar:
            ;
            break;
          default:
            jj_la1[115] = jj_gen;
            break label_27;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EscapeQuot:
            jj_consume_token(EscapeQuot);
                                                                             SimpleNode jjtn002 = new SimpleNode(this, JJTESCAPEQUOT);
                                                                             boolean jjtc002 = true;
                                                                             jjtree.openNodeScope(jjtn002);
            try {
                                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                                             jjtc002 = false;
                                                            jjtn002.processToken(token);
            } finally {
                                                                             if (jjtc002) {
                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                             }
            }
            break;
          case PredefinedEntityRef:
          case CharRef:
          case Lbrace:
          case LbraceExprEnclosure:
          case LCurlyBraceEscape:
          case RCurlyBraceEscape:
          case QuotAttrContentChar:
            QuotAttrValueContent();
            break;
          default:
            jj_la1[116] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(CloseQuot);
                                                                                                                                                                     SimpleNode jjtn003 = new SimpleNode(this, JJTCLOSEQUOT);
                                                                                                                                                                     boolean jjtc003 = true;
                                                                                                                                                                     jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                     jjtc003 = false;
                                                                                                                                  jjtn003.processToken(token);
        } finally {
                                                                                                                                                                     if (jjtc003) {
                                                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                     }
        }
        break;
      case OpenApos:
        jj_consume_token(OpenApos);
                                                                                                                                                                                                                                   SimpleNode jjtn004 = new SimpleNode(this, JJTOPENAPOS);
                                                                                                                                                                                                                                   boolean jjtc004 = true;
                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                   jjtc004 = false;
                                                                                                                                                                               jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                   if (jjtc004) {
                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                   }
        }
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PredefinedEntityRef:
          case CharRef:
          case Lbrace:
          case LbraceExprEnclosure:
          case LCurlyBraceEscape:
          case RCurlyBraceEscape:
          case EscapeApos:
          case AposAttrContentChar:
            ;
            break;
          default:
            jj_la1[117] = jj_gen;
            break label_28;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EscapeApos:
            jj_consume_token(EscapeApos);
                                                                                                                                                                                                                                                                                                SimpleNode jjtn005 = new SimpleNode(this, JJTESCAPEAPOS);
                                                                                                                                                                                                                                                                                                boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                jjtree.openNodeScope(jjtn005);
            try {
                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                jjtc005 = false;
                                                                                                                                                                                                                            jjtn005.processToken(token);
            } finally {
                                                                                                                                                                                                                                                                                                if (jjtc005) {
                                                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                }
            }
            break;
          case PredefinedEntityRef:
          case CharRef:
          case Lbrace:
          case LbraceExprEnclosure:
          case LCurlyBraceEscape:
          case RCurlyBraceEscape:
          case AposAttrContentChar:
            AposAttrValueContent();
            break;
          default:
            jj_la1[118] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(CloseApos);
                                                                                                                                                                                                                                                                                                                                                                                        SimpleNode jjtn006 = new SimpleNode(this, JJTCLOSEAPOS);
                                                                                                                                                                                                                                                                                                                                                                                        boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                        jjtc006 = false;
                                                                                                                                                                                                                                                                                                  jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                                                                                        if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                        }
        }
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void UnorderedExpr() throws ParseException {
    jj_consume_token(UnorderedOpen);
                   SimpleNode jjtn001 = new SimpleNode(this, JJTUNORDEREDOPEN);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
    try {
                   jjtree.closeNodeScope(jjtn001,  true);
                   jjtc001 = false;
                  jjtn001.processToken(token);
    } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  true);
                   }
    }
    Expr();
    jj_consume_token(Rbrace);
                                                                                      SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
                                                                                      boolean jjtc002 = true;
                                                                                      jjtree.openNodeScope(jjtn002);
    try {
                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                      jjtc002 = false;
                                                                jjtn002.processToken(token);
    } finally {
                                                                                      if (jjtc002) {
                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                      }
    }
  }


  final public void OrderedExpr() throws ParseException {
    jj_consume_token(OrderedOpen);
                 SimpleNode jjtn001 = new SimpleNode(this, JJTORDEREDOPEN);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
    try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
    } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
    }
    Expr();
    jj_consume_token(Rbrace);
                                                                                  SimpleNode jjtn002 = new SimpleNode(this, JJTRBRACE);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
    try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                              jjtn002.processToken(token);
    } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
    }
  }


  final public void DirPIContents() throws ParseException {
 /*@bgen(jjtree) DirPIContents */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDIRPICONTENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_30:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PIContentChar:
          ;
          break;
        default:
          jj_la1[129] = jj_gen;
          break label_30;
        }
        jj_consume_token(PIContentChar);
                    SimpleNode jjtn001 = new SimpleNode(this, JJTPICONTENTCHAR);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
        try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
        } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
        }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CDataSectionContents() throws ParseException {
 /*@bgen(jjtree) CDataSectionContents */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCDATASECTIONCONTENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CDataSectionChar:
          ;
          break;
        default:
          jj_la1[131] = jj_gen;
          break label_31;
        }
        jj_consume_token(CDataSectionChar);
                       SimpleNode jjtn001 = new SimpleNode(this, JJTCDATASECTIONCHAR);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
        try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
        } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
        }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void TypeName() throws ParseException {
 /*@bgen(jjtree) TypeName */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(QNameForItemType);
                      SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AttributeName() throws ParseException {
 /*@bgen(jjtree) AttributeName */
  SimpleNode jjtn000 = new SimpleNode(this, JJTATTRIBUTENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(QNameForItemType);
                      SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void ElementName() throws ParseException {
 /*@bgen(jjtree) ElementName */
  SimpleNode jjtn000 = new SimpleNode(this, JJTELEMENTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(QNameForItemType);
                      SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMEFORITEMTYPE);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void QueryList() throws ParseException {
 /*@bgen(jjtree) QueryList */
  SimpleNode jjtn000 = new SimpleNode(this, JJTQUERYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Module();
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QuerySeparator:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(QuerySeparator);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IntegerLiteral:
        case DecimalLiteral:
        case DoubleLiteral:
        case StringLiteral:
        case XQueryVersion:
        case ModuleNamespace:
        case ProcessingInstructionStart:
        case ProcessingInstructionStartForElementContent:
        case AxisChild:
        case AxisDescendant:
        case AxisParent:
        case AxisAttribute:
        case AxisSelf:
        case AxisDescendantOrSelf:
        case AxisAncestor:
        case AxisFollowingSibling:
        case AxisPrecedingSibling:
        case AxisFollowing:
        case AxisPreceding:
        case AxisAncestorOrSelf:
        case DefineFunction:
        case DeclareOrdering:
        case DeclareDefaultOrderingEmpty:
        case DeclareInheritNamespaces:
        case VariableIndicator:
        case DeclareConstruction:
        case DeclareXMLSpace:
        case DeclareBaseURI:
        case DeclareNamespace:
        case ElementType:
        case AttributeType:
        case SchemaElementType:
        case SchemaAttributeType:
        case OrderedOpen:
        case UnorderedOpen:
        case ElementQNameLbrace:
        case AttributeQNameLbrace:
        case PINCNameLbrace:
        case PILbrace:
        case CommentLbrace:
        case ElementLbrace:
        case AttributeLbrace:
        case TextLbrace:
        case DeclareCollation:
        case DeclareDefaultElement:
        case DeclareDefaultFunction:
        case ImportSchemaToken:
        case ImportModuleToken:
        case Star:
        case NCNameColonStar:
        case StarColonNCName:
        case Root:
        case RootDescendants:
        case UnaryMinus:
        case UnaryPlus:
        case Lpar:
        case At:
        case Some:
        case Every:
        case ForVariable:
        case LetVariable:
        case ValidateLbrace:
        case ValidateSchemaMode:
        case DocumentLpar:
        case DocumentLparForKindTest:
        case DocumentLbrace:
        case NodeLpar:
        case CommentLpar:
        case TextLpar:
        case ProcessingInstructionLpar:
        case ElementTypeForKindTest:
        case ElementTypeForDocumentTest:
        case AttributeTypeForKindTest:
        case SchemaElementTypeForKindTest:
        case SchemaElementTypeForDocumentTest:
        case SchemaAttributeTypeForKindTest:
        case ProcessingInstructionLparForKindTest:
        case TextLparForKindTest:
        case CommentLparForKindTest:
        case NodeLparForKindTest:
        case IfLpar:
        case TypeswitchLpar:
        case Dot:
        case DotDot:
        case DefineVariable:
        case QNameLpar:
        case StartTagOpen:
        case StartTagOpenRoot:
        case XmlCommentStart:
        case XmlCommentStartForElementContent:
        case QName:
          Module();
          break;
        default:
          jj_la1[1] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void FunctionCall() throws ParseException {
 /*@bgen(jjtree) FunctionCall */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(QNameLpar);
                SimpleNode jjtn001 = new SimpleNode(this, JJTQNAMELPAR);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
      try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
      } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case VariableIndicator:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case LetVariable:
      case ValidateLbrace:
      case ValidateSchemaMode:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case DocumentLbrace:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case TypeswitchLpar:
      case Dot:
      case DotDot:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
      case QName:
        ExprSingle();
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[103] = jj_gen;
            break label_24;
          }
          jj_consume_token(Comma);
          ExprSingle();
        }
        break;
      default:
        jj_la1[104] = jj_gen;
        ;
      }
      jj_consume_token(Rpar);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void Module() throws ParseException {
 /*@bgen(jjtree) Module */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XQueryVersion:
        VersionDecl();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case DefineFunction:
      case DeclareOrdering:
      case DeclareDefaultOrderingEmpty:
      case DeclareInheritNamespaces:
      case VariableIndicator:
      case DeclareConstruction:
      case DeclareXMLSpace:
      case DeclareBaseURI:
      case DeclareNamespace:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case DeclareCollation:
      case DeclareDefaultElement:
      case DeclareDefaultFunction:
      case ImportSchemaToken:
      case ImportModuleToken:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case LetVariable:
      case ValidateLbrace:
      case ValidateSchemaMode:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case DocumentLbrace:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case TypeswitchLpar:
      case Dot:
      case DotDot:
      case DefineVariable:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
      case QName:
        MainModule();
        break;
      case ModuleNamespace:
        LibraryModule();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void StepExpr() throws ParseException {
 /*@bgen(jjtree) #StepExpr(> 1 || isStep) */
 SimpleNode jjtn000 = new SimpleNode(this, JJTSTEPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean savedIsStep = isStep; isStep=false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case At:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case DotDot:
      case QName:
    isStep=true;
        AxisStep();
                             jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
                             jjtc000 = false;
                            isStep = savedIsStep;
        break;
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case VariableIndicator:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case Lpar:
      case DocumentLbrace:
      case Dot:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
        FilterExpr();
                                                                   jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
                                                                   jjtc000 = false;
                                                                  isStep = savedIsStep;
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
    }
    }
  }


  final public void Separator() throws ParseException {
 /*@bgen(jjtree) Separator */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSEPARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SemiColon);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void AbbrevReverseStep() throws ParseException {
    jj_consume_token(DotDot);
            SimpleNode jjtn001 = new SimpleNode(this, JJTDOTDOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
    try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
    } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
    }
  }


  final public void ContextItemExpr() throws ParseException {
    jj_consume_token(Dot);
         SimpleNode jjtn001 = new SimpleNode(this, JJTDOT);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
    try {
         jjtree.closeNodeScope(jjtn001,  true);
         jjtc001 = false;
        jjtn001.processToken(token);
    } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  true);
         }
    }
  }


  final public void AscendingOrderSpec() throws ParseException {
 /*@bgen(jjtree) AscendingOrderSpec */
  ASTAscendingOrderSpec jjtn000 = new ASTAscendingOrderSpec(JJTASCENDINGORDERSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ASC);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void DescendingOrderSpec() throws ParseException {
 /*@bgen(jjtree) DescendingOrderSpec */
  ASTDescendingOrderSpec jjtn000 = new ASTDescendingOrderSpec(JJTDESCENDINGORDERSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DESC);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void VarRef() throws ParseException {
    jj_consume_token(VariableIndicator);
    jj_consume_token(VarName);
                                 SimpleNode jjtn001 = new SimpleNode(this, JJTVARNAME);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
    try {
                                 jjtree.closeNodeScope(jjtn001,  true);
                                 jjtc001 = false;
                                jjtn001.processToken(token);
    } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  true);
                                 }
    }
  }


  final public void ExprSingle() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ForVariable:
    case LetVariable:
      FLWORExpr();
      break;
    case Some:
    case Every:
      QuantifiedExpr();
      break;
    case TypeswitchLpar:
      TypeswitchExpr();
      break;
    case IfLpar:
      IfExpr();
      break;
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
    case ProcessingInstructionStart:
    case ProcessingInstructionStartForElementContent:
    case AxisChild:
    case AxisDescendant:
    case AxisParent:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisAncestor:
    case AxisFollowingSibling:
    case AxisPrecedingSibling:
    case AxisFollowing:
    case AxisPreceding:
    case AxisAncestorOrSelf:
    case VariableIndicator:
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case OrderedOpen:
    case UnorderedOpen:
    case ElementQNameLbrace:
    case AttributeQNameLbrace:
    case PINCNameLbrace:
    case PILbrace:
    case CommentLbrace:
    case ElementLbrace:
    case AttributeLbrace:
    case TextLbrace:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case Root:
    case RootDescendants:
    case UnaryMinus:
    case UnaryPlus:
    case Lpar:
    case At:
    case ValidateLbrace:
    case ValidateSchemaMode:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case DocumentLbrace:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case Dot:
    case DotDot:
    case QNameLpar:
    case StartTagOpen:
    case StartTagOpenRoot:
    case XmlCommentStart:
    case XmlCommentStartForElementContent:
    case QName:
      OrExpr();
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void ParenthesizedExpr() throws ParseException {
    jj_consume_token(Lpar);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
    case ProcessingInstructionStart:
    case ProcessingInstructionStartForElementContent:
    case AxisChild:
    case AxisDescendant:
    case AxisParent:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisAncestor:
    case AxisFollowingSibling:
    case AxisPrecedingSibling:
    case AxisFollowing:
    case AxisPreceding:
    case AxisAncestorOrSelf:
    case VariableIndicator:
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case OrderedOpen:
    case UnorderedOpen:
    case ElementQNameLbrace:
    case AttributeQNameLbrace:
    case PINCNameLbrace:
    case PILbrace:
    case CommentLbrace:
    case ElementLbrace:
    case AttributeLbrace:
    case TextLbrace:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case Root:
    case RootDescendants:
    case UnaryMinus:
    case UnaryPlus:
    case Lpar:
    case At:
    case Some:
    case Every:
    case ForVariable:
    case LetVariable:
    case ValidateLbrace:
    case ValidateSchemaMode:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case DocumentLbrace:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case IfLpar:
    case TypeswitchLpar:
    case Dot:
    case DotDot:
    case QNameLpar:
    case StartTagOpen:
    case StartTagOpenRoot:
    case XmlCommentStart:
    case XmlCommentStartForElementContent:
    case QName:
      Expr();
      break;
    default:
      jj_la1[102] = jj_gen;
      ;
    }
    jj_consume_token(Rpar);
  }


  final public void ValueExpr() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ValidateLbrace:
    case ValidateSchemaMode:
      ValidateExpr();
      break;
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
    case ProcessingInstructionStart:
    case ProcessingInstructionStartForElementContent:
    case AxisChild:
    case AxisDescendant:
    case AxisParent:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisAncestor:
    case AxisFollowingSibling:
    case AxisPrecedingSibling:
    case AxisFollowing:
    case AxisPreceding:
    case AxisAncestorOrSelf:
    case VariableIndicator:
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case OrderedOpen:
    case UnorderedOpen:
    case ElementQNameLbrace:
    case AttributeQNameLbrace:
    case PINCNameLbrace:
    case PILbrace:
    case CommentLbrace:
    case ElementLbrace:
    case AttributeLbrace:
    case TextLbrace:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case Root:
    case RootDescendants:
    case Lpar:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case DocumentLbrace:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case Dot:
    case DotDot:
    case QNameLpar:
    case StartTagOpen:
    case StartTagOpenRoot:
    case XmlCommentStart:
    case XmlCommentStartForElementContent:
    case QName:
      PathExpr();
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void GeneralComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Equals:
      jj_consume_token(Equals);
          binaryTokenStack.push(token);
      break;
    case NotEquals:
      jj_consume_token(NotEquals);
          binaryTokenStack.push(token);
      break;
    case Lt:
      jj_consume_token(Lt);
          binaryTokenStack.push(token);
      break;
    case LtEquals:
      jj_consume_token(LtEquals);
          binaryTokenStack.push(token);
      break;
    case Gt:
      jj_consume_token(Gt);
          binaryTokenStack.push(token);
      break;
    case GtEquals:
      jj_consume_token(GtEquals);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void ValueComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FortranEq:
      jj_consume_token(FortranEq);
          binaryTokenStack.push(token);
      break;
    case FortranNe:
      jj_consume_token(FortranNe);
          binaryTokenStack.push(token);
      break;
    case FortranLt:
      jj_consume_token(FortranLt);
          binaryTokenStack.push(token);
      break;
    case FortranLe:
      jj_consume_token(FortranLe);
          binaryTokenStack.push(token);
      break;
    case FortranGt:
      jj_consume_token(FortranGt);
          binaryTokenStack.push(token);
      break;
    case FortranGe:
      jj_consume_token(FortranGe);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void AxisStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
    case AxisDescendant:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisFollowingSibling:
    case AxisFollowing:
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case QName:
      ForwardStep();
      break;
    case AxisParent:
    case AxisAncestor:
    case AxisPrecedingSibling:
    case AxisPreceding:
    case AxisAncestorOrSelf:
    case DotDot:
      ReverseStep();
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    PredicateList();
  }


  final public void ForwardStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
    case AxisDescendant:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisFollowingSibling:
    case AxisFollowing:
      ForwardAxis();
      NodeTest();
      break;
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case QName:
      AbbrevForwardStep();
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void PrimaryExpr() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
      Literal();
      break;
    case VariableIndicator:
      VarRef();
      break;
    case Lpar:
      ParenthesizedExpr();
      break;
    case Dot:
                                                 isStep=true;
      ContextItemExpr();
      break;
    case QNameLpar:
      FunctionCall();
      break;
    case ProcessingInstructionStart:
    case ProcessingInstructionStartForElementContent:
    case ElementQNameLbrace:
    case AttributeQNameLbrace:
    case PINCNameLbrace:
    case PILbrace:
    case CommentLbrace:
    case ElementLbrace:
    case AttributeLbrace:
    case TextLbrace:
    case DocumentLbrace:
    case StartTagOpen:
    case StartTagOpenRoot:
    case XmlCommentStart:
    case XmlCommentStartForElementContent:
      Constructor();
      break;
    case OrderedOpen:
      OrderedExpr();
      break;
    case UnorderedOpen:
      UnorderedExpr();
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void PrimaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BY:
    case IN:
    case OR:
    case IS:
    case AND:
    case LIKE:
    case NULL:
    case FROM:
    case LOWER:
    case ORDER:
    case UPPER:
    case WHERE:
    case SELECT:
    case BETWEEN:
    case SIMILAR:
    case SPELLCHECK:
    case REGULAR_IDENTIFIER:
    case DELIMITED_IDENTIFIER:
    case EXACT_NUMERIC_LITERAL:
    case APPROXIMATE_NUMERIC_LITERAL:
    case DATETIME_LITERAL:
    case CHAR_STRING_LITERAL:
      Predicate();
      break;
    case LEFT_PAREN:
      BracketExpression();
      break;
    case CONTAINS:
      ContainsExpression();
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void KindTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DocumentLpar:
    case DocumentLparForKindTest:
      DocumentTest();
      break;
    case ElementType:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
      ElementTest();
      break;
    case AttributeType:
    case AttributeTypeForKindTest:
      AttributeTest();
      break;
    case SchemaElementType:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
      SchemaElementTest();
      break;
    case SchemaAttributeType:
    case SchemaAttributeTypeForKindTest:
      SchemaAttributeTest();
      break;
    case ProcessingInstructionLpar:
    case ProcessingInstructionLparForKindTest:
      PITest();
      break;
    case CommentLpar:
    case CommentLparForKindTest:
      CommentTest();
      break;
    case TextLpar:
    case TextLparForKindTest:
      TextTest();
      break;
    case NodeLpar:
    case NodeLparForKindTest:
      AnyKindTest();
      break;
    default:
      jj_la1[145] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void ItemType() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QNameForSequenceType:
    case QNameForAtomicType:
      AtomicType();
      break;
    case ElementType:
    case AttributeType:
    case SchemaElementType:
    case SchemaAttributeType:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case SchemaElementTypeForKindTest:
    case SchemaElementTypeForDocumentTest:
    case SchemaAttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
      KindTest();
      break;
    case Item:
      jj_consume_token(Item);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTITEM);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
      try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
      } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
      }
      break;
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void SelectItem() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCERPT:
      ExcerptFunction();
      break;
    case BY:
    case IN:
    case OR:
    case IS:
    case AND:
    case LIKE:
    case NULL:
    case FROM:
    case ORDER:
    case WHERE:
    case SELECT:
    case BETWEEN:
    case REGULAR_IDENTIFIER:
    case DELIMITED_IDENTIFIER:
      Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        jj_consume_token(PERIOD);
        Identifier();
                                                             Node n = jjtree.popNode(); jjtree.popNode(); jjtree.pushNode(n);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void AbbrevForwardStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case At:
      jj_consume_token(At);
         SimpleNode jjtn001 = new SimpleNode(this, JJTAT);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
      try {
         jjtree.closeNodeScope(jjtn001,  true);
         jjtc001 = false;
        jjtn001.processToken(token);
      } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  true);
         }
      }
      break;
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    NodeTest();
  }


  final public void Literal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
      NumericLiteral();
      break;
    case StringLiteral:
      jj_consume_token(StringLiteral);
                                       SimpleNode jjtn001 = new SimpleNode(this, JJTSTRINGLITERAL);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
      try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
      } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
      }
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }


  final public void CompElemConstructor() throws ParseException {
 /*@bgen(jjtree) CompElemConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPELEMCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementQNameLbrace:
        jj_consume_token(ElementQNameLbrace);
                         SimpleNode jjtn001 = new SimpleNode(this, JJTELEMENTQNAMELBRACE);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
        try {
                         jjtree.closeNodeScope(jjtn001,  true);
                         jjtc001 = false;
                        jjtn001.processToken(token);
        } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  true);
                         }
        }
        break;
      case ElementLbrace:
        jj_consume_token(ElementLbrace);
                                                                                                    SimpleNode jjtn002 = new SimpleNode(this, JJTELEMENTLBRACE);
                                                                                                    boolean jjtc002 = true;
                                                                                                    jjtree.openNodeScope(jjtn002);
        try {
                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    jjtc002 = false;
                                                                         jjtn002.processToken(token);
        } finally {
                                                                                                    if (jjtc002) {
                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    }
        }
        Expr();
        jj_consume_token(Rbrace);
                                                                                                                                                                       SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                       boolean jjtc003 = true;
                                                                                                                                                                       jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                       jjtc003 = false;
                                                                                                                       jjtn003.processToken(token);
        } finally {
                                                                                                                                                                       if (jjtc003) {
                                                                                                                                                                         jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                       }
        }
        jj_consume_token(LbraceExprEnclosure);
                                                                                                                                                                                                                                         SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
                                                                                                                                                                                                                                         boolean jjtc004 = true;
                                                                                                                                                                                                                                         jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         jjtc004 = false;
                                                                                                                                                                           jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                         if (jjtc004) {
                                                                                                                                                                                                                                           jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         }
        }
        break;
      default:
        jj_la1[133] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case VariableIndicator:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case LetVariable:
      case ValidateLbrace:
      case ValidateSchemaMode:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case DocumentLbrace:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case TypeswitchLpar:
      case Dot:
      case DotDot:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
      case QName:
        ContentExpr();
        break;
      default:
        jj_la1[134] = jj_gen;
        ;
      }
      jj_consume_token(Rbrace);
                                                                                                                                                                                                                                                                                                                             SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                                                                                                                                                                             boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                             jjtc005 = false;
                                                                                                                                                                                                                                    jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                             if (jjtc005) {
                                                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                             }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CompPIConstructor() throws ParseException {
 /*@bgen(jjtree) CompPIConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPPICONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PINCNameLbrace:
        jj_consume_token(PINCNameLbrace);
                     SimpleNode jjtn001 = new SimpleNode(this, JJTPINCNAMELBRACE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
        try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
        } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
        }
        break;
      case PILbrace:
        jj_consume_token(PILbrace);
                                                                                       SimpleNode jjtn002 = new SimpleNode(this, JJTPILBRACE);
                                                                                       boolean jjtc002 = true;
                                                                                       jjtree.openNodeScope(jjtn002);
        try {
                                                                                       jjtree.closeNodeScope(jjtn002,  true);
                                                                                       jjtc002 = false;
                                                                jjtn002.processToken(token);
        } finally {
                                                                                       if (jjtc002) {
                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                       }
        }
        Expr();
        jj_consume_token(Rbrace);
                                                                                                                                                     SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                     boolean jjtc003 = true;
                                                                                                                                                     jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                     jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                     jjtc003 = false;
                                                                                                              jjtn003.processToken(token);
        } finally {
                                                                                                                                                     if (jjtc003) {
                                                                                                                                                       jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                     }
        }
        jj_consume_token(LbraceExprEnclosure);
                                                                                                                                                                                                                       SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
                                                                                                                                                                                                                       boolean jjtc004 = true;
                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                       jjtc004 = false;
                                                                                                                                                                  jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                       if (jjtc004) {
                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                       }
        }
        break;
      default:
        jj_la1[137] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case VariableIndicator:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case LetVariable:
      case ValidateLbrace:
      case ValidateSchemaMode:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case DocumentLbrace:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case TypeswitchLpar:
      case Dot:
      case DotDot:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
      case QName:
        Expr();
        break;
      default:
        jj_la1[138] = jj_gen;
        ;
      }
      jj_consume_token(Rbrace);
                                                                                                                                                                                                                                                                                                    SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                                                                                                                                                    boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                    jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                    jjtc005 = false;
                                                                                                                                                                                                                    jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                    if (jjtc005) {
                                                                                                                                                                                                                                                                                                      jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                    }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  final public void CompAttrConstructor() throws ParseException {
 /*@bgen(jjtree) CompAttrConstructor */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPATTRCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AttributeQNameLbrace:
        jj_consume_token(AttributeQNameLbrace);
                           SimpleNode jjtn001 = new SimpleNode(this, JJTATTRIBUTEQNAMELBRACE);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
        try {
                           jjtree.closeNodeScope(jjtn001,  true);
                           jjtc001 = false;
                          jjtn001.processToken(token);
        } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001,  true);
                           }
        }
        break;
      case AttributeLbrace:
        jj_consume_token(AttributeLbrace);
                                                                                                          SimpleNode jjtn002 = new SimpleNode(this, JJTATTRIBUTELBRACE);
                                                                                                          boolean jjtc002 = true;
                                                                                                          jjtree.openNodeScope(jjtn002);
        try {
                                                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                                                          jjtc002 = false;
                                                                             jjtn002.processToken(token);
        } finally {
                                                                                                          if (jjtc002) {
                                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                                          }
        }
        Expr();
        jj_consume_token(Rbrace);
                                                                                                                                                                               SimpleNode jjtn003 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                               boolean jjtc003 = true;
                                                                                                                                                                               jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               jjtc003 = false;
                                                                                                                           jjtn003.processToken(token);
        } finally {
                                                                                                                                                                               if (jjtc003) {
                                                                                                                                                                                 jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                               }
        }
        jj_consume_token(LbraceExprEnclosure);
                                                                                                                                                                                                                                                 SimpleNode jjtn004 = new SimpleNode(this, JJTLBRACEEXPRENCLOSURE);
                                                                                                                                                                                                                                                 boolean jjtc004 = true;
                                                                                                                                                                                                                                                 jjtree.openNodeScope(jjtn004);
        try {
                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                 jjtc004 = false;
                                                                                                                                                                               jjtn004.processToken(token);
        } finally {
                                                                                                                                                                                                                                                 if (jjtc004) {
                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                 }
        }
        break;
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case ProcessingInstructionStart:
      case ProcessingInstructionStartForElementContent:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisAncestorOrSelf:
      case VariableIndicator:
      case ElementType:
      case AttributeType:
      case SchemaElementType:
      case SchemaAttributeType:
      case OrderedOpen:
      case UnorderedOpen:
      case ElementQNameLbrace:
      case AttributeQNameLbrace:
      case PINCNameLbrace:
      case PILbrace:
      case CommentLbrace:
      case ElementLbrace:
      case AttributeLbrace:
      case TextLbrace:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case LetVariable:
      case ValidateLbrace:
      case ValidateSchemaMode:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case DocumentLbrace:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case SchemaElementTypeForKindTest:
      case SchemaElementTypeForDocumentTest:
      case SchemaAttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case TypeswitchLpar:
      case Dot:
      case DotDot:
      case QNameLpar:
      case StartTagOpen:
      case StartTagOpenRoot:
      case XmlCommentStart:
      case XmlCommentStartForElementContent:
      case QName:
        Expr();
        break;
      default:
        jj_la1[136] = jj_gen;
        ;
      }
      jj_consume_token(Rbrace);
                                                                                                                                                                                                                                                                                                                              SimpleNode jjtn005 = new SimpleNode(this, JJTRBRACE);
                                                                                                                                                                                                                                                                                                                              boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                              jjtc005 = false;
                                                                                                                                                                                                                                 jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                              if (jjtc005) {
                                                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                              }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }


  public XPath(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XPathTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 166; i++) jj_la1[i] = -1;
  }


  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 166; i++) jj_la1[i] = -1;
  }


  public JCRSQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JCRSQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }


  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }


  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 166; i++) jj_la1[i] = -1;
  }


  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }


  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[251];
    for (int i = 0; i < 251; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 166; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 251; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }


  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[101];
    for (int i = 0; i < 101; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 35; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 101; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }


private final int jjStartNfaWithStates_14(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_14(state, pos + 1);
}


private final int jjStartNfaWithStates_24(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_24(state, pos + 1);
}


private final int jjStartNfaWithStates_3(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_3(state, pos + 1);
}


private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}


private final int jjStartNfaWithStates_15(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_15(state, pos + 1);
}


private final int jjStartNfaWithStates_8(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_8(state, pos + 1);
}


private final int jjStartNfaWithStates_21(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_21(state, pos + 1);
}


private final int jjStartNfaWithStates_12(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_12(state, pos + 1);
}


private final int jjStartNfaWithStates_25(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_25(state, pos + 1);
}


private final int jjStartNfaWithStates_4(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_4(state, pos + 1);
}


private final int jjStartNfaWithStates_22(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_22(state, pos + 1);
}


private final int jjStartNfaWithStates_10(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_10(state, pos + 1);
}


private final int jjStartNfaWithStates_7(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_7(state, pos + 1);
}


private final int jjStartNfaWithStates_2(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_2(state, pos + 1);
}


private final int jjStartNfaWithStates_6(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_6(state, pos + 1);
}


private final int jjStartNfaWithStates_23(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_23(state, pos + 1);
}


private final int jjStartNfaWithStates_20(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_20(state, pos + 1);
}


private final int jjStartNfaWithStates_1(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_1(state, pos + 1);
}


private final int jjStartNfaWithStates_11(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_11(state, pos + 1);
}


private final int jjStartNfaWithStates_13(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_13(state, pos + 1);
}


private final int jjStartNfaWithStates_9(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_9(state, pos + 1);
}


private final int jjStartNfaWithStates_5(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_5(state, pos + 1);
}


private final int jjStartNfaWithStates_17(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_17(state, pos + 1);
}


private final int jjStartNfaWithStates_16(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_16(state, pos + 1);
}


private final int jjMoveStringLiteralDfa1_14(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_14(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 62:
         if ((active0 & 0x20000L) != 0L)
            return jjStopAtPos(1, 17);
         break;
      default :
         break;
   }
   return jjStartNfa_14(0, active0);
}


private final int jjMoveStringLiteralDfa1_16(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_16(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 62:
         if ((active3 & 0x80L) != 0L)
            return jjStopAtPos(1, 199);
         break;
      default :
         break;
   }
   return jjStartNfa_16(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_12(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_12(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
            return jjStopAtPos(1, 227);
         break;
      default :
         break;
   }
   return jjStartNfa_12(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_15(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_15(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 62:
         if ((active0 & 0x20000L) != 0L)
            return jjStopAtPos(1, 17);
         break;
      default :
         break;
   }
   return jjStartNfa_15(0, active0);
}


private final int jjMoveStringLiteralDfa1_7(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_7(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
            return jjStopAtPos(1, 227);
         break;
      default :
         break;
   }
   return jjStartNfa_7(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_11(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_11(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
            return jjStopAtPos(1, 227);
         break;
      default :
         break;
   }
   return jjStartNfa_11(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_9(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_9(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
            return jjStopAtPos(1, 227);
         break;
      default :
         break;
   }
   return jjStartNfa_9(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_2(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
            return jjStopAtPos(1, 227);
         break;
      default :
         break;
   }
   return jjStartNfa_2(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_25(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_25(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 114:
         return jjMoveStringLiteralDfa2_25(active3, 0x4000000000L);
      case 120:
         return jjMoveStringLiteralDfa2_25(active3, 0x8000000000L);
      default :
         break;
   }
   return jjStartNfa_25(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_22(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_22(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 45:
         return jjMoveStringLiteralDfa2_22(active3, 0x40000000000L);
      default :
         break;
   }
   return jjStartNfa_22(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_24(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_24(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         return jjMoveStringLiteralDfa2_24(active3, 0x100000000L);
      default :
         break;
   }
   return jjStartNfa_24(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_5(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 227;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_5(active3, 0x40000000L);
      default :
         break;
   }
   return jjStartNfa_5(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_10(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_10(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 227;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_10(active3, 0x40000000L);
      default :
         break;
   }
   return jjStartNfa_10(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_3(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_3(0, active0, 0L, 0L);
      return 1;
   }
   switch(curChar)
   {
      case 110:
         return jjMoveStringLiteralDfa2_3(active0, 0x100L);
      default :
         break;
   }
   return jjStartNfa_3(0, active0, 0L, 0L);
}


private final int jjMoveStringLiteralDfa1_6(long active1, long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_6(0, 0L, active1, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 227;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_6(active1, 0L, active3, 0x40000000L);
      case 97:
         return jjMoveStringLiteralDfa2_6(active1, 0x1L, active3, 0L);
      default :
         break;
   }
   return jjStartNfa_6(0, 0L, active1, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_23(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_23(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 41:
         if ((active3 & 0x2000000000L) != 0L)
            return jjStopAtPos(1, 229);
         break;
      case 58:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 227;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_23(active3, 0x40000000L);
      default :
         break;
   }
   return jjStartNfa_23(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_8(long active0, long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(0, active0, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 227;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_8(active0, 0L, active3, 0x40000000L);
      case 114:
         return jjMoveStringLiteralDfa2_8(active0, 0x4000000000000000L, active3, 0L);
      case 116:
         return jjMoveStringLiteralDfa2_8(active0, 0x8000000000000000L, active3, 0L);
      default :
         break;
   }
   return jjStartNfa_8(0, active0, 0L, 0L, active3);
}


private final int jjMoveNfa_14(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 3;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 2:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 238;
                  jjCheckNAdd(2);
                  break;
               case 1:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  kind = 46;
                  jjstateSet[jjnewStateCnt++] = 1;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 46)
                     kind = 46;
                  jjCheckNAdd(1);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 46)
                     kind = 46;
                  jjCheckNAdd(1);
                  break;
               case 1:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 46)
                     kind = 46;
                  jjCheckNAdd(1);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_24(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 2;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                  {
                     if (kind > 223)
                        kind = 223;
                  }
                  if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 239)
                        kind = 239;
                     jjCheckNAdd(1);
                  }
                  break;
               case 1:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 239)
                     kind = 239;
                  jjCheckNAdd(1);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  kind = 223;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 223)
                     kind = 223;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_19(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 4;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L && kind > 216)
                     kind = 216;
                  break;
               case 2:
                  if (curChar == 62 && kind > 192)
                     kind = 192;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (kind > 216)
                     kind = 216;
                  if (curChar == 93)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if (curChar == 93)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 3:
                  if (kind > 216)
                     kind = 216;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 216)
                     kind = 216;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_15(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 1;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                     kind = 215;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  kind = 215;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 215)
                     kind = 215;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_23(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 1;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                     kind = 228;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  kind = 228;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 228)
                     kind = 228;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_22(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 3;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                  {
                     if (kind > 213)
                        kind = 213;
                  }
                  if (curChar == 45)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 1:
                  if (curChar == 45)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 2:
                  if ((0xffffffff00002600L & l) != 0L && kind > 214)
                     kind = 214;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (kind > 213)
                     kind = 213;
                  break;
               case 2:
                  if (kind > 214)
                     kind = 214;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 213)
                     kind = 213;
                  break;
               case 2:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 214)
                     kind = 214;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_11(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 2;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7ffff3ffffffffffL & l) != 0L)
                  {
                     if (kind > 14)
                        kind = 14;
                  }
                  if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 12)
                        kind = 12;
                     jjCheckNAdd(0);
                  }
                  break;
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(0);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  kind = 14;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 14)
                     kind = 14;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_25(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 1;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 239;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_8(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 1;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 12;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_12(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 1;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 12;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveStringLiteralDfa7_3(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_3(5, old0, 0L, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_3(6, active0, 0L, 0L);
      return 7;
   }
   switch(curChar)
   {
      case 103:
         if ((active0 & 0x100L) != 0L)
            return jjStopAtPos(7, 8);
         break;
      default :
         break;
   }
   return jjStartNfa_3(6, active0, 0L, 0L);
}


private final int jjMoveStringLiteralDfa7_8(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_8(5, old0, 0L, 0L, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(6, active0, 0L, 0L, 0L);
      return 7;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x4000000000000000L) != 0L)
            return jjStopAtPos(7, 62);
         break;
      default :
         break;
   }
   return jjStartNfa_8(6, active0, 0L, 0L, 0L);
}


private final int jjMoveStringLiteralDfa8_6(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_6(6, 0L, old1, 0L, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_6(7, 0L, active1, 0L, 0L);
      return 8;
   }
   switch(curChar)
   {
      case 101:
         if ((active1 & 0x1L) != 0L)
            return jjStopAtPos(8, 64);
         break;
      default :
         break;
   }
   return jjStartNfa_6(7, 0L, active1, 0L, 0L);
}


private final int jjMoveStringLiteralDfa8_25(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_25(6, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_25(7, 0L, 0L, 0L, active3);
      return 8;
   }
   switch(curChar)
   {
      case 110:
         if ((active3 & 0x8000000000L) != 0L)
            return jjStopAtPos(8, 231);
         break;
      default :
         break;
   }
   return jjStartNfa_25(7, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa8_13(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_13(6, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(7, 0L, 0L, active2, 0L);
      return 8;
   }
   switch(curChar)
   {
      case 91:
         if ((active2 & 0x8000000000000000L) != 0L)
            return jjStopAtPos(8, 191);
         break;
      default :
         break;
   }
   return jjStartNfa_13(7, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa8_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(6, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(7, 0L, 0L, active2, 0L);
      return 8;
   }
   switch(curChar)
   {
      case 91:
         if ((active2 & 0x4000000000000000L) != 0L)
            return jjStopAtPos(8, 190);
         break;
      default :
         break;
   }
   return jjStartNfa_0(7, 0L, 0L, active2, 0L);
}


private final int jjMoveNfa_3(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 7;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 7:
                  if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 12)
                        kind = 12;
                     jjCheckNAdd(6);
                  }
                  else if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  else if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 0:
                  if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 1:
                  if ((0xfffffffbffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 2:
                  if (curChar != 34)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 3:
                  if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 4:
                  if ((0xffffff7fffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 5:
                  if (curChar != 39)
                     break;
                  if (kind > 7)
                     kind = 7;
                  jjstateSet[jjnewStateCnt++] = 3;
                  break;
               case 6:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(6);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  jjAddStates(0, 1);
                  break;
               case 4:
                  jjAddStates(2, 3);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 1);
                  break;
               case 4:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(2, 3);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_5(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 9;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 7:
                  if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 12)
                        kind = 12;
                     jjCheckNAdd(6);
                  }
                  else if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  else if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 0:
                  if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 1:
                  if ((0xfffffffbffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 2:
                  if (curChar != 34)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 3:
                  if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 4:
                  if ((0xffffff7fffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 5:
                  if (curChar != 39)
                     break;
                  if (kind > 10)
                     kind = 10;
                  jjstateSet[jjnewStateCnt++] = 3;
                  break;
               case 6:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 12)
                     kind = 12;
                  jjCheckNAdd(6);
                  break;
               case 8:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 188)
                     kind = 188;
                  jjstateSet[jjnewStateCnt++] = 8;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 7:
               case 8:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 188)
                     kind = 188;
                  jjCheckNAdd(8);
                  break;
               case 1:
                  jjAddStates(0, 1);
                  break;
               case 4:
                  jjAddStates(2, 3);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 7:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 188)
                     kind = 188;
                  jjCheckNAdd(8);
                  break;
               case 1:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 1);
                  break;
               case 4:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(2, 3);
                  break;
               case 8:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 188)
                     kind = 188;
                  jjCheckNAdd(8);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 9 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_2(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 8;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  else if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 0:
                  if (curChar == 34)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 1:
                  if ((0xfffffffbffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(1, 2);
                  break;
               case 2:
                  if (curChar != 34)
                     break;
                  if (kind > 5)
                     kind = 5;
                  jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 3:
                  if (curChar == 39)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 4:
                  if ((0xffffff7fffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(4, 5);
                  break;
               case 5:
                  if (curChar != 39)
                     break;
                  if (kind > 5)
                     kind = 5;
                  jjstateSet[jjnewStateCnt++] = 3;
                  break;
               case 7:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 189)
                     kind = 189;
                  jjstateSet[jjnewStateCnt++] = 7;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
               case 7:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 189)
                     kind = 189;
                  jjCheckNAdd(7);
                  break;
               case 1:
                  jjAddStates(0, 1);
                  break;
               case 4:
                  jjAddStates(2, 3);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 189)
                     kind = 189;
                  jjCheckNAdd(7);
                  break;
               case 1:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(0, 1);
                  break;
               case 4:
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                     jjAddStates(2, 3);
                  break;
               case 7:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 189)
                     kind = 189;
                  jjCheckNAdd(7);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 8 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjStopStringLiteralDfa_15(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x20000L) != 0L)
         {
            jjmatchedKind = 215;
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjStopStringLiteralDfa_20(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x4028000L) != 0L)
         {
            jjmatchedKind = 212;
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjStopStringLiteralDfa_11(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x800000000L) != 0L)
         {
            jjmatchedKind = 14;
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjStopStringLiteralDfa_17(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x8000L) != 0L)
         {
            jjmatchedKind = 211;
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjMoveNfa_21(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 6;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 237;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if ((0x3ff600000000000L & l) != 0L)
                     jjAddStates(4, 5);
                  break;
               case 3:
                  if (curChar == 58)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 5:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               case 5:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_10(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 6;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 12;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if ((0x3ff600000000000L & l) != 0L)
                     jjAddStates(4, 5);
                  break;
               case 3:
                  if (curChar == 58)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 5:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAdd(5);
                  break;
               case 5:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_16(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 6;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 237;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if ((0x3ff600000000000L & l) != 0L)
                     jjAddStates(4, 5);
                  break;
               case 3:
                  if (curChar == 58)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 5:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               case 5:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 203)
                     kind = 203;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_9(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 6;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 12;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if ((0x3ff600000000000L & l) != 0L)
                     jjAddStates(4, 5);
                  break;
               case 3:
                  if (curChar == 58)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 5:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjCheckNAdd(5);
                  break;
               case 5:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 184)
                     kind = 184;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_18(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 6;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
               case 0:
                  if ((0x100002600L & l) == 0L)
                     break;
                  kind = 239;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if ((0x3ff600000000000L & l) != 0L)
                     jjAddStates(4, 5);
                  break;
               case 3:
                  if (curChar == 58)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 5:
                  if ((0x3ff600000000000L & l) == 0L)
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjstateSet[jjnewStateCnt++] = 5;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
               case 5:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjCheckNAddStates(6, 8);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjCheckNAdd(5);
                  break;
               case 5:
                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 186)
                     kind = 186;
                  jjCheckNAdd(5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 6 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveStringLiteralDfa2_22(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_22(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_22(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 62:
         if ((active3 & 0x40000000000L) != 0L)
            return jjStopAtPos(2, 234);
         break;
      default :
         break;
   }
   return jjStartNfa_22(1, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa2_10(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_10(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_10(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x40000000L) != 0L)
            return jjStopAtPos(2, 222);
         break;
      default :
         break;
   }
   return jjStartNfa_10(1, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa2_24(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_24(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_24(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 41:
         if ((active3 & 0x100000000L) != 0L)
            return jjStopAtPos(2, 224);
         break;
      default :
         break;
   }
   return jjStartNfa_24(1, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa2_23(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_23(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_23(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x40000000L) != 0L)
            return jjStopAtPos(2, 222);
         break;
      default :
         break;
   }
   return jjStartNfa_23(1, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa2_25(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_25(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_25(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa3_25(active3, 0x4000000000L);
      case 116:
         return jjMoveStringLiteralDfa3_25(active3, 0x8000000000L);
      default :
         break;
   }
   return jjStartNfa_25(1, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa2_5(long old3, long active3)
{
   if (((active3 &= old3)) == 0L)
      return jjStartNfa_5(0, 0L, 0L, 0L, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(1, 0L, 0L, 0L, active3);
      return 2;
   }
   switch(curChar)
   {
      case 58:
         if ((active3 & 0x40000000L) != 0L)
            return jjStopAtPos(2, 222);
         break;
      default :
         break;
   }
   return jjStartNfa_5(1, 0L, 0L, 0L, active3);
}


private final int jjStopStringLiteralDfa_24(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x100000000L) != 0L)
         {
            jjmatchedKind = 223;
            return -1;
         }
         return -1;
      case 1:
         if ((active3 & 0x100000000L) != 0L)
         {
            if (jjmatchedPos == 0)
            {
               jjmatchedKind = 223;
               jjmatchedPos = 0;
            }
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjStopStringLiteralDfa_13(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x8000L) != 0L)
         {
            jjmatchedKind = 210;
            return -1;
         }
         return -1;
      case 1:
         if ((active3 & 0x8000L) != 0L)
         {
            if (jjmatchedPos == 0)
            {
               jjmatchedKind = 210;
               jjmatchedPos = 0;
            }
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjStopStringLiteralDfa_23(int pos, long active0, long active1, long active2, long active3)
{
   switch (pos)
   {
      case 0:
         if ((active3 & 0x2840000000L) != 0L)
         {
            jjmatchedKind = 228;
            return -1;
         }
         return -1;
      case 1:
         if ((active3 & 0x2840000000L) != 0L)
         {
            if (jjmatchedPos == 0)
            {
               jjmatchedKind = 228;
               jjmatchedPos = 0;
            }
            return -1;
         }
         return -1;
      default :
         return -1;
   }
}


private final int jjMoveStringLiteralDfa0_23()
{
   switch(curChar)
   {
      case 40:
         return jjMoveStringLiteralDfa1_23(0x840000000L);
      case 58:
         return jjMoveStringLiteralDfa1_23(0x2000000000L);
      default :
         return jjMoveNfa_23(0, 0);
   }
}


private final int jjMoveStringLiteralDfa0_5()
{
   switch(curChar)
   {
      case 40:
         return jjMoveStringLiteralDfa1_5(0x840000000L);
      case 61:
         return jjStopAtPos(0, 110);
      default :
         return jjMoveNfa_5(7, 0);
   }
}


private final int jjMoveStringLiteralDfa3_13(long old2, long active2, long old3, long active3)
{
   if (((active2 &= old2) | (active3 &= old3)) == 0L)
      return jjStartNfa_13(1, 0L, 0L, old2, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(2, 0L, 0L, active2, active3);
      return 3;
   }
   switch(curChar)
   {
      case 45:
         if ((active3 & 0x20000000000L) != 0L)
            return jjStopAtPos(3, 233);
         break;
      case 67:
         return jjMoveStringLiteralDfa4_13(active2, 0x8000000000000000L, active3, 0L);
      default :
         break;
   }
   return jjStartNfa_13(2, 0L, 0L, active2, active3);
}


private final int jjMoveStringLiteralDfa3_0(long old2, long active2, long old3, long active3)
{
   if (((active2 &= old2) | (active3 &= old3)) == 0L)
      return jjStartNfa_0(1, 0L, 0L, old2, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, 0L, 0L, active2, active3);
      return 3;
   }
   switch(curChar)
   {
      case 45:
         if ((active3 & 0x10000000000L) != 0L)
            return jjStopAtPos(3, 232);
         break;
      case 67:
         return jjMoveStringLiteralDfa4_0(active2, 0x4000000000000000L, active3, 0L);
      default :
         break;
   }
   return jjStartNfa_0(2, 0L, 0L, active2, active3);
}


private final int jjMoveStringLiteralDfa4_13(long old2, long active2, long old3, long active3)
{
   if (((active2 &= old2) | (active3 &= old3)) == 0L)
      return jjStartNfa_13(2, 0L, 0L, old2, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(3, 0L, 0L, active2, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 68:
         return jjMoveStringLiteralDfa5_13(active2, 0x8000000000000000L);
      default :
         break;
   }
   return jjStartNfa_13(3, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa4_0(long old2, long active2, long old3, long active3)
{
   if (((active2 &= old2) | (active3 &= old3)) == 0L)
      return jjStartNfa_0(2, 0L, 0L, old2, old3); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, 0L, 0L, active2, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 68:
         return jjMoveStringLiteralDfa5_0(active2, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(3, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa5_13(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_13(3, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(4, 0L, 0L, active2, 0L);
      return 5;
   }
   switch(curChar)
   {
      case 65:
         return jjMoveStringLiteralDfa6_13(active2, 0x8000000000000000L);
      default :
         break;
   }
   return jjStartNfa_13(4, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa5_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(3, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, 0L, 0L, active2, 0L);
      return 5;
   }
   switch(curChar)
   {
      case 65:
         return jjMoveStringLiteralDfa6_0(active2, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(4, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa7_13(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_13(5, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(6, 0L, 0L, active2, 0L);
      return 7;
   }
   switch(curChar)
   {
      case 65:
         return jjMoveStringLiteralDfa8_13(active2, 0x8000000000000000L);
      default :
         break;
   }
   return jjStartNfa_13(6, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa5_8(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_8(3, old0, 0L, 0L, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(4, active0, 0L, 0L, 0L);
      return 5;
   }
   switch(curChar)
   {
      case 114:
         return jjMoveStringLiteralDfa6_8(active0, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_8(4, active0, 0L, 0L, 0L);
}


private final int jjMoveStringLiteralDfa7_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(5, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, 0L, 0L, active2, 0L);
      return 7;
   }
   switch(curChar)
   {
      case 65:
         return jjMoveStringLiteralDfa8_0(active2, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(6, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa6_13(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_13(4, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_13(5, 0L, 0L, active2, 0L);
      return 6;
   }
   switch(curChar)
   {
      case 84:
         return jjMoveStringLiteralDfa7_13(active2, 0x8000000000000000L);
      default :
         break;
   }
   return jjStartNfa_13(5, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa6_0(long old2, long active2)
{
   if (((active2 &= old2)) == 0L)
      return jjStartNfa_0(4, 0L, 0L, old2, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, 0L, 0L, active2, 0L);
      return 6;
   }
   switch(curChar)
   {
      case 84:
         return jjMoveStringLiteralDfa7_0(active2, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(5, 0L, 0L, active2, 0L);
}


private final int jjMoveStringLiteralDfa6_8(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_8(4, old0, 0L, 0L, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(5, active0, 0L, 0L, 0L);
      return 6;
   }
   switch(curChar)
   {
      case 118:
         return jjMoveStringLiteralDfa7_8(active0, 0x4000000000000000L);
      default :
         break;
   }
   return jjStartNfa_8(5, active0, 0L, 0L, 0L);
}


private final int jjMoveNfa_13(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 21;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                  {
                     if (kind > 210)
                        kind = 210;
                  }
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  if (curChar == 38)
                     jjAddStates(77, 80);
                  break;
               case 2:
                  if (curChar == 59 && kind > 193)
                     kind = 193;
                  break;
               case 14:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(15, 17);
                  break;
               case 15:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(15, 16);
                  break;
               case 16:
                  if (curChar == 59 && kind > 194)
                     kind = 194;
                  break;
               case 18:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               case 19:
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  break;
               case 20:
                  if ((0xffffffff00002600L & l) != 0L && kind > 210)
                     kind = 210;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (kind > 210)
                     kind = 210;
                  break;
               case 1:
                  if (curChar == 116)
                     jjCheckNAdd(2);
                  break;
               case 3:
                  if (curChar == 108)
                     jjCheckNAdd(1);
                  break;
               case 4:
                  if (curChar == 103)
                     jjCheckNAdd(1);
                  break;
               case 5:
                  if (curChar == 111)
                     jjCheckNAdd(1);
                  break;
               case 6:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 113)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 8:
                  if (curChar == 97)
                     jjAddStates(81, 82);
                  break;
               case 9:
                  if (curChar == 112)
                     jjCheckNAdd(2);
                  break;
               case 10:
                  if (curChar == 109)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 115)
                     jjCheckNAdd(2);
                  break;
               case 12:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 11;
                  break;
               case 13:
                  if (curChar == 112)
                     jjstateSet[jjnewStateCnt++] = 12;
                  break;
               case 17:
                  if (curChar == 120)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if ((0x7e0000007eL & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 210)
                     kind = 210;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_17(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 21;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                  {
                     if (kind > 211)
                        kind = 211;
                  }
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  if (curChar == 38)
                     jjAddStates(77, 80);
                  break;
               case 2:
                  if (curChar == 59 && kind > 193)
                     kind = 193;
                  break;
               case 14:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(15, 17);
                  break;
               case 15:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(15, 16);
                  break;
               case 16:
                  if (curChar == 59 && kind > 194)
                     kind = 194;
                  break;
               case 18:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               case 19:
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  break;
               case 20:
                  if ((0xffffffff00002600L & l) != 0L && kind > 211)
                     kind = 211;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (kind > 211)
                     kind = 211;
                  break;
               case 1:
                  if (curChar == 116)
                     jjCheckNAdd(2);
                  break;
               case 3:
                  if (curChar == 108)
                     jjCheckNAdd(1);
                  break;
               case 4:
                  if (curChar == 103)
                     jjCheckNAdd(1);
                  break;
               case 5:
                  if (curChar == 111)
                     jjCheckNAdd(1);
                  break;
               case 6:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 113)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 8:
                  if (curChar == 97)
                     jjAddStates(81, 82);
                  break;
               case 9:
                  if (curChar == 112)
                     jjCheckNAdd(2);
                  break;
               case 10:
                  if (curChar == 109)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 115)
                     jjCheckNAdd(2);
                  break;
               case 12:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 11;
                  break;
               case 13:
                  if (curChar == 112)
                     jjstateSet[jjnewStateCnt++] = 12;
                  break;
               case 17:
                  if (curChar == 120)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if ((0x7e0000007eL & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 211)
                     kind = 211;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveNfa_20(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 21;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0xffffffff00002600L & l) != 0L)
                  {
                     if (kind > 212)
                        kind = 212;
                  }
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  if (curChar == 38)
                     jjAddStates(77, 80);
                  break;
               case 2:
                  if (curChar == 59 && kind > 193)
                     kind = 193;
                  break;
               case 14:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(15, 17);
                  break;
               case 15:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(15, 16);
                  break;
               case 16:
                  if (curChar == 59 && kind > 194)
                     kind = 194;
                  break;
               case 18:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               case 19:
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 14;
                  break;
               case 20:
                  if ((0xffffffff00002600L & l) != 0L && kind > 212)
                     kind = 212;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (kind > 212)
                     kind = 212;
                  break;
               case 1:
                  if (curChar == 116)
                     jjCheckNAdd(2);
                  break;
               case 3:
                  if (curChar == 108)
                     jjCheckNAdd(1);
                  break;
               case 4:
                  if (curChar == 103)
                     jjCheckNAdd(1);
                  break;
               case 5:
                  if (curChar == 111)
                     jjCheckNAdd(1);
                  break;
               case 6:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 113)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 8:
                  if (curChar == 97)
                     jjAddStates(81, 82);
                  break;
               case 9:
                  if (curChar == 112)
                     jjCheckNAdd(2);
                  break;
               case 10:
                  if (curChar == 109)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 115)
                     jjCheckNAdd(2);
                  break;
               case 12:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 11;
                  break;
               case 13:
                  if (curChar == 112)
                     jjstateSet[jjnewStateCnt++] = 12;
                  break;
               case 17:
                  if (curChar == 120)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if ((0x7e0000007eL & l) != 0L)
                     jjCheckNAddTwoStates(18, 16);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if (jjCanMove_3(hiByte, i1, i2, l1, l2) && kind > 212)
                     kind = 212;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 21 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}


private final int jjMoveStringLiteralDfa0_20()
{
   switch(curChar)
   {
      case 39:
         jjmatchedKind = 212;
         return jjMoveStringLiteralDfa1_20(0x20000L);
      case 123:
         jjmatchedKind = 204;
         return jjMoveStringLiteralDfa1_20(0x4000L);
      case 125:
         return jjMoveStringLiteralDfa1_20(0x8000L);
      default :
         return jjMoveNfa_20(0, 0);
   }
}


private final int jjMoveStringLiteralDfa0_17()
{
   switch(curChar)
   {
      case 34:
         jjmatchedKind = 173;
         return jjMoveStringLiteralDfa1_17(0x10000L);
      case 123:
         jjmatchedKind = 204;
         return jjMoveStringLiteralDfa1_17(0x4000L);
      case 125:
         return jjMoveStringLiteralDfa1_17(0x8000L);
      default :
         return jjMoveNfa_17(0, 0);
   }
}


private final int jjMoveStringLiteralDfa1_20(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_20(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 39:
         if ((active3 & 0x20000L) != 0L)
            return jjStopAtPos(1, 209);
         break;
      case 123:
         if ((active3 & 0x4000L) != 0L)
            return jjStopAtPos(1, 206);
         break;
      case 125:
         if ((active3 & 0x8000L) != 0L)
            return jjStopAtPos(1, 207);
         break;
      default :
         break;
   }
   return jjStartNfa_20(0, 0L, 0L, 0L, active3);
}


private final int jjMoveStringLiteralDfa1_17(long active3)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_17(0, 0L, 0L, 0L, active3);
      return 1;
   }
   switch(curChar)
   {
      case 34:
         if ((active3 & 0x10000L) != 0L)
            return jjStopAtPos(1, 208);
         break;
      case 123:
         if ((active3 & 0x4000L) != 0L)
            return jjStopAtPos(1, 206);
         break;
      case 125:
         if ((active3 & 0x8000L) != 0L)
            return jjStopAtPos(1, 207);
         break;
      default :
         break;
   }
   return jjStartNfa_17(0, 0L, 0L, 0L, active3);
}


private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec2[i2] & l2) != 0L);
      case 1:
         return ((jjbitVec3[i2] & l2) != 0L);
      case 2:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 3:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 4:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 5:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 6:
         return ((jjbitVec8[i2] & l2) != 0L);
      case 9:
         return ((jjbitVec9[i2] & l2) != 0L);
      case 10:
         return ((jjbitVec10[i2] & l2) != 0L);
      case 11:
         return ((jjbitVec11[i2] & l2) != 0L);
      case 12:
         return ((jjbitVec12[i2] & l2) != 0L);
      case 13:
         return ((jjbitVec13[i2] & l2) != 0L);
      case 14:
         return ((jjbitVec14[i2] & l2) != 0L);
      case 15:
         return ((jjbitVec15[i2] & l2) != 0L);
      case 16:
         return ((jjbitVec16[i2] & l2) != 0L);
      case 17:
         return ((jjbitVec17[i2] & l2) != 0L);
      case 30:
         return ((jjbitVec18[i2] & l2) != 0L);
      case 31:
         return ((jjbitVec19[i2] & l2) != 0L);
      case 33:
         return ((jjbitVec20[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec21[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec22[i2] & l2) != 0L);
      case 159:
         return ((jjbitVec23[i2] & l2) != 0L);
      case 215:
         return ((jjbitVec24[i2] & l2) != 0L);
      default : 
         if ((jjbitVec0[i1] & l1) != 0L)
            return true;
         return false;
   }
}


private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec25[i2] & l2) != 0L);
      case 1:
         return ((jjbitVec3[i2] & l2) != 0L);
      case 2:
         return ((jjbitVec26[i2] & l2) != 0L);
      case 3:
         return ((jjbitVec27[i2] & l2) != 0L);
      case 4:
         return ((jjbitVec28[i2] & l2) != 0L);
      case 5:
         return ((jjbitVec29[i2] & l2) != 0L);
      case 6:
         return ((jjbitVec30[i2] & l2) != 0L);
      case 9:
         return ((jjbitVec31[i2] & l2) != 0L);
      case 10:
         return ((jjbitVec32[i2] & l2) != 0L);
      case 11:
         return ((jjbitVec33[i2] & l2) != 0L);
      case 12:
         return ((jjbitVec34[i2] & l2) != 0L);
      case 13:
         return ((jjbitVec35[i2] & l2) != 0L);
      case 14:
         return ((jjbitVec36[i2] & l2) != 0L);
      case 15:
         return ((jjbitVec37[i2] & l2) != 0L);
      case 16:
         return ((jjbitVec16[i2] & l2) != 0L);
      case 17:
         return ((jjbitVec17[i2] & l2) != 0L);
      case 30:
         return ((jjbitVec18[i2] & l2) != 0L);
      case 31:
         return ((jjbitVec19[i2] & l2) != 0L);
      case 32:
         return ((jjbitVec38[i2] & l2) != 0L);
      case 33:
         return ((jjbitVec20[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec39[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec22[i2] & l2) != 0L);
      case 159:
         return ((jjbitVec23[i2] & l2) != 0L);
      case 215:
         return ((jjbitVec24[i2] & l2) != 0L);
      default : 
         if ((jjbitVec0[i1] & l1) != 0L)
            return true;
         return false;
   }
}


private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 1:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 2:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 3:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 4:
         return ((jjbitVec8[i2] & l2) != 0L);
      case 5:
         return ((jjbitVec9[i2] & l2) != 0L);
      case 6:
         return ((jjbitVec10[i2] & l2) != 0L);
      case 9:
         return ((jjbitVec11[i2] & l2) != 0L);
      case 10:
         return ((jjbitVec12[i2] & l2) != 0L);
      case 11:
         return ((jjbitVec13[i2] & l2) != 0L);
      case 12:
         return ((jjbitVec14[i2] & l2) != 0L);
      case 13:
         return ((jjbitVec15[i2] & l2) != 0L);
      case 14:
         return ((jjbitVec16[i2] & l2) != 0L);
      case 15:
         return ((jjbitVec17[i2] & l2) != 0L);
      case 16:
         return ((jjbitVec18[i2] & l2) != 0L);
      case 17:
         return ((jjbitVec19[i2] & l2) != 0L);
      case 30:
         return ((jjbitVec20[i2] & l2) != 0L);
      case 31:
         return ((jjbitVec21[i2] & l2) != 0L);
      case 33:
         return ((jjbitVec22[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec23[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec24[i2] & l2) != 0L);
      case 159:
         return ((jjbitVec25[i2] & l2) != 0L);
      case 215:
         return ((jjbitVec26[i2] & l2) != 0L);
      default : 
         if ((jjbitVec3[i1] & l1) != 0L)
            return true;
         return false;
   }
}


protected Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}


protected Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}


    public And and(Constraint constraint1, Constraint constraint2)
            throws InvalidQueryException, RepositoryException {
        if (constraint1 == null || constraint2 == null) {
            throw new InvalidQueryException("Constraints must not be null");
        }
        if (constraint1 instanceof ConstraintImpl
                && constraint2 instanceof ConstraintImpl) {
            return new AndImpl(resolver,
                    (ConstraintImpl) constraint1,
                    (ConstraintImpl) constraint2);
        } else {
            throw new RepositoryException("Unknown constraint implementation");
        }
    }


    public Or or(Constraint constraint1, Constraint constraint2)
            throws InvalidQueryException, RepositoryException {
        if (constraint1 == null || constraint2 == null) {
            throw new InvalidQueryException("Constraints must not be null");
        }
        if (constraint1 instanceof ConstraintImpl
                && constraint2 instanceof ConstraintImpl) {
            return new OrImpl(resolver,
                    (ConstraintImpl) constraint1,
                    (ConstraintImpl) constraint2);
        } else {
            throw new RepositoryException("Unknown constraint implementation");
        }
    }


    public Column column(String propertyName)                                     // CM
            throws InvalidQueryException, RepositoryException {
        Name propName = null;
        if (propertyName != null) {
            try {
                propName = resolver.getQName(propertyName);
            } catch (NameException e) {
                throw new InvalidQueryException(e.getMessage());
            }
        }
        return new ColumnImpl(resolver, null, propName, propertyName);
    }


    public Column column(String propertyName, String columnName)                  // CM
            throws InvalidQueryException, RepositoryException {
        if (propertyName == null && columnName != null) {
            throw new InvalidQueryException(
                    "columnName must be null if propertyName is null");
        }
        Name propName = null;
        if (propertyName != null) {
            try {
                propName = resolver.getQName(propertyName);
            } catch (NameException e) {
                throw new InvalidQueryException(e.getMessage());
            }
        }
        return new ColumnImpl(resolver, null, propName, columnName);
    }


    public Column column(String selectorName,
                         String propertyName,
                         String columnName) throws InvalidQueryException, RepositoryException {
        if (propertyName == null && columnName != null) {
            throw new InvalidQueryException(
                    "columnName must be null if propertyName is null");
        }
        Name propName = null;
        if (propertyName != null) {
            try {
                propName = resolver.getQName(propertyName);
            } catch (NameException e) {
                throw new InvalidQueryException(e.getMessage());
            }
        }
        return new ColumnImpl(resolver, checkSelectorName(selectorName),
                propName, columnName);
    }


    public Binary getBinary() throws RepositoryException {
        // JCR-2511 Value#getBinary() and #getStream() return internal representation for type PATH and NAME
        if (getType() == PropertyType.NAME || getType() == PropertyType.PATH) {
            // qualified name/path value needs to be resolved,
            // delegate conversion to getString() method
            try {
                final byte[] value = getString().getBytes("UTF-8");
                return new Binary() {
                    public int read(byte[] b, long position) {
                        if (position >= value.length) {
                            return -1;
                        } else {
                            int p = (int) position;
                            int n = Math.min(b.length, value.length - p);
                            System.arraycopy(value, p, b, 0, n);
                            return n;
                        }
                    }
                    public InputStream getStream() {
                        return new ByteArrayInputStream(value);
                    }
                    public long getSize() {
                        return value.length;
                    }
                    public void dispose() {
                    }
                };
            } catch (UnsupportedEncodingException ex) {
                throw new RepositoryException("UTF-8 is not supported", ex);
            }
        } else {
            return qvalue.getBinary();
        }
    }


    public Binary getBinary() throws RepositoryException {
        try {
            final byte[] value = getString().getBytes("UTF-8");
            return new Binary() {
                public int read(byte[] b, long position) {
                    if (position >= value.length) {
                        return -1;
                    } else {
                        int p = (int) position;
                        int n = Math.min(b.length, value.length - p);
                        System.arraycopy(value, p, b, 0, n);
                        return n;
                    }
                }
                public InputStream getStream() {
                    return new ByteArrayInputStream(value);
                }
                public long getSize() {
                    return value.length;
                }
                public void dispose() {
                }
            };
        } catch (UnsupportedEncodingException e) {
            throw new RepositoryException("UTF-8 is not supported", e);
        }
    }


    public Value createValue(InputStream value) {
        try {
            try {
                QValue qvalue = qfactory.create(value);
                return new QValueValue(qvalue, resolver);
            } finally {
                value.close(); // JCR-2903
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        } catch (RepositoryException ex) {
            throw new RuntimeException(ex);
        }
    }


    public Binary createBinary(InputStream stream) throws RepositoryException {
        // TODO review/optimize/refactor
        try {
            try {
                QValue qvalue = qfactory.create(stream);
                return qvalue.getBinary();
            } finally {
                stream.close(); // JCR-2903
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        } catch (RepositoryException ex) {
            throw new RuntimeException(ex);
        }
    }


    public static QValue getQValue(String jcrValue, int propertyType,
                                   NamePathResolver resolver,
                                   QValueFactory factory) throws RepositoryException {
        QValue qValue;
        switch (propertyType) {
            case PropertyType.STRING:
            case PropertyType.BOOLEAN:
            case PropertyType.DOUBLE:
            case PropertyType.LONG:
            case PropertyType.DECIMAL:
            case PropertyType.DATE:
            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
            case PropertyType.URI:
                qValue = factory.create(jcrValue, propertyType);
                break;
            case PropertyType.BINARY:
                qValue = factory.create(jcrValue.getBytes());
                break;
            case PropertyType.NAME:
                Name qName = resolver.getQName(jcrValue);
                qValue = factory.create(qName);
                break;
            case PropertyType.PATH:
                Path qPath = resolver.getQPath(jcrValue, false);
                qValue = factory.create(qPath);
                break;
            default:
                throw new IllegalArgumentException("Invalid property type.");
        }
        return qValue;
    }


    public static String getJCRString(QValue value,
                                      NamePathResolver resolver) throws RepositoryException {
        String jcrString;
        int propertyType = value.getType();
        switch (propertyType) {
            case PropertyType.STRING:
            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
            case PropertyType.URI:
            case PropertyType.BOOLEAN:
            case PropertyType.DATE:
            case PropertyType.DOUBLE:
            case PropertyType.LONG:
            case PropertyType.DECIMAL:
            case PropertyType.BINARY:
                jcrString = value.getString();
                break;
            case PropertyType.PATH:
                Path qPath = value.getPath();
                jcrString = resolver.getJCRPath(qPath);
                break;
            case PropertyType.NAME:
                Name qName = value.getName();
                jcrString = resolver.getJCRName(qName);
                break;
            default:
                throw new RepositoryException("illegal internal value type");
        }
        return jcrString;
    }


    public Name getName() throws RepositoryException {
        if (type == PropertyType.NAME) {
            return (Name) val;
        } else {
            try {
                return AbstractQValueFactory.NAME_FACTORY.create(getString());
            } catch (IllegalArgumentException e) {
                throw new ValueFormatException("not a valid Name value: " + getString(), e);
            }
        }
    }


    public URI getURI() throws RepositoryException {
        if (type == PropertyType.URI) {
            return (URI) val;
        } else {
            try {
                return URI.create(getString());
            } catch (IllegalArgumentException e) {
                throw new ValueFormatException("not a valid uri: " + getString(), e);
            }
        }
    }


    public InputStream getStream() throws RepositoryException {
        if (type == PropertyType.BINARY) {
            return ((Binary) val).getStream();
        } else {
            try {
                // convert via string
                return new ByteArrayInputStream(getString().getBytes(InternalValueFactory.DEFAULT_ENCODING));
            } catch (UnsupportedEncodingException e) {
                throw new RepositoryException(InternalValueFactory.DEFAULT_ENCODING + " is not supported encoding on this platform", e);
            }
        }
    }


    public Path getPath() throws RepositoryException {
        if (type == PropertyType.PATH) {
            return (Path) val;
        } else {
            try {
                return AbstractQValueFactory.PATH_FACTORY.create(getString());
            } catch (IllegalArgumentException e) {
                throw new ValueFormatException("not a valid Path: " + getString(), e);
            }
        }
    }


    public Binary getBinary() throws RepositoryException {
        if (type == PropertyType.BINARY) {
            // return an independent copy that can be disposed without
            // affecting this value
            return ((BLOBFileValue) val).copy();
        } else {
            try {
                // convert via string
                byte[] data = getString().getBytes(InternalValueFactory.DEFAULT_ENCODING);
                return BLOBInMemory.getInstance(data);
            } catch (UnsupportedEncodingException e) {
                throw new RepositoryException(InternalValueFactory.DEFAULT_ENCODING + " is not supported encoding on this platform", e);
            }
        }
    }


    public double getDouble() throws RepositoryException {
        if (type == PropertyType.DOUBLE) {
            return (Double) val;
        } else if (type == PropertyType.LONG) {
            return ((Long) val).doubleValue();
        } else if (type == PropertyType.DATE) {
            return getCalendar().getTimeInMillis();
        } else if (type == PropertyType.DECIMAL) {
            return ((BigDecimal) val).doubleValue();
        } else {
            try {
                return Double.parseDouble(getString());
            } catch (NumberFormatException ex) {
                throw new ValueFormatException("not a double: " + getString(), ex);
            }
        }
    }


    public long getLong() throws RepositoryException {
        if (type == PropertyType.LONG) {
            return (Long) val;
        } else if (type == PropertyType.DOUBLE) {
            return ((Double) val).longValue();
        } else if (type == PropertyType.DECIMAL) {
            return ((BigDecimal) val).longValue();
        } else if (type == PropertyType.DATE) {
            return getCalendar().getTimeInMillis();
        } else {
            try {
                return Long.parseLong(getString());
            } catch (NumberFormatException ex) {
                throw new ValueFormatException("not a long: " + getString(), ex);
            }
        }
    }


            public int read(byte[] b, long position) throws IOException, RepositoryException {
                InputStream in = getStream();
                try {
                    long skip = position;
                    while (skip > 0) {
                        long skipped = in.skip(skip);
                        if (skipped <= 0) {
                            return -1;
                        }
                        skip -= skipped;
                    }
                    return in.read(b);
                } finally {
                    in.close();
                }
            }


    public int read(byte[] b, long position) throws IOException, RepositoryException {
        InputStream in = getStream();
        try {
            long skip = position;
            while (skip > 0) {
                long skipped = in.skip(skip);
                if (skipped <= 0) {
                    return -1;
                }
                skip -= skipped;
            }
            return in.read(b);
        } finally {
            in.close();
        }
    }


    public static String cache(String s) {
        if (!OBJECT_CACHE) {
            return s;
        }
        if (s == null) {
            return s;
        } else if (s.length() == 0) {
            return "";
        }
        int hash = s.hashCode();
        String[] cache = getCache();
        if (cache != null) {
            int index = hash & (OBJECT_CACHE_SIZE - 1);
            String cached = cache[index];
            if (cached != null) {
                if (s.equals(cached)) {
                    return cached;
                }
            }
            cache[index] = s;
        }
        return s;
    }


    public static String fromCacheOrNew(String s) {
        if (!OBJECT_CACHE) {
            return s;
        }
        if (s == null) {
            return s;
        } else if (s.length() == 0) {
            return "";
        }
        int hash = s.hashCode();
        String[] cache = getCache();
        int index = hash & (OBJECT_CACHE_SIZE - 1);
        if (cache == null) {
            return s;
        }
        String cached = cache[index];
        if (cached != null) {
            if (s.equals(cached)) {
                return cached;
            }
        }
        // create a new object that is not shared
        // (to avoid out of memory if it is a substring of a big String)
        // NOPMD
        s = new String(s);
        cache[index] = s;
        return s;
    }


    public Object get(Object key) {
        Object value = cache.get(key);
        if (value == null) {
            value = old.get(key);
            if (value != null) {
                put(key, value);
            }
        }
        return value;
    }


    private Privilege getPrivilegeFromName(SessionInfo sessionInfo, NamePathResolver resolver, Name privilegeName) throws RepositoryException {
        Privilege priv = privileges.get(privilegeName);
        if (priv == null) {
            readPrivilegesFromService(sessionInfo, resolver);
            if (privileges.containsKey(privilegeName)) {
                priv = privileges.get(privilegeName);
            }
        }
        return priv;
    }


        public String toString() {
            StringBuffer b = new StringBuffer();
            if (uniqueID != null) {
                b.append(uniqueID);
            }
            if (path != null) {
                b.append(path.toString());
            }
            return b.toString();
        }


        public String toString() {
            StringBuilder sb = new StringBuilder();
            String separator = "";
            for (AtomicLong bucket : buckets) {
                sb.append(separator);
                sb.append(bucket.get());
                separator = ",";
            }
            return sb.toString();
        }


        public String toString() {
            StringBuilder sb = new StringBuilder();
            String separator = "";
            for (AtomicLong bucket : buckets) {
                sb.append(separator);
                sb.append(bucket.get());
                separator = ",";
            }
            return sb.toString();
        }


    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("EffectiveNodeTypeCache (" + super.toString() + ")\n");
        builder.append("EffectiveNodeTypes in cache:\n");
        for (Key key : sortedKeys) {
            builder.append(key);
            builder.append("\n");
        }
        return builder.toString();
    }


    private String encode(String[] names) {
        StringBuilder builder = new StringBuilder();
        String delim = "";
        for (String name : names) {
            builder.append(delim);
            builder.append(ISO9075.encode(name));
            delim = " ";
        }
        return builder.toString();
    }


    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("BitSetENTCacheImpl (" + super.toString() + ")\n");
        builder.append("EffectiveNodeTypes in cache:\n");
        for (Key key : sortedKeys) {
            builder.append(key);
            builder.append("\n");
        }
        return builder.toString();
    }


    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("EffectiveNodeTypeCache (" + super.toString() + ")\n");
        builder.append("EffectiveNodeTypes in cache:\n");
        for (Key k : sortedKeys) {
            builder.append(k);
            builder.append('\n');
        }
        return builder.toString();
    }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(parentId, nodeName);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    if (thisPath.equals(otherPath)) {
                        return CANCEL_BOTH;
                    }
                    return (thisPath.isDescendantOf(otherPath))
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(parentId, tree.getName());
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    if (thisPath.equals(otherPath)) {
                        return CANCEL_BOTH;
                    }
                    return (thisPath.isDescendantOf(otherPath))
                            ? CANCEL_THIS
                            : CANCEL_NONE;
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(parentId, propertyName);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    if (thisPath.equals(otherPath)) {
                        return CANCEL_BOTH;
                    }
                    return (thisPath.isDescendantOf(otherPath))
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                if (other instanceof SetValue) {
                    SetValue setValue = (SetValue) other;
                    Path thisPath = ConsolidatingChangeLog.getPath(parentId, propertyName);
                    Path otherPath = ConsolidatingChangeLog.getPath(setValue.propertyId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    if (thisPath.equals(otherPath)) {
                        if (!isMultivalued && setValue.values[0] == null) {
                            return CANCEL_BOTH;
                        }
                        else if (values.length == setValue.values.length) {
                            for (int k = 0; k < values.length; k++) {
                                if (!values[k].equals(setValue.values[k])) {
                                    return CANCEL_NONE;
                                }
                            }
                            return CANCEL_OTHER;
                        }
                    }
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(nodeId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    return thisPath.isDescendantOf(otherPath) || thisPath.equals(otherPath)
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                if (other instanceof SetMixins) {
                    SetMixins setMixin = (SetMixins) other;
                    if (mixinNodeTypeNames.length == setMixin.mixinNodeTypeNames.length) {
                        Path thisPath = ConsolidatingChangeLog.getPath(nodeId);
                        Path otherPath = ConsolidatingChangeLog.getPath(setMixin.nodeId);
                        if (thisPath == null || otherPath == null) {
                            return CANCEL_NONE;
                        }
                        if (thisPath.equals(otherPath)) {
                            for (int k = 0; k < mixinNodeTypeNames.length; k++) {
                                if (!mixinNodeTypeNames[k].equals(setMixin.mixinNodeTypeNames[k])) {
                                    return CANCEL_NONE;
                                }
                            }
                            return CANCEL_THIS;
                        }
                    }
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(nodeId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    return thisPath.isDescendantOf(otherPath) || thisPath.equals(otherPath)
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                if (other instanceof SetPrimaryType) {
                    SetPrimaryType setPrimaryType = (SetPrimaryType) other;
                    if (primaryTypeName.equals(setPrimaryType.primaryTypeName)) {
                        Path thisPath = ConsolidatingChangeLog.getPath(nodeId);
                        Path otherPath = ConsolidatingChangeLog.getPath(setPrimaryType.nodeId);
                        if (thisPath == null || otherPath == null) {
                            return CANCEL_NONE;
                        }
                        if (thisPath.equals(otherPath)) {
                            return CANCEL_THIS;
                        }
                    }
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(srcNodeId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    return thisPath.isDescendantOf(otherPath) || thisPath.equals(otherPath)
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                if (other instanceof ReorderNodes) {
                    Path thisPath = ConsolidatingChangeLog.getPath(parentId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((ReorderNodes) other).parentId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    return thisPath.equals(otherPath) && !hasSNS(srcNodeId) && !hasSNS(beforeNodeId)
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                return CANCEL_NONE;
            }


            public int cancel(CancelableOperation other) throws RepositoryException {
                if (other instanceof Remove) {
                    Path thisPath = ConsolidatingChangeLog.getPath(propertyId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((Remove) other).itemId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    return thisPath.isDescendantOf(otherPath) || thisPath.equals(otherPath)
                        ? CANCEL_THIS
                        : CANCEL_NONE;
                }
                if (other instanceof SetValue) {
                    Path thisPath = ConsolidatingChangeLog.getPath(propertyId);
                    Path otherPath = ConsolidatingChangeLog.getPath(((SetValue) other).propertyId);
                    if (thisPath == null || otherPath == null) {
                        return CANCEL_NONE;
                    }
                    if (thisPath.equals(otherPath)) {
                        return CANCEL_THIS;
                    }
                }
                return CANCEL_NONE;
            }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof AddNode) {
                return equals((AddNode) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof ReorderNodes) {
                return equals((ReorderNodes) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof SetMixins) {
                return equals((SetMixins) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof SetValue) {
                return equals((SetValue) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof Move) {
                return equals((Move) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof SetTree) {
                return equals((SetTree) other);
            }
            return false;
        }


    public boolean equals(Object other) {
        if (null == other) {
            return false;
        }
        if (this == other) {
            return true;
        }
        if (other instanceof AbstractChangeLog<?>) {
            return equals((AbstractChangeLog<?>) other);
        }
        return false;
    }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof AddProperty) {
                return equals((AddProperty) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof SetPrimaryType) {
                return equals((SetPrimaryType) other);
            }
            return false;
        }


        public boolean equals(Object other) {
            if (null == other) {
                return false;
            }
            if (this == other) {
                return true;
            }
            if (other instanceof Remove) {
                return equals((Remove) other);
            }
            return false;
        }


        private Iterator<ChildInfo> getChildInfos() {
            return transformIterator(filterIterator(itemInfos.iterator(),
                    new Predicate<ItemInfo>(){
                        public boolean evaluate(ItemInfo info) {
                            return info.denotesNode();
                        }
                    }),
                    new Transformer<ItemInfo, ChildInfo>(){
                        public ChildInfo transform(ItemInfo info) {
                            return new ChildInfoImpl(
                                    info.getPath().getName(), null,
                                    Path.INDEX_DEFAULT);
                        }
                    });
        }


        private Iterator<PropertyId> getPropertyIds() {
            return transformIterator(filterIterator(itemInfos.iterator(),
                    new Predicate<ItemInfo>(){
                        public boolean evaluate(ItemInfo info) {
                            return !info.denotesNode();
                        }
                    }),
                    new Transformer<ItemInfo, PropertyId>(){
                        public PropertyId transform(ItemInfo info) {
                            return (PropertyId) info.getId();
                        }
                    });
        }


        private Map<Object, List<T>> collectChildNodeDefs(final T[] defs) {
            Map<Object, List<T>> result = new HashMap<Object, List<T>>();
            for (T def : defs) {
                final Object defId = createQItemDefinitionId(def);
                List<T> list = result.get(defId);
                if (list == null) {
                    list = new ArrayList<T>();
                    result.put(defId, list);
                }
                list.add(def);
            }
            return result;
        }


    private Map<String, List<Row>> buildRightRowValues(RowIterator rightRows)
            throws RepositoryException {
        Map<String, List<Row>> map = new HashMap<String, List<Row>>();
        for (Row row : new RowIterable(rightRows)) {
            for (String value : getRightValues(row)) {
                List<Row> rows = map.get(value);
                if (rows == null) {
                    rows = new ArrayList<Row>();
                    map.put(value, rows);
                }
                rows.add(row);
            }
        }
        return map;
    }


    public String getDefaultPrimaryTypeName() {
        Name ntName = ((QNodeDefinition) itemDef).getDefaultPrimaryType();
        if (ntName == null) {
            return null;
        }
        try {
            return resolver.getJCRName(ntName);
        } catch (NamespaceException e) {
            // should never get here
            log.error("invalid default node type " + ntName, e);
            return null;
        }
    }


    public NodeType getDefaultPrimaryType() {
        if (ntMgr == null) {
            // not attached to an existing node type
            return null;
        }
        Name ntName = ((QNodeDefinition) itemDef).getDefaultPrimaryType();
        if (ntName == null) {
            return null;
        }
        try {
            return ntMgr.getNodeType(ntName);
        } catch (NoSuchNodeTypeException e) {
            // should never get here
            log.error("invalid default node type " + ntName, e);
            return null;
        }
    }


    public NodeType[] getRequiredPrimaryTypes() {
        if (ntMgr == null) {
            // not attached to an existing node type
            return null;
        }
        Name[] ntNames = ((QNodeDefinition) itemDef).getRequiredPrimaryTypes();
        try {
            if (ntNames == null || ntNames.length == 0) {
                // return "nt:base"
                return new NodeType[] { ntMgr.getNodeType(NameConstants.NT_BASE) };
            } else {
                NodeType[] nodeTypes = new NodeType[ntNames.length];
                for (int i = 0; i < ntNames.length; i++) {
                    nodeTypes[i] = ntMgr.getNodeType(ntNames[i]);
                }
                return nodeTypes;
            }
        } catch (NoSuchNodeTypeException e) {
            // should never get here
            log.error("required node type does not exist", e);
            return new NodeType[0];
        }
    }


    public String[] getRequiredPrimaryTypeNames() {
        Name[] ntNames = ((QNodeDefinition) itemDef).getRequiredPrimaryTypes();
        try {
            if (ntNames == null || ntNames.length == 0) {
                // return "nt:base"
                return new String[] { resolver.getJCRName(NameConstants.NT_BASE) };
            } else {
                String[] jcrNames = new String[ntNames.length];
                for (int i = 0; i < ntNames.length; i++) {
                    jcrNames[i] = resolver.getJCRName(ntNames[i]);
                }
                return jcrNames;
            }
        } catch (NamespaceException e) {
            // should never get here
            log.error("required node type does not exist", e);
            return new String[0];
        }
    }


    public NodeType getDeclaringNodeType() {
        if (ntMgr == null) {
            // only a template
            return null;
        } else {
            try {
                return ntMgr.getNodeType(itemDef.getDeclaringNodeType());
            } catch (NoSuchNodeTypeException e) {
                // should never get here
                log.error("declaring node type does not exist", e);
                return null;
            }
        }
    }


    public String getName() {
        if (name == null) {
            return null;
        } else {
            try {
                return resolver.getJCRName(name);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in node type name", e);
                return name.toString();
            }
        }
    }


    public String getDefaultPrimaryTypeName() {
        if (defaultPrimaryTypeName == null) {
            return null;
        } else {
            try {
                return resolver.getJCRName(defaultPrimaryTypeName);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in default primary type name", e);
                return defaultPrimaryTypeName.toString();
            }
        }
    }


    public String getPrimaryItemName() {
        if (primaryItemName == null) {
            return null;
        } else {
            try {
                return resolver.getJCRName(primaryItemName);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in primary type name", e);
                return primaryItemName.toString();
            }
        }
    }


    public String getName() {
        if (name == null) {
            return null;
        } else {
            try {
                return resolver.getJCRName(name);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in item definition name", e);
                return name.toString();
            }
        }
    }


    public String getPrimaryItemName() {
        try {
            Name piName = ntd.getPrimaryItemName();
            if (piName != null) {
                return resolver.getJCRName(piName);
            } else {
                return null;
            }
        } catch (NamespaceException e) {
            // should never get here
            log.error("encountered unregistered namespace in name of primary item", e);
            return ntd.getName().toString();
        }
    }


    public String getPrimaryItemName() {
        try {
            Name piName = ntd.getPrimaryItemName();
            if (piName != null) {
                return resolver.getJCRName(piName);
            } else {
                return null;
            }
        } catch (NamespaceException e) {
            // should never get here
            log.error("encountered unregistered namespace in name of primary item", e);
            return ntd.getName().toString();
        }
    }


    public String getPrimaryItemName() {
        // TODO JCR-1947: JSR 283: Node Type Attribute Subtyping Rules
        try {
            Name piName = ntd.getPrimaryItemName();
            if (piName != null) {
                return resolver.getJCRName(piName);
            } else {
                return null;
            }
        } catch (NamespaceException e) {
            // should never get here
            log.error("encountered unregistered namespace in name of primary item", e);
            return ntd.getName().toString();
        }
    }


    public String[] getDeclaredSupertypeNames() {
        Name[] stNames = ntd.getSupertypes();
        String[] dstn = new String[stNames.length];
        for (int i = 0; i < stNames.length; i++) {
            try {
                dstn[i] = resolver.getJCRName(stNames[i]);
            } catch (NamespaceException e) {
                // should never get here
                log.error("invalid node type name: " + stNames[i], e);
                dstn[i] = stNames[i].toString();
            }
        }
        return dstn;
    }


    public NodeType[] getDeclaredSupertypes() {
        Name[] ntNames = ntd.getSupertypes();
        NodeType[] supertypes = new NodeType[ntNames.length];
        for (int i = 0; i < ntNames.length; i++) {
            try {
                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
            } catch (NoSuchNodeTypeException e) {
                // should never get here
                log.error("undefined supertype", e);
                return new NodeType[0];
            }
        }
        return supertypes;
    }


    public String[] getDeclaredSupertypeNames() {
        Name[] ntNames = ntd.getSupertypes();
        String[] supertypes = new String[ntNames.length];
        for (int i = 0; i < ntNames.length; i++) {
            try {
                supertypes[i] = resolver.getJCRName(ntNames[i]);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in node type name", e);
                supertypes[i] = ntNames[i].toString();
            }
        }
        return supertypes;
    }


    public String[] getDeclaredSupertypeNames() {
        Name[] ntNames = ntd.getSupertypes();
        String[] supertypes = new String[ntNames.length];
        for (int i = 0; i < ntNames.length; i++) {
            try {
                supertypes[i] = resolver.getJCRName(ntNames[i]);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in node type name", e);
                supertypes[i] = ntNames[i].toString();
            }
        }
        return supertypes;
    }


    public NodeType[] getSupertypes() {
        Name[] ntNames = ent.getInheritedNodeTypes();
        NodeType[] supertypes = new NodeType[ntNames.length];
        for (int i = 0; i < ntNames.length; i++) {
            try {
                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
            } catch (NoSuchNodeTypeException e) {
                // should never get here
                log.error("undefined supertype", e);
                return new NodeType[0];
            }
        }
        return supertypes;
    }


    public String[] getRequiredPrimaryTypeNames() {
        if (requiredPrimaryTypeNames == null) {
            return null;
        } else {
            String[] rptNames = new String[requiredPrimaryTypeNames.length];
            for (int i = 0; i < requiredPrimaryTypeNames.length; i++) {
                try {
                    rptNames[i] = resolver.getJCRName(requiredPrimaryTypeNames[i]);
                } catch (NamespaceException e) {
                    // should never get here
                    log.error("invalid node type name: " + requiredPrimaryTypeNames[i], e);
                    rptNames[i] = requiredPrimaryTypeNames[i].toString();
                }
            }
            return rptNames;
        }
    }


    public NodeType[] getSupertypes() {
        Name[] ntNames = ent.getInheritedNodeTypes();
        NodeType[] supertypes = new NodeType[ntNames.length];
        for (int i = 0; i < ntNames.length; i++) {
            try {
                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
            } catch (NoSuchNodeTypeException e) {
                // should never get here
                log.error("undefined supertype", e);
                return new NodeType[0];
            }
        }
        return supertypes;
    }


    public String[] getDeclaredSupertypeNames() {
        String[] names = new String[superTypeNames.length];
        for (int i = 0; i < superTypeNames.length; i++) {
            try {
                names[i] = resolver.getJCRName(superTypeNames[i]);
            } catch (NamespaceException e) {
                // should never get here
                log.error("encountered unregistered namespace in super type name", e);
                names[i] = superTypeNames[i].toString();
            }
        }
        return names;
    }


    public void setRequiredPrimaryTypeNames(String[] requiredPrimaryTypeNames) throws ConstraintViolationException {
        if (requiredPrimaryTypeNames == null) {
            throw new ConstraintViolationException("null isn't a valid array of JCR names.");
        } else {
            this.requiredPrimaryTypeNames = new Name[requiredPrimaryTypeNames.length];
            for (int i = 0; i < requiredPrimaryTypeNames.length; i++) {
                try {
                    this.requiredPrimaryTypeNames[i] = resolver.getQName(requiredPrimaryTypeNames[i]);
                } catch (RepositoryException e) {
                    throw new ConstraintViolationException(e);
                }
            }
        }
    }


    public void setDeclaredSuperTypeNames(String[] names) throws ConstraintViolationException {
        // TODO see https://jsr-283.dev.java.net/issues/show_bug.cgi?id=797
        if (names == null) {
            throw new ConstraintViolationException("null isn't a valid array of JCR names.");            
        } else {
            superTypeNames = new Name[names.length];
            for (int i = 0; i < names.length; i++) {
                try {
                    superTypeNames[i] = resolver.getQName(names[i]);
                } catch (RepositoryException e) {
                    throw new ConstraintViolationException(e);
                }
            }
        }
    }


    static ReferenceConstraint create(String jcrName, NameResolver resolver)
            throws InvalidConstraintException {
        // constraint format: JCR name in prefix form
        try {
            Name name = resolver.getQName(jcrName);
            return new ReferenceConstraint(name.toString(), name);
        } catch (NameException e) {
            String msg = "Invalid name constraint: " + jcrName;
            log.debug(msg);
            throw new InvalidConstraintException(msg, e);
        } catch (NamespaceException e) {
            String msg = "Invalid name constraint: " + jcrName;
            log.debug(msg);
            throw new InvalidConstraintException(msg, e);
        }
    }


    static NameConstraint create(String jcrName, NameResolver resolver)
            throws InvalidConstraintException {
        // constraint format: A JCR name string.
        try {
            Name name = resolver.getQName(jcrName);
            return new NameConstraint(name.toString(), name);
        } catch (NameException e) {
            String msg = "Invalid name constraint: " + jcrName;
            log.debug(msg);
            throw new InvalidConstraintException(msg, e);
        } catch (NamespaceException e) {
            String msg = "Invalid name constraint: " + jcrName;
            log.debug(msg);
            throw new InvalidConstraintException(msg, e);
        }
    }


    public void check(QValue value) throws ConstraintViolationException, RepositoryException {
        if (value == null) {
            throw new ConstraintViolationException("Null value does not satisfy the constraint '" + getString() + "'");
        }
        switch (value.getType()) {
            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
                // TODO check value constraint (requires a session)
                log.warn("validation of reference constraint is not yet implemented");
                return;

            default:
                String msg = "Reference constraint can not be applied to value of type: "
                        + PropertyType.nameFromValue(value.getType());
                log.debug(msg);
                throw new RepositoryException(msg);
        }
    }


    public void check(QValue value) throws ConstraintViolationException, RepositoryException {
        if (value == null) {
            throw new ConstraintViolationException("null value does not satisfy the constraint '" + getString() + "'");
        }
        switch (value.getType()) {
            case PropertyType.DATE:
                check(value.getCalendar());
                return;

            default:
                String msg = "DATE constraint can not be applied to value of type: "
                        + PropertyType.nameFromValue(value.getType());
                log.debug(msg);
                throw new RepositoryException(msg);
        }
    }


    public void check(QValue value) throws ConstraintViolationException, RepositoryException {
        if (value == null) {
            throw new ConstraintViolationException("null value does not satisfy the constraint '"  + getString() + "'");
        }
        switch (value.getType()) {
            case PropertyType.BOOLEAN:
                boolean b = Boolean.valueOf(value.getString());
                if (b != reqBool) {
                    throw new ConstraintViolationException("'" + b + "' does not satisfy the constraint '" + getString() + "'");
                }
                return;

            default:
                String msg = "BOOLEAN constraint can not be applied to value of type: "
                        + PropertyType.nameFromValue(value.getType());
                log.debug(msg);
                throw new RepositoryException(msg);
        }
    }


    public void check(QValue value) throws ConstraintViolationException, RepositoryException {
        if (value == null) {
            throw new ConstraintViolationException("null value does not satisfy the constraint '" + getString() + "'");
        }
        switch (value.getType()) {
            case PropertyType.NAME:
                Name n = value.getName();
                if (!name.equals(n)) {
                    throw new ConstraintViolationException(n
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
                return;

            default:
                String msg = "NAME constraint can not be applied to value of type: "
                        + PropertyType.nameFromValue(value.getType());
                log.debug(msg);
                throw new RepositoryException(msg);
        }
    }


    public void check(QValue value) throws ConstraintViolationException, RepositoryException {
        if (value == null) {
            throw new ConstraintViolationException("null value does not satisfy the constraint '" + getString() + "'");
        }
        switch (value.getType()) {
            case PropertyType.STRING:
            case PropertyType.URI:
                String text = value.getString();
                Matcher matcher = pattern.matcher(text);
                if (!matcher.matches()) {
                    throw new ConstraintViolationException("'" + text  + "' does not satisfy the constraint '" + getString() + "'");
                }
                return;

            default:
                String msg = "String constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
                log.debug(msg);
                throw new RepositoryException(msg);
        }
    }


    public static ValueConstraint create(int type, String definition)
        throws InvalidConstraintException {
        if (definition == null) {
            throw new IllegalArgumentException("illegal definition (null)");
        }
        switch (type) {
            // constraints which are not qName sensitive
            case PropertyType.STRING:
            case PropertyType.URI:
                return new StringConstraint(definition);

            case PropertyType.BOOLEAN:
                return new BooleanConstraint(definition);

            case PropertyType.BINARY:
                return new NumericConstraint(definition);

            case PropertyType.DATE:
                return new DateConstraint(definition);

            case PropertyType.LONG:
            case PropertyType.DOUBLE:
            case PropertyType.DECIMAL:
                return new NumericConstraint(definition);

            case PropertyType.NAME:
                return NameConstraint.create(definition);

            case PropertyType.PATH:
                return PathConstraint.create(definition);

            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
                return ReferenceConstraint.create(definition);

            default:
                throw new IllegalArgumentException("unknown/unsupported target type for constraint: "
                        + PropertyType.nameFromValue(type));
        }
    }


    public static ValueConstraint create(int type, String jcrDefinition,
                                         NamePathResolver resolver)
            throws InvalidConstraintException {
        if (jcrDefinition == null) {
            throw new IllegalArgumentException("Illegal definition (null) for ValueConstraint.");
        }
        switch (type) {
            case PropertyType.STRING:
            case PropertyType.URI:
                return new StringConstraint(jcrDefinition);

            case PropertyType.BOOLEAN:
                return new BooleanConstraint(jcrDefinition);

            case PropertyType.BINARY:
                return new NumericConstraint(jcrDefinition);

            case PropertyType.DATE:
                return new DateConstraint(jcrDefinition);

            case PropertyType.LONG:
            case PropertyType.DOUBLE:
            case PropertyType.DECIMAL:
                return new NumericConstraint(jcrDefinition);

            case PropertyType.NAME:
                return NameConstraint.create(jcrDefinition, resolver);

            case PropertyType.PATH:
                return PathConstraint.create(jcrDefinition, resolver);

            case PropertyType.REFERENCE:
            case PropertyType.WEAKREFERENCE:
                return ReferenceConstraint.create(jcrDefinition, resolver);

            default:
                throw new IllegalArgumentException("Unknown/unsupported target type for constraint: " + PropertyType.nameFromValue(type));
        }
    }


    public static void checkValueConstraints(QPropertyDefinition pd, QValue[] values)
            throws ConstraintViolationException, RepositoryException {
        // check multi-value flag
        if (!pd.isMultiple() && values != null && values.length > 1) {
            throw new ConstraintViolationException("the property is not multi-valued");
        }

        QValueConstraint[] constraints = pd.getValueConstraints();
        if (constraints == null || constraints.length == 0) {
            // no constraints to check
            return;
        }
        if (values != null && values.length > 0) {
            // check value constraints on every value
            for (QValue value : values) {
                // constraints are OR-ed together
                boolean satisfied = false;
                ConstraintViolationException cve = null;
                for (int j = 0; j < constraints.length && !satisfied; j++) {
                    try {
                        constraints[j].check(value);
                        satisfied = true;
                    } catch (ConstraintViolationException e) {
                        cve = e;
                    } catch (InvalidConstraintException e) {
                        cve = new ConstraintViolationException(e.getMessage(), e);
                    }
                }
                if (!satisfied) {
                    // re-throw last exception we encountered
                    throw cve;
                }
            }
        }
    }


    public static void checkSetPropertyValueConstraints(QPropertyDefinition pd,
                                                        InternalValue[] values)
            throws ConstraintViolationException, RepositoryException {
        // check multi-value flag
        if (!pd.isMultiple() && values != null && values.length > 1) {
            throw new ConstraintViolationException("the property is not multi-valued");
        }

        QValueConstraint[] constraints = pd.getValueConstraints();
        if (constraints == null || constraints.length == 0) {
            // no constraints to check
            return;
        }
        if (values != null && values.length > 0) {
            // check value constraints on every value
            for (InternalValue value : values) {
                // constraints are OR-ed together
                boolean satisfied = false;
                ConstraintViolationException cve = null;
                for (QValueConstraint constraint : constraints) {
                    try {
                        constraint.check(value);
                        satisfied = true;
                        break;
                    } catch (ConstraintViolationException e) {
                        cve = e;
                    }
                }
                if (!satisfied) {
                    // re-throw last exception we encountered
                    throw cve;
                }
            }
        }
    }


    public DateConstraint(String definition) throws InvalidConstraintException {
        super(definition);

        // format: '(<fromDate>, <toDate>)', '[<fromDate>, <toDate>]', '[, <toDate>]' etc.
        Pattern pattern = Pattern.compile("([\\(\\[]) *([0-9TZ\\.\\+-:]*)? *, *([0-9TZ\\.\\+-:]*)? *([\\)\\]])");
        Matcher matcher = pattern.matcher(definition);
        if (matcher.matches()) {
            try {
                // group 1 is lower inclusive/exclusive
                String s = matcher.group(1);
                lowerInclusive = s.equals("[");
                // group 2 is lower limit
                s = matcher.group(2);
                if (s == null || s.length() == 0) {
                    lowerLimit = null;
                } else {
                    lowerLimit = DateValue.valueOf(matcher.group(2)).getDate();
                }
                // group 3 is upper limit
                s = matcher.group(3);
                if (s == null || s.length() == 0) {
                    upperLimit = null;
                } else {
                    upperLimit = DateValue.valueOf(matcher.group(3)).getDate();
                }
                // group 4 is upper inclusive/exclusive
                s = matcher.group(4);
                upperInclusive = s.equals("]");

                if (lowerLimit == null && upperLimit == null) {
                    String msg = "'" + definition
                            + "' is not a valid value constraint format for dates: neither min- nor max-date specified";
                    log.debug(msg);
                    throw new InvalidConstraintException(msg);
                }
                if (lowerLimit != null && upperLimit != null) {
                    if (lowerLimit.after(upperLimit)) {
                        String msg = "'" + definition
                                + "' is not a valid value constraint format for dates: min-date > max-date";
                        log.debug(msg);
                        throw new InvalidConstraintException(msg);
                    }
                }
            } catch (ValueFormatException vfe) {
                String msg = "'" + definition
                        + "' is not a valid value constraint format for dates";
                log.debug(msg);
                throw new InvalidConstraintException(msg, vfe);
            } catch (RepositoryException re) {
                String msg = "'" + definition
                        + "' is not a valid value constraint format for dates";
                log.debug(msg);
                throw new InvalidConstraintException(msg, re);
            }
        } else {
            String msg = "'" + definition
                    + "' is not a valid value constraint format for dates";
            log.debug(msg);
            throw new InvalidConstraintException(msg);
        }
    }


    public NumericConstraint(String definition) throws InvalidConstraintException {
        super(definition);

        // format: '(<min>, <max>)',  '[<min>, <max>]', '(, <max>)' etc.
        Pattern pattern = Pattern.compile("([\\(\\[]) *(\\-?\\d+\\.?\\d*)? *, *(\\-?\\d+\\.?\\d*)? *([\\)\\]])");
        Matcher matcher = pattern.matcher(definition);
        if (matcher.matches()) {
            try {
                // group 1 is lower inclusive/exclusive
                String s = matcher.group(1);
                lowerInclusive = s.equals("[");
                // group 2 is lower limit
                s = matcher.group(2);
                if (s == null || s.length() == 0) {
                    lowerLimit = null;
                } else {
                    lowerLimit = Double.valueOf(matcher.group(2));
                }
                // group 3 is upper limit
                s = matcher.group(3);
                if (s == null || s.length() == 0) {
                    upperLimit = null;
                } else {
                    upperLimit = Double.valueOf(matcher.group(3));
                }
                // group 4 is lower inclusive/exclusive
                s = matcher.group(4);
                upperInclusive = s.equals("]");
                if (lowerLimit == null && upperLimit == null) {
                    String msg = "'" + definition + "' is not a valid value constraint"
                            + " format for numeric types: neither lower- nor upper-limit specified";
                    log.debug(msg);
                    throw new InvalidConstraintException(msg);
                }
                if (lowerLimit != null && upperLimit != null) {
                    if (lowerLimit > upperLimit) {
                        String msg = "'" + definition
                                + "' is not a valid value constraint format for numeric types: lower-limit exceeds upper-limit";
                        log.debug(msg);
                        throw new InvalidConstraintException(msg);
                    }
                }
            } catch (NumberFormatException nfe) {
                String msg = "'" + definition
                        + "' is not a valid value constraint format for numeric types";
                log.debug(msg);
                throw new InvalidConstraintException(msg, nfe);
            }
        } else {
            String msg = "'" + definition
                    + "' is not a valid value constraint format for numeric values";
            log.debug(msg);
            throw new InvalidConstraintException(msg);
        }
    }


    private void check(Calendar cal) throws ConstraintViolationException {
        if (cal == null) {
            throw new ConstraintViolationException("null value does not satisfy the constraint '" + getString() + "'");
        }
        if (lowerLimit != null) {
            if (lowerInclusive) {
                if (cal.getTimeInMillis() < lowerLimit.getTimeInMillis()) {
                    throw new ConstraintViolationException(cal
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            } else {
                if (cal.getTimeInMillis() <= lowerLimit.getTimeInMillis()) {
                    throw new ConstraintViolationException(cal
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            }
        }
        if (upperLimit != null) {
            if (upperInclusive) {
                if (cal.getTimeInMillis() > upperLimit.getTimeInMillis()) {
                    throw new ConstraintViolationException(cal
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            } else {
                if (cal.getTimeInMillis() >= upperLimit.getTimeInMillis()) {
                    throw new ConstraintViolationException(cal
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            }
        }
    }


    private void check(double number) throws ConstraintViolationException {
        if (lowerLimit != null) {
            if (lowerInclusive) {
                if (number < lowerLimit) {
                    throw new ConstraintViolationException(number
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            } else {
                if (number <= lowerLimit) {
                    throw new ConstraintViolationException(number
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            }
        }
        if (upperLimit != null) {
            if (upperInclusive) {
                if (number > upperLimit) {
                    throw new ConstraintViolationException(number
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            } else {
                if (number >= upperLimit) {
                    throw new ConstraintViolationException(number
                            + " does not satisfy the constraint '"
                            + getString() + "'");
                }
            }
        }
    }


    public void setName(String name) throws ConstraintViolationException {
        if (ItemDefinitionImpl.ANY_NAME.equals(name)) {
            // handle the * special case that isn't a valid JCR name but a valid
            // name for a ItemDefinition (residual).
            this.name = NameConstants.ANY_NAME;
        } else {
            try {
                this.name = resolver.getQName(name);
            } catch (RepositoryException e) {
                throw new ConstraintViolationException(e);
            }
        }
    }


    public void setPrimaryItemName(String name) throws ConstraintViolationException {
        if (name == null) {
            primaryItemName = null;
        } else {
            try {
                primaryItemName = resolver.getQName(name);
            } catch (RepositoryException e) {
                throw new ConstraintViolationException(e);
            }
        }
    }


    PropertyDefinitionTemplateImpl(PropertyDefinition def, NamePathResolver resolver) throws ConstraintViolationException {
        super(def, resolver);
        type = def.getRequiredType();
        defaultValues = def.getDefaultValues();
        multiple = def.isMultiple();
        fullTextSearchable = def.isFullTextSearchable();
        queryOrderable = def.isQueryOrderable();
        queryOperators = def.getAvailableQueryOperators();
        setValueConstraints(def.getValueConstraints());
    }


    private PropertyDefinitionImpl(PropertyDefinition definition) {
        super(definition);

        type = definition.getRequiredType();
        valueConstraints = definition.getValueConstraints();
        defaultValues = definition.getDefaultValues();
        isMultiple = definition.isMultiple();
        availableQueryOperators = definition.getAvailableQueryOperators();
        isFullTextSearchable = definition.isFullTextSearchable();
        isQueryOrderable = definition.isQueryOrderable();
    }


    protected void notifyNamespaceAdded(String prefix, String uri) {
        if (listeners == null) {
            throw new UnsupportedOperationException("notifyNamespaceAdded");
        }
        // addition is infrequent compared to listener registration
        // -> use copy-on-read
        NamespaceListener[] currentListeners;
        synchronized (listeners) {
            int i = 0;
            currentListeners = new NamespaceListener[listeners.size()];
            for (Iterator it = listeners.iterator(); it.hasNext();) {
                currentListeners[i++] = (NamespaceListener) it.next();
            }
        }
        for (int i = 0; i < currentListeners.length; i++) {
            currentListeners[i].namespaceAdded(prefix, uri);
        }
    }


    protected void notifyNamespaceRemoved(String uri) {
        if (listeners == null) {
            throw new UnsupportedOperationException("notifyNamespaceRemapped");
        }
        // removal is infrequent compared to listener registration
        // -> use copy-on-read
        NamespaceListener[] currentListeners;
        synchronized (listeners) {
            int i = 0;
            currentListeners = new NamespaceListener[listeners.size()];
            for (Iterator it = listeners.iterator(); it.hasNext();) {
                currentListeners[i++] = (NamespaceListener) it.next();
            }
        }
        for (int i = 0; i < currentListeners.length; i++) {
            currentListeners[i].namespaceRemoved(uri);
        }
    }


    protected void notifyNamespaceRemapped(String oldPrefix,
                                           String newPrefix,
                                           String uri) {
        if (listeners == null) {
            throw new UnsupportedOperationException("notifyNamespaceRemapped");
        }
        // remapping is infrequent compared to listener registration
        // -> use copy-on-read
        NamespaceListener[] currentListeners;
        synchronized (listeners) {
            int i = 0;
            currentListeners = new NamespaceListener[listeners.size()];
            for (Iterator it = listeners.iterator(); it.hasNext();) {
                currentListeners[i++] = (NamespaceListener) it.next();
            }
        }
        for (int i = 0; i < currentListeners.length; i++) {
            currentListeners[i].namespaceRemapped(oldPrefix, newPrefix, uri);
        }
    }


    public String getPrefix(String uri) throws NamespaceException {
        try {
            return registry.getPrefix(uri);
        } catch (RepositoryException e) {
            if (!(e instanceof NamespaceException)) {
                e = new NamespaceException(
                        "Failed to resolve namespace URI: " + uri, e);
            }
            throw (NamespaceException) e;
        }
    }


    public String getURI(String prefix) throws NamespaceException {
        try {
            return registry.getURI(prefix);
        } catch (RepositoryException e) {
            if (!(e instanceof NamespaceException)) {
                e = new NamespaceException(
                        "Failed to resolve namespace prefix: " + prefix, e);
            }
            throw (NamespaceException) e;
        }
    }


    public String getProperty(String propName) throws RepositoryException {
        String testCaseName = getName();
        String testClassName = getClass().getName();
        String testPackName = "";
        int idx;
        if ((idx = testClassName.lastIndexOf('.')) > -1) {
            testPackName = testClassName.substring(testClassName.lastIndexOf('.', idx - 1) + 1, idx);
            testClassName = testClassName.substring(idx + 1);
        }

        // 1) test case specific property first
        String value = helper.getProperty(RepositoryServiceStub.PROP_PREFIX + "."
                + testClassName + "." + testCaseName + "." + propName);
        if (value != null) {
            return value;
        }

        // 2) check test class property
        value = helper.getProperty(RepositoryServiceStub.PROP_PREFIX + "."
                + testClassName + "." + propName);
        if (value != null) {
            return value;
        }

        // 3) check package property
        value = helper.getProperty(RepositoryServiceStub.PROP_PREFIX + "."
                + testPackName + "." + propName);
        if (value != null) {
            return value;
        }

        // finally try global property
        return helper.getProperty(RepositoryServiceStub.PROP_PREFIX + "." + propName);
    }


    public String getProperty(String propName) throws RepositoryException {
        String testCaseName = getName();
        String testClassName = getClass().getName();
        String testPackName = "";
        int idx;
        if ((idx = testClassName.lastIndexOf('.')) > -1) {
            testPackName = testClassName.substring(testClassName.lastIndexOf('.', idx - 1) + 1, idx);
            testClassName = testClassName.substring(idx + 1);
        }

        // 1) test case specific property first
        String value = getHelper().getProperty(RepositoryStub.PROP_PREFIX + "."
                + testClassName + "." + testCaseName + "." + propName);
        if (value != null) {
            return value;
        }

        // 2) check test class property
        value = getHelper().getProperty(RepositoryStub.PROP_PREFIX + "."
                + testClassName + "." + propName);
        if (value != null) {
            return value;
        }

        // 3) check package property
        value = getHelper().getProperty(RepositoryStub.PROP_PREFIX + "."
                + testPackName + "." + propName);
        if (value != null) {
            return value;
        }

        // finally try global property
        return getHelper().getProperty(RepositoryStub.PROP_PREFIX + "." + propName);
    }


    public void beforeSuite() throws RepositoryException {
        failOnRepositoryVersions("1.4", "1.5", "1.6");

        session = loginWriter();

        root = session.getRootNode().addNode(
                "BigFileReadTest", "nt:folder");
        for (int i = 0; i < FILE_COUNT; i++) {
            Node file = root.addNode("file" + i, "nt:file");
            Node content = file.addNode("jcr:content", "nt:resource");
            content.setProperty("jcr:mimeType", "application/octet-stream");
            content.setProperty("jcr:lastModified", Calendar.getInstance());
            content.setProperty(
                    "jcr:data", new TestInputStream(FILE_SIZE * 1024 * 1024));
        }
        session.save();
    }


    public void runTest() throws Exception {
        for (int i = 0; i < FILE_COUNT; i++) {
            Node file = root.addNode("file" + i, "nt:file");
            Node content = file.addNode("jcr:content", "nt:resource");
            content.setProperty("jcr:mimeType", "application/octet-stream");
            content.setProperty("jcr:lastModified", Calendar.getInstance());
            content.setProperty(
                    "jcr:data", new TestInputStream(FILE_SIZE * 1024));
        }
        session.save();
    }


    public void beforeSuite() throws RepositoryException {
        session = getRepository().login(getCredentials());

        root = session.getRootNode().addNode(
                "SmallFileReadTest", "nt:folder");
        for (int i = 0; i < FILE_COUNT; i++) {
            Node file = root.addNode("file" + i, "nt:file");
            Node content = file.addNode("jcr:content", "nt:resource");
            content.setProperty("jcr:mimeType", "application/octet-stream");
            content.setProperty("jcr:lastModified", Calendar.getInstance());
            content.setProperty(
                    "jcr:data", new TestInputStream(FILE_SIZE * 1024));
        }
        session.save();
    }


    public void beforeSuite() throws RepositoryException {
        String joins = getRepository().getDescriptor("query.joins");
        if (joins == null || joins.equals("query.joins.none")) {
            throw new RepositoryException(
                    "Join queries not supported by this repository");
        }

        session = loginWriter();
        root = session.getRootNode().addNode("testroot", "nt:unstructured");

        for (int i = 0; i < NODE_COUNT; i++) {
            Node foo = root.addNode("node" + i, "nt:unstructured");
            foo.setProperty("foo", i);
            for (int j = 0; j < NODE_COUNT; j++) {
                Node bar = foo.addNode("node" + j, "nt:unstructured");
                bar.setProperty("bar", j);
                for (int k = 0; k < NODE_COUNT; k++) {
                    Node baz = bar.addNode("node" + k, "nt:unstructured");
                    baz.setProperty("baz", k);
                }
            }
            session.save();
        }
    }


    public void beforeSuite() throws RepositoryException {
        String joins = getRepository().getDescriptor("query.joins");
        if (joins == null || joins.equals("query.joins.none")) {
            throw new RepositoryException(
                    "Join queries not supported by this repository");
        }

        session = loginWriter();
        root = session.getRootNode().addNode("testroot", "nt:unstructured");

        for (int i = 0; i < NODE_COUNT; i++) {
            Node node = root.addNode("node" + i, "nt:unstructured");
            node.setProperty("foo", i);
            for (int j = 0; j < NODE_COUNT; j++) {
                Node child = node.addNode("node" + j, "nt:unstructured");
                child.setProperty("bar", j);
            }
            session.save();
        }
    }


    public void runTest() throws Exception {
        int x = random.nextInt(NODE_COUNT);
        String query =
            "SELECT a.foo AS a, b.bar AS b, c.baz AS c"
            + " FROM [nt:unstructured] AS a"
            + " INNER JOIN [nt:unstructured] AS b ON a.foo = b.bar"
            + " INNER JOIN [nt:unstructured] AS c ON b.bar = c.baz"
            + " WHERE a.foo = " + x;

        QueryManager manager = session.getWorkspace().getQueryManager();
        RowIterator iterator =
            manager.createQuery(query, "JCR-SQL2").execute().getRows();
        int count = 0;
        while (iterator.hasNext()) {
            Row row = iterator.nextRow();
            long a = row.getValue("a").getLong();
            long b = row.getValue("b").getLong();
            long c = row.getValue("c").getLong();
            if (a != x || b != x || c != x) {
                throw new Exception(
                        "Invalid test result: "
                        + x + " -> " + a + ", " + b + ", " + c);
            }
            count++;
        }
        if (count != NODE_COUNT * NODE_COUNT * NODE_COUNT) {
            throw new Exception(
                    "Invalid test result count: " + count);
        }
    }


    public void runTest() throws Exception {
        int x = random.nextInt(NODE_COUNT);
        String query =
            "SELECT a.foo AS a, b.bar AS b"
            + " FROM [nt:unstructured] AS a"
            + " INNER JOIN [nt:unstructured] AS b ON a.foo = b.bar"
            + " WHERE a.foo = " + x;

        QueryManager manager = session.getWorkspace().getQueryManager();
        RowIterator iterator =
            manager.createQuery(query, "JCR-SQL2").execute().getRows();
        int count = 0;
        while (iterator.hasNext()) {
            Row row = iterator.nextRow();
            long a = row.getValue("a").getLong();
            long b = row.getValue("b").getLong();
            if (a != x || a != b) {
                throw new Exception(
                        "Invalid test result: " + x + " -> " + a + ", " + b);
            }
            count++;
        }
        if (count != NODE_COUNT) {
            throw new Exception(
                    "Invalid test result count: " + count + " !=" + NODE_COUNT);
        }
    }


    public void beforeSuite() throws RepositoryException {
        session = getRepository().login(getCredentials());

        root = session.getRootNode().addNode("testroot", "nt:unstructured");
        for (int i = 0; i < NODE_COUNT; i++) {
            Node node = root.addNode("node" + i, "nt:unstructured");
            for (int j = 0; j < NODE_COUNT; j++) {
                Node child = node.addNode("node" + j, "nt:unstructured");
                child.setProperty("testcount", j);
            }
            session.save();
        }
    }


    public void beforeSuite() throws RepositoryException {
        session = getRepository().login(getCredentials());

        root = session.getRootNode().addNode("testroot", "nt:unstructured");
        for (int i = 0; i < NODE_COUNT; i++) {
            Node node = root.addNode("node" + i, "nt:unstructured");
            for (int j = 0; j < NODE_COUNT; j++) {
                Node child = node.addNode("node" + j, "nt:unstructured");
                child.setProperty("testcount", j);
            }
            session.save();
        }
    }


    public void runTest() throws Exception {
        QueryManager manager = session.getWorkspace().getQueryManager();
        for (int i = 0; i < NODE_COUNT; i++) {
            Query query = createQuery(manager, i);
            NodeIterator iterator = query.execute().getNodes();
            while (iterator.hasNext()) {
                Node node = iterator.nextNode();
                if (node.getProperty("testcount").getLong() != i) {
                    throw new Exception("Invalid test result: " + node.getPath());
                }
            }
        }
    }


    public void runTest() throws Exception {
        QueryManager manager = session.getWorkspace().getQueryManager();
        for (int i = 0; i < NODE_COUNT; i++) {
            Query query = createQuery(manager, i);
            NodeIterator iterator = query.execute().getNodes();
            while (iterator.hasNext()) {
                Node node = iterator.nextNode();
                if (node.getProperty("testcount").getLong() != i) {
                    throw new Exception("Invalid test result: " + node.getPath());
                }
            }
        }
    }


    public void afterSuite() throws RepositoryException {
        for (int i = 0; i < NODE_COUNT; i++) {
            root.getNode("node" + i).remove();
            session.save();
        }

        root.remove();
        session.save();
        session.logout();
    }


    public void afterSuite() throws RepositoryException {
        for (int i = 0; i < NODE_COUNT; i++) {
            root.getNode("node" + i).remove();
            session.save();
        }

        root.remove();
        session.save();
        session.logout();
    }


    protected void testPerformance(String name) throws Exception {
        repoPattern = Pattern.compile(System.getProperty("repo", "\\d\\.\\d"));
        testPattern = Pattern.compile(System.getProperty("only", ".*"));

        // Create a repository using the Jackrabbit default configuration
        testPerformance(name, getDefaultConfig());

        // Create repositories for any special configurations included
        File directory = new File(new File("src", "test"), "resources");
        File[] files = directory.listFiles();
        if (files != null) {
            Arrays.sort(files);
            for (File file : files) {
                String xml = file.getName();
                if (file.isFile() && xml.endsWith(".xml")) {
                    String repositoryName =
                        name + "-" + xml.substring(0, xml.length() - 4);
                    testPerformance(
                            repositoryName, FileUtils.openInputStream(file));
                }
            }
        }
    }


    protected void doCreateRepositories(String name) throws Exception {
        // Create a repository using the Jackrabbit default configuration
        doCreateRepository(
                name,
                RepositoryImpl.class.getResourceAsStream("repository.xml"));

        // Create repositories for any special configurations included
        File directory = new File(new File("src", "test"), "resources");
        File[] files = directory.listFiles();
        if (files != null) {
            Arrays.sort(files);
            for (File file : files) {
                String xml = file.getName();
                if (file.isFile() && xml.endsWith(".xml")) {
                    doCreateRepository(
                            name + "-" + xml.substring(0, xml.length() - 4),
                            FileUtils.openInputStream(file));
                }
            }
        }
    }


    public RepositoryService getRepositoryService() throws RepositoryException {
        if (service == null) {
            Repository repository;
            try {
                repository = RepositoryStub.getInstance(Collections.EMPTY_MAP).getRepository();
            } catch (RepositoryStubException e) {
                throw new RepositoryException(e);
            }
            service = new RepositoryServiceImpl(repository, new BatchReadConfig());
        }
        return service;
    }


    public VersionManager getVersionManager() throws RepositoryException {
        if (versionManager == null) {
            try {
                versionManager = getFactory().getVersionManager(
                        session, remote.getVersionManager());
            } catch (RemoteException ex) {
                throw new RemoteRepositoryException(ex);
            }
        }

        return versionManager;
    }


    public LockManager getLockManager() throws RepositoryException {
        if (lockManager == null) {
            try {
                lockManager = getFactory().getLockManager(
                        session, remote.getLockManager());
            } catch (RemoteException ex) {
                throw new RemoteRepositoryException(ex);
            }
        }

        return lockManager;
    }


    public ObservationManager getObservationManager()
            throws RepositoryException {
        if (observationManager == null) {
            try {
                observationManager =
                    getFactory().
                        getObservationManager(this, remote.getObservationManager());
            } catch (RemoteException ex) {
                throw new RemoteRepositoryException(ex);
            }
        }

        return observationManager;
    }


    public long getSize() throws RemoteRuntimeException {
        if (size == -2) {
            try {
                size = remote.getSize();
            } catch (RemoteException e) {
                throw new RemoteRuntimeException(e);
            }
        }
        return size;
    }


    public Workspace getWorkspace() {
        if (workspace == null) {
            try {
                workspace =
                    getFactory().getWorkspace(this, remote.getWorkspace());
            } catch (RemoteException ex) {
                throw new RemoteRuntimeException(ex);
            }
        }

        return workspace;
    }


    public RowIterator getRows() throws RepositoryException {
        if (excerptProvider == null) {
            try {
                excerptProvider = createExcerptProvider();
            } catch (IOException e) {
                throw new RepositoryException(e);
            }
        }
        return new RowIteratorImpl(
                getScoreNodes(), columns,
                selectorNames, sessionContext.getItemManager(),
                index.getContext().getHierarchyManager(),
                sessionContext, 
                sessionContext.getSessionImpl().getValueFactory(),
                excerptProvider, spellSuggestion);
    }


    public void update(final SessionInfo sessionInfo,
                       final NodeId nodeId,
                       final String srcWorkspaceName)
            throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                getNode(nodeId, sInfo).update(srcWorkspaceName);
                return null;
            }
        }, sInfo);
    }


    public void checkout(final SessionInfo sessionInfo, final NodeId nodeId)
            throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                getNode(nodeId, sInfo).checkout();
                return null;
            }
        }, sInfo);
    }


                public Object run() throws RepositoryException {
                    executeWithLocalEvents(new Callable() {
                        public Object run() throws RepositoryException {
                            sInfo.getSession().save();
                            return null;
                        }
                    }, sInfo);
                    return null;
                }


    public void unlock(final SessionInfo sessionInfo, final NodeId nodeId)
            throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                getNode(nodeId, sInfo).unlock();
                return null;
            }
        }, sInfo);
    }


    public NodeId checkin(final SessionInfo sessionInfo, final NodeId nodeId)
            throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        Version newVersion = (Version) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                return getNode(nodeId, getSessionInfoImpl(sessionInfo)).checkin();
            }
        }, sInfo);
        return idFactory.createNodeId(newVersion);
    }


    public NodeId checkpoint(SessionInfo sessionInfo, final NodeId nodeId) throws UnsupportedRepositoryOperationException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        Version newVersion = (Version) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
                return vMgr.checkpoint(getNodePath(nodeId, sInfo));
            }
        }, sInfo);
        return idFactory.createNodeId(newVersion);
    }


    public NodeId createActivity(SessionInfo sessionInfo, final String title) throws UnsupportedRepositoryOperationException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        final VersionManager vMgr = getVersionManager(sInfo);
        Node activity = (Node) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                return vMgr.createActivity(title);
            }
        }, getSessionInfoImpl(sessionInfo));
        return idFactory.createNodeId(activity);
    }


    public NodeId createConfiguration(SessionInfo sessionInfo, final NodeId nodeId)
            throws UnsupportedRepositoryOperationException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        final VersionManager vMgr = getVersionManager(sInfo);
        Node configuration = (Node) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                return vMgr.createConfiguration(getNodePath(nodeId, sInfo));
            }
        }, getSessionInfoImpl(sessionInfo));
        return idFactory.createNodeId(configuration);
    }


    public void checkout(final SessionInfo sessionInfo, final NodeId nodeId, NodeId activityId) throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        Node activity = (activityId == null) ? null : getNode(activityId, sInfo);
        VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
        vMgr.setActivity(activity);
        try {
            executeWithLocalEvents(new Callable() {
                public Object run() throws RepositoryException {
                    getNode(nodeId, sInfo).checkout();
                    return null;
                }
            }, sInfo);
        } finally {
            vMgr.setActivity(null);
        }
    }


    public NodeId checkpoint(SessionInfo sessionInfo, final NodeId nodeId, final NodeId activityId) throws UnsupportedRepositoryOperationException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        Node activity = (activityId == null) ? null : getNode(activityId, sInfo);
        VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
        vMgr.setActivity(activity);
        try {
            Version newVersion = (Version) executeWithLocalEvents(new Callable() {
                public Object run() throws RepositoryException {
                    VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
                    return vMgr.checkpoint(getNodePath(nodeId, sInfo));
                }
            }, sInfo);
            return idFactory.createNodeId(newVersion);
        } finally {
            vMgr.setActivity(null);
        }
    }


    public void removeVersion(final SessionInfo sessionInfo,
                              final NodeId versionHistoryId,
                              final NodeId versionId)
            throws ReferentialIntegrityException, AccessDeniedException, UnsupportedRepositoryOperationException, VersionException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                Node vHistory = getNode(versionHistoryId, sInfo);
                Node version = getNode(versionId, sInfo);
                if (vHistory instanceof VersionHistory) {
                    ((VersionHistory) vHistory).removeVersion(version.getName());
                } else {
                    throw new RepositoryException("versionHistoryId does not reference a VersionHistor node");
                }
                return null;
            }
        }, sInfo);
    }


    public void removeVersionLabel(final SessionInfo sessionInfo,
                                   final NodeId versionHistoryId,
                                   final NodeId versionId,
                                   final Name label) throws VersionException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                String jcrLabel;
                jcrLabel = sInfo.getNamePathResolver().getJCRName((label));
                Node vHistory = getNode(versionHistoryId, sInfo);
                if (vHistory instanceof VersionHistory) {
                    ((VersionHistory) vHistory).removeVersionLabel(jcrLabel);
                } else {
                    throw new RepositoryException("versionHistoryId does not reference a VersionHistory node");
                }
                return null;
            }
        }, sInfo);
    }


    public void addVersionLabel(final SessionInfo sessionInfo,
                                final NodeId versionHistoryId,
                                final NodeId versionId,
                                final Name label,
                                final boolean moveLabel) throws VersionException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                String jcrLabel;
                jcrLabel = sInfo.getNamePathResolver().getJCRName(label);
                Node version = getNode(versionId, sInfo);
                Node vHistory = getNode(versionHistoryId, sInfo);
                if (vHistory instanceof VersionHistory) {
                    ((VersionHistory) vHistory).addVersionLabel(
                            version.getName(), jcrLabel, moveLabel);
                } else {
                    throw new RepositoryException("versionHistoryId does not reference a VersionHistory node");
                }
                return null;
            }
        }, sInfo);
    }


    public Iterator<NodeId> merge(final SessionInfo sessionInfo,
                          final NodeId nodeId,
                          final String srcWorkspaceName,
                          final boolean bestEffort)
            throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                String nodePath = getNodePath(nodeId, sInfo);
                NodeIterator it = getVersionManager(sInfo).merge(nodePath, srcWorkspaceName, bestEffort);
                List<NodeId> ids = new ArrayList<NodeId>();
                while (it.hasNext()) {
                    ids.add(idFactory.createNodeId(it.nextNode()
                    ));
                }
                return ids.iterator();
            }
        }, sInfo);
    }


    public Iterator<NodeId> merge(final SessionInfo sessionInfo,
                          final NodeId nodeId,
                          final String srcWorkspaceName,
                          final boolean bestEffort,
                          final boolean isShallow)
            throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                String nodePath = getNodePath(nodeId, sInfo);
                NodeIterator it = getVersionManager(sInfo).merge(nodePath, srcWorkspaceName, bestEffort, isShallow);
                List<NodeId> ids = new ArrayList<NodeId>();
                while (it.hasNext()) {
                    ids.add(idFactory.createNodeId(it.nextNode()
                    ));
                }
                return ids.iterator();
            }
        }, sInfo);
    }


    public Iterator<NodeId> mergeActivity(SessionInfo sessionInfo, final NodeId activityId) throws UnsupportedRepositoryOperationException, RepositoryException {
        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
            public Object run() throws RepositoryException {
                Node node = getNode(activityId, sInfo);
                NodeIterator it = getVersionManager(sInfo).merge(node);
                List<NodeId> ids = new ArrayList<NodeId>();
                while (it.hasNext()) {
                    ids.add(idFactory.createNodeId(it.nextNode()
                    ));
                }
                return ids.iterator();
            }
        }, sInfo);
    }


        public void addProperty(final NodeId parentId,
                                final Name propertyName,
                                final QValue value)
                throws ValueFormatException, VersionException, LockException, ConstraintViolationException, PathNotFoundException, ItemExistsException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
            executeGuarded(new Callable() {
                public Object run() throws RepositoryException {
                    Session s = sInfo.getSession();
                    Node parent = getParent(parentId, sInfo);
                    Value jcrValue = ValueFormat.getJCRValue(value,
                            sInfo.getNamePathResolver(), s.getValueFactory());
                    parent.setProperty(getJcrName(propertyName), jcrValue);
                    return null;
                }
            });
        }


        public void setValue(final PropertyId propertyId, final QValue value)
                throws RepositoryException {
            executeGuarded(new Callable() {
                public Object run() throws RepositoryException {
                    Session s = sInfo.getSession();
                    Value jcrValue = ValueFormat.getJCRValue(value,
                            sInfo.getNamePathResolver(), s.getValueFactory());
                    getProperty(propertyId, sInfo).setValue(jcrValue);
                    return null;
                }
            });
        }


        public void setPrimaryType(final NodeId nodeId, final Name primaryNodeTypeName) throws RepositoryException {
            executeGuarded(new Callable() {
                public Object run() throws RepositoryException {
                    Node n = getNode(nodeId, sInfo);
                    n.setPrimaryType(getJcrName(primaryNodeTypeName));
                    return null;
                }
            });
        }


        public void addProperty(final NodeId parentId,
                                final Name propertyName,
                                final QValue[] values) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, PathNotFoundException, ItemExistsException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
            executeGuarded(new Callable() {
                public Object run() throws RepositoryException {
                    Session s = sInfo.getSession();
                    Node n = getParent(parentId, sInfo);
                    Value[] jcrValues = new Value[values.length];
                    for (int i = 0; i < jcrValues.length; i++) {
                        jcrValues[i] = ValueFormat.getJCRValue(values[i],
                                sInfo.getNamePathResolver(), s.getValueFactory());
                    }
                    n.setProperty(getJcrName(propertyName), jcrValues);
                    return null;
                }
            });
        }


        public void setValue(final PropertyId propertyId, final QValue[] values)
                throws RepositoryException {
            executeGuarded(new Callable() {
                public Object run() throws RepositoryException {
                    Session s = sInfo.getSession();
                    Value[] jcrValues = new Value[values.length];
                    for (int i = 0; i < jcrValues.length; i++) {
                        jcrValues[i] = ValueFormat.getJCRValue(values[i],
                                sInfo.getNamePathResolver(), s.getValueFactory());
                    }
                    getProperty(propertyId, sInfo).setValue(jcrValues);
                    return null;
                }
            });
        }


    private Node getNode(NodeId id, SessionInfoImpl sessionInfo) throws ItemNotFoundException, PathNotFoundException, RepositoryException {
        Session session = sessionInfo.getSession();
        Node n;
        if (id.getUniqueID() != null) {
            n = session.getNodeByIdentifier(id.getUniqueID());
        } else {
            n = session.getRootNode();
        }
        Path path = id.getPath();
        if (path == null || path.denotesRoot()) {
            return n;
        }
        String jcrPath;
        jcrPath = sessionInfo.getNamePathResolver().getJCRPath(path);
        if (path.isAbsolute()) {
            jcrPath = jcrPath.substring(1, jcrPath.length());
        }
        return n.getNode(jcrPath);
    }


    private Property getProperty(PropertyId id, SessionInfoImpl sessionInfo) throws ItemNotFoundException, PathNotFoundException, RepositoryException {
        Session session = sessionInfo.getSession();
        Node n;
        if (id.getUniqueID() != null) {
            n = session.getNodeByIdentifier(id.getUniqueID());
        } else {
            n = session.getRootNode();
        }
        Path path = id.getPath();
        String jcrPath = sessionInfo.getNamePathResolver().getJCRPath(path);
        if (path.isAbsolute()) {
            jcrPath = jcrPath.substring(1, jcrPath.length());
        }
        return n.getProperty(jcrPath);
    }


    public void testInvalidStateRemovedItem() throws RepositoryException {
        removeItem.remove();
        try {
            removeItem.getName();
            fail("Calling getName() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            removeItem.getPath();
            fail("Calling getPath() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            removeItem.save();
            fail("Calling save() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public void testInvalidStateRemovedItem2() throws RepositoryException {
        removeItem.remove();
        testRootNode.save();
        try {
            removeItem.getName();
            fail("Calling getName() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            removeItem.getPath();
            fail("Calling getPath() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            removeItem.save();
            fail("Calling save() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public static Test suite() {

        TestSuite suite = new TestSuite("jcr2spi tests");

        suite.addTestSuite(AccessByRelativePathTest.class);
        suite.addTestSuite(GetItemsTest.class);

        // get node(s)
        suite.addTestSuite(SNSIndexTest.class);
        suite.addTestSuite(NodeOrderTest.class);

        // add nodes
        suite.addTestSuite(AddNodeTest.class);
        
        // set/add property
        suite.addTestSuite(GetPropertyTest.class);
        suite.addTestSuite(AddPropertyTest.class);
        suite.addTestSuite(AddNewPropertyTest.class);
        suite.addTestSuite(SingleValuedPropertyTest.class);
        suite.addTestSuite(MultiValuedPropertyTest.class);
        suite.addTestSuite(BinaryTest.class);

        // change mixin types
        suite.addTestSuite(MixinModificationTest.class);

        // move
        suite.addTestSuite(MoveTest.class);
        suite.addTestSuite(MoveReferenceableTest.class);
        suite.addTestSuite(MoveSNSTest.class);
        suite.addTestSuite(MoveTreeTest.class);
        suite.addTestSuite(MoveNewTreeTest.class);
        suite.addTestSuite(MoveMultipleTest.class);
        suite.addTestSuite(WorkspaceMoveTest.class);
        suite.addTestSuite(RevertMoveTest.class);
        suite.addTestSuite(MoveToNewTest.class);
        suite.addTestSuite(MoveCombinedTest.class);

        // refresh
        suite.addTestSuite(RefreshFalseTest.class);
        suite.addTestSuite(RefreshTrueTest.class);
        suite.addTestSuite(RefreshMovedTest.class);

        // remove
        suite.addTestSuite(RemoveNodeTest.class);
        suite.addTestSuite(RemovePropertyTest.class);
        suite.addTestSuite(RemoveReferenceableNodeTest.class);
        suite.addTestSuite(RemoveSNSTest.class);
        suite.addTestSuite(RemoveMovedNodeTest.class);

        // rename
        suite.addTestSuite(RenameTest.class);

        // reorder
        suite.addTestSuite(ReorderTest.class);
        suite.addTestSuite(ReorderReferenceableSNSTest.class);
        suite.addTestSuite(ReorderSNSTest.class);
        suite.addTestSuite(ReorderNewSNSTest.class);
        suite.addTestSuite(ReorderNewTest.class);
        suite.addTestSuite(ReorderNewAndSavedTest.class);
        suite.addTestSuite(ReorderMixedTest.class);
        suite.addTestSuite(ReorderMoveTest.class);

        // update
        suite.addTestSuite(UpdateTest.class);

        // various
        suite.addTestSuite(ReplaceNodeTest.class);
        suite.addTestSuite(HierarchyNodeTest.class);
        suite.addTestSuite(LazyItemIteratorTest.class);
        suite.addTestSuite(ExternalModificationTest.class);
        suite.addTestSuite(IsSameTest.class);

        // repository
        suite.addTestSuite(LoginTest.class);

        // observation
        suite.addTestSuite(ObservationTest.class);

        // workspace mgt
        suite.addTestSuite(WorkspaceTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("javax.jcr.query tests");

        // ADD TEST CLASSES HERE:
        suite.addTestSuite(SaveTest.class);
        suite.addTestSuite(SQLOrderByTest.class);
        suite.addTestSuite(SQLQueryLevel2Test.class);
        suite.addTestSuite(SQLJoinTest.class);
        suite.addTestSuite(SQLJcrPathTest.class);
        suite.addTestSuite(SQLPathTest.class);
        suite.addTestSuite(XPathPosIndexTest.class);
        suite.addTestSuite(XPathDocOrderTest.class);
        suite.addTestSuite(XPathOrderByTest.class);
        suite.addTestSuite(XPathQueryLevel2Test.class);
        suite.addTestSuite(XPathJcrPathTest.class);

        suite.addTestSuite(DerefQueryLevel1Test.class);
        suite.addTestSuite(ElementTest.class);
        suite.addTestSuite(TextNodeTest.class);
        suite.addTestSuite(GetLanguageTest.class);
        suite.addTestSuite(GetPersistentQueryPathLevel1Test.class);
        suite.addTestSuite(GetPersistentQueryPathTest.class);
        suite.addTestSuite(GetStatementTest.class);
        suite.addTestSuite(GetSupportedQueryLanguagesTest.class);
        suite.addTestSuite(CreateQueryTest.class);

        suite.addTestSuite(QueryResultNodeIteratorTest.class);
        suite.addTestSuite(GetPropertyNamesTest.class);
        suite.addTestSuite(PredicatesTest.class);
        suite.addTestSuite(SimpleSelectionTest.class);

        suite.addTestSuite(OrderByDateTest.class);
        suite.addTestSuite(OrderByDoubleTest.class);
        suite.addTestSuite(OrderByLongTest.class);
        suite.addTestSuite(OrderByMultiTypeTest.class);
        suite.addTestSuite(OrderByStringTest.class);
        suite.addTestSuite(OrderByLengthTest.class);
        suite.addTestSuite(OrderByLocalNameTest.class);
        suite.addTestSuite(OrderByNameTest.class);
        suite.addTestSuite(OrderByLowerCaseTest.class);
        suite.addTestSuite(OrderByUpperCaseTest.class);
        suite.addTestSuite(OrderByDecimalTest.class);
        suite.addTestSuite(OrderByURITest.class);
        suite.addTestSuite(SetLimitTest.class);
        suite.addTestSuite(SetOffsetTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("javax.jcr.version tests");

        suite.addTestSuite(VersionTest.class);
        suite.addTestSuite(VersionHistoryTest.class);
        suite.addTestSuite(VersionStorageTest.class);
        suite.addTestSuite(VersionLabelTest.class);
        suite.addTestSuite(CheckoutTest.class);
        suite.addTestSuite(CheckinTest.class);
        suite.addTestSuite(CopyTest.class);
        suite.addTestSuite(VersionGraphTest.class);
        suite.addTestSuite(RemoveVersionTest.class);
        suite.addTestSuite(RestoreTest.class);
        suite.addTestSuite(WorkspaceRestoreTest.class);
        suite.addTestSuite(OnParentVersionAbortTest.class);
        suite.addTestSuite(OnParentVersionComputeTest.class);
        suite.addTestSuite(OnParentVersionCopyTest.class);
        suite.addTestSuite(OnParentVersionIgnoreTest.class);
        suite.addTestSuite(OnParentVersionInitializeTest.class);
        suite.addTestSuite(GetReferencesNodeTest.class);
        suite.addTestSuite(GetPredecessorsTest.class);
        suite.addTestSuite(GetCreatedTest.class);
        suite.addTestSuite(GetContainingHistoryTest.class);
        suite.addTestSuite(GetVersionableUUIDTest.class);
        suite.addTestSuite(SessionMoveVersionExceptionTest.class);
        suite.addTestSuite(WorkspaceMoveVersionExceptionTest.class);
        suite.addTestSuite(MergeCancelMergeTest.class);
        suite.addTestSuite(MergeCheckedoutSubNodeTest.class);
        suite.addTestSuite(MergeDoneMergeTest.class);
        suite.addTestSuite(MergeNodeIteratorTest.class);
        suite.addTestSuite(MergeNodeTest.class);
        suite.addTestSuite(MergeShallowTest.class);
        suite.addTestSuite(MergeActivityTest.class);
        suite.addTestSuite(MergeNonVersionableSubNodeTest.class);
        suite.addTestSuite(MergeSubNodeTest.class);
        
        // JCR 2.0

        suite.addTestSuite(ActivitiesTest.class);
        suite.addTestSuite(ConfigurationsTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("Search tests");

        suite.addTestSuite(SimpleQueryTest.class);
        suite.addTestSuite(FulltextQueryTest.class);
        suite.addTestSuite(SelectClauseTest.class);
        suite.addTestSuite(SQLTest.class);
        suite.addTestSuite(JoinTest.class);
        suite.addTestSuite(OrderByTest.class);
        suite.addTestSuite(XPathAxisTest.class);
        suite.addTestSuite(SkipDeletedNodesTest.class);
        suite.addTestSuite(SkipDeniedNodesTest.class);
        suite.addTestSuite(MixinTest.class);
        suite.addTestSuite(DerefTest.class);
        suite.addTestSuite(VersionStoreQueryTest.class);
        suite.addTestSuite(UpperLowerCaseQueryTest.class);
        suite.addTestSuite(ChildAxisQueryTest.class);
        suite.addTestSuite(QueryResultTest.class);
        suite.addTestSuite(FnNameQueryTest.class);
        suite.addTestSuite(PathQueryNodeTest.class);
        suite.addTestSuite(ExcerptTest.class);
        suite.addTestSuite(ShareableNodeTest.class);
        suite.addTestSuite(ParentNodeTest.class);
        suite.addTestSuite(SimilarQueryTest.class);
        suite.addTestSuite(FulltextSQL2QueryTest.class);
        suite.addTestSuite(LimitAndOffsetTest.class);
        suite.addTestSuite(SQL2NodeLocalNameTest.class);
        suite.addTestSuite(SQL2OuterJoinTest.class);
        suite.addTestSuite(SQL2PathEscapingTest.class);
        suite.addTestSuite(SQL2QueryResultTest.class);
        suite.addTestSuite(LimitedAccessQueryTest.class);
        suite.addTestSuite(SQL2OffsetLimitTest.class);
        suite.addTestSuite(SQL2OrderByTest.class);
        suite.addTestSuite(DescendantSelfAxisTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("Core tests");

        suite.addTestSuite(ReplacePropertyWhileOthersReadTest.class);
        suite.addTestSuite(CachingHierarchyManagerTest.class);
        suite.addTestSuite(ShareableNodeTest.class);
        suite.addTestSuite(MultiWorkspaceShareableNodeTest.class);
        suite.addTestSuite(TransientRepositoryTest.class);
        suite.addTestSuite(XATest.class);
        suite.addTestSuite(RestoreAndCheckoutTest.class);
        suite.addTestSuite(NodeImplTest.class);
        suite.addTestSuite(RetentionRegistryImplTest.class);
        suite.addTestSuite(InvalidDateTest.class);
        suite.addTestSuite(SessionGarbageCollectedTest.class);
        suite.addTestSuite(ReferencesTest.class);
        suite.addTestSuite(ReplaceTest.class);

        // test related to NodeStateMerger
        suite.addTestSuite(ConcurrentImportTest.class);
        suite.addTestSuite(ConcurrentAddRemoveMoveTest.class);
        suite.addTestSuite(ConcurrentAddRemovePropertyTest.class);
        suite.addTestSuite(ConcurrentMixinModificationTest.class);
        suite.addTestSuite(ConcurrentModificationWithSNSTest.class);
        suite.addTestSuite(ConcurrentMoveTest.class);
        suite.addTestSuite(ConcurrentReorderTest.class);
        suite.addTestSuite(ConcurrentAddRemoveNodeTest.class);

        suite.addTestSuite(LostFromCacheIssueTest.class);

        // TODO: These tests pass, but they cause some instability in other
        // parts of the test suite, most likely due to uncleaned test data
        if (Boolean.getBoolean("org.apache.jackrabbit.test.integration")) {
            suite.addTestSuite(ConcurrencyTest.class);
//            // suite.addTestSuite(ConcurrencyTest3.class);
            suite.addTestSuite(ConcurrentVersioningTest.class);
//            // suite.addTestSuite(ConcurrentVersioningWithTransactionsTest.class);
//            suite.addTestSuite(ConcurrentCheckinMixedTransactionTest.class);
//            suite.addTestSuite(ConcurrentLoginTest.class);
//            suite.addTestSuite(ConcurrentNodeModificationTest.class);
//            suite.addTestSuite(ConcurrentReadWriteTest.class);
            suite.addTestSuite(ConcurrentRenameTest.class);
            suite.addTestSuite(ConcurrentSaveTest.class);
//            suite.addTestSuite(ConcurrentWorkspaceCopyTest.class);
        }

        suite.addTestSuite(UserPerWorkspaceSecurityManagerTest.class);
        suite.addTestSuite(OverlappingNodeAddTest.class);
        suite.addTestSuite(NPEandCMETest.class);
        suite.addTestSuite(ConsistencyCheck.class);
        suite.addTestSuite(RemoveAddNodeWithUUIDTest.class);
        suite.addTestSuite(MoveAtRootTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("QOM tests");

        suite.addTestSuite(AndConstraintTest.class);
        suite.addTestSuite(BindVariableValueTest.class);
        suite.addTestSuite(ChildNodeJoinConditionTest.class);
        suite.addTestSuite(ChildNodeTest.class);
        suite.addTestSuite(ColumnTest.class);
        suite.addTestSuite(DescendantNodeJoinConditionTest.class);
        suite.addTestSuite(DescendantNodeTest.class);
        suite.addTestSuite(EquiJoinConditionTest.class);
        suite.addTestSuite(FullTextSearchScoreTest.class);
        suite.addTestSuite(GetQueryTest.class);
        suite.addTestSuite(LengthTest.class);
        suite.addTestSuite(NodeLocalNameTest.class);
        suite.addTestSuite(NodeNameTest.class);
        suite.addTestSuite(NotConstraintTest.class);
        suite.addTestSuite(OrConstraintTest.class);
        suite.addTestSuite(OrderingTest.class);
        suite.addTestSuite(PropertyExistenceTest.class);
        suite.addTestSuite(PropertyValueTest.class);
        suite.addTestSuite(QueryObjectModelFactoryTest.class);
        suite.addTestSuite(RowTest.class);
        suite.addTestSuite(SameNodeJoinConditionTest.class); 
        suite.addTestSuite(SameNodeTest.class);
        suite.addTestSuite(SelectorTest.class);
        suite.addTestSuite(UpperLowerCaseTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("core.security.user tests");

        suite.addTestSuite(UserManagerImplTest.class);
        suite.addTestSuite(AuthorizableImplTest.class);
        suite.addTestSuite(UserImplTest.class);
        suite.addTestSuite(GroupImplTest.class);
        suite.addTestSuite(ImpersonationImplTest.class);
        suite.addTestSuite(AuthorizableActionTest.class);

        suite.addTestSuite(UserAdministratorTest.class);
        suite.addTestSuite(NotUserAdministratorTest.class);
        suite.addTestSuite(GroupAdministratorTest.class);
        suite.addTestSuite(AdministratorTest.class);

        suite.addTestSuite(IndexNodeResolverTest.class);
        suite.addTestSuite(TraversingNodeResolverTest.class);

        suite.addTestSuite(NodeCreationTest.class);

        suite.addTestSuite(UserImporterTest.class);

        suite.addTestSuite(UserAccessControlProviderTest.class);
        suite.addTestSuite(DefaultPrincipalProviderTest.class);        

        suite.addTestSuite(PasswordUtilityTest.class);
        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("Observation tests");

        suite.addTestSuite(EventIteratorTest.class);
        suite.addTestSuite(EventTest.class);
        suite.addTestSuite(GetRegisteredEventListenersTest.class);
        suite.addTestSuite(LockingTest.class);
        suite.addTestSuite(NodeAddedTest.class);
        suite.addTestSuite(NodeRemovedTest.class);
        suite.addTestSuite(NodeMovedTest.class);
        suite.addTestSuite(NodeReorderTest.class);
        suite.addTestSuite(PropertyAddedTest.class);
        suite.addTestSuite(PropertyChangedTest.class);
        suite.addTestSuite(PropertyRemovedTest.class);
        suite.addTestSuite(AddEventListenerTest.class);
        suite.addTestSuite(WorkspaceOperationTest.class);

        // JCR 2.0
        
        suite.addTestSuite(EventJournalTest.class);
        suite.addTestSuite(GetDateTest.class);
        suite.addTestSuite(GetIdentifierTest.class);
        suite.addTestSuite(GetInfoTest.class);
        suite.addTestSuite(GetUserDataTest.class);
        
        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("javax.jcr.nodetype tests");

        // ADD TEST CLASSES HERE:
        suite.addTestSuite(NodeDefTest.class);
        suite.addTestSuite(NodeTypeManagerTest.class);
        suite.addTestSuite(NodeTypeTest.class);
        suite.addTestSuite(PropertyDefTest.class);

        suite.addTestSuite(PredefinedNodeTypeTest.class);

        suite.addTestSuite(CanSetPropertyBinaryTest.class);
        suite.addTestSuite(CanSetPropertyBooleanTest.class);
        suite.addTestSuite(CanSetPropertyDateTest.class);
        suite.addTestSuite(CanSetPropertyDoubleTest.class);
        suite.addTestSuite(CanSetPropertyLongTest.class);
        suite.addTestSuite(CanSetPropertyMultipleTest.class);
        suite.addTestSuite(CanSetPropertyNameTest.class);
        suite.addTestSuite(CanSetPropertyPathTest.class);
        suite.addTestSuite(CanSetPropertyStringTest.class);
        suite.addTestSuite(CanSetPropertyTest.class);

        suite.addTestSuite(CanAddChildNodeCallWithNodeTypeTest.class);
        suite.addTestSuite(CanAddChildNodeCallWithoutNodeTypeTest.class);

        suite.addTestSuite(CanRemoveItemTest.class);
        
        // JCR 2.0

        suite.addTestSuite(NodeTypeCreationTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("Data tests");

        suite.addTestSuite(ConcurrentGcTest.class);
        suite.addTestSuite(CopyValueTest.class);
        suite.addTestSuite(DataStoreAPITest.class);
        suite.addTestSuite(DataStoreTest.class);
        suite.addTestSuite(DBDataStoreTest.class);
        suite.addTestSuite(ExportImportTest.class);
        suite.addTestSuite(GarbageCollectorTest.class);
        suite.addTestSuite(GCConcurrentTest.class);
        suite.addTestSuite(GCEventListenerTest.class);
        suite.addTestSuite(LazyFileInputStreamTest.class);
        suite.addTestSuite(NodeTypeTest.class);
        suite.addTestSuite(OpenFilesTest.class);
        suite.addTestSuite(PersistenceManagerIteratorTest.class);
        suite.addTestSuite(TestTwoGetStreams.class);
        suite.addTestSuite(WriteWhileReadingTest.class);
        suite.addTestSuite(GCSubtreeMoveTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new TestSuite("Daily integration tests");

        // random operation test
        suite.addTestSuite(RandomOperationTest.class);

        // multi-threading tests
        suite.addTestSuite(ConcurrencyTest.class);
        suite.addTestSuite(ConcurrentLoginTest.class);
        suite.addTestSuite(ConcurrentNodeModificationTest.class);
        suite.addTestSuite(ConcurrentReadWriteTest.class);
        suite.addTestSuite(ConcurrentSaveTest.class);
        suite.addTestSuite(ConcurrentVersioningTest.class);
        suite.addTestSuite(ConcurrentVersioningWithTransactionsTest.class);
        suite.addTestSuite(ConcurrentCheckinMixedTransactionTest.class);
        suite.addTestSuite(ConcurrentAddMoveRemoveTest.class);
        suite.addTestSuite(LockTest.class);
        suite.addTestSuite(ReadVersionsWhileModified.class);
        suite.addTestSuite(ConcurrentLockingTest.class);
        suite.addTestSuite(ConcurrentLockingWithTransactionsTest.class);
        suite.addTestSuite(LargeResultSetTest.class);
        suite.addTestSuite(ConcurrentQueriesWithUpdatesTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("security.authorization.acl tests");

        suite.addTestSuite(ACLTemplateTest.class);
        suite.addTestSuite(ACLTemplateEntryTest.class);
        suite.addTestSuite(EntryTest.class);
        suite.addTestSuite(EntryCollectorTest.class);

        suite.addTestSuite(ReadTest.class);
        suite.addTestSuite(WriteTest.class);
        suite.addTestSuite(AcReadWriteTest.class);
        suite.addTestSuite(LockTest.class);
        suite.addTestSuite(VersionTest.class);
        suite.addTestSuite(NodeTypeTest.class);
        suite.addTestSuite(EffectivePolicyTest.class);
        suite.addTestSuite(ACLEditorTest.class);
        suite.addTestSuite(RepositoryOperationTest.class);
        suite.addTestSuite(MoveTest.class);
        suite.addTestSuite(RestrictionTest.class);

        return suite;
    }


    public static Test suite() {
        TestSuite suite = new ConcurrentTestSuite("Search tests");

        suite.addTestSuite(IndexingQueueTest.class);
        suite.addTestSuite(DecimalConvertTest.class);
        suite.addTestSuite(IndexingAggregateTest.class);
        suite.addTestSuite(IndexMigrationTest.class);
        suite.addTestSuite(ChainedTermEnumTest.class);
        suite.addTestSuite(IndexingConfigurationImplTest.class);
        suite.addTestSuite(SQL2IndexingAggregateTest.class);
        suite.addTestSuite(SQL2IndexingAggregateTest2.class);
        suite.addTestSuite(LazyTextExtractorFieldTest.class);
        suite.addTestSuite(IndexInfosTest.class);
        suite.addTestSuite(IndexingRuleTest.class);
        suite.addTestSuite(TextExtractionQueryTest.class);
        suite.addTestSuite(ArrayHitsTest.class);
        suite.addTestSuite(IndexFormatVersionTest.class);
        suite.addTestSuite(SynonymProviderTest.class);

        return suite;
    }


    protected void tearDown() throws Exception {
        try {
            lockedNode.unlock();
        } catch (RepositoryException e) {
            log.warn(e.getMessage());
        }
        lockedNode = null;
        childNode = null;
        lock = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        // make sure all locks are removed
        try {
            lockedNode.unlock();
        } catch (RepositoryException e) {
            // ignore
        }
        if (otherSession.isLive()) {
            otherSession.logout();
            otherSession = null;
        }
        lockedNode = null;
        childNode = null;
        lock = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            // clean up: remove the version labels again.
            vHistory.removeVersionLabel(versionLabel);
            vHistory.removeVersionLabel(versionLabel2);
        } catch (RepositoryException e) {
            // ignore
        }
        vHistory = null;
        version = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        if (session != null) {
            session.logout();
            session = null;
        }
        ntreg = null;
        ntDefCollection = null;
        nameFactory = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            versionableNode2.remove();
        } finally {
            versionableNode2 = null;
            version = null;
            version2 = null;
            vHistory = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        // remove versionable nodes
        try {
            versionableNode.remove();
            testRootNode.getSession().save();
        } catch (Exception e) {
            log.println("Exception in tearDown: " + e.toString());
        } finally {
            versionableNodeType = null;
            nonVersionableNodeType = null;
            versionableNode = null;
            nonVersionableNode = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        file.delete();
        if (session != null) {
            session.logout();
            session = null;
        }
        workspace = null;
        nsr = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        property1 = null;
        property2 = null;
        node = null;
        sv1 = null;
        sv2 = null;
        mv1 = null;
        mv2 = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            if (session != null) {
                session.logout();
                session = null;
            }
        } finally {
            nsr = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        if (sessionW2 != null) {
            sessionW2.logout();
            sessionW2 = null;
        }
        if (session != null) {
            session.logout();
            session = null;
        }
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            if (s2 != null) {
                s2.logout();
                s2 = null;
            }
        } finally {
            qm = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            versionableNode2.remove();
            testRootNode.getSession().save();
        } finally {
            version = null;
            version2 = null;
            rootVersion = null;
            versionableNode2 = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            versionableNode2.remove();
            testRootNode.getSession().save();
        } finally {
            version = null;
            version2 = null;
            rootVersion = null;
            versionableNode2 = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        // remove versionable nodes
        try {
            if (versionableNode != null) {
                versionableNode.remove();
            }
            testRootNode.getSession().save();
        } catch (Exception e) {
            log.println("Exception in tearDown: " + e.toString());
        } finally {
            versionableNodeType = null;
            nonVersionableNodeType = null;
            versionableNode = null;
            nonVersionableNode = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        andrew = null;
        bill = null;
        carl = null;
        daren = null;
        eric = null;
        frank = null;
        sun = null;
        microsoft = null;
        ibm = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            Session session = getHelper().getSuperuserSession();
            if (session.getRootNode().hasNode("test")) {
                session.getRootNode().getNode("test").remove();
                session.save();
            }
        } finally {
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            if (addNodeSession != null) {
                addNodeSession.logout();
                addNodeSession = null;
            }
            if (removePropertySession != null) {
                removePropertySession.logout();
                removePropertySession = null;
            }
        } finally {
            super.tearDown();
        }
    }


    protected synchronized void invalidateSharedReader() throws IOException {
        // also close the read-only reader
        if (readOnlyReader != null) {
            readOnlyReader.release();
            readOnlyReader = null;
        }
        // invalidate shared reader
        if (sharedReader != null) {
            sharedReader.release();
            sharedReader = null;
        }
    }


    protected void tearDown() throws Exception {
        if (otherS != null) {
            otherS.logout();
        }
        superuser.refresh(false);
        RetentionPolicy rp = retentionMgr.getRetentionPolicy(testNodePath);
        if (rp != null) {
            retentionMgr.removeRetentionPolicy(testNodePath);
            superuser.save();
        }
        super.tearDown();
    }


    public void tearDown() throws Exception {
        if (file != null) {
            file.delete();
            file = null;
        }
        if (session != null && session.isLive()) {
            session.logout();
            session = null;
        }
        workspace = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            if (uSession != null) {
                uSession.logout();
            }
        } finally {
            Authorizable a = userMgr.getAuthorizable(uID);
            if (a != null) {
                a.remove();
                save(superuser);
            }
        }
        super.tearDown();
    }


    public void close() throws IOException {
        if (in != null) {
            in.close();
            in = null;
            // some additional database objects
            // may need to be closed
            if (rs != null) {
                DbUtility.close(rs);
                rs = null;
            }
        }
    }


    protected void tearDown() throws Exception {
        try {
            if (uSession != null) {
                uSession.logout();
            }
        } finally {
            // remove group member ship
            groupAdmin.removeMember(userMgr.getAuthorizable(uID));

            // remove all users that have been created
            Authorizable a = userMgr.getAuthorizable(otherUID);
            if (a != null) {
                a.remove();
            }
            save(superuser);
        }
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        try {
            uSession.logout();
        } finally {
            Authorizable a = userMgr.getAuthorizable(uID);
            if (a != null) {
                a.remove();
            }
            a = userMgr.getAuthorizable(otherUID);
            if (a != null) {
                a.remove();
            }
            save(superuser);
        }
        super.tearDown();
    }


    public void testRemoveLockedChild() throws RepositoryException {
        Session otherSession = getHelper().getReadWriteSession();
        try {
            Node child = (Node) otherSession.getItem(childNode.getPath());
            child.remove();
            otherSession.save();
            fail("A node below a deeply locked node cannot be removed by another Session.");
        } catch (LockException e) {
            // success
        } finally {
            otherSession.logout();
        }
    }


    public void testRemoveLockedChild() throws RepositoryException {
        Session otherSession = getHelper().getReadWriteSession();
        try {
            Node child = (Node) otherSession.getItem(childNode.getPath());
            child.remove();
            otherSession.save();
            fail("A node below a deeply locked node cannot be removed by another Session.");
        } catch (LockException e) {
            // success
        } finally {
            otherSession.logout();
        }
    }


    public void testTokenTransfer() throws Exception {
        String lockToken = lock.getLockToken();
        try {
            superuser.removeLockToken(lockToken);

            String nlt = lock.getLockToken();
            assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                    nlt == null || nlt.equals(lockToken));
        } finally {
            // move lock token back in order to have lock removed properly
            superuser.addLockToken(lockToken);
        }
    }


    public void testRemoveLockToken2() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        try {
            lockMgr.removeLockToken(ltoken);

            String nlt = l.getLockToken();
            assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                    nlt == null || nlt.equals(ltoken));
        } finally {
            // make sure lock token is added even if test fail
            lockMgr.addLockToken(ltoken);
        }
    }


    public void testUnlockAfterTokenTransfer() throws Exception {
        String lockToken = lock.getLockToken();
        try {
            superuser.removeLockToken(lockToken);
            lockedNode.unlock();
            fail("After transfering lock token the original lock object cannot be unlocked by session, that does hold lock any more.");
        } catch (LockException e) {
            // oK
        } finally {
            // move lock token back in order to have lock removed properly
            superuser.addLockToken(lockToken);
        }
    }


    public void testRefreshAfterTokenTransfer() throws Exception {
        String lockToken = lock.getLockToken();
        try {
            superuser.removeLockToken(lockToken);
            lock.refresh();
            fail("After transfering lock token the original lock object cannot be refresh by session, that does hold lock any more.");
        } catch (LockException e) {
            // oK
        } finally {
            // move lock token back in order to have lock removed properly
            superuser.addLockToken(lockToken);
        }
    }


    public void testRemoveLockTokenTwice() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        lockMgr.removeLockToken(ltoken);
        try {
            // remove token a second time
            lockMgr.removeLockToken(ltoken);
            fail("Removing a lock token twice must fail.");
        } catch (LockException e) {
            // success
        } finally {
            // make sure lock token is added even if test fail
            lockMgr.addLockToken(ltoken);
        }
    }


    public void testAddLockTokenAgain() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        try {
            // remove lock token
            lockMgr.removeLockToken(ltoken);
        } finally {
            // make sure lock token is added even if test fail
            lockMgr.addLockToken(ltoken);
            assertTrue(containsLockToken(lockMgr, ltoken));
            assertNotNull("Token must be exposed again", l.getLockToken());
            assertEquals("The lock must get the same token again.", ltoken, l.getLockToken());
        }
    }


    public void testRemoveLockToken3() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        try {
            lockMgr.removeLockToken(ltoken);

            // without holding the token session must not be allowed to modify
            // the locked node.
            try {
                testNode.addNode(nodeName2, testNodeType);
                fail("Session must not be allowed to modify node");
            } catch (LockException e) {
                // expected
            }
        } finally {
            // make sure lock token is added even if test fail
            lockMgr.addLockToken(ltoken);
        }
    }


    public void testRemoveLockToken() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        try {
            // remove lock token
            lockMgr.removeLockToken(ltoken);

            assertFalse(containsLockToken(lockMgr, ltoken));
            assertFalse(containsLockToken(superuser.getLockTokens(), ltoken));
        } finally {
            // make sure lock token is added even if test fail
            lockMgr.addLockToken(ltoken);
            assertTrue(containsLockToken(lockMgr, ltoken));
            assertNotNull("Token must be exposed again", l.getLockToken());
            assertEquals("The lock must get the same token again.", ltoken, l.getLockToken());
        }
    }


    public void testRefreshAfterTokenTransfer2() throws Exception {
        String lockToken = lock.getLockToken();

        Node n2 = (Node) otherSession.getItem(lockedNode.getPath());
        try {
            superuser.removeLockToken(lockToken);
            otherSession.addLockToken(lockToken);

            n2.getLock().refresh();
        } finally {
            // move lock token back in order to have lock removed properly
            otherSession.removeLockToken(lockToken);
            superuser.addLockToken(lockToken);
        }
    }


    public void testLockHolderAfterTokenTransfer() throws Exception {
        String lockToken = lock.getLockToken();
        Node n2 = (Node) otherSession.getItem(lockedNode.getPath());
        try {
            superuser.removeLockToken(lockToken);
            otherSession.addLockToken(lockToken);

            assertTrue("After lockToken transfer, the new lockHolder must get a non-null token", n2.getLock().getLockToken() != null);
            assertTrue("After lockToken transfer, the new lockHolder must get the same token.", n2.getLock().getLockToken().equals(lockToken));
        } finally {
            // move lock token back in order to have lock removed properly
            otherSession.removeLockToken(lockToken);
            superuser.addLockToken(lockToken);
        }
    }


    public void testParentChildLock() throws Exception {
        childNode.addMixin(mixLockable);
        testRootNode.save();

        // lock child node
        try {
            childNode.lock(false, isSessionScoped());
            // unlock parent node
            lockedNode.unlock();
            // child node must still hold lock
            assertTrue("child node must still hold lock", childNode.isLocked() && childNode.holdsLock());
        } finally {
            childNode.unlock();
        }
    }


    public void testParentChildLock2() throws Exception {
        childNode.addMixin(mixLockable);
        testRootNode.save();
        try {
            Lock l = childNode.lock(false, isSessionScoped());
            assertTrue("child node must still hold lock", l.getNode().isSame(childNode));
        } finally {
            childNode.unlock();
        }
    }


    public void testReorder2() throws RepositoryException {
        testRootNode.orderBefore(getRelPath(child3), getRelPath(child1));
        testRootNode.save();

        Session otherSession = getHelper().getReadOnlySession();
        try {
            testOrder((Node) otherSession.getItem(testRootNode.getPath()), new Node[] {child3, child1, child2, child4});
        } finally {
            otherSession.logout();
        }
    }


    public void testNodeSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        defaultRootNode.save();

        // get the new node with a different session
        Session testSession = getHelper().getReadOnlySession();
        try {
            testSession.getItem(testNode.getPath());
        } finally {
            testSession.logout();
        }
    }


    public void testAddNodeParentSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // add a node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new nodes
        defaultRootNode.save();

        // use a different session to verify if the node is there
        Session session = getHelper().getReadOnlySession();
        try {
            testNode = (Node) session.getItem(testNode.getPath());
        } finally {
            session.logout();
        }
    }


    public void testAddNodeParentSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // add node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        defaultRootNode.save();

        // use a different session to verify if the node is there
        Session session = getHelper().getReadOnlySession();
        try {
            session.getItem(testNode.getPath());
        } finally {
            session.logout();
        }
    }


    public void testAddNodeSessionSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // add node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        superuser.save();

        // use a different session to verify if the node is there
        Session session = getHelper().getReadOnlySession();
        try {
            session.getItem(testNode.getPath());
        } finally {
            session.logout();
        }
    }


    public void testCheckPermission() throws Exception {
        testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        Session readOnly = getHelper().getReadOnlySession();
        try {
            permissionCheckReadOnly(readOnly);
            permissionCheckReadWrite(superuser);
        } finally {
            readOnly.logout();
        }
    }


    public void testAddNodeSessionSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // add a node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new nodes
        superuser.save();

        // use a different session to verify if the node is there
        Session session = getHelper().getReadOnlySession();
        try {
            testNode = (Node) session.getItem(testNode.getPath());
        } finally {
            session.logout();
        }
    }


    public void testSaveNewNode() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node newNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save changes
        superuser.save();

        // use a different session to verify if the node is there
        Session s = getHelper().getReadOnlySession();
        try {
            s.getItem(newNode.getPath());
            // throws PathNotFoundException if item was not saved
        } finally {
            s.logout();
        }
    }


    public void testRegisterPrivilegeAsNonAdmin() throws RepositoryException {
        Session s = getHelper().getReadOnlySession();
        try {
            ((JackrabbitWorkspace) s.getWorkspace()).getPrivilegeManager().registerPrivilege("test", true, new String[0]);
            fail("Only admin is allowed to register privileges.");
        } catch (AccessDeniedException e) {
            // success
        } finally {
            s.logout();
        }
    }


    public void testIsSameProperty() throws RepositoryException {

        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Property p = n.setProperty(propertyName1, "anyvalue");
        testRootNode.save();

        // access same property through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Property otherProperty = (Property) otherSession.getItem(p.getPath());
            assertTrue(p.isSame(otherProperty));
        } finally {
            otherSession.logout();
        }
    }


    public void testSaveModifiedNode() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node newNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        superuser.save();

        // and add a child node
        newNode.addNode(nodeName2, testNodeType);

        // save the changes
        superuser.save();

        // check if the child node was created properly

        // get a reference with a second session to the modified node
        Session s = getHelper().getReadOnlySession();
        try {
            Node newNodeSession2 = (Node) s.getItem(newNode.getPath());
            // check if child is there
            assertTrue("Modifications on  a node are not save after Session.save()", newNodeSession2.hasNode(nodeName2));
        } finally {
            s.logout();
        }
    }


    public void testGetPrivilegesThrowsAccessDenied() throws RepositoryException {
        Session readOnly = getHelper().getReadOnlySession();
        JackrabbitAccessControlManager jacMgr = (JackrabbitAccessControlManager) readOnly.getAccessControlManager();
        try {
            jacMgr.getPrivileges(testRoot, principals);
            fail("ReadOnly session isn't allowed to determine the privileges of other principals.");
        } catch (AccessDeniedException e) {
            // success
        } finally {
            readOnly.logout();
        }
    }


    public void testHasPrivilegeThrowsAccessDenied() throws RepositoryException {
        Session readOnly = getHelper().getReadOnlySession();
        JackrabbitAccessControlManager jacMgr = (JackrabbitAccessControlManager) readOnly.getAccessControlManager();
        try {
            jacMgr.hasPrivileges(testRoot, principals, new Privilege[] {jacMgr.privilegeFromName(Privilege.JCR_READ)});
            fail("ReadOnly session isn't allowed to determine the privileges of other principals.");
        } catch (AccessDeniedException e) {
            // success
        } finally {
            readOnly.logout();
        }
    }


    public void testCheckAddNodePermissionOnRoot() throws RepositoryException {
        Session session = getHelper().getReadOnlySession();
        try {
            session.checkPermission("/", "add_node");
        } catch (PathNotFoundException e) {
            fail("JCR-1731: Session.checkPermission(\"/\", \"add_node\")"
                    + " throws PathNotFoundException instead of"
                    + " AccessControlException");
        } catch (AccessControlException e) {
            // expected
        } finally {
            session.logout();
        }
    }


    public void testIsSameMustNotCompareStates()
            throws RepositoryException {

        // create a node and save it
        Node testNode1 = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();

        // acquire the same node with a different session
        Session session = getHelper().getReadOnlySession();
        try {
            Node testNode2 = (Node) session.getItem(testNode1.getPath());

            // add a property and do not save it so property is different in testNode2
            testNode1.setProperty(propertyName1, "value1");

            assertTrue("Two references of same node should return true for Node1.isSame(Node2)",
                    testNode1.isSame(testNode2));
        } finally {
            session.logout();
        }
    }


    public void testIsSameProperty2() throws RepositoryException {

        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Property p = n.setProperty(propertyName1, "anyvalue");
        testRootNode.save();

        // add transient modification to the property:
        p.setValue("someOtherValue");

        // access same property through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Property otherProperty = (Property) otherSession.getItem(p.getPath());
            assertTrue(p.isSame(otherProperty));
        } finally {
            otherSession.logout();
        }
    }


    public void testMoveNode() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create parent node
        Node srcParentNode = defaultRootNode.addNode(nodeName1, testNodeType);
        // create node to be moved
        Node moveNode = srcParentNode.addNode(nodeName2, testNodeType);

        // create a node that will serve as new parent
        Node destParentNode = defaultRootNode.addNode(nodeName3, testNodeType);

        // save the new nodes
        superuser.save();

        //move the nodes
        superuser.move(moveNode.getPath(), destParentNode.getPath() + "/" + nodeName2);

        superuser.save();

        // get moved tree root node with session 2
        Session testSession = getHelper().getReadWriteSession();
        try {
            testSession.getItem(destParentNode.getPath() + "/" + nodeName2);
            // node found
        } finally {
            testSession.logout();
        }
    }


    public void testMoveConstraintViolationExceptionDest() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create parent node
        Node srcParentNode = defaultRootNode.addNode(nodeName1, testNodeType);
        // create node to be moved
        Node moveNode = srcParentNode.addNode(nodeName2, testNodeType);

        // create a node that will serve as new parent
        Node destParentNode = defaultRootNode.addNode(nodeName3, testNodeType);

        // save the new nodes
        superuser.save();

        // move the node
        superuser.move(moveNode.getPath(), destParentNode.getPath() + "/" + nodeName2);

        // save only moved node
        try {
            destParentNode.save();
            fail("Saving only moved node after a Session.move() operation should throw ConstraintViolationException");
        } catch (ConstraintViolationException e) {
            // ok try to save the source
        }
    }


    public void testMoveConstraintViolationExceptionSrc() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create parent node
        Node srcParentNode = defaultRootNode.addNode(nodeName1, testNodeType);
        // create node to be moved
        Node moveNode = srcParentNode.addNode(nodeName2, testNodeType);

        // create a node that will serve as new parent
        Node destParentNode = defaultRootNode.addNode(nodeName3, testNodeType);

        // save the new nodes
        superuser.save();

        // move the node
        superuser.move(moveNode.getPath(), destParentNode.getPath() + "/" + nodeName2);

        // save only old parent node
        try {
            srcParentNode.save();
            fail("Saving only the source parent node after a Session.move() operation must throw ConstraintViolationException");
        } catch (ConstraintViolationException e) {
            // ok both work as expected
        }
    }


    public void testMoveRepositoryException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create parent node
        Node srcParentNode = defaultRootNode.addNode(nodeName1, testNodeType);
        // create node to be moved
        Node moveNode = srcParentNode.addNode(nodeName2, testNodeType);

        // create a node that will serve as new parent
        Node destParentNode = defaultRootNode.addNode(nodeName3, testNodeType);

        // save the new nodes
        superuser.save();

        // move the node
        try {
            superuser.move(moveNode.getPath(), destParentNode.getPath() + "/" + nodeName2 + "[1]");
            fail("If destination path of Session.move() contains an index as postfix it must throw RepositoryException");
        } catch (RepositoryException e) {
            // ok works as expected
        }
    }


    public void testMovePathNotFoundExceptionDestInvalid() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create parent node
        Node srcParentNode = defaultRootNode.addNode(nodeName1, testNodeType);
        // create node to move
        Node moveNode = srcParentNode.addNode(nodeName2, testNodeType);

        // save the new nodes
        superuser.save();

        // move the node
        try {
            superuser.move(moveNode.getPath(), defaultRootNode.getPath() + "/" + nodeName2 + "/" + nodeName1);
            fail("Invalid destination path during Session.move() must throw PathNotFoundException");
        } catch (PathNotFoundException e) {
            // ok, works as expected
        }
    }


    public void testRefreshInvalidItemStateException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save the new node
        defaultRootNode.save();

        // remove the node
        defaultRootNode.remove();

        try {
            testNode.refresh(true);
            fail("Calling Node.refresh() on deleted node should throw InvalidItemStateException!");
        } catch (InvalidItemStateException e) {
            // ok, works as expected
        }
    }


    public void testUpdateNoSuchWorkspaceException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a test node in default workspace
        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save changes
        superuser.save();

        try {
            testNode.update(getNonExistingWorkspaceName(superuser));
            fail("Calling Node.update() on a non existing workspace should throw NoSuchWorkspaceException");
        } catch (NoSuchWorkspaceException e) {
            // ok, works as expected
        }
    }


    public void testMovePathNotFoundExceptionSrcInvalid() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node that will serve as new parent
        Node destParentNode = defaultRootNode.addNode(nodeName3, testNodeType);

        // save the new nodes
        superuser.save();

        // move the node
        try {
            superuser.move(defaultRootNode.getPath() + "/" + nodeName1, destParentNode.getPath() + "/" + nodeName2);
            fail("Invalid source path during Session.move() must throw PathNotFoundException");
        } catch (PathNotFoundException e) {
            // ok. works as expected
        }
    }


    public void testGetCorrespondingNodePathNoSuchWorkspaceException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create testNode in default workspace
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save changes
        superuser.save();

        try {
            defaultTestNode.getCorrespondingNodePath(getNonExistingWorkspaceName(superuser));
            fail("Calling Node.getCorrespondingNodePath(workspace) with invalid workspace should throw NoSuchWorkspaceException");
        } catch (NoSuchWorkspaceException e) {
            // ok, works as expected
        }
    }


    public void testShadowingItems3() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Property p = n.setProperty(propertyName1, "anyValue");
        testRootNode.save();

        p.remove();
        Property p2 = n.setProperty(propertyName1, "anyValue");
        try {
            assertFalse(p2.isSame(p));
        } catch (InvalidItemStateException e) {
            // ok as well.
        }
    }


    public void testRemoveNodeParentSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create the node
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save the nodes
        defaultRootNode.save();

        // remove them
        defaultTestNode.remove();

        defaultRootNode.save();

        // check if the node has been properly removed
        try {
            defaultRootNode.getNode(nodeName1);
            fail("Permanently removed node should no longer be adressable using Parent Node's getNode() method");
        } catch (PathNotFoundException e) {
            // ok, works as expected
        }
    }


    public void testRemoveNodeSessionSave() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create the node
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save the nodes
        superuser.save();

        // remove them
        defaultTestNode.remove();

        superuser.save();

        // check if the node has been properly removed
        try {
            superuser.getItem(defaultRootNode.getPath() + "/" + nodeName1);
            fail("Permanently removed node should no longer be adressable using Session.getItem()");
        } catch (PathNotFoundException e) {
            // ok, works as expected
        }
    }


    public void testMixinTypesProtected() throws Exception {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);

        Value mixinName = superuser.getValueFactory().createValue(mixLockable, PropertyType.NAME);
        try {
            testNode.setProperty(jcrMixinTypes, new Value[]{mixinName});
            fail("Manually setting jcr:mixinTypes should throw a ConstraintViolationException");
        }
        catch (ConstraintViolationException success) {
            // ok
        }
    }


    public void testAddNodeConstraintViolationExceptionProperty() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // add a node
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // set a property
        defaultTestNode.setProperty(propertyName1, "test");

        try {
            // try to add a node as a child of a property
            defaultTestNode.addNode(propertyName1 + "/" + nodeName2);
            fail("Adding a node as a child of a property should throw ConstraintViolationException");
        } catch (ConstraintViolationException e) {
            // ok, works as expected
        }
    }


    public void testAddReplacementAfterMove() throws RepositoryException {
        // transiently move the 'removeNode'
        superuser.move(removeNode.getPath(), testRootNode.getPath() + "/" + nodeName4);
        // add node that replaces the moved node
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        // ... and a child node.
        n.addNode(nodeName2, testNodeType);
        testRootNode.save();

        try {
            // if (for impl reasons) 'n' is referenceable -> it must have a
            // different uuid.
            assertFalse(uuid.equals(n.getUUID()));
        } catch (UnsupportedRepositoryOperationException e) {
            // n has not been made referenceable before -> OK.
        }
    }


    public void testAddNodeConstraintViolationExceptionUndefinedNodeType() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, nodetype);

        try {
            defaultTestNode.addNode(nodeName2);
            fail("Adding a node with node.addNode(node) where nodetype can not be determined from parent should" +
                    " throw ConstraintViolationException");
        } catch (ConstraintViolationException e) {
            // ok, works as expected
        }
    }


    public void testAddReplacementAfterRemove() throws RepositoryException {
        // transient removal of the 'removeNode'
        removeNode.remove();
        // add node that replaces the transiently removed node
        Node n = testRootNode.addNode(nodeName2, testNodeType);
        // ... and a child node.
        n.addNode(nodeName3, testNodeType);
        testRootNode.save();

        try {
            // if (for impl reasons) 'n' is referenceable -> it must have a
            // different uuid.
            assertFalse(uuid.equals(n.getUUID()));
        } catch (UnsupportedRepositoryOperationException e) {
            // n has not been made referenceable before -> OK.
        }
    }


    public void testMove() throws Exception {
        superuser.move(srcAbsPath, destAbsPath1);
        session.move(srcAbsPath, destAbsPath2);
        superuser.save();
        try {
            session.save();
            fail("InvalidItemStateException expected");
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testAddNonExisting() throws RepositoryException {
        Session session = testRootNode.getSession();
        String nonExistingMixinName = NodeMixinUtil.getNonExistingMixinName(session);

        Node node = testRootNode.addNode(nodeName1, testNodeType);

        try {
            node.addMixin(nonExistingMixinName);
            fail("Node.addMixin(String mixinName) must throw a " +
                    "NoSuchNodeTypeException if mixinName is an unknown mixin type");
        } catch (NoSuchNodeTypeException e) {
            // success
        }
    }


    public void testNonExisting() throws RepositoryException {
        Session session = testRootNode.getSession();
        String nonExistingMixinName = NodeMixinUtil.getNonExistingMixinName(session);

        Node node = testRootNode.addNode(nodeName1, testNodeType);

        try {
            node.canAddMixin(nonExistingMixinName);
            fail("Node.canAddMixin(String mixinName) must throw a " +
                    "NoSuchNodeTypeException if mixinName is an unknown mixin type");
        } catch (NoSuchNodeTypeException e) {
            // success
        }
    }


    public void testWorkspaceMoveSourceCheckedInVersionException() throws RepositoryException {
        // add a node under a versionable node
        Node movingNode = versionableNode.addNode(nodeName1, nonVersionableNodeType.getName());
        versionableNode.save();
        // check the parent node in
        versionableNode.checkin();
        try {
            // try to move the sub node this should throw an VersionException
            superuser.getWorkspace().move(movingNode.getPath(), nonVersionableNode.getPath() + "/" + nodeName1);
            fail("Moving a node using Workspace.move() where parent node is " +
                    "versionable and checked in should throw a VersionException!");
        } catch (VersionException e) {
            // ok, works as expected
        }
    }


    public void testMergeNodeBestEffortFalse() throws RepositoryException {
        /// create successor versions for a node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        // merge, besteffort set to false
        try {
            nodeToMerge.merge(workspace.getName(), false);
            fail("bestEffort is false and any merge should throw a MergeException.");
        } catch (MergeException e) {
            // successful
        }
    }


    public void testRemoveFirstSibling4() throws RepositoryException {
        firstSiblingNode.remove();
        testRootNode.save();

        // check if the node has been properly removed
        try {
            Item secondSibling = superuser.getItem(firstSiblingPath);
            // implementation specific:
            assertTrue("", removeItem.isSame(secondSibling));
        } catch (PathNotFoundException e) {
            fail("Removing a SNS Node -> successor must be accessible from the session by removed path.");
        }
    }


    public void testAddWithMoveFrom() throws Exception {
        testRootNode.getNode("A").addNode("D");
        session.move(testRoot + "/A/B", testRoot + "/C/B");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testReRegisteredNamespace() throws RepositoryException {
        nsRegistry.registerNamespace(testPrefix, testURI);
        String replacePrefix = getUnusedPrefix();
        nsRegistry.registerNamespace(replacePrefix, testURI);
        try {
            nsRegistry.getURI(testPrefix);
            fail("Namespace with prefix " + testPrefix + " has been reregistered with new prefix " + replacePrefix);
        } catch (NamespaceException e) {
            // OK
        }
    }


    public void testAddWithMoveTo() throws Exception {
        testRootNode.getNode("A").addNode("D");
        session.move(testRoot + "/C", testRoot + "/A/C");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testReorderWithAdd() throws Exception {
        testRootNode.orderBefore("C", "A");
        session.getNode(testRoot).addNode("D");
        session.save();
        try {
            superuser.save();
            fail("must throw InvalidItemStateException");
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testRemoveRemove() throws Exception {
        testRootNode.getNode("A[1]").remove();
        session.getNode(testRoot).getNode("A[3]").remove();
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testAddAdd() throws Exception {
        testRootNode.getNode("A").addNode("D");
        session.getNode(testRoot).getNode("A").addNode("E");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testAddAdd() throws Exception {
        testRootNode.addNode("A");
        session.getNode(testRoot).addNode("A");
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testAddWithReorder() throws Exception {
        testRootNode.addNode("D");
        session.getNode(testRoot).orderBefore("C", "A");
        session.save();
        try {
            superuser.save();
            fail("must throw InvalidItemStateException");
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMoveToWithAdd() throws Exception {
        superuser.move(testRoot + "/C", testRoot + "/A/C");
        session.getNode(testRoot).getNode("A").addNode("D");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testAddRemove() throws Exception {
        testRootNode.addNode("A");
        session.getNode(testRoot).getNode("A[2]").remove();
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testRemoveAdd() throws Exception {
        testRootNode.getNode("A[2]").remove();
        session.getNode(testRoot).addNode("A");
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testMoveFromWithAdd() throws Exception {
        superuser.move(testRoot + "/A/B", testRoot + "/C/B");
        session.getNode(testRoot).getNode("A").addNode("D");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testRemoval() throws RepositoryException {
        String identifier = tokenNode.getIdentifier();

        TokenBasedAuthentication expiredToken = expiredToken();
        assertFalse(expiredToken.authenticate(tokenCreds));

        try {
            adminSession.getNodeByIdentifier(identifier);
            fail("expired token node should be removed.");
        } catch (ItemNotFoundException e) {
            // success
        }
    }


    public void testRemoval() throws RepositoryException {
        String identifier = expiredNode.getIdentifier();

        TokenBasedAuthentication expiredToken = createAuthenticationForExpiredToken();
        assertFalse(expiredToken.authenticate(expiredCreds));

        try {
            superuser.getNodeByIdentifier(identifier);
            fail("expired token node should be removed.");
        } catch (ItemNotFoundException e) {
            // success
        }
    }


    public void testSessionMoveSourceCheckedInVersionException() throws RepositoryException {
        // add a node under a versionable node
        Node movingNode = versionableNode.addNode(nodeName1, nonVersionableNodeType.getName());
        versionableNode.save();
        // check the parent node in
        versionableNode.checkin();
        try {
            // try to move the sub node this should throw an VersionException
            // either instantly or upon save()
            superuser.move(movingNode.getPath(), nonVersionableNode.getPath() + "/" + nodeName1);
            superuser.save();
            fail("Moving a node using Session.move() where parent node is " +
                    "versionable and checked in should throw a VersionException!");
        } catch (VersionException e) {
            // ok, works as expected
        }
    }


    public void testMergeNodeBestEffortFalseAmbiguousVersions() throws RepositoryException {
        /// create 2 independent base versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // second workspace
        nodeToMerge.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        nodeToMerge.checkout();

        // merge, besteffort set to false
        try {
            nodeToMerge.merge(workspace.getName(), false);
            fail("BestEffort is false and corresponding node's version is ambiguous. Merge should throw a MergeException.");
        } catch (MergeException e) {
            // successful
        }
    }


    public void testFailIfCorrespondingNodeIsSuccessor() throws RepositoryException {
        // make V' of a subnode N' in source workspace be a successor version of
        // the base version of the corresponding subnode.
        Node n = testRootNode.getNode(nodeName1 + "/" + nodeName2);
        n.checkout();
        n.checkin();

        n.checkout();

        try {
            // merge, besteffort set to false to stop at the first failure
            nodeToMerge.merge(workspace.getName(), false);
            fail("Merging a checkedout node if the version V' of the corresponding node is a successor of this node's base version must fail.");

        } catch (MergeException e) {
            // success
        }
    }


    public void testMergeNodeVersionAmbiguous() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // second workspace
        nodeToMerge.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        // besteffort set to false to stop at the first failure
        try {
            nodeToMerge.checkout();
            nodeToMerge.merge(workspace.getName(), false);
            fail("Node has ambigous versions. Merge must throw a MergeException");
        } catch (MergeException e) {
            // success if the merge exception thrown
        }
    }


    public void testRemoveFirstSibling2() throws RepositoryException, NotExecutableException {
        firstSiblingNode.remove();
        testRootNode.save();

        // check if the node has been properly removed
        try {
            Node secondSibling = testRootNode.getNode(nodeName1);
            // implementation specific:
            assertTrue("", removeItem.isSame(secondSibling));
        } catch (PathNotFoundException e) {
            fail("Second sibling must still be available.");
        }
    }


    public void testRemoveWithMoveFrom() throws Exception {
        Node d = testRootNode.getNode("A").addNode("D");
        superuser.save();
        d.remove();
        session.move(testRoot + "/A/B", testRoot + "/C/B");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testMoveFromWithRemove() throws Exception {
        Node d = session.getNode(testRoot).getNode("A").addNode("D");
        session.save();

        superuser.move(testRoot + "/A/B", testRoot + "/C/B");
        d.remove();

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testRemoveWithMoveTo() throws Exception {
        Node d = testRootNode.getNode("A").addNode("D");
        superuser.save();
        d.remove();
        session.move(testRoot + "/C", testRoot + "/A/C");

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testMoveToWithRemove() throws Exception {
        Node d = session.getNode(testRoot).getNode("A").addNode("D");
        session.save();

        superuser.move(testRoot + "/C", testRoot + "/A/C");
        d.remove();

        testRootNode.getSession().save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void disable_testMergeNodeForceFailure() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // second workspace
        nodeToMerge.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        // besteffort set to true to report all failures
        nodeToMerge.checkout();
        nodeToMerge.merge(workspace.getName(), true);

        try {
            nodeToMerge.merge(workspace.getName(), true);
            fail("Merge failed for node in earlier merge operations. Because the mergeFailedProperty is present, merge must throw a VersionException");
        } catch (VersionException e) {
            // success version exception expected
        }
    }


    public void testAdd() throws Exception {
        Node n = testRootNode.addNode(nodeName1);
        superuser.save();
        n.setProperty(propertyName1, "foo");
        session.getNode(testRoot).getNode(nodeName1).setProperty(propertyName2, "bar");
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testMixin() throws Exception {
        Node n = testRootNode.addNode(nodeName1);
        superuser.save();
        n.addMixin(mixReferenceable);
        session.getNode(testRoot).getNode(nodeName1).addMixin(mixLockable);
        superuser.save();
        try {
            session.save();
            fail("InvalidItemStateException expected");
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testRemoveRemove() throws Exception {
        Node d = testRootNode.getNode("A").addNode("D");
        superuser.save();
        d.remove();
        session.getNode(testRoot).getNode("A").getNode("B").remove();

        superuser.save();

        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw exception");
        }
    }


    public void testRemoveNode2() throws RepositoryException, NotExecutableException {
        removeItem.remove();
        testRootNode.save();
        try {
            String relPath = removePath.substring(removePath.lastIndexOf('/') + 1);
            testRootNode.getNode(relPath);
            fail("Persistently removed node should no longer be accessible from parent node.");
        } catch (PathNotFoundException e) {
            // ok , works as expected
        }
    }


    public void testAddSameName() throws Exception {
        Node n = testRootNode.addNode(nodeName1);
        superuser.save();
        n.setProperty(propertyName1, "foo");
        session.getNode(testRoot).getNode(nodeName1).setProperty(propertyName1, "bar");
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
        assertEquals("bar", n.getProperty(propertyName1).getString());
    }


    public void testRemoveSameName() throws Exception {
        Node n = testRootNode.addNode(nodeName1);
        n.setProperty(propertyName1, "foo");
        superuser.save();
        n.getProperty(propertyName1).remove();
        session.getNode(testRoot).getNode(nodeName1).getProperty(propertyName1).remove();
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testRemove() throws Exception {
        Node n = testRootNode.addNode(nodeName1);
        n.setProperty(propertyName1, "foo");
        n.setProperty(propertyName2, "bar");
        superuser.save();
        n.getProperty(propertyName1).remove();
        session.getNode(testRoot).getNode(nodeName1).getProperty(propertyName2).remove();
        superuser.save();
        try {
            session.save();
        } catch (InvalidItemStateException e) {
            fail("must not throw InvalidItemStateException");
        }
    }


    public void testGetCorrespondingNodePathItemNotFoundException() throws RepositoryException, NotExecutableException {

        // make sure the repository supports multiple workspaces
        super.ensureMultipleWorkspacesSupported();

        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create testNode in default workspace
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save changes
        superuser.save();

        try {
            // call the update method on test node in default workspace
            defaultTestNode.getCorrespondingNodePath(workspaceName);
            fail("Calling Node.getCorrespondingNodePath() on node that has no correspondend node should throw ItemNotFoundException");
        } catch (ItemNotFoundException e) {
            // ok, works as expected
        }
    }


    public void testInvalidStateRemovedProperty() throws RepositoryException {
        removeItem.remove();

        try {
            ((Property)removeItem).getType();
            fail("Calling getType() on a removed property must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            ((Property)removeItem).getValue();
            fail("Calling getValue() on a removed property must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public void testInvalidStateRemovedProperty2() throws RepositoryException {
        removeItem.remove();
        testRootNode.save();
                try {
            ((Property)removeItem).getType();
            fail("Calling getType() on a removed property must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            ((Property)removeItem).getValue();
            fail("Calling getValue() on a removed property must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public void testInvalidStateRemovedNode() throws RepositoryException {
        removeItem.remove();
        try {
            ((Node)removeItem).getPrimaryNodeType();
            fail("Calling getPrimaryNodeType() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            ((Node)removeItem).getProperty(jcrPrimaryType);
            fail("Calling getProperty(String) on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public void testInvalidStateRemovedNode2() throws RepositoryException {
        removeItem.remove();
        testRootNode.save();

        try {
            ((Node)removeItem).getPrimaryNodeType();
            fail("Calling getPrimaryNodeType() on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }

        try {
            ((Node)removeItem).getProperty(jcrPrimaryType);
            fail("Calling getProperty(String) on a removed node must throw InvalidItemStateException.");
        } catch (InvalidItemStateException e) {
            //ok
        }
    }


    public void testRegisteredNamespaceVisibility() throws RepositoryException {
        Session otherSession = getHelper().getReadOnlySession();
        try {
            NamespaceRegistry other = otherSession.getWorkspace().getNamespaceRegistry();

            nsRegistry.registerNamespace(testPrefix, testURI);
            String otherUri = other.getURI(testPrefix);
            String otherPrefix = other.getPrefix(testURI);
            assertTrue("Namespace registered must be immediately visible to any other session.", testURI.equals(otherUri) && testPrefix.equals(otherPrefix));
        } finally {
            otherSession.logout();
        }
    }


    public void testReRegisteredNamespace2() throws RepositoryException {
        Session otherSession = getHelper().getReadOnlySession();
        try {
            NamespaceRegistry other = otherSession.getWorkspace().getNamespaceRegistry();

            nsRegistry.registerNamespace(testPrefix, testURI);
            other.getPrefix(testURI);

            String replacePrefix = getUnusedPrefix();
            nsRegistry.registerNamespace(replacePrefix, testURI);

            String otherPrefix = other.getPrefix(testURI);
            assertEquals("Namespace with prefix " + testPrefix + " has been reregistered with new prefix " + replacePrefix, replacePrefix, otherPrefix);
        } finally {
            otherSession.logout();
        }
    }


    public void testAddMixin2() throws RepositoryException,
            NotExecutableException {
        Node n;
        try {
            n = testRootNode.addNode(nodeName1);
            n.addMixin(mixVersionable);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        // after saving the affected target node must be marked 'invalidated'
        // even if adding the node and setting a mixin was achieved in the
        // same batch.
        assertItemStatus(n, Status.INVALIDATED);
    }


    public void testAddMultipleAtOnce() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            node.addMixin(mixReferenceable);
            node.addMixin(mixLockable);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        assertTrue("Adding 2 mixins at once -> both must be present.", node.isNodeType(mixReferenceable) && node.isNodeType(mixLockable));
    }


    public void testAddMultipleSeparately() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            node.addMixin(mixReferenceable);
            testRootNode.save();
            node.addMixin(mixLockable);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        assertTrue("Adding 2 mixins at once -> both must be present.", node.isNodeType(mixReferenceable) && node.isNodeType(mixLockable));
        List<NodeType> mixins = Arrays.asList(node.getMixinNodeTypes());
        assertTrue("Adding 2 mixins at once -> both must be present.", mixins.contains(ntMgr.getNodeType(mixReferenceable)) && mixins.contains(ntMgr.getNodeType(mixLockable)));
    }


    public void testRemoveMixinTakingAffectUponSave() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            node.addMixin(mixReferenceable);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        node.removeMixin(mixReferenceable);
        assertTrue("Removing Mixin must not take effect but after Node has been saved.", node.isNodeType(mixReferenceable));
        List<NodeType> mixins = Arrays.asList(node.getMixinNodeTypes());
        assertTrue("Removing Mixin must not take effect but after Node has been saved.", mixins.contains(ntMgr.getNodeType(mixReferenceable)));
    }


    public void testAddMultipleAtOnce2() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            node.addMixin(mixReferenceable);
            node.addMixin(mixLockable);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        List<NodeType> mixins = Arrays.asList(node.getMixinNodeTypes());
        assertTrue("Adding 2 mixins at once -> both must be present.", mixins.contains(ntMgr.getNodeType(mixReferenceable)) && mixins.contains(ntMgr.getNodeType(mixLockable)));
    }


    public void testAddAndRemoveMixinFromNew() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            node.addMixin(mixReferenceable);
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        node.removeMixin(mixReferenceable);
        testRootNode.save();

        assertFalse("Adding + Removing a mixin within the same batch must have not effect.", node.isNodeType(mixReferenceable));
        List<NodeType> mixins = Arrays.asList(node.getMixinNodeTypes());
        assertFalse("Adding + Removing a mixin within the same batch must have not effect.", mixins.contains(ntMgr.getNodeType(mixReferenceable)));
    }


    public void testAddAndRemoveMixin() throws NotExecutableException, RepositoryException {
        Node node;
        try {
            node = testRootNode.addNode(nodeName1, testNodeType);
            testRootNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        node.addMixin(mixReferenceable);
        node.removeMixin(mixReferenceable);
        testRootNode.save();

        assertFalse("Adding + Removing a mixin within the same batch must have not effect.", node.isNodeType(mixReferenceable));
        List<NodeType> mixins = Arrays.asList(node.getMixinNodeTypes());
        assertFalse("Adding + Removing a mixin within the same batch must have not effect.", mixins.contains(ntMgr.getNodeType(mixReferenceable)));
    }


    public void testOrderAfterIndividualAccess() throws RepositoryException {
        Session another = getHelper().getReadOnlySession();
        try {
            Node n2 = (Node) another.getItem(children[2].getPath());
            Node n0 = (Node) another.getItem(children[0].getPath());
            NodeIterator it = ((Node) another.getItem(testRootNode.getPath())).getNodes();
            checkOrder(it, children);
        } finally {
            another.logout();
        }
    }


    public void testOrderAfterIndividualAccess2() throws RepositoryException {
        Session another = getHelper().getReadOnlySession();
        try {
            Node n2 = (Node) another.getItem(children[3].getPath());
            Node n3 = (Node) another.getItem(children[1].getPath());
            NodeIterator it = ((Node) another.getItem(testRootNode.getPath())).getNodes();
            checkOrder(it, children);
        } finally {
            another.logout();
        }
    }


    private static String getUnknownURI(Session session, String uriHint) throws RepositoryException {
        String uri = uriHint;
        int index = 0;
        List<String> uris = Arrays.asList(session.getWorkspace().getNamespaceRegistry().getURIs());
        while (uris.contains(uri)) {
            uri = uriHint + index;
            index++;
        }
        return uri;
    }


    protected String getPathToNonExistingNode() throws RepositoryException {
        String name = "nonexisting";
        String path = name;
        int i = 0;
        while (testRootNode.hasNode(path)) {
            path = name + i;
            i++;
        }

        path = testRootNode.getPath() + "/" + path;
        return path;
    }


    public void testGetStreamFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getStream();
                fail("Property.getStream() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengthFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        try {
            prop.getLength();
            fail("Property.getLength() called on a multivalue property must fail (ValueFormatException).");
        } catch (ValueFormatException vfe) {
            // ok
        }
    }


    public void testGetLongFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getLong();
                fail("Property.getLong() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetStringFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getString();
                fail("Property.getString() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetDoubleFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getDouble();
                fail("Property.getDouble() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetDateFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getDate();
                fail("Property.getDate() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetNode() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("Test Property.getNode is throwing a "
                    + "ValueFormaException not executable in case of a multivalued property.");
        }
        else {
            try {
                prop.getNode();
                fail("Property.getNode should throw a ValueFormatException in case of "
                        + "a multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetBooleanFromMultivalued() throws RepositoryException, NotExecutableException {
        Property prop = PropertyUtil.searchMultivalProp(testRootNode);
        if (prop == null) {
            throw new NotExecutableException("No multivalued property found.");
        }
        else {
            try {
                prop.getBoolean();
                fail("Property.getLong() must fail with ValueFormatException for any multivalued property.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetValues() throws RepositoryException, NotExecutableException {
        Property singleProp = PropertyUtil.searchSingleValuedProperty(testRootNode);
        if (singleProp == null) {
            throw new NotExecutableException("No single valued property found.");
        }

        try {
            singleProp.getValues();
            fail("Property.getValues() called on a single property " +
                    "should throw a ValueFormatException.");
        } catch (ValueFormatException vfe) {
            // ok
        }
    }


    public void testGetLengthsFromSingleValued() throws RepositoryException, NotExecutableException {
        Property singleProp = PropertyUtil.searchSingleValuedProperty(testRootNode);
        if (singleProp == null) {
            throw new NotExecutableException("No single valued property found.");
        }
        try {
            singleProp.getLengths();
            fail("Property.getLengths() called on a single value property must fail (ValueFormatException).");
        } catch (ValueFormatException vfe) {
            // ok
        }
    }


    public void testRemoveSelf() throws RepositoryException, NotExecutableException {
        Authorizable admin = userMgr.getAuthorizable(adminId);
        if (admin == null) {
            throw new NotExecutableException();
        }
        try {
            admin.remove();
            fail("The Administrator should not be allowed to remove the own authorizable.");
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testGetUUIDOfNonReferenceableNode()
            throws NotExecutableException, RepositoryException {

        // find a node NOT of type mix:referenceable
        Node node = locateNonReferenceableNode(testRootNode);

        if (node == null) {
            throw new NotExecutableException("Workspace does not contain a non referenceable node");
        }

        try {
            node.getUUID();
            fail("UnsupportedRepositoryOperationException expected");
        } catch (UnsupportedRepositoryOperationException e) {
            // success
        }
    }


    public void testGetPrimaryItemItemNotFoundException()
            throws NotExecutableException, RepositoryException {

        Node node = locateNodeWithoutPrimaryItem(testRootNode);

        if (node == null) {
            throw new NotExecutableException("Workspace does not contain a node without primary item defined");
        }

        try {
            node.getPrimaryItem();
            fail("getPrimaryItem() must throw a ItemNotFoundException " +
                    "if the primary node type does not define one");
        } catch (ItemNotFoundException e) {
            // success
        }
    }


    public void testGetUUID()
            throws NotExecutableException, RepositoryException {

        // find a node of type mix:referenceable
        Node node = locateReferenceableNode(testRootNode);

        if (node == null) {
            throw new NotExecutableException("Workspace does not contain a referencable node");
        }

        try {
            assertEquals("node.getUUID() does not match " +
                    "node.getProperty(\"jcr:uuid\").getString()",
                    node.getProperty(jcrUUID).getString(), node.getUUID());
        } catch (PathNotFoundException e) {
            fail("Property UUID expected for " +
                    "node of type \"" + mixReferenceable + "\"");
        }
    }


    public void testIsSameProperty3() throws RepositoryException {
        // create a node (nt:resource) that implicitly is referenceable
        Node n = testRootNode.addNode("aFile", "nt:file");
        n = n.addNode("jcr:content", "nt:resource");
        n.setProperty("jcr:lastModified", Calendar.getInstance());
        n.setProperty("jcr:mimeType", "text/plain");
        Property jcrData = n.setProperty("jcr:data", "abc", PropertyType.BINARY);
        testRootNode.save();

        // access same property through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Property otherProperty = (Property) otherSession.getItem(jcrData.getPath());
            assertTrue(jcrData.isSame(otherProperty));
        } finally {
            otherSession.logout();
        }
    }


    public void testIsSameProperty4() throws RepositoryException {
        // create a node (nt:resource) that implicitly is referenceable
        Node n = testRootNode.addNode("aFile", "nt:file");
        n = n.addNode("jcr:content", "nt:resource");
        n.setProperty("jcr:lastModified", Calendar.getInstance());
        n.setProperty("jcr:mimeType", "text/plain");
        Property jcrData = n.setProperty("jcr:data", "abc", PropertyType.BINARY);
        testRootNode.save();

        // access same property through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Property otherProperty = (Property) otherSession.getItem(jcrData.getPath());
            assertTrue(n.getProperty("jcr:data").isSame(otherProperty));
        } finally {
            otherSession.logout();
        }
    }


    public void testIsSameNode() throws RepositoryException {
        // create a node (nt:resource) that implicitly is referenceable
        Node n = testRootNode.addNode("aFile", "nt:file");
        n = n.addNode("jcr:content", "nt:resource");
        n.setProperty("jcr:lastModified", Calendar.getInstance());
        n.setProperty("jcr:mimeType", "text/plain");
        n.setProperty("jcr:data", "abc", PropertyType.BINARY);
        testRootNode.save();

        // access nt:resource node through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Node otherNode = (Node) otherSession.getItem(n.getPath());
            assertTrue(n.isSame(otherNode));
        } finally {
            otherSession.logout();
        }
    }


    public void testIsSameNode2() throws RepositoryException {
        // create a node (nt:resource) that implicitly is referenceable
        Node n = testRootNode.addNode("aFile", "nt:file");
        n = n.addNode("jcr:content", "nt:resource");
        n.setProperty("jcr:lastModified", Calendar.getInstance());
        n.setProperty("jcr:mimeType", "text/plain");
        n.setProperty("jcr:data", "abc", PropertyType.BINARY);
        testRootNode.save();

        // access nt:resource node through different session
        Session otherSession = getHelper().getReadOnlySession();
        try {
            Node otherNode = (Node) otherSession.getItem(n.getPath());
            assertTrue(otherNode.isSame(n));
        } finally {
            otherSession.logout();
        }
    }


    public void testIsSameNode4() throws RepositoryException {

        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Property p = n.setProperty(propertyName1, "anyvalue");
        testRootNode.save();

        // transiently move the node.
        String srcPath = n.getPath();
        String destPath = testRootNode.getPath() + "/" + nodeName2;
        testRootNode.getSession().move(srcPath, destPath);

        Session otherSession = getHelper().getReadOnlySession();
        try {
            Node otherNode = (Node) otherSession.getItem(srcPath);
            assertTrue(n.isSame(otherNode));
            assertTrue(superuser.getItem(destPath).isSame(otherNode));
        } finally {
            otherSession.logout();
        }
    }


    public void testIsSameNode5() throws RepositoryException {

        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        // transiently move the node.
        String srcPath = n.getPath();
        String destPath = testRootNode.getPath() + "/" + nodeName2;

        Session otherSession = getHelper().getReadOnlySession();
        try {
            Node otherNode = (Node) otherSession.getItem(srcPath);

            testRootNode.getSession().getWorkspace().move(srcPath, destPath);

            assertTrue(otherNode.isSame(n));
            assertTrue(n.isSame(otherNode));
        } finally {
            otherSession.logout();
        }
    }


    public void testShadowingItems() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = testRootNode.addNode(nodeName2, testNodeType);

        Property p = n.setProperty(propertyName1, "anyValue");
        testRootNode.save();

        testRootNode.getSession().move(n.getPath(), n2.getPath() + "/destination");

        Node replaceNode = testRootNode.addNode(nodeName1, testNodeType);
        Property replaceProp = replaceNode.setProperty(propertyName1, "anyValue");

        assertFalse(replaceNode.isSame(n));
        assertFalse(replaceProp.isSame(p));
    }


    public void testShadowingItems2() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        Property p = n.setProperty(propertyName1, "anyValue");

        testRootNode.getSession().move(n.getPath(), n2.getPath() + "/destination");

        Node replaceNode = testRootNode.addNode(nodeName1, testNodeType);
        Property replaceProp = replaceNode.setProperty(propertyName1, "anyValue");

        assertFalse(replaceNode.isSame(n));
        assertFalse(replaceProp.isSame(p));
    }


    public void testAccessMovedNodeByOldPath() throws RepositoryException, NotExecutableException {
        String oldPath = moveNode.getPath();
        //move the node
        doMove(oldPath, destinationPath);
        try {
            Item item = superuser.getItem(oldPath);
            // Implementation specific:
            assertTrue("A moved SNS node must be 'replaced' but is successor sibling.", item.isSame(sourceSibling));
        } catch (PathNotFoundException e) {
            fail("A moved SNS node must be 'replaced' but is successor sibling.");
        }
    }


    public void testAccessMovedNodeByOldPath2() throws RepositoryException, NotExecutableException {
        String oldPath = moveNode.getPath();
        //move the node
        doMove(oldPath, destinationPath);
        superuser.save();
        try {
            Item item = superuser.getItem(oldPath);
            // Implementation specific:
            assertTrue("A moved SNS node must be 'replaced' but is successor sibling.", item.isSame(sourceSibling));
        } catch (PathNotFoundException e) {
            fail("A moved SNS node must be 'replaced' but is successor sibling.");
        }
    }


    public void testMovedNodeIsSame() throws RepositoryException, NotExecutableException {
        //move the node
        doMove(moveNode.getPath(), destinationPath);

        int cnt = 0;
        for (NodeIterator it = destParentNode.getNodes(nodeName2); it.hasNext();) {
            Node n = it.nextNode();
            if (cnt == 0) {
                assertTrue("Moved node must be appended to list of SNSs.", destSibling.isSame(n));
            } else {
                assertTrue("Moved node must be appended to list of SNSs.", moveNode.isSame(n));
            }
            cnt++;
        }
    }


    public void testMovedNodeIsSame2() throws RepositoryException, NotExecutableException {
        //move the node
        doMove(moveNode.getPath(), destinationPath);
        superuser.save();

        int cnt = 0;
        for (NodeIterator it = destParentNode.getNodes(nodeName2); it.hasNext();) {
            Node n = it.nextNode();
            if (cnt == 0) {
                assertTrue("Moved node must be appended to list of SNSs.", destSibling.isSame(n));
            } else {
                assertTrue("Moved node must be appended to list of SNSs.", moveNode.isSame(n));
            }
            cnt++;
        }
    }


    public void testRemove() throws RepositoryException {
        String srcPath = moveNode.getPath();
        doMove(srcPath, destinationPath);

        // now remove the moved node
        testRootNode.getSession().getItem(destinationPath).remove();
        assertFalse(superuser.itemExists(srcPath));
        assertFalse(superuser.itemExists(destinationPath));

        testRootNode.save();

        assertFalse(superuser.itemExists(srcPath));
        assertFalse(superuser.itemExists(destinationPath));
        assertFalse(destParentNode.isModified());
        assertFalse(srcParentNode.isModified());
    }


    public void testRefresh() throws RepositoryException {
        String srcPath = moveNode.getPath();
        doMove(srcPath, destinationPath);

        // now remove the moved node
        testRootNode.getSession().getItem(destinationPath).remove();
        testRootNode.refresh(true);

        assertFalse(superuser.itemExists(srcPath));
        assertFalse(superuser.itemExists(destinationPath));

        // after removal the 'modified' flag is removed from the moved node
        assertFalse(moveNode.isModified());
        // however: parent states are still modified
        assertTrue(destParentNode.isModified()); // TODO: check if correct.
        assertTrue(srcParentNode.isModified());
    }


    public void testRevert() throws RepositoryException {
        String srcPath = moveNode.getPath();
        doMove(srcPath, destinationPath);

        // now remove the moved node
        testRootNode.getSession().getItem(destinationPath).remove();
        testRootNode.refresh(false);

        assertTrue(superuser.itemExists(srcPath));
        assertFalse(superuser.itemExists(destinationPath));

        assertFalse(moveNode.isModified());
        assertFalse(destParentNode.isModified());
        assertFalse(srcParentNode.isModified());
    }


    public void testReplacingProperty() throws RepositoryException,
            NotExecutableException {
        Property p1 = testNode.setProperty(propertyName1, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName1, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName1, "value3");
        testNode.save();

        assertTrue(testNode.hasProperty(propertyName1));
        assertEquals("value3", testNode.getProperty(propertyName1).getString());

        assertItemStatus(p1, Status.REMOVED);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.EXISTING);
    }


    public void testAddingProperty() throws RepositoryException,
            NotExecutableException {
        Property p1 = testNode.setProperty(propertyName2, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName2, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName2, "value3");
        testNode.save();

        assertTrue(testNode.hasProperty(propertyName2));

        assertItemStatus(p1, Status.REMOVED);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.EXISTING);
    }


    public void testRevertAddingProperty() throws RepositoryException,
            NotExecutableException {
        Property p1 = testNode.setProperty(propertyName2, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName2, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName2, "value3");
        testNode.refresh(false);

        assertFalse(testNode.hasProperty(propertyName2));

        assertItemStatus(p1, Status.REMOVED);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.REMOVED);
    }


    public void testAddingProperty2() throws RepositoryException,
            NotExecutableException {
        Property p1 = testNode.setProperty(propertyName2, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName2, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName2, "value3");
        p3.remove();
        testNode.save();

        assertFalse(testNode.hasProperty(propertyName2));

        assertItemStatus(p1, Status.REMOVED);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.REMOVED);
    }


    public void testRevertReplacingProperty() throws RepositoryException,
            NotExecutableException {
        String val = testNode.getProperty(propertyName1).getString();
        Property p1 = testNode.setProperty(propertyName1, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName1, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName1, "value3");
        testNode.refresh(false);

        assertTrue(testNode.hasProperty(propertyName1));
        assertEquals(val, p1.getString());

        assertItemStatus(p1, Status.EXISTING);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.REMOVED);
    }


    public void testReplacingProperty2() throws RepositoryException,
            NotExecutableException {
        Property p1 = testNode.setProperty(propertyName2, "value1");
        p1.remove();

        Property p2 = testNode.setProperty(propertyName2, "value2");
        p2.remove();

        Property p3 = testNode.setProperty(propertyName2, "value3");
        p3.remove();
        testNode.save();

        assertFalse(testNode.hasProperty(propertyName2));

        assertItemStatus(p1, Status.REMOVED);
        assertItemStatus(p2, Status.REMOVED);
        assertItemStatus(p3, Status.REMOVED);
    }


    public void testOldChildPath() throws RepositoryException {
        for (int i = 0; i < childPaths.size(); i++) {
            String path = childPaths.get(i).toString();
            assertFalse(superuser.itemExists(path));
            try {
                superuser.getItem(path);
                fail("Moving a node must move all child items as well.");
            } catch (PathNotFoundException e) {
                // ok
            }
        }
    }


    public void testOldChildPropertyPath() throws RepositoryException {
        for (int i = 0; i < childPaths.size(); i++) {
            String propPath = childPaths.get(i).toString() + "/" + jcrPrimaryType;
            assertFalse(superuser.itemExists(propPath));
            try {
                superuser.getItem(propPath);
                fail("Moving a node must move all child items as well.");
            } catch (PathNotFoundException e) {
                // ok
            }
        }
    }


    public void testGetPolicesAfterSetPoliciesCall() throws Exception {
        try {
            AccessControlPolicyIterator policies = acMgr.getApplicablePolicies(testRoot);
            AccessControlPolicy policy = null;
            while (policies.hasNext()) {
                policy = policies.nextAccessControlPolicy();
                acMgr.setPolicy(testRoot, policy);
                AccessControlPolicy[] acl = acMgr.getPolicies(testRoot);
                assertNotNull(acl);
            }
        } finally {
            superuser.refresh(false);
        }        
    }


    public void testRemovePolicyAfterASetPoliciesCall() throws Exception {
        try {
            AccessControlPolicyIterator policies = acMgr.getApplicablePolicies(testRoot);
            while (policies.hasNext()) {
                AccessControlList acl = (AccessControlListImpl) policies.nextAccessControlPolicy();
                
                // GRANT read privilege
                acl.addAccessControlEntry(getUnknownPrincipal(), privilegesFromName(Privilege.JCR_READ));
                
                acMgr.setPolicy(testRoot, acl);
                
                AccessControlPolicy[] transientPolicy = acMgr.getPolicies(testRoot);
                
                acMgr.removePolicy(testRoot, transientPolicy[0]);
                
                assertEquals(0, acMgr.getPolicies(testRoot).length);
            }

        } finally {
            superuser.refresh(false);
        }
    }


    public void testAccessMovedNodeByOldPath() throws RepositoryException, NotExecutableException {
        NodeIterator it = srcParentNode.getNodes(moveNode.getName());
        int cnt = 0;
        while (it.hasNext()) {
            it.nextNode();
            cnt++;
        }
        if (cnt > 1) {
            throw new NotExecutableException("Move source parent has multiple child nodes with name " + moveNode.getName());
        }

        String oldPath = moveNode.getPath();

        //move the node
        doMove(oldPath, destinationPath);
        try {
            superuser.getItem(oldPath);
            fail("A moved node must not be accessible by its old path any more.");
        } catch (PathNotFoundException e) {
            // ok.
        }
    }


    public void testAccessMovedNodeByOldPath2() throws RepositoryException, NotExecutableException {
        NodeIterator it = srcParentNode.getNodes(moveNode.getName());
        int cnt = 0;
        while (it.hasNext()) {
            it.nextNode();
            cnt++;
        }
        if (cnt > 1) {
           throw new NotExecutableException("Move source parent has multiple child nodes with name " + moveNode.getName());
        }

        String oldPath = moveNode.getPath();

        //move the node
        doMove(oldPath, destinationPath);
        superuser.save();
        try {
            superuser.getItem(oldPath);
            fail("A moved node must not be accessible by its old path any more.");
        } catch (PathNotFoundException e) {
            // ok.
        }
    }


    public void testMovedNodeIsSame() throws RepositoryException, NotExecutableException {
        if (destParentNode.hasNode(nodeName2)) {
            throw new NotExecutableException(destParentNode + " already has child node " + ". Test cannot be preformed if SNS is present.");
        }

        String oldPath = moveNode.getPath();
        String newPath = destParentNode.getPath() + "/" + nodeName2;

        //move the node
        doMove(oldPath, destinationPath);
        Item movedItem = superuser.getItem(newPath);
        assertTrue("Moved Node must be the same after the move.", movedItem.isSame(moveNode));
    }


    public void testMovedNodeIsSame2() throws RepositoryException, NotExecutableException {
        if (destParentNode.hasNode(nodeName2)) {
            throw new NotExecutableException(destParentNode + " already has child node " + ". Test cannot be preformed if SNS is present.");
        }

        String oldPath = moveNode.getPath();

        //move the node
        doMove(oldPath, destinationPath);
        superuser.save();

        Item movedItem = superuser.getItem(destinationPath);
        assertTrue("Moved Node must be the same after the move.", movedItem.isSame(moveNode));
    }


    public void testMovePropertyExists() throws RepositoryException, NotExecutableException {
        // try to create a property with the name of the node to be moved
        // to the destination parent
        Property destProperty;
        try {
            destProperty = destParentNode.setProperty(nodeName2, "anyString");
        } catch (RepositoryException e) {
            throw new NotExecutableException("Cannot create property with name '" +nodeName2+ "' and value 'anyString' at move destination.");
        }

        // TODO: fix 2.0 behaviour according to the OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED descriptor
        if ("1.0".equals(getHelper().getRepository().getDescriptor(Repository.SPEC_VERSION_DESC))) {
            try {
                // move the node
                doMove(moveNode.getPath(), destProperty.getPath());
                fail("Moving a node to a location where a property exists must throw ItemExistsException");
            } catch (ItemExistsException e) {
                // ok, works as expected
            }
        } else {
            // move the node: same name property and node must be supported
            // see Issue 725
            doMove(moveNode.getPath(), destProperty.getPath());
        }
    }


    public void testMovePropertyExists() throws RepositoryException, NotExecutableException {
        // try to create a property with the name of the node to be moved
        // to the destination parent
        Property destProperty;
        try {
            destProperty = destParentNode.setProperty(nodeName2, "anyString");
            destParentNode.save();
        } catch (RepositoryException e) {
            throw new NotExecutableException("Cannot create property with name '" +nodeName2+ "' and value 'anyString' at move destination.");
        }

        // TODO: fix 2.0 behaviour according to the OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED descriptor
        if ("1.0".equals(getHelper().getRepository().getDescriptor(Repository.SPEC_VERSION_DESC))) {
            try {
                // move the node
                doMove(moveNode.getPath(), destProperty.getPath());
                fail("Moving a node to a location where a property exists must throw ItemExistsException");
            } catch (ItemExistsException e) {
                // ok, works as expected
            }
        } else {
            // JCR 2.0 move the node: same name property and node must be supported
            doMove(moveNode.getPath(), destProperty.getPath());
        }
    }


    public void testMoveTransientPropertyExists() throws RepositoryException, NotExecutableException {
        // try to create a property with the name of the node to be moved
        // to the destination parent
        Property destProperty;
        try {
            destProperty = destParentNode.setProperty(nodeName2, "anyString");
        } catch (RepositoryException e) {
            throw new NotExecutableException("Cannot create property with name '" +nodeName2+ "' and value 'anyString' at move destination.");
        }

        // TODO: fix 2.0 behaviour according to the OPTION_NODE_AND_PROPERTY_WITH_SAME_NAME_SUPPORTED descriptor
        // workspace-move the node (must succeed)
        doMove(moveNode.getPath(), destProperty.getPath());
         if ("1.0".equals(getHelper().getRepository().getDescriptor(Repository.SPEC_VERSION_DESC))) {
             try {
                 // saving transient new property must fail
                 destParentNode.save();
                 fail("Saving new transient property must fail");
            } catch (RepositoryException e) {
                // ok.
             }
         } else {
             // JCR 2.0: saving must succeed.
             destParentNode.save();
         }
    }


    public void testRefreshMovedReferenceableNode() throws RepositoryException, NotExecutableException {
        Node refNode2 = (Node) testSession.getItem(refNode.getPath());

        superuser.move(refNode.getPath(), destParentNode.getPath() + "/" + nodeName2);
        superuser.save();

        try {
            refNode2.refresh(true);
            Node parent = refNode2.getParent();
            if (parent.isSame(testSession.getItem(destParentNode.getPath()))) {
                // node has been automatically moved to new place
                assertItemStatus(refNode2, Status.EXISTING);
            } else {
                assertItemStatus(refNode2, Status.REMOVED);
            }
        } catch (InvalidItemStateException e) {
            // no automatic move of the externally moved node. ok.
            log.debug(e.getMessage());
            // since node had no pending changes -> status should be changed
            // to REMOVED.
            assertItemStatus(refNode2, Status.REMOVED);
        }
    }


    public void testConflictingAddMixin() throws RepositoryException, NotExecutableException {
        Node refNode2 = (Node) testSession.getItem(refNode.getPath());
        refNode2.addMixin(mixLockable);

        superuser.move(refNode.getPath(), destParentNode.getPath() + "/" + nodeName2);
        superuser.save();

        try {
            refNode2.refresh(true);
            Node parent = refNode2.getParent();
            if (parent.isSame(testSession.getItem(destParentNode.getPath()))) {
                // node has been automatically moved to new place
                assertItemStatus(refNode2, Status.EXISTING_MODIFIED);
            } else if (!isItemStatus(refNode2, Status.EXISTING_MODIFIED)) {
                // external removal was detected either by observation or be
                // batch-reading the parent -> status must be stale.
                assertItemStatus(refNode2, Status.STALE_DESTROYED);
            }
        } catch (InvalidItemStateException e) {
            // no automatic move of the externally moved node. ok.
            log.debug(e.getMessage());
            // since refNode2 has pending modifications its status should be
            // changed to STALE_DESTROYED.
            assertItemStatus(refNode2, Status.STALE_DESTROYED);
            Node refAgain = testSession.getNodeByUUID(refNode.getUUID());
            assertTrue(refAgain.getParent().isSame(testSession.getItem(destParentNode.getPath())));
            assertFalse(refAgain.isNodeType(mixLockable));
        }
    }


    public void testExternalRemoval2() throws RepositoryException, NotExecutableException {
        Node childN = refNode.addNode(nodeName3);
        Property p = childN.setProperty(propertyName1, "anyvalue");
        refNode.save();

        String uuid = refNode.getUUID();
        Node refNode2 = testSession.getNodeByUUID(uuid);
        Node c2 =  (Node) testSession.getItem(childN.getPath());
        Property p2 = (Property) testSession.getItem(p.getPath());
        // transiently remove the property -> test effect of external removal.
        p2.remove();

        String srcPath = refNode.getPath();
        String destPath = destParentNode.getPath() + "/" + nodeName2;
        superuser.move(srcPath, destPath);
        superuser.save();

        try {
            refNode2.refresh(true);
            Node parent = refNode2.getParent();
        } catch (InvalidItemStateException e) {
        }

        assertItemStatus(refNode2, Status.REMOVED);
        assertItemStatus(c2, Status.STALE_DESTROYED);
        assertItemStatus(p2, Status.REMOVED);
    }


    public void testExternalRemoval3() throws RepositoryException, NotExecutableException {
        Node childN = refNode.addNode(nodeName3);
        Property p = childN.setProperty(propertyName1, "anyvalue");
        refNode.save();

        String uuid = refNode.getUUID();
        Node refNode2 = testSession.getNodeByUUID(uuid);
        Node c2 =  (Node) testSession.getItem(childN.getPath());
        Property p2 = (Property) testSession.getItem(p.getPath());
        // transiently modify  -> test effect of external removal.
        p2.setValue("changedValue");

        String srcPath = refNode.getPath();
        String destPath = destParentNode.getPath() + "/" + nodeName2;
        superuser.move(srcPath, destPath);
        superuser.save();

        try {
            refNode2.refresh(true);
            Node parent = refNode2.getParent();
        } catch (InvalidItemStateException e) {
        }

        assertItemStatus(refNode2, Status.REMOVED);
        assertItemStatus(c2, Status.REMOVED);
        assertItemStatus(p2, Status.STALE_DESTROYED);
        assertEquals("changedValue", p2.getString());
    }


    public void testNewItemsUponStaleDestroyed() throws RepositoryException, NotExecutableException {
        String uuid = refNode.getUUID();
        Node refNode2 = (Node) testSession.getItem(refNode.getPath());
        refNode2.addMixin(mixLockable);

        Node childN = refNode2.addNode(nodeName3);
        String childNPath = childN.getPath();

        Property childP = refNode2.setProperty(propertyName2, "someValue");
        String childPPath = childP.getPath();

        String destPath = destParentNode.getPath() + "/" + nodeName2;
        superuser.move(refNode.getPath(), destPath);
        superuser.save();

        testSession.refresh(true);
        testSession.getItem(destPath);

        assertItemStatus(refNode2, Status.STALE_DESTROYED);
        assertItemStatus(refNode2.getProperty(jcrMixinTypes), Status.STALE_DESTROYED);
        assertItemStatus(childN, Status.NEW);
        assertItemStatus(childP, Status.NEW);
        assertItemStatus(childN.getProperty(jcrPrimaryType), Status.NEW);

        assertTrue(testSession.itemExists(childNPath));
        assertTrue(childN.isSame(testSession.getItem(childNPath)));

        assertTrue(testSession.itemExists(childPPath));
        assertTrue(childP.isSame(testSession.getItem(childPPath)));

        testSession.refresh(false);

        assertItemStatus(childN, Status.REMOVED);
        assertItemStatus(childP, Status.REMOVED);
        assertFalse(testSession.itemExists(childNPath));
        assertFalse(testSession.itemExists(childPPath));
    }


    public void testUnmodifiedAncestorRemoved() throws RepositoryException, NotExecutableException {
        String uuid = refNode.getUUID();
        Node n3 = refNode.addNode(nodeName3, testNodeType);
        refNode.save();

        Node refNode2 = (Node) testSession.getItem(refNode.getPath());
        // add transient modification to non-referenceable child node
        Node node3 = (Node) testSession.getItem(n3.getPath());
        node3.addMixin(mixLockable);

        // add new child node and child property below
        Node childN = node3.addNode(nodeName3);
        String childNPath = childN.getPath();

        Property childP = node3.setProperty(propertyName2, "someValue");
        String childPPath = childP.getPath();

        // externally move the 'refNode' in order to provoke uuid-conflict
        // in testSession -> refNode2 gets removed, since it doesn't have
        // transient modifications.
        String destPath = destParentNode.getPath() + "/" + nodeName2;
        superuser.move(refNode.getPath(), destPath);
        superuser.save();

        testSession.refresh(true);
        testSession.getItem(destPath);

        assertItemStatus(refNode2, Status.REMOVED);
        assertItemStatus(node3, Status.STALE_DESTROYED);
        assertItemStatus(childN, Status.NEW);
        assertItemStatus(childP, Status.NEW);

        // since 'refNode2' is removed -> child items must not be accessible
        // any more.
        assertFalse(testSession.itemExists(childNPath));
        assertFalse(testSession.itemExists(childPPath));

        // revert all pending changes...
        testSession.refresh(false);
        // must mark all modified/new items as removed.
        assertItemStatus(node3, Status.REMOVED);
        assertItemStatus(childN, Status.REMOVED);
        assertItemStatus(childP, Status.REMOVED);
    }


    public void testChildItemsUponStaleDestroyed() throws RepositoryException, NotExecutableException {
        Node cNode = refNode.addNode(nodeName3);
        Node cNode2 = cNode.addNode(nodeName4);
        refNode.save();

        String uuid = refNode.getUUID();
        Node refNode2 = (Node) testSession.getItem(refNode.getPath());
        refNode2.addMixin(mixLockable);

        Node child =  (Node) testSession.getItem(cNode.getPath());
        Node child2 = (Node) testSession.getItem(cNode2.getPath());
        Node child3 = child2.addNode(nodeName4);
        String child3Path = child3.getPath();

        String destPath = destParentNode.getPath() + "/" + nodeName2;
        superuser.move(refNode.getPath(), destPath);
        superuser.save();

        testSession.refresh(true);
        testSession.getItem(destPath);

        assertItemStatus(refNode2, Status.STALE_DESTROYED);
        assertItemStatus(refNode2.getProperty(jcrMixinTypes), Status.STALE_DESTROYED);
        assertItemStatus(child, Status.REMOVED);
        assertItemStatus(child2, Status.STALE_DESTROYED);
        assertItemStatus(child3, Status.NEW);
        assertItemStatus(child3.getProperty(jcrPrimaryType), Status.NEW);

        testSession.refresh(false);

        assertItemStatus(child2, Status.REMOVED);
        assertItemStatus(child3, Status.REMOVED);
    }


    public void testStreamBinary() throws Exception {
        Node test = testRootNode.addNode("test");
        Property p = test.setProperty("prop", generateValue());
        // check before save
        checkBinary(p);
        superuser.save();
        // check after save
        checkBinary(p);

        // check from other session
        Session s = getHelper().getReadOnlySession();
        try {
            p = s.getNode(testRoot).getNode("test").getProperty("prop");
            checkBinary(p);
        } finally {
            s.logout();
        }
    }


    public void testStreamBinary2() throws Exception {
        Node test = testRootNode.addNode("test");
        Property p = test.setProperty("prop", generateValue());
        // check before save
        checkBinary(p);
        superuser.save();
        // check after save
        checkBinary(p);

        // check from other session
        Session s = getHelper().getReadOnlySession();
        try {
            p = s.getProperty(testRoot + "/test/prop");
            checkBinary(p);
        } finally {
            s.logout();
        }
    }


    public void testBinaryTwiceNewProperty() throws Exception {
        Node test = testRootNode.addNode("test");
        Property p = test.setProperty("prop", generateValue());
        QValue qv1 = getQValue(p);
        test.setProperty("prop", generateValue());
        QValue qv2 = getQValue(p);

        assertFalse(qv1.equals(qv2));

        superuser.save();

        assertEquals(qv2, getQValue(p));
        assertDisposed(qv1);
    }


    public void testBinaryTwiceIntermediateSave() throws Exception {
        Node test = testRootNode.addNode("test");
        Property p = test.setProperty("prop", generateValue());
        QValue qv1 = getQValue(p);
        superuser.save();

        test.setProperty("prop", generateValue());
        QValue qv2 = getQValue(p);

        assertFalse(qv1.equals(qv2));
        
        superuser.save();

        assertEquals(qv2, getQValue(p));
        assertDisposed(qv1);
    }


    public void testBinaryTwiceModifiedProperty() throws Exception {
        Node test = testRootNode.addNode("test");
        Property p = test.setProperty("prop", generateValue());
        superuser.save();

        // modify twice
        test.setProperty("prop", generateValue());
        QValue qv1 = getQValue(p);
        test.setProperty("prop", generateValue());
        QValue qv2 = getQValue(p);

        assertFalse(qv1.equals(qv2));

        superuser.save();
        
        assertEquals(qv2, getQValue(p));
        assertDisposed(qv1);
    }


    protected void checkBinary(Property p) throws Exception {
        for (int i = 0; i < 3; i++) {
            Binary bin = p.getBinary();
            try {
                //System.out.println(bin.getClass() + "@" + System.identityHashCode(bin));
                bin.read(new byte[1], 0);
            } finally {
                bin.dispose();
            }
        }
    }


    protected void checkProperty(Property prop) throws Exception {
        for (int i = 0; i < 3; i++) {
            Binary b = prop.getBinary();
            try {
                //System.out.println(b.getClass() + ": " + System.identityHashCode(b));
                b.read(new byte[1], 0);
            } finally {
                b.dispose();
            }
        }
    }


    public void testMoveSaved() throws RepositoryException {
        String srcPath = moveNode.getPath();
        testRootNode.getSession().move(srcPath, destinationPath);
        testRootNode.save();

        assertFalse(destParentNode.isNew());
        assertFalse(srcParentNode.isModified());
        assertFalse(moveNode.isModified());

        assertTrue(testRootNode.getSession().itemExists(destinationPath));
        assertFalse(testRootNode.getSession().itemExists(srcPath));
    }


    public void testRemoveDestParent() throws RepositoryException {
        String srcPath = moveNode.getPath();
        testRootNode.getSession().move(srcPath, destinationPath);
        destParentNode.remove();

        assertFalse(destParentNode.isNew());
        assertFalse(destParentNode.isModified());

        assertFalse(moveNode.isModified());
        assertTrue(srcParentNode.isModified());
        assertFalse(testRootNode.getSession().itemExists(srcPath));
    }


    public void testInvalidStateRemovedNode3() throws RepositoryException {
        Node childNode = testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        // get the node with session 2
        Session otherSession = getHelper().getReadWriteSession();
        try {
            Node childNode2 = (Node) otherSession.getItem(childNode.getPath());

            childNode.remove();
            superuser.save();

            // try to remove already removed node with session 2
            try {
                childNode2.refresh(false);
                childNode2.remove();
                otherSession.save();
                fail("Removing a node already removed by other session should throw an InvalidItemStateException!");
            } catch (InvalidItemStateException e) {
                //ok, works as expected
            }
        } finally {
            otherSession.logout();
        }
    }


    public void testSaveMovedRefNode() throws RepositoryException, NotExecutableException {
        checkMixReferenceable();
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node newParentNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // create a referenceable node
        Node refTargetNode = defaultRootNode.addNode(nodeName2, getProperty("nodetype2"));

        // save the new nodes
        superuser.save();

        // get the moving node with session 2
        Session testSession = getHelper().getReadWriteSession();
        try {
            Node refTargetNodeSession2 = (Node) testSession.getItem(refTargetNode.getPath());

            //move the node with session 1
            superuser.move(refTargetNode.getPath(), newParentNode.getPath() + "/" + nodeName3);

            // make the move persistent with session 1
            superuser.save();

            // modify some prop of the moved node with session 2
            try {
                refTargetNodeSession2.setProperty(propertyName1, "test");

                // save it
                refTargetNodeSession2.save();
                // ok, works as expected
            } catch (InvalidItemStateException e) {
                // ok as well.
            }
        } finally {
            testSession.logout();
        }
    }


    public void testSaveInvalidStateException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node nodeSession1 = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        superuser.save();

        // make a modification
        nodeSession1.addNode(nodeName2, testNodeType);

        // get the new node with a different session
        Session testSession = getHelper().getReadWriteSession();
        try {
            Node nodeSession2 = (Node) testSession.getItem(nodeSession1.getPath());

            // delete the node with the new session
            nodeSession2.remove();

            // make node removal persistent
            testSession.save();

            // save changes made with superuser session
            try {
                superuser.save();
                fail("Saving a modified Node using Session.save() already deleted by an other session should throw InvalidItemStateException");
            } catch (InvalidItemStateException e) {
                // ok, works as expected
            }
        } finally {
            testSession.logout();
        }
    }


    public void testSaveInvalidStateException() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node nodeSession1 = defaultRootNode.addNode(nodeName1, testNodeType);

        // save new node
        superuser.save();

        // make a modification
        nodeSession1.addNode(nodeName2, testNodeType);

        // get the new node with a different session
        Session testSession = getHelper().getReadWriteSession();
        try {
            Node nodeSession2 = (Node) testSession.getItem(nodeSession1.getPath());

            // delete the node with the new session
            nodeSession2.remove();

            // make node removal persistent
            testSession.save();

            // save changes made wit superuser session
            try {
                defaultRootNode.save();
                fail("Saving a modified Node using Node.save() already deleted by an other session should throw InvalidItemStateException");
            } catch (InvalidItemStateException e) {
                // ok, works as expected
            }
        } finally {
            testSession.logout();
        }
    }


    public void testRemoveInvalidItemStateException() throws RepositoryException {

        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create the node
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save the nodes
        superuser.save();

        // get the node with session 2
        Session testSession = getHelper().getReadWriteSession();
        try {
            Node defaultTestNodeSession2 = (Node) testSession.getItem(defaultTestNode.getPath());

            // remove node with session 1
            defaultTestNode.remove();
            superuser.save();

            // try to remove already deleted node with session 2
            try {
                defaultTestNodeSession2.remove();
                testSession.save();
                fail("Removing a node already deleted by other session should throw an InvalidItemStateException!");
            } catch (InvalidItemStateException e) {
                //ok, works as expected
            }
        } finally {
            testSession.logout();
        }
    }


    public void testSaveMovedRefNode() throws RepositoryException, NotExecutableException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node newParentNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // create a referenceable node
        Node refTargetNode = defaultRootNode.addNode(nodeName2, getProperty("nodetype2"));

        // save the new nodes
        superuser.save();

        if (!refTargetNode.isNodeType(mixReferenceable)) {
            throw new NotExecutableException("Cannot test referential integrity. Node is not referenceable.");
        }

        // get the moving node with session 2
        Session testSession = getHelper().getReadWriteSession();

        try {
            Node refTargetNodeSession2 = (Node) testSession.getItem(refTargetNode.getPath());

            // move the node with session 1
            superuser.move(refTargetNode.getPath(), newParentNode.getPath() + "/" + nodeName2);

            // make the move persistent with session 1
            superuser.save();

            try {
                // modify some prop of the moved node with session 2
                refTargetNodeSession2.setProperty(propertyName1, "test");
                // save it
                testSession.save();
                // ok, works as expected
            } catch (InvalidItemStateException e) {
                // ok as well.
            }
        } finally {
            testSession.logout();
        }
    }


    public void testGetExternallyChangedNode() throws RepositoryException {
        // Access node1 through session 1
        Node node1 = (Node) readOnly.getItem(node1Path);

        // Add node and property through session 2
        Node n2 = testRootNode.getNode(nodeName1).addNode(nodeName2);
        Property p3 = n2.setProperty(propertyName1, "test");
        testRootNode.save();

        // Assert added nodes are visible in session 1 after refresh
        node1.refresh(false);
        assertTrue(readOnly.itemExists(n2.getPath()));
        assertTrue(readOnly.itemExists(p3.getPath()));

        Item m2 = readOnly.getItem(n2.getPath());
        assertTrue(m2.isNode());
        assertTrue(((Node) m2).hasProperty(propertyName1));

        // Remove property through session 2
        p3.remove();
        testRootNode.save();

        // Assert removal is visible through session 1
        node1.refresh(false);
        assertFalse(((Node) m2).hasProperty(propertyName1));
    }


    public void testGetExternallyChangedProperty() throws RepositoryException {
        // Access node1 through session 1
        Node node1 = (Node) readOnly.getItem(node1Path);

        // Add node and property through session 2
        Node n2 = testRootNode.getNode(nodeName1).addNode(nodeName2);
        Property p3 = n2.setProperty(propertyName1, "test");
        p3.setValue("v3");
        testRootNode.save();

        // Assert added nodes are visible in session 1 after refresh
        node1.refresh(false);
        assertTrue(readOnly.itemExists(n2.getPath()));
        assertTrue(readOnly.itemExists(p3.getPath()));

        Item q3 = readOnly.getItem(p3.getPath());
        assertFalse(q3.isNode());
        assertTrue("v3".equals(((Property) q3).getString()));

        // Change property value through session 2
        p3.setValue("v3_modified");
        testRootNode.save();

        // Assert modification is visible through session 1
        node1.refresh(false);
        assertTrue("v3_modified".equals(((Property) q3).getString()));
    }


    public void testAddMixinToNewNode() throws NotExecutableException, RepositoryException {
        Node newNode;
        try {
            newNode = testRootNode.addNode(nodeName1, testNodeType);
            newNode.addMixin(mixReferenceable);
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        assertFalse("Mixin must not be active before Node has been saved.", newNode.isNodeType(mixReferenceable));
        NodeType[] mixins = newNode.getMixinNodeTypes();
        for (int i = 0; i < mixins.length; i++) {
            if (mixins[i].getName().equals(testNodeType)) {
                fail("Mixin must not be active before Node has been saved.");
            }
        }
    }


    public void testImplicitMixinOnNewNode() throws NotExecutableException, RepositoryException {
        Node newNode;
        try {
            String ntResource = superuser.getNamespacePrefix(NS_NT_URI) + ":resource";
            newNode = testRootNode.addNode(nodeName1, ntResource);
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }

        assertFalse("Implict Mixin inherited by primary Nodetype must not be active before Node has been saved.", newNode.isNodeType(mixReferenceable));
        NodeType[] mixins = newNode.getMixinNodeTypes();
        for (int i = 0; i < mixins.length; i++) {
            if (mixins[i].getName().equals(testNodeType)) {
                fail("Implict Mixin inherited by primary Nodetype must not be active before Node has been saved.");
            }
        }
    }


    public void testAddItemsDefinedByMixin() throws NotExecutableException, RepositoryException {
        // register mixin
        NodeTypeManager ntm = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeTemplate ntd = ntm.createNodeTypeTemplate();
        ntd.setName("testMixin");
        ntd.setMixin(true);
        NodeDefinitionTemplate nodeDef = ntm.createNodeDefinitionTemplate();
        nodeDef.setName("child");
        nodeDef.setRequiredPrimaryTypeNames(new String[] {"nt:folder"});
        ntd.getNodeDefinitionTemplates().add(nodeDef);
        ntm.registerNodeType(ntd, true);

        // create node and add mixin
        Node node = testRootNode.addNode(nodeName1, "nt:resource");
        node.setProperty("jcr:data", "abc");
        node.addMixin("testMixin");
        superuser.save();

        // create a child node defined by the mixin
        node.addNode("child", "nt:folder");
        node.save();
    }


    public void testAddItemsDefinedByMixin3() throws NotExecutableException, RepositoryException {
        // register mixin
        NodeTypeManager ntm = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeTemplate ntd = ntm.createNodeTypeTemplate();
        ntd.setName("testMixin");
        ntd.setMixin(true);
        NodeDefinitionTemplate nodeDef = ntm.createNodeDefinitionTemplate();
        nodeDef.setName("child");
        nodeDef.setRequiredPrimaryTypeNames(new String[] {"nt:folder"});
        nodeDef.setDefaultPrimaryTypeName("nt:folder");
        ntd.getNodeDefinitionTemplates().add(nodeDef);
        ntm.registerNodeType(ntd, true);

        // create node and add mixin
        Node node = testRootNode.addNode(nodeName1, "nt:resource");
        node.setProperty("jcr:data", "abc");
        node.addMixin("testMixin");
        superuser.save();

        // create a child node defined by the mixin without specifying the
        // node type -> must succeed since default primary type is specified
        // in the child node def
        Node c = node.addNode("child");
        assertEquals("nt:folder", c.getPrimaryNodeType().getName());
        superuser.save();
    }


    public void testAddItemsDefinedByMixin2() throws NotExecutableException, RepositoryException {
        // register mixin
        NodeTypeManager ntm = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeTemplate ntd = ntm.createNodeTypeTemplate();
        ntd.setName("testMixin");
        ntd.setMixin(true);
        NodeDefinitionTemplate nodeDef = ntm.createNodeDefinitionTemplate();
        nodeDef.setName("child");
        nodeDef.setRequiredPrimaryTypeNames(new String[] {"nt:folder"});
        ntd.getNodeDefinitionTemplates().add(nodeDef);
        ntm.registerNodeType(ntd, true);

        // create node and add mixin
        Node node = testRootNode.addNode(nodeName1, "nt:resource");
        node.setProperty("jcr:data", "abc");
        node.addMixin("testMixin");
        superuser.save();

        // create a child node defined by the mixin without specifying the
        // node type
        try {
            node.addNode("child");
            fail();
        } catch (ConstraintViolationException e) {
            // success as ChildNode Definition doesn't specify a default primary
            // type -> see comment in ItemDefinitionProvider#getQNodeDefinition
        }
    }


    public void testCreateWorkspace() throws Exception {
        Session s = null;
        try {
            Workspace wsp = superuser.getWorkspace();
            String name = getNewWorkspaceName(wsp);
            wsp.createWorkspace(name);

            List<String> wsps = Arrays.asList(wsp.getAccessibleWorkspaceNames());
            assertTrue(wsps.contains(name));

            s = getHelper().getSuperuserSession(name);
            Workspace newW = s.getWorkspace();
            assertEquals(name, newW.getName());
        } catch (UnsupportedRepositoryOperationException e) {
            throw new NotExecutableException();
        } catch (UnsupportedOperationException e) {
            throw new NotExecutableException();
        } finally {
            if (s != null) {
                s.logout();
            }
        }
    }


    public void testCreateWorkspaceFromSource() throws Exception {
        Session s = null;
        try {
            Workspace wsp = superuser.getWorkspace();
            String name = getNewWorkspaceName(wsp);

            wsp.createWorkspace(name, wsp.getName());

            List<String> wsps = Arrays.asList(wsp.getAccessibleWorkspaceNames());
            assertTrue(wsps.contains(name));

            s = getHelper().getSuperuserSession(name);
            Workspace newW = s.getWorkspace();
            assertEquals(name, newW.getName());
        } catch (UnsupportedRepositoryOperationException e) {
            throw new NotExecutableException();
        } catch (UnsupportedOperationException e) {
            throw new NotExecutableException();
        } finally {
            if (s != null) {
                s.logout();
            }
        }
    }


    public void testNewProperty() throws RepositoryException, LockException, ConstraintViolationException, VersionException {
        Property p = testRootNode.setProperty(propertyName1, testValue);
        testRootNode.refresh(false);

        try {
            p.getString();
            fail("Refresh 'false' must invalidate a new child property");
        } catch (InvalidItemStateException e) {
            // ok
        }
        assertFalse("Refresh 'false' must remove a new child property", testRootNode.hasProperty(propertyName1));
    }


    public void testRemovedNewProperty() throws RepositoryException, LockException, ConstraintViolationException, VersionException {
        Property p = testRootNode.setProperty(propertyName1, testValue);
        p.remove();

        testRootNode.refresh(false);

        try {
            p.getString();
            fail("Refresh 'false' must not bring a removed new child property back to life.");
        } catch (InvalidItemStateException e) {
            // ok
        }
        assertFalse("Refresh 'false' must not bring a removed new child property back to life.", testRootNode.hasProperty(propertyName1));
    }


    private LockImpl getLockFromMap(NodeState nodeState) {
        try {
            LockImpl l = lockMap.get(nodeState);
            if (l != null && l.isLive()) {
                return l;
            }
        } catch (RepositoryException e) {
            // ignore
        }
        return null;
    }


    public EventIterator getEventIterator(long wait) {
        try {
            if (sync.attempt(wait)) {
                // result ready
                return events;
            }
        } catch (InterruptedException e) {
            log.println("Interrupted while waiting for EventIterator");
        }
        return null;
    }


        public ItemState getItemState(ItemId id) throws NoSuchItemStateException, ItemStateException {
            // check ChangeLog first
            try {
                ItemState state = changes.get(id);
                if (state != null) {
                    return state;
                }
            } catch (NoSuchItemStateException e) {
                // item has been deleted, but we still return it by asking base
            }
            return base.getItemState(id);
        }


        public boolean hasItemState(ItemId id) {
            // check ChangeLog first
            try {
                ItemState state = changes.get(id);
                if (state != null) {
                    return true;
                }
            } catch (NoSuchItemStateException e) {
                // item has been deleted, but we still might return true by asking base
            }
            return base.hasItemState(id);
        }


    public boolean hasItemState(ItemId id) {

        // check items in change log
        try {
            ItemState state = changeLog.get(id);
            if (state != null) {
                return true;
            }
        } catch (NoSuchItemStateException e) {
            return false;
        }

        // check cache
        if (cache.isCached(id)) {
            return true;
        }

        // regular behaviour
        return sharedStateMgr.hasItemState(id);
    }


        public boolean isMember(Principal member) {
            // shortcut for everyone group -> avoid collecting all members
            // as all users and groups are member of everyone.
            try {
                if (isEveryone()) {
                    return !getPrincipal().equals(member);
                }
            } catch (RepositoryException e) {
                // continue using regular membership evaluation
            }

            Collection<Principal> members = getMembers();
            return members.contains(member);
        }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        try {
            NodeEntry vhEntry = (NodeEntry) versionHistoryState.getHierarchyEntry();
            NodeEntry lnEntry = vhEntry.getNodeEntry(NameConstants.JCR_VERSIONLABELS, Path.INDEX_DEFAULT);
            if (lnEntry != null) {
                lnEntry.invalidate(moveLabel);
            }
        } catch (RepositoryException e) {
            log.debug(e.getMessage());
        }
    }


    public void persisted() throws RepositoryException {
        status = STATUS_PERSISTED;
        try {
            NodeEntry vhEntry = (NodeEntry) versionHistoryState.getHierarchyEntry();
            NodeEntry lnEntry = vhEntry.getNodeEntry(NameConstants.JCR_VERSIONLABELS, Path.INDEX_DEFAULT);
            if (lnEntry != null) {
                lnEntry.invalidate(true);
            }
        } catch (RepositoryException e) {
            log.debug(e.getMessage());
        }
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        try {
            NodeEntry vhe = mgr.getVersionHistoryEntry(nodeState);
            if (vhe != null) {
                vhe.invalidate(true);
            }
        } catch (RepositoryException e) {
            log.warn("Failed to access Version history entry -> skip invalidation.", e);
        }
        // non-recursive invalidation (but including all properties)
        NodeEntry nodeEntry = (NodeEntry) nodeState.getHierarchyEntry();
        Iterator<PropertyEntry> entries = nodeEntry.getPropertyEntries();
        while (entries.hasNext()) {
            PropertyEntry pe = entries.next();
            pe.invalidate(false);
        }
        nodeEntry.invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        try {
            NodeEntry vhe = mgr.getVersionHistoryEntry(nodeState);
            if (vhe != null) {
                vhe.invalidate(true);
            }
        } catch (RepositoryException e) {
            log.warn("Failed to access Version history entry -> skip invalidation.", e);
        }
        // non-recursive invalidation (but including all properties)
        NodeEntry nodeEntry = (NodeEntry) nodeState.getHierarchyEntry();
        Iterator<PropertyEntry> entries = nodeEntry.getPropertyEntries();
        while (entries.hasNext()) {
            PropertyEntry pe = entries.next();
            pe.invalidate(false);
        }
        nodeEntry.invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        try {
            NodeEntry vhe = mgr.getVersionHistoryEntry(nodeState);
            if (vhe != null) {
                vhe.invalidate(true);
            }
        } catch (RepositoryException e) {
            log.debug("Failed to access Version history entry -> skip invalidation.", e);
        }
        Iterator<PropertyEntry> entries = ((NodeEntry) nodeState.getHierarchyEntry()).getPropertyEntries();
        while (entries.hasNext()) {
            PropertyEntry pe = entries.next();
            pe.invalidate(false);
        }
        nodeState.getHierarchyEntry().invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        // non-recursive invalidation BUT including all properties
        Iterator<PropertyEntry> propEntries = ((NodeEntry) nodeState.getHierarchyEntry()).getPropertyEntries();
        while (propEntries.hasNext()) {
            PropertyEntry pe = propEntries.next();
            pe.invalidate(false);
        }
        nodeState.getHierarchyEntry().invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;

        // invalidate all references to the removed activity
        while (refs.hasNext()) {
            HierarchyEntry entry = hMgr.lookup(refs.next());
            if (entry != null) {
                entry.invalidate(false);
            }
        }

        // invalidate the activities parent
        parent.getNodeEntry().invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        // non-recursive invalidation but including all properties
        NodeEntry nodeEntry = nodeState.getNodeEntry();
        Iterator<PropertyEntry> entries = nodeEntry.getPropertyEntries();
        while (entries.hasNext()) {
            PropertyEntry pe = entries.next();
            pe.invalidate(false);
        }
        nodeEntry.invalidate(false);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        // Invalidate the versionable node as well (version related properties)
        if (versionableEntry != null) {
            Iterator<PropertyEntry> propEntries = versionableEntry.getPropertyEntries();
            while (propEntries.hasNext()) {
                PropertyEntry pe = propEntries.next();
                pe.invalidate(false);
            }
            versionableEntry.invalidate(false);
        }

        // invalidate the versionhistory entry and all its children
        // in order to have the v-graph recalculated
        parent.getNodeEntry().invalidate(true);
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        NodeEntry entry;
        if (uuidBehaviour == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING ||
                uuidBehaviour == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {
            // invalidate the complete tree
            entry = nodeState.getNodeEntry();
            while (entry.getParent() != null) {
                entry = entry.getParent();
            }
            entry.invalidate(true);
        } else {
            // import only added new items below the import target. therefore
            // recursive invalidation is not required. // TODO correct?
            nodeState.getNodeEntry().invalidate(false);
        }
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        if (removeExisting) {
            status = STATUS_PERSISTED;
            // invalidate the complete tree -> find root-hierarchy-entry
            HierarchyEntry he = destParentState.getHierarchyEntry();
            while (he.getParent() != null) {
                he = he.getParent();
            }
            he.invalidate(true);
        } else {
            super.persisted();
        }
    }


    public void persisted() {
        assert status == STATUS_PENDING;
        status = STATUS_PERSISTED;
        NodeEntry entry;
        if (nodeState == null || removeExisting) {
            // invalidate the complete tree
            // -> start searching root-entry from any version-entry or
            //    from the given nodestate
            entry = (nodeState == null) ? versionStates[0].getNodeEntry() : nodeState.getNodeEntry();
            while (entry.getParent() != null) {
                entry = entry.getParent();
            }
        } else {
            entry = nodeState.getNodeEntry();
        }
        entry.invalidate(true);
    }


        private static int getItemCacheSize(Map<?, ?> parameters) throws RepositoryException {
            Object paramItemCacheSize = parameters.get(PARAM_ITEM_CACHE_SIZE);
            log.debug("Setting ItemCacheSize from {}", PARAM_ITEM_CACHE_SIZE);

            if (paramItemCacheSize == null) {
                log.debug("{} not set, defaulting to {}", PARAM_ITEM_CACHE_SIZE, DEFAULT_ITEM_CACHE_SIZE);
                return DEFAULT_ITEM_CACHE_SIZE;
            } else if (paramItemCacheSize instanceof Integer) {
                log.debug("Setting ItemCacheSize to {}", paramItemCacheSize);
                return (Integer) paramItemCacheSize;
            } else if (paramItemCacheSize instanceof String) {
                try {
                    log.debug("Setting ItemCacheSize to {}", paramItemCacheSize);
                    return Integer.parseInt((String) paramItemCacheSize);
                } catch (NumberFormatException e) {
                    String msg = "Invalid value for ItemCacheSize: " + paramItemCacheSize;
                    log.error(msg);
                    throw new RepositoryException(msg, e);
                }
            } else {
                String msg = "Invalid value for ItemCacheSize: " + paramItemCacheSize;
                log.error(msg);
                throw new RepositoryException(msg);
            }
        }


        private static int getPollTimeout(Map<?, ?> parameters) throws RepositoryException {
            Object paramPollTimeOut = parameters.get(PARAM_POLL_TIME_OUT);
            log.debug("Setting PollTimeout from {}", PARAM_POLL_TIME_OUT);

            if (paramPollTimeOut == null) {
                log.debug("{} not set, defaulting to {}", PARAM_POLL_TIME_OUT, DEFAULT_POLL_TIME_OUT);
                return DEFAULT_POLL_TIME_OUT;
            } else if (paramPollTimeOut instanceof Integer) {
                log.debug("Setting PollTimeout to {}", paramPollTimeOut);
                return (Integer) paramPollTimeOut;
            } else if (paramPollTimeOut instanceof String) {
                try {
                    log.debug("Setting PollTimeout to {}", paramPollTimeOut);
                    return Integer.parseInt((String) paramPollTimeOut);
                } catch (NumberFormatException e) {
                    String msg = "Invalid value for PollTimeout: " + paramPollTimeOut;
                    log.error(msg);
                    throw new RepositoryException(msg, e);
                }
            } else {
                String msg = "Invalid value for PollTimeout: " + paramPollTimeOut;
                log.error(msg);
                throw new RepositoryException(msg);
            }
        }


    public void execute(Operation operation) throws RepositoryException {
        // block event delivery while changes are executed
        try {
            updateSync.acquire();
        } catch (InterruptedException e) {
            throw new RepositoryException(e);
        }
        try {
            /*
            Execute operation and delegate invalidation of affected item
            states to the operation.
            NOTE, that the invalidation is independent of the cache behaviour
            due to the fact, that local event bundles are not processed by
            the HierarchyEventListener.
            */
            new OperationVisitorImpl(sessionInfo).execute(operation);
            operation.persisted();
        } finally {
            updateSync.release();
        }
    }


    public void execute(ChangeLog changes) throws RepositoryException {
        // block event delivery while changes are executed
        try {
            updateSync.acquire();
        } catch (InterruptedException e) {
            throw new RepositoryException(e);
        }
        try {
            new OperationVisitorImpl(sessionInfo).execute(changes);
            changes.persisted();
        } finally {
            updateSync.release();
        }
    }


    public NodeEntry getNodeEntry(NodeId nodeId)
            throws ItemNotFoundException, RepositoryException {
        String uniqueID = nodeId.getUniqueID();
        if (uniqueID == null) {
            return getNodeEntry(nodeId.getPath());
        } else {
            if (nodeId.getPath() == null) {
                NodeEntry nEntry = uniqueIdResolver.resolve(nodeId, rootEntry);
                return nEntry;
            } else {
                NodeEntry nEntry = uniqueIdResolver.resolve(idFactory.createNodeId(uniqueID), rootEntry);
                return nEntry.getDeepNodeEntry(nodeId.getPath());
            }
        }
    }


    public PropertyEntry getPropertyEntry(PropertyId propertyId)
            throws ItemNotFoundException, RepositoryException {
        String uniqueID = propertyId.getUniqueID();
        if (uniqueID == null) {
            return getPropertyEntry(propertyId.getPath());
        } else {
            if (propertyId.getPath() == null) {
                // a property id always contains a Path part.
                throw new ItemNotFoundException("No property found for id " + LogUtil.saveGetIdString(propertyId, resolver));
            } else {
                NodeEntry nEntry = uniqueIdResolver.resolve(idFactory.createNodeId(uniqueID), rootEntry);
                return nEntry.getDeepPropertyEntry(propertyId.getPath());
            }
        }
    }


    public NodeEntry getNodeEntry(Path qPath) throws PathNotFoundException, RepositoryException {
        NodeEntry rootEntry = getRootEntry();
        // shortcut
        if (qPath.denotesRoot()) {
            return rootEntry;
        }
        if (!qPath.isCanonical()) {
            String msg = "Path is not canonical";
            log.debug(msg);
            throw new RepositoryException(msg);
        }
        return rootEntry.getDeepNodeEntry(qPath);
    }


    public PropertyEntry getPropertyEntry(Path qPath)
            throws PathNotFoundException, RepositoryException {
        // shortcut
        if (qPath.denotesRoot()) {
            throw new PathNotFoundException("The root path never points to a Property.");
        }
        if (!qPath.isCanonical()) {
            String msg = "Path is not canonical";
            log.debug(msg);
            throw new RepositoryException(msg);
        }
        return getRootEntry().getDeepPropertyEntry(qPath);
    }


    public NodeState getNodeState(Path qPath) throws PathNotFoundException, RepositoryException {
        NodeEntry entry = getNodeEntry(qPath);
        try {
            NodeState state = entry.getNodeState();
            if (state.isValid()) {
                return state;
            } else {
                throw new PathNotFoundException(LogUtil.safeGetJCRPath(qPath, resolver));
            }
        } catch (ItemNotFoundException e) {
            throw new PathNotFoundException(e);
        }
    }


    public PropertyState getPropertyState(Path qPath) throws PathNotFoundException, RepositoryException {
        PropertyEntry entry = getPropertyEntry(qPath);
        try {
            PropertyState state = entry.getPropertyState();
            if (state.isValid()) {
                return state;
            } else {
                throw new PathNotFoundException(LogUtil.safeGetJCRPath(qPath, resolver));
            }
        } catch (ItemNotFoundException e) {
            throw new PathNotFoundException(e);
        }
    }


    boolean contains(Name name, int index, String uniqueId) {
        for (NodeEntryImpl ne : attic) {
            if (uniqueId != null && uniqueId.equals(ne.getUniqueID())) {
                return true;
            } else if (ne.matches(name, index)) {
                return true;
            }
        }
        // not found
        return false;
    }


    private boolean isAnonymous(Set<Principal> principals) {
        for (Principal p : principals) {
            if (p instanceof AnonymousPrincipal) {
                return true;
            } else if (p.getName().equals(anonymousId)) {
                return true;
            }
        }
        return false;
    }


    NodeEntry get(String uniqueId) {
        if (uniqueId == null) {
            throw new IllegalArgumentException();
        }
        for (NodeEntry ne : attic) {
            if (uniqueId.equals(ne.getUniqueID())) {
                return ne;
            }
        }
        // not found
        return null;
    }


    public NodeEntry get(Name nodeName, String uniqueID) {
        if (uniqueID == null || nodeName == null) {
            throw new IllegalArgumentException();
        }
        for (NodeEntry cne : get(nodeName)) {
            if (uniqueID.equals(cne.getUniqueID())) {
                return cne;
            }
        }
        return null;
    }


    static boolean isValidNodeEntry(NodeEntry cne) {
        // shortcut.
        if (cne == null) {
            return false;
        }
        boolean isValid = false;
        if (cne.isAvailable()) {
            try {
                isValid = cne.getNodeState().isValid();
            } catch (ItemNotFoundException e) {
                // may occur if the cached state is marked 'INVALIDATED' and
                // does not exist any more on the persistent layer -> invalid.
            } catch (RepositoryException e) {
                // should not occur, if the cne is available.
            }
        } else {
            // assume entry is valid
            // TODO: check if this assumption is correct
            isValid = true;
        }

        return isValid;
    }


    static boolean isValidPropertyEntry(PropertyEntry cpe) {
        if (cpe == null) {
            return false;
        }
        boolean isValid = false;
        if (cpe.isAvailable()) {
            try {
                isValid = cpe.getPropertyState().isValid();
            } catch (ItemNotFoundException e) {
                // may occur if the cached state is marked 'INVALIDATED' and
                // does not exist any more on the persistent layer -> invalid.
            } catch (RepositoryException e) {
                // probably removed in the meantime. should not occur.
            }
        } else {
            // assume entry is valid // TODO check if this assumption is correct.
            isValid = true;
        }
        return isValid;
    }


    public synchronized NodeEntry reorder(NodeEntry insertEntry, NodeEntry beforeEntry) {
        // the link node to move
        LinkedEntries.LinkNode insertLN = entries.getLinkNode(insertEntry);
        if (insertLN == null) {
            throw new NoSuchElementException();
        }
        // the link node where insertLN is ordered before
        LinkedEntries.LinkNode beforeLN = (beforeEntry != null) ? entries.getLinkNode(beforeEntry) : null;
        if (beforeEntry != null && beforeLN == null) {
            throw new NoSuchElementException();
        }

        NodeEntry previousBefore = insertLN.getNextLinkNode().getNodeEntry();
        if (previousBefore != beforeEntry) {
            reorder(insertEntry.getName(), insertLN, beforeLN);
        }
        return previousBefore;
    }


    public void reorderAfter(NodeEntry insertEntry, NodeEntry afterEntry) {
        // the link node to move
        LinkedEntries.LinkNode insertLN = entries.getLinkNode(insertEntry);
        if (insertLN == null) {
            throw new NoSuchElementException();
        }
        // the link node where insertLN is ordered before
        LinkedEntries.LinkNode afterLN = (afterEntry != null) ? entries.getLinkNode(afterEntry) : null;
        if (afterEntry != null && afterLN == null) {
            throw new NoSuchElementException();
        }

        LinkedEntries.LinkNode previousLN = insertLN.getPreviousLinkNode();
        if (previousLN != afterLN) {
            reorderAfter(insertLN, afterLN);
        } // else: already in correct position. nothing to do
    }


    private void complete(AddProperty operation) throws RepositoryException {
        if (operation.getParentState().getHierarchyEntry() != this) {
            throw new IllegalArgumentException();
        }
        PropertyEntry pe = getPropertyEntry(operation.getPropertyName());
        if (pe != null && pe.getStatus() == Status.NEW) {
            switch (operation.getStatus()) {
                case Operation.STATUS_PERSISTED:
                    // for autocreated/protected props, mark to be reloaded
                    // upon next access.
                    PropertyState addedState = (PropertyState) ((PropertyEntryImpl) pe).internalGetItemState();
                    addedState.setStatus(Status.EXISTING);
                    QPropertyDefinition pd = addedState.getDefinition();
                    if (pd.isAutoCreated() || pd.isProtected()) {
                        pe.invalidate(true);
                    } // else: assume added property is up to date.
                    break;
                case Operation.STATUS_UNDO:
                    pe.revert();
                    break;
                default: // ignore
            }
        } // else: no such prop entry or entry has already been persisted
          //       e.g due to external modifications merged into this NodeEntry.
    }


    private void complete(SetMixin operation) throws RepositoryException {
        if (operation.getNodeState().getHierarchyEntry() != this) {
            throw new IllegalArgumentException();
        }
        PropertyEntry pe = getPropertyEntry(NameConstants.JCR_MIXINTYPES);
        if (pe != null) {
            PropertyState pState = pe.getPropertyState();
            switch (operation.getStatus()) {
                case Operation.STATUS_PERSISTED:
                    Name[] mixins = StateUtility.getMixinNames(pState);
                    getNodeState().setMixinTypeNames(mixins);
                    if (pState.getStatus() == Status.NEW || pState.getStatus() == Status.EXISTING_MODIFIED) {
                        pState.setStatus(Status.EXISTING);
                    }
                    break;
                case Operation.STATUS_UNDO:
                    pe.revert();
                    break;
                default: // ignore
            }
        } // else: no such prop-Entry (should not occur)
    }


    private void complete(SetPrimaryType operation) throws RepositoryException {
        if (operation.getNodeState().getHierarchyEntry() != this) {
            throw new IllegalArgumentException();
        }
        PropertyEntry pe = getPropertyEntry(NameConstants.JCR_PRIMARYTYPE);
        if (pe != null) {
            PropertyState pState = pe.getPropertyState();
            switch (operation.getStatus()) {
                case Operation.STATUS_PERSISTED:
                    // NOTE: invalidation of this node entry is performed by
                    // ChangeLog.persisted...
                    // TODO: check if correct
                    if (pState.getStatus() == Status.NEW || pState.getStatus() == Status.EXISTING_MODIFIED) {
                        pState.setStatus(Status.EXISTING);
                    }
                    break;
                case Operation.STATUS_UNDO:
                    pe.revert();
                    break;
                default: // ignore
            }
        } // else: no such prop-Entry (should not occur)
    }


    private void complete(ReorderNodes operation) throws RepositoryException {
        HierarchyEntry he = operation.getInsertNode().getHierarchyEntry();
        if (he != this) {
            throw new IllegalArgumentException();
        }
        // NOTE: if reorder occurred in combination with a 'move' the clean-up
        // of the revertInfo is postponed until {@link #complete(Move)}.
        switch (operation.getStatus()) {
            case Operation.STATUS_PERSISTED:
                if (revertInfo != null && !revertInfo.isMoved()) {
                    revertInfo.dispose(true);
                }
                break;
            case Operation.STATUS_UNDO:
                if (he.getStatus() == Status.NEW) {
                    he.revert();
                } else if (revertInfo != null && !revertInfo.isMoved()) {
                    revertInfo.dispose(false);
                }
                break;
            default: // ignore
        }
    }


    private void complete(Move operation) throws RepositoryException {
        HierarchyEntry he = operation.getSourceState().getHierarchyEntry();
        if (he != this) {
            throw new IllegalArgumentException();
        }
        switch (operation.getStatus()) {
            case Operation.STATUS_PERSISTED:
                if (getStatus() != Status.NEW && revertInfo != null) {
                    revertInfo.oldParent.childNodeAttic.remove(this);
                    revertInfo.dispose(true);
                }
                // and mark the moved state existing
                // internalGetItemState().setStatus(Status.EXISTING);
                break;
            case Operation.STATUS_UNDO:
                if (getStatus() == Status.NEW) {
                    revert();
                } else if (revertInfo != null) {
                    revertMove();
                    revertInfo.dispose(false);
                }
                break;
            default: // ignore
        }
    }


    public Property getProperty() throws RepositoryException {
        Value value = getValue();
        Value pathValue = ValueHelper.convert(value, PropertyType.PATH, session.getValueFactory());
        String path = pathValue.getString();
        boolean absolute;
        try {
            Path p = session.getPathResolver().getQPath(path);
            absolute = p.isAbsolute();
        } catch (RepositoryException e) {
            throw new ValueFormatException("Property value cannot be converted to a PATH");
        }
        try {
            return (absolute) ? session.getProperty(path) : getParent().getProperty(path);
        } catch (PathNotFoundException e) {
            throw new ItemNotFoundException(path);
        }
    }


    public Property getProperty() throws RepositoryException {
        Value value = getValue();
        Value pathValue = ValueHelper.convert(value, PATH, getSession().getValueFactory());
        String path = pathValue.getString();
        boolean absolute;
        try {
            Path p = sessionContext.getQPath(path);
            absolute = p.isAbsolute();
        } catch (RepositoryException e) {
            throw new ValueFormatException("Property value cannot be converted to a PATH");
        }
        try {
            return (absolute) ? getSession().getProperty(path) : getParent().getProperty(path);
        } catch (PathNotFoundException e) {
            throw new ItemNotFoundException(path);
        }
    }


    private long getLength(QValue value) throws RepositoryException {
        long length;
        switch (value.getType()) {
            case PropertyType.NAME:
            case PropertyType.PATH:
                String jcrString = ValueFormat.getJCRString(value, session.getNamePathResolver());
                length = jcrString.length();
                break;
            default:
                length = value.getLength();
                break;
        }
        return length;
    }


    protected long getLength(InternalValue value) throws RepositoryException {
        long length;
        switch (value.getType()) {
            case NAME:
            case PATH:
                String str = ValueFormat.getJCRString(value, sessionContext);
                length = str.length();
                break;
            default:
                length = value.getLength();
                break;
        }
        return length;
    }


    private void appendCharacters(char[] ch, int start, int length)
            throws SAXException {
        if (textHandler == null) {
            textHandler = new BufferedStringValue();
        }
        try {
            textHandler.append(ch, start, length);
        } catch (IOException ioe) {
            String msg = "internal error while processing internal buffer data";
            log.error(msg, ioe);
            throw new SAXException(msg, ioe);
        }
    }


    private void appendCharacters(char[] ch, int start, int length)
            throws SAXException {
        if (textHandler == null) {
            textHandler = new BufferedStringValue(resolver, valueFactory);
        }
        try {
            textHandler.append(ch, start, length);
        } catch (IOException ioe) {
            String msg = "internal error while processing internal buffer data";
            log.error(msg, ioe);
            throw new SAXException(msg, ioe);
        }
    }


    private void processCharacters()
            throws SAXException {
        try {
            if (textHandler != null && textHandler.length() > 0) {
                // there is character data that needs to be added to
                // the current node

                // check for pure whitespace character data
                Reader reader = textHandler.reader();
                try {
                    int ch;
                    while ((ch = reader.read()) != -1) {
                        if (ch > 0x20) {
                            break;
                        }
                    }
                    if (ch == -1) {
                        // the character data consists of pure whitespace, ignore
                        log.debug("ignoring pure whitespace character data...");
                        // reset handler
                        textHandler.dispose();
                        textHandler = null;
                        return;
                    }
                } finally {
                    reader.close();
                }

                Importer.NodeInfo node =
                        new Importer.NodeInfo(NameConstants.JCR_XMLTEXT, null, null, null);
                Importer.TextValue[] values =
                        new Importer.TextValue[]{textHandler};
                List<Importer.PropInfo> props = new ArrayList<Importer.PropInfo>();
                Importer.PropInfo prop =
                        new Importer.PropInfo(NameConstants.JCR_XMLCHARACTERS, PropertyType.STRING, values);
                props.add(prop);
                // call Importer
                importer.startNode(node, props, resolver);
                importer.endNode(node);

                // reset handler
                textHandler.dispose();
                textHandler = null;
            }
        } catch (IOException ioe) {
            String msg = "internal error while processing internal buffer data";
            log.error(msg, ioe);
            throw new SAXException(msg, ioe);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    private void processCharacters()
            throws SAXException {
        try {
            if (textHandler != null && textHandler.length() > 0) {
                // there is character data that needs to be added to
                // the current node

                // check for pure whitespace character data
                Reader reader = textHandler.reader();
                try {
                    int ch;
                    while ((ch = reader.read()) != -1) {
                        if (ch > 0x20) {
                            break;
                        }
                    }
                    if (ch == -1) {
                        // the character data consists of pure whitespace, ignore
                        log.debug("ignoring pure whitespace character data...");
                        // reset handler
                        textHandler.dispose();
                        textHandler = null;
                        return;
                    }
                } finally {
                    reader.close();
                }

                NodeInfo node =
                        new NodeInfo(NameConstants.JCR_XMLTEXT, null, null, null);
                TextValue[] values =
                        new TextValue[]{textHandler};
                ArrayList<PropInfo> props = new ArrayList<PropInfo>();
                props.add(new PropInfo(
                        NameConstants.JCR_XMLCHARACTERS,
                        PropertyType.STRING, values));
                // call Importer
                importer.startNode(node, props);
                importer.endNode(node);

                // reset handler
                textHandler.dispose();
                textHandler = null;
            }
        } catch (IOException ioe) {
            String msg = "internal error while processing internal buffer data";
            log.error(msg, ioe);
            throw new SAXException(msg, ioe);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    public void startElement(String namespaceURI, String localName,
                             String qName, Attributes atts)
            throws SAXException {
        // process buffered character data
        processCharacters();

        try {
            String dcdLocalName = ISO9075.decode(localName);
            Name nodeName = nameFactory.create(namespaceURI, dcdLocalName);

            // properties
            String uuid = null;
            Name nodeTypeName = null;
            Name[] mixinTypes = null;

            List<Importer.PropInfo> props = new ArrayList<Importer.PropInfo>(atts.getLength());
            for (int i = 0; i < atts.getLength(); i++) {
                if (atts.getURI(i).equals(Name.NS_XMLNS_URI)) {
                    // skip namespace declarations reported as attributes
                    // see http://issues.apache.org/jira/browse/JCR-620#action_12448164
                    continue;
                }

                dcdLocalName = ISO9075.decode(atts.getLocalName(i));
                Name propName = nameFactory.create(atts.getURI(i), dcdLocalName);

                // attribute value
                String attrValue = atts.getValue(i);
                if (propName.equals(NameConstants.JCR_PRIMARYTYPE)) {
                    // jcr:primaryType
                    if (attrValue.length() > 0) {
                        try {
                            nodeTypeName = resolver.getQName(attrValue);
                        } catch (NameException ne) {
                            throw new SAXException("illegal jcr:primaryType value: "
                                    + attrValue, ne);
                        }
                    }
                } else if (propName.equals(NameConstants.JCR_MIXINTYPES)) {
                    // jcr:mixinTypes
                    mixinTypes = parseNames(attrValue);
                } else if (propName.equals(NameConstants.JCR_UUID)) {
                    // jcr:uuid
                    if (attrValue.length() > 0) {
                        uuid = attrValue;
                    }
                } else {
                    // always assume single-valued property for the time being
                    // until a way of properly serializing/detecting multi-valued
                    // properties on re-import is found (see JCR-325);
                    // see also DocViewSAXEventGenerator#leavingProperties(Node, int)
                    // TODO: proper multi-value serialization support
                    Importer.TextValue[] propValues = new Importer.TextValue[1];
                    propValues[0] = new StringValue(attrValue);
                    props.add(new Importer.PropInfo(propName, PropertyType.UNDEFINED, propValues));
                }
            }

            Importer.NodeInfo node = new Importer.NodeInfo(nodeName, nodeTypeName, mixinTypes, uuid);
            // all information has been collected, now delegate to importer
            importer.startNode(node, props, resolver);
            // push current node data onto stack
            stack.push(node);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    public void startElement(String namespaceURI, String localName,
                             String qName, Attributes atts)
            throws SAXException {
        // process buffered character data
        processCharacters();

        try {
            Name nodeName = NameFactoryImpl.getInstance().create(namespaceURI, localName);
            // process node name
            nodeName = processName(nodeName);

            // properties
            NodeId id = null;
            Name nodeTypeName = null;
            Name[] mixinTypes = null;

            List<PropInfo> props = new ArrayList<PropInfo>(atts.getLength());
            for (int i = 0; i < atts.getLength(); i++) {
                if (atts.getURI(i).equals(Name.NS_XMLNS_URI)) {
                    // skip namespace declarations reported as attributes
                    // see http://issues.apache.org/jira/browse/JCR-620#action_12448164
                    continue;
                }
                Name propName = NameFactoryImpl.getInstance().create(atts.getURI(i), atts.getLocalName(i));
                // process property name
                propName = processName(propName);

                // value(s)
                String attrValue = atts.getValue(i);
                TextValue[] propValues;

                // always assume single-valued property for the time being
                // until a way of properly serializing/detecting multi-valued
                // properties on re-import is found (see JCR-325);
                // see also DocViewSAXEventGenerator#leavingProperties(Node, int)
                // todo proper multi-value serialization support
                propValues = new TextValue[1];
                propValues[0] = new StringValue(attrValue, resolver, valueFactory);

                if (propName.equals(NameConstants.JCR_PRIMARYTYPE)) {
                    // jcr:primaryType
                    if (attrValue.length() > 0) {
                        try {
                            nodeTypeName = resolver.getQName(attrValue);
                        } catch (NameException ne) {
                            throw new SAXException("illegal jcr:primaryType value: "
                                    + attrValue, ne);
                        }
                    }
                } else if (propName.equals(NameConstants.JCR_MIXINTYPES)) {
                    // jcr:mixinTypes
                    mixinTypes = parseNames(attrValue);
                } else if (propName.equals(NameConstants.JCR_UUID)) {
                    // jcr:uuid
                    if (attrValue.length() > 0) {
                        id = NodeId.valueOf(attrValue);
                    }
                } else {
                    props.add(new PropInfo(
                            propName, PropertyType.UNDEFINED, propValues));
                }
            }

            NodeInfo node =
                    new NodeInfo(nodeName, nodeTypeName, mixinTypes, id);
            // all information has been collected, now delegate to importer
            importer.startNode(node, props);
            // push current node data onto stack
            stack.push(node);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    private Name[] parseNames(String value) throws SAXException {
        String[] names = value.split("\\p{Space}+");
        Name[] qnames = new Name[names.length];
        for (int i = 0; i < names.length; i++) {
            try {
                qnames[i] = resolver.getQName(names[i]);
            } catch (NameException ne) {
                throw new SAXException("Invalid name: " + names[i], ne);
            } catch (NamespaceException e) {
                throw new SAXException("Invalid name: " + names[i], e);
            }
        }
        return qnames;
    }


    private Name[] parseNames(String value) throws SAXException {
        String[] names = value.split("\\p{Space}+");
        Name[] qnames = new Name[names.length];
        for (int i = 0; i < names.length; i++) {
            try {
                qnames[i] = resolver.getQName(names[i]);
            } catch (NameException ne) {
                throw new SAXException("Invalid name: " + names[i], ne);
            } catch (NamespaceException e) {
                throw new SAXException("Invalid name: " + names[i], e);
            }
        }
        return qnames;
    }


    public void endElement(String namespaceURI, String localName, String qName)
            throws SAXException {
        // process buffered character data
        processCharacters();

        Importer.NodeInfo node = stack.peek();
        try {
            // call Importer
            importer.endNode(node);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
        // we're done with this node, pop it from stack
        stack.pop();
    }


    public void endElement(String namespaceURI, String localName, String qName)
            throws SAXException {
        // process buffered character data
        processCharacters();

        NodeInfo node = stack.peek();
        try {
            // call Importer
            importer.endNode(node);
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
        // we're done with this node, pop it from stack
        stack.pop();
    }


    private void processNode(ImportState state, boolean start, boolean end)
            throws SAXException {
        if (!start && !end) {
            return;
        }
        Name[] mixins = null;
        if (state.mixinNames != null) {
            mixins = state.mixinNames.toArray(new Name[state.mixinNames.size()]);
        }
        Importer.NodeInfo nodeInfo = new Importer.NodeInfo(state.nodeName, state.nodeTypeName, mixins, state.uuid);

        if (state.uuid != null) {
            nodeInfo.setUUID(state.uuid);
        }
        // call Importer
        try {
            if (start) {
                importer.startNode(nodeInfo, state.props, resolver);
                // dispose temporary property values
                for (Importer.PropInfo pi : state.props) {
                    disposePropertyValues(pi);
                }
            }
            if (end) {
                importer.endNode(nodeInfo);
            }
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    private void processNode(ImportState state, boolean start, boolean end)
            throws SAXException {
        if (!start && !end) {
            return;
        }
        Name[] mixinNames = null;
        if (state.mixinNames != null) {
            mixinNames = state.mixinNames.toArray(
                    new Name[state.mixinNames.size()]);
        }
        NodeId id = null;
        if (state.uuid != null) {
            id = NodeId.valueOf(state.uuid);
        }
        NodeInfo node =
            new NodeInfo(state.nodeName, state.nodeTypeName, mixinNames, id);
        // call Importer
        try {
            if (start) {
                importer.startNode(node, state.props);
                // dispose temporary property values
                for (PropInfo pi : state.props) {
                    pi.dispose();
                }

            }
            if (end) {
                importer.endNode(node);
            }
        } catch (RepositoryException re) {
            throw new SAXException(re);
        }
    }


    public void endElement(String namespaceURI, String localName, String qName)
            throws SAXException {
        // check element name
        ImportState state = stack.peek();
        if (NODE.equals(localName)) {
            // sv:node element
            if (!state.started) {
                // need to start & end current node
                processNode(state, true, true);
                state.started = true;
            } else {
                // need to end current node
                processNode(state, false, true);
            }
            // pop current state from stack
            stack.pop();
        } else if (PROPERTY.equals(localName)) {
            // sv:property element

            // check if all system properties (jcr:primaryType, jcr:uuid etc.)
            // have been collected and create node as necessary
            if (currentPropName.equals(NameConstants.JCR_PRIMARYTYPE)) {
                AppendableValue val = (AppendableValue) currentPropValues.get(0);
                String s = null;
                try {
                    s = val.retrieve();
                    state.nodeTypeName = resolver.getQName(s);
                } catch (IOException ioe) {
                    throw new SAXException("error while retrieving value", ioe);
                } catch (NameException e) {
                    throw new SAXException(new InvalidSerializedDataException("illegal node type name: " + s, e));
                } catch (NamespaceException e) {
                    throw new SAXException(new InvalidSerializedDataException("illegal node type name: " + s, e));
                }
            } else if (currentPropName.equals(NameConstants.JCR_MIXINTYPES)) {
                if (state.mixinNames == null) {
                    state.mixinNames = new ArrayList<Name>(currentPropValues.size());
                }
                for (int i = 0; i < currentPropValues.size(); i++) {
                    AppendableValue val =
                            (AppendableValue) currentPropValues.get(i);
                    String s = null;
                    try {
                        s = val.retrieve();
                        Name mixin = resolver.getQName(s);
                        state.mixinNames.add(mixin);
                    } catch (IOException ioe) {
                        throw new SAXException("error while retrieving value", ioe);
                    } catch (NameException e) {
                        throw new SAXException(new InvalidSerializedDataException("illegal mixin type name: " + s, e));
                    } catch (NamespaceException e) {
                        throw new SAXException(new InvalidSerializedDataException("illegal mixin type name: " + s, e));
                    }
                }
            } else if (currentPropName.equals(NameConstants.JCR_UUID)) {
                AppendableValue val = (AppendableValue) currentPropValues.get(0);
                try {
                    state.uuid = val.retrieve();
                } catch (IOException ioe) {
                    throw new SAXException("error while retrieving value", ioe);
                }
            } else {
                Importer.TextValue[] values = currentPropValues.toArray(new Importer.TextValue[currentPropValues.size()]);
                Importer.PropInfo prop = new Importer.PropInfo(currentPropName, currentPropType, values);
                state.props.add(prop);
            }
            // reset temp fields
            currentPropValues.clear();
        } else if (VALUE.equals(localName)) {
            // sv:value element
            currentPropValues.add(currentPropValue);
            // reset temp fields
            currentPropValue = null;
        } else {
            throw new SAXException(new InvalidSerializedDataException("invalid element in system view xml document: " + localName));
        }
    }


    public void endElement(String namespaceURI, String localName, String qName)
            throws SAXException {
        Name name = NameFactoryImpl.getInstance().create(namespaceURI, localName);
        // check element name
        ImportState state = stack.peek();
        if (name.equals(NameConstants.SV_NODE)) {
            // sv:node element
            if (!state.started) {
                // need to start & end current node
                processNode(state, true, true);
                state.started = true;
            } else {
                // need to end current node
                processNode(state, false, true);
            }
            // pop current state from stack
            stack.pop();
        } else if (name.equals(NameConstants.SV_PROPERTY)) {
            // sv:property element

            // check if all system properties (jcr:primaryType, jcr:uuid etc.)
            // have been collected and create node as necessary
            if (currentPropName.equals(NameConstants.JCR_PRIMARYTYPE)) {
                BufferedStringValue val = currentPropValues.get(0);
                String s = null;
                try {
                    s = val.retrieve();
                    state.nodeTypeName = resolver.getQName(s);
                } catch (IOException ioe) {
                    throw new SAXException("error while retrieving value", ioe);
                } catch (NameException e) {
                    throw new SAXException(new InvalidSerializedDataException("illegal node type name: " + s, e));
                } catch (NamespaceException e) {
                    throw new SAXException(new InvalidSerializedDataException("illegal node type name: " + s, e));
                }
            } else if (currentPropName.equals(NameConstants.JCR_MIXINTYPES)) {
                if (state.mixinNames == null) {
                    state.mixinNames = new ArrayList<Name>(currentPropValues.size());
                }
                for (BufferedStringValue val : currentPropValues) {
                    String s = null;
                    try {
                        s = val.retrieve();
                        Name mixin = resolver.getQName(s);
                        state.mixinNames.add(mixin);
                    } catch (IOException ioe) {
                        throw new SAXException("error while retrieving value", ioe);
                    } catch (NameException e) {
                        throw new SAXException(new InvalidSerializedDataException("illegal mixin type name: " + s, e));
                    } catch (NamespaceException e) {
                        throw new SAXException(new InvalidSerializedDataException("illegal mixin type name: " + s, e));
                    }
                }
            } else if (currentPropName.equals(NameConstants.JCR_UUID)) {
                BufferedStringValue val = currentPropValues.get(0);
                try {
                    state.uuid = val.retrieve();
                } catch (IOException ioe) {
                    throw new SAXException("error while retrieving value", ioe);
                }
            } else {
                if (currentPropMultipleStatus == MultipleStatus.UNKNOWN
                        && currentPropValues.size() != 1) {
                    currentPropMultipleStatus = MultipleStatus.MULTIPLE;
                }
                PropInfo prop = new PropInfo(
                        currentPropName,
                        currentPropType,
                        currentPropValues.toArray(new TextValue[currentPropValues.size()]),
                        currentPropMultipleStatus);
                state.props.add(prop);
            }
            // reset temp fields
            currentPropValues.clear();
        } else if (name.equals(NameConstants.SV_VALUE)) {
            // sv:value element
            currentPropValues.add(currentPropValue);
            // reset temp fields
            currentPropValue = null;
        } else {
            throw new SAXException(new InvalidSerializedDataException("invalid element in system view xml document: " + localName));
        }
    }


        public long length() throws IOException {
            if (buffer != null) {
                return bufferPos;
            } else if (tmpFile != null) {
                // flush writer first
                writer.flush();
                return tmpFile.length();
            } else {
                throw new IOException("this instance has already been disposed");
            }
        }


        public Reader reader() throws IOException {
            if (buffer != null) {
                return new StringReader(new String(buffer, 0, bufferPos));
            } else if (tmpFile != null) {
                // flush writer first
                writer.flush();
                return new FileReader(tmpFile);
            } else {
                throw new IOException("this instance has already been disposed");
            }
        }


    public Reader reader() throws IOException {
        if (buffer != null) {
            return new StringReader(retrieve());
        } else if (tmpFile != null) {
            // close writer first
            writer.close();
            return openReader();
        } else {
            throw new IOException("this instance has already been disposed");
        }
    }


        public String retrieve() throws IOException {
            if (buffer != null) {
                return new String(buffer, 0, bufferPos);
            } else if (tmpFile != null) {
                // flush writer first
                writer.flush();
                if (tmpFile.length() > Integer.MAX_VALUE) {
                    throw new IOException("size of value is too big, use reader()");
                }
                StringBuffer sb = new StringBuffer((int) tmpFile.length());
                char[] chunk = new char[0x2000];
                int read;
                Reader reader = new FileReader(tmpFile);
                try {
                    while ((read = reader.read(chunk)) > -1) {
                        sb.append(chunk, 0, read);
                    }
                } finally {
                    reader.close();
                }
                return sb.toString();
            } else {
                throw new IOException("this instance has already been disposed");
            }
        }


    public String retrieve() throws IOException {
        if (buffer != null) {
            return buffer.toString();
        } else if (tmpFile != null) {
            // close writer first
            writer.close();
            if (tmpFile.length() > Integer.MAX_VALUE) {
                throw new IOException("size of value is too big, use reader()");
            }
            StringBuilder sb = new StringBuilder((int) length);
            char[] chunk = new char[0x2000];
            Reader reader = openReader();
            try {
                int read;
                while ((read = reader.read(chunk)) > -1) {
                    sb.append(chunk, 0, read);
                }
            } finally {
                reader.close();
            }
            return sb.toString();
        } else {
            throw new IOException("this instance has already been disposed");
        }
    }


    public void itemCreated(Item item) {
        if (!(item instanceof ItemImpl)) {
            String msg = "Incompatible Item object: " + ItemImpl.class.getName() + " expected.";
            throw new IllegalArgumentException(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug("created item " + item);
        }
        // add instance to cache
        cacheItem(((ItemImpl)item).getItemState(), item);
    }


    public void itemDestroyed(Item item) {
        if (!(item instanceof ItemImpl)) {
            String msg = "Incompatible Item object: " + ItemImpl.class.getName() + " expected.";
            throw new IllegalArgumentException(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug("destroyed item " + item);
        }
        // we're no longer interested in this item
        ((ItemImpl)item).removeLifeCycleListener(this);
        // remove instance from cache
        evictItem(((ItemImpl)item).getItemState());
    }


    public Session login(Credentials credentials, String workspaceName) throws LoginException, NoSuchWorkspaceException, RepositoryException {
        SessionInfo info = config.getRepositoryService().obtain(credentials, workspaceName);
        try {
            if (info instanceof XASessionInfo) {
                return new XASessionImpl((XASessionInfo) info, this, config);
            } else {
                return new SessionImpl(info, this, config);
            }
        } catch (RepositoryException ex) {
            config.getRepositoryService().dispose(info);
            throw ex;
        }
    }


    public Session impersonate(Credentials credentials) throws LoginException, RepositoryException {
        checkIsAlive();
        SessionInfo info = config.getRepositoryService().impersonate(sessionInfo, credentials);
        try {
            if (info instanceof XASessionInfo) {
                return new XASessionImpl((XASessionInfo) info, repository, config);
            } else {
                return new SessionImpl(info, repository, config);
            }
        } catch (RepositoryException ex) {
            config.getRepositoryService().dispose(info);
            throw ex;
        }
    }


    public PrivilegeImpl(PrivilegeDefinition definition, PrivilegeDefinition[] allDefs, NamePathResolver npResolver) throws RepositoryException {
        this.definition = definition;
        this.npResolver = npResolver;

        Set<Name> set = definition.getDeclaredAggregateNames();
        Name[] declAggrNames = set.toArray(new Name[set.size()]);
        if (declAggrNames.length == 0) {
            declaredAggregates = EMPTY_ARRAY;
            aggregates = EMPTY_ARRAY;
        } else {
            declaredAggregates = new Privilege[declAggrNames.length];
            for (int i = 0; i < declAggrNames.length; i++) {
                for (PrivilegeDefinition def : allDefs) {
                    if (def.getName().equals(declAggrNames[i])) {
                        declaredAggregates[i] = new PrivilegeImpl(def, allDefs, npResolver);
                    }
                }
            }

            Set<Privilege> aggr = new HashSet<Privilege>();
            for (Privilege decl : declaredAggregates) {
                aggr.add(decl);
                if (decl.isAggregate()) {
                    aggr.addAll(Arrays.asList(decl.getAggregatePrivileges()));
                }
            }
            aggregates = aggr.toArray(new Privilege[aggr.size()]);
        }
    }


        private PrivilegeImpl(PrivilegeDefinition definition) throws RepositoryException {
            this.definition = definition;

            Set<Name> set = definition.getDeclaredAggregateNames();
            Name[] declAggrNames = set.toArray(new Name[set.size()]);
            if (declAggrNames.length == 0) {
                declaredAggregates = EMPTY_ARRAY;
                aggregates = EMPTY_ARRAY;
            } else {
                declaredAggregates = new Privilege[declAggrNames.length];
                for (int i = 0; i < declAggrNames.length; i++) {
                    declaredAggregates[i] = getPrivilege(declAggrNames[i]);
                }

                Set<Privilege> aggr = new HashSet<Privilege>();
                for (Privilege decl : declaredAggregates) {
                    aggr.add(decl);
                    if (decl.isAggregate()) {
                        aggr.addAll(Arrays.asList(decl.getAggregatePrivileges()));
                    }
                }
                aggregates = aggr.toArray(new Privilege[aggr.size()]);
            }
        }


    public void removePolicy(String absPath, AccessControlPolicy policy) throws RepositoryException {
        checkValidNodePath(absPath);
        checkValidPolicy(policy);
        
        NodeState aclNode = getAclNode(absPath);        
        if (aclNode != null) {
            removeNode(aclNode);
        } else {
            throw new AccessControlException("No policy exist at "+absPath);
        }
    }


    public synchronized void removePolicy(String nodePath, AccessControlPolicy policy) throws AccessControlException, RepositoryException {
        checkProtectsNode(nodePath);
        checkValidPolicy(nodePath, policy);

        NodeImpl aclNode = getAclNode(nodePath);
        if (aclNode != null) {
            removeItem(aclNode);
        } else {
            throw new AccessControlException("No policy to remove at " + nodePath);
        }
    }


    private void checkValidNodePath(String absPath) throws PathNotFoundException, RepositoryException {
        if (absPath != null) {
            Path qPath = npResolver.getQPath(absPath);
            if (!qPath.isAbsolute()) {
                throw new RepositoryException("Absolute path expected. Found: " + absPath);
            }

            if (hierarchyManager.getNodeEntry(qPath).getNodeState() == null) {
                throw new PathNotFoundException(absPath);
            }
        }
    }


    protected void checkValidNodePath(String absPath) throws PathNotFoundException, RepositoryException {
        if (absPath != null) {
            Path path = resolver.getQPath(absPath);
            if (!path.isAbsolute()) {
                throw new RepositoryException("Absolute path expected. Found: " + absPath);
            }

            if (hierMgr.resolveNodePath(path) == null) {
                throw new PathNotFoundException(absPath);
            }
        }
    }


    protected void checkValidNodePath(String absPath) throws PathNotFoundException, RepositoryException {
        Path p = getPath(absPath);
        if (p != null) {
            if (!p.isAbsolute()) {
                throw new RepositoryException("Absolute path expected.");
            }
            if (hierMgr.resolveNodePath(p) == null) {
                throw new PathNotFoundException("No such node " + absPath);
            }
        }
    }


        protected void checkValidNodePath(String absPath)
                throws PathNotFoundException, RepositoryException {
            if (absPath != null) {
                Path p = getQPath(absPath);
                if (!p.isAbsolute()) {
                    throw new RepositoryException("Absolute path expected.");
                }
                if (context.getHierarchyManager().resolveNodePath(p) == null) {
                    throw new PathNotFoundException("No such node " + absPath);
                }
            }
        }


    public String[] getVersionLabels() throws RepositoryException {
        checkStatus();
        Name[] qLabels = getQLabels();
        String[] labels = new String[qLabels.length];

        for (int i = 0; i < qLabels.length; i++) {
            labels[i] = session.getNameResolver().getJCRName(qLabels[i]);
        }
        return labels;
    }


    public NodeType[] getMixinNodeTypes() throws RepositoryException {
        checkStatus();
        Name[] mixinNames = getNodeState().getMixinTypeNames();
        NodeType[] nta = new NodeType[mixinNames.length];
        for (int i = 0; i < mixinNames.length; i++) {
            nta[i] = session.getNodeTypeManager().getNodeType(mixinNames[i]);
        }
        return nta;
    }


    public boolean nodeExists(Path path) throws RepositoryException {
        try {
            // session-sanity & permissions are checked upon itemExists(ItemState)
            NodeState nodeState = hierMgr.getNodeState(path);
            return itemExists(nodeState);
        } catch (PathNotFoundException pnfe) {
            return false;
        } catch (ItemNotFoundException infe) {
            return false;
        }
    }


    public boolean hasNodeType(String name) throws RepositoryException {
        try {
            Name qname = context.getQName(name);
            return getNodeTypeRegistry().isRegistered(qname);
        } catch (NamespaceException e) {
            return false;
        } catch (NameException e) {
           throw new RepositoryException("Invalid name: " + name, e);
        }
    }


    private boolean itemExists(ItemState itemState) {
        try {
            // check sanity of session
            session.checkIsAlive();
            // return true, if ItemState is valid. Access rights are granted,
            // otherwise the state would not have been retrieved.
            return itemState.isValid();
        } catch (ItemNotFoundException infe) {
            return false;
        } catch (RepositoryException re) {
            return false;
        }
    }


    public boolean propertyExists(Path path) throws RepositoryException {
        try {
            // session-sanity & permissions are checked upon itemExists(ItemState)
            PropertyState propState = hierMgr.getPropertyState(path);
            return itemExists(propState);
        } catch (PathNotFoundException pnfe) {
            return false;
        } catch (ItemNotFoundException infe) {
            return false;
        }
    }


    public boolean hasNodeType(String name) throws RepositoryException {
        try {
            Name qName = getNamePathResolver().getQName(name);
            return hasNodeType(qName);
        } catch (NamespaceException e) {
            return false;
        } catch (NameException e) {
            return false;
        }
    }


    private boolean isExcluded(EventImpl event) {
        try {
            return excludePath != null
                && excludePath.isAncestorOf(event.getQPath());
        } catch (MalformedPathException ex) {
            log.error("Error filtering events.", ex);
            return false;
        } catch (RepositoryException ex) {
            log.error("Error filtering events.", ex);
            return false;
        }

    }


    public NodeType getNodeType(String nodeTypeName)
            throws NoSuchNodeTypeException {
        try {
            Name qName = getNamePathResolver().getQName(nodeTypeName);
            return getNodeType(qName);
        } catch (NamespaceException e) {
            throw new NoSuchNodeTypeException(nodeTypeName, e);
        } catch (NameException e) {
            throw new NoSuchNodeTypeException(nodeTypeName, e);
        }
    }


    public synchronized boolean hasChildNodes(NodeEntry parentEntry)
            throws ItemNotFoundException, RepositoryException {
        // check sanity of session
        session.checkIsAlive();

        Iterator<NodeEntry> iter = parentEntry.getNodeEntries();
        while (iter.hasNext()) {
            try {
                // check read access by accessing the nodeState (implicit validation check)
                NodeEntry entry = iter.next();
                entry.getNodeState();
                return true;
            } catch (ItemNotFoundException e) {
                // should not occur. ignore
                log.debug("Failed to access node state.", e);
            }
        }
        return false;
    }


    public synchronized boolean hasChildProperties(NodeEntry parentEntry)
            throws ItemNotFoundException, RepositoryException {
        // check sanity of session
        session.checkIsAlive();

        Iterator<PropertyEntry> iter = parentEntry.getPropertyEntries();
        while (iter.hasNext()) {
            try {
                PropertyEntry entry = iter.next();
                // check read access by accessing the propState (also implicit validation).
                entry.getPropertyState();
                return true;
            } catch (ItemNotFoundException e) {
                // should not occur. ignore
                log.debug("Failed to access node state.", e);
            }
        }
        return false;
    }


    public Property setProperty(String name, Value value, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
        checkIsWritable();
        Name propName = getQName(name);
        Property prop;
        if (hasProperty(propName)) {
            // property already exists: pass call to property
            prop = getProperty(propName);
            Value v = (type == PropertyType.UNDEFINED) ? value : ValueHelper.convert(value, type, session.getValueFactory());
            prop.setValue(v);
        } else {
            if (value == null) {
                return new StaleProperty();
            } else {
                // new property to be added
                prop = createProperty(propName, value, type);
            }
        }
        return prop;
    }


    public Property setProperty(String name, Value[] values, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
        checkIsWritable();
        Name propName = getQName(name);
        Property prop;
        if (hasProperty(propName)) {
            // property already exists: pass call to property
            prop = getProperty(propName);
            Value[] vs = (type == PropertyType.UNDEFINED) ? values : ValueHelper.convert(values, type, session.getValueFactory());
            prop.setValue(vs);
        } else {
            if (values == null) {
                // create and remove property is a nop.
                throw new ItemNotFoundException("Cannot remove a non-existing property.");
            } else {
                // new property to be added
                prop = createProperty(propName, values, type);
            }
        }
        return prop;
    }


    public Node getNode(String relPath) throws PathNotFoundException, RepositoryException {
        checkStatus();
        NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
        if (nodeEntry == null) {
            throw new PathNotFoundException(relPath);
        }
        try {
            return (Node) getItemManager().getItem(nodeEntry);
        } catch (ItemNotFoundException e) {
            throw new PathNotFoundException(relPath, e);
        }
    }


    public Property getProperty(String relPath) throws PathNotFoundException, RepositoryException {
        checkStatus();
        PropertyEntry entry = resolveRelativePropertyPath(relPath);
        if (entry == null) {
            throw new PathNotFoundException(relPath);
        }
        try {
            return (Property) getItemManager().getItem(entry);
        } catch (AccessDeniedException e) {
            throw new PathNotFoundException(relPath);
        } catch (ItemNotFoundException e) {
            throw new PathNotFoundException(relPath);
        }
    }


    public NodeIterator getNodes() throws RepositoryException {
        checkStatus();
        // NOTE: Don't use a class derived from TraversingElementVisitor to traverse
        // the child nodes because this would lead to an infinite recursion.
        try {
            return getItemManager().getChildNodes(getNodeEntry());
        } catch (ItemNotFoundException infe) {
            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
            log.debug(msg);
            throw new RepositoryException(msg, infe);
        } catch (AccessDeniedException ade) {
            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
            log.debug(msg);
            throw new RepositoryException(msg, ade);
        }
    }


    public PropertyIterator getProperties() throws RepositoryException {
        checkStatus();
        try {
            return getItemManager().getChildProperties(getNodeEntry());
        } catch (ItemNotFoundException infe) {
            String msg = "Failed to list the child properties of " + getPath();
            log.debug(msg);
            throw new RepositoryException(msg, infe);
        } catch (AccessDeniedException ade) {
            String msg = "Failed to list the child properties of " + getPath();
            log.debug(msg);
            throw new RepositoryException(msg, ade);
        }
    }


    public Item getPrimaryItem() throws ItemNotFoundException, RepositoryException {
        checkStatus();
        String name = getPrimaryNodeType().getPrimaryItemName();
        if (name == null) {
            throw new ItemNotFoundException("No primary item present on Node " + safeGetJCRPath());
        }
        if (hasProperty(name)) {
            return getProperty(name);
        } else if (hasNode(name)) {
            return getNode(name);
        } else {
            throw new ItemNotFoundException("Primary item " + name + " does not exist on Node " + safeGetJCRPath());
        }
    }


    public Item getPrimaryItem()
            throws ItemNotFoundException, RepositoryException {
        // check state of this instance
        sanityCheck();

        String name = getPrimaryNodeType().getPrimaryItemName();
        if (name == null) {
            throw new ItemNotFoundException();
        }
        if (hasProperty(name)) {
            return getProperty(name);
        } else if (hasNode(name)) {
            return getNode(name);
        } else {
            throw new ItemNotFoundException();
        }
    }


    protected Node getNode(Name nodeName, int index) throws PathNotFoundException, RepositoryException {
        checkStatus();
        try {
            NodeEntry nEntry = getNodeEntry().getNodeEntry(nodeName, index);
            if (nEntry == null) {
                throw new PathNotFoundException(LogUtil.saveGetJCRName(nodeName, session.getNameResolver()));
            }
            return (Node) getItemManager().getItem(nEntry);
        } catch (AccessDeniedException e) {
            throw new PathNotFoundException(LogUtil.saveGetJCRName(nodeName, session.getNameResolver()));
        }
    }


    protected Property getProperty(Name qName) throws PathNotFoundException, RepositoryException {
        checkStatus();
        try {
            PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName, true);
            if (pEntry == null) {
                throw new PathNotFoundException(LogUtil.saveGetJCRName(qName, session.getNameResolver()));
            }
            return (Property) getItemManager().getItem(pEntry);
        } catch (AccessDeniedException e) {
            throw new PathNotFoundException(LogUtil.saveGetJCRName(qName, session.getNameResolver()));
        }
    }


    public void copy(String srcWorkspace, String srcAbsPath, String destAbsPath) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, RepositoryException {
        session.checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
        session.checkIsAlive();

        // check workspace name
        if (getName().equals(srcWorkspace)) {
            // same as current workspace, delegate to within workspace copy method
            copy(srcAbsPath, destAbsPath);
            return;
        }

        // make sure the specified workspace is visible for the current session.
        session.checkAccessibleWorkspace(srcWorkspace);

        Path srcPath = session.getQPath(srcAbsPath);
        Path destPath = session.getQPath(destAbsPath);

        // copy (i.e. pull) subtree at srcAbsPath from srcWorkspace
        // to 'this' workspace at destAbsPath
        SessionImpl srcSession = null;
        try {
            // create session on other workspace for current subject
            // (may throw NoSuchWorkspaceException and AccessDeniedException)
            srcSession = session.switchWorkspace(srcWorkspace);
            WorkspaceImpl srcWsp = (WorkspaceImpl) srcSession.getWorkspace();

            // do cross-workspace copy
            Operation op = Copy.create(srcPath, destPath, srcWsp.getName(), srcWsp, this);
            getUpdatableItemStateManager().execute(op);
        } finally {
            if (srcSession != null) {
                // we don't need the other session anymore, logout
                srcSession.logout();
            }
        }
    }


    public void clone(String srcWorkspace, String srcAbsPath, String destAbsPath, boolean removeExisting) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, RepositoryException {
        session.checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
        session.checkIsAlive();

        // check workspace name
        if (getName().equals(srcWorkspace)) {
            // same as current workspace
            String msg = srcWorkspace + ": illegal workspace (same as current)";
            log.debug(msg);
            throw new RepositoryException(msg);
        }

        // make sure the specified workspace is visible for the current session.
        session.checkAccessibleWorkspace(srcWorkspace);

        Path srcPath = session.getQPath(srcAbsPath);
        Path destPath = session.getQPath(destAbsPath);

        // clone (i.e. pull) subtree at srcAbsPath from srcWorkspace
        // to 'this' workspace at destAbsPath

        SessionImpl srcSession = null;
        try {
            // create session on other workspace for current subject
            // (may throw NoSuchWorkspaceException and AccessDeniedException)
            srcSession = session.switchWorkspace(srcWorkspace);
            WorkspaceImpl srcWsp = (WorkspaceImpl) srcSession.getWorkspace();

            // do clone
            Operation op = Clone.create(srcPath, destPath, srcWsp.getName(), removeExisting, srcWsp, this);
            getUpdatableItemStateManager().execute(op);
        } finally {
            if (srcSession != null) {
                // we don't need the other session anymore, logout
                srcSession.logout();
            }
        }
    }


    public boolean canRemoveNode(String nodeName) {
        Name name;
        try {
            name = resolver().getQName(nodeName);
        } catch (RepositoryException e) {
            // should never get here
            log.warn("Unable to determine if there are any remove constraints for a node with name " + nodeName);
            return false;
        }
        return !ent.hasRemoveNodeConstraint(name);

    }


    public boolean canRemoveProperty(String propertyName) {
        Name name;
        try {
            name = resolver().getQName(propertyName);
        } catch (RepositoryException e) {
            // should never get here
            log.warn("Unable to determine if there are any remove constraints for a property with name " + propertyName);
            return false;
        }
        return !ent.hasRemovePropertyConstraint(name);
    }


    private static QPropertyDefinition getQPropertyDefinition(EffectiveNodeType ent,
                                                              Name name, int type,
                                                              boolean multiValued, boolean throwWhenAmbiguous)
           throws ConstraintViolationException {
        // try named property definitions first
        QPropertyDefinition[] defs = ent.getNamedQPropertyDefinitions(name);
        QPropertyDefinition match = getMatchingPropDef(defs, type, multiValued, throwWhenAmbiguous);
        if (match != null) {
            return match;
        }

        // no item with that name defined;
        // try residual property definitions
        defs = ent.getUnnamedQPropertyDefinitions();
        match = getMatchingPropDef(defs, type, multiValued, throwWhenAmbiguous);
        if (match != null) {
            return match;
        }

        // no applicable definition found
        throw new ConstraintViolationException("no matching property definition found for " + name);
    }


    private static QPropertyDefinition getQPropertyDefinition(EffectiveNodeType ent,
                                                              Name name, int type)
            throws ConstraintViolationException {
        // try named property definitions first
        QPropertyDefinition[] defs = ent.getNamedQPropertyDefinitions(name);
        QPropertyDefinition match = getMatchingPropDef(defs, type);
        if (match != null) {
            return match;
        }

        // no item with that name defined;
        // try residual property definitions
        defs = ent.getUnnamedQPropertyDefinitions();
        match = getMatchingPropDef(defs, type);
        if (match != null) {
            return match;
        }

        // no applicable definition found
        throw new ConstraintViolationException("no matching property definition found for " + name);
    }


    private static QPropertyDefinition getMatchingPropDef(QPropertyDefinition[] defs, int type) {
        QPropertyDefinition match = null;
        for (int i = 0; i < defs.length; i++) {
            QItemDefinition qDef = defs[i];
            if (!qDef.definesNode()) {
                QPropertyDefinition pd = (QPropertyDefinition) qDef;
                int reqType = pd.getRequiredType();
                // match type
                if (reqType == PropertyType.UNDEFINED
                        || type == PropertyType.UNDEFINED
                        || reqType == type) {
                    if (match == null) {
                        match = pd;
                    } else {
                        // check if this definition is a better match than
                        // the one we've already got
                        if (match.getRequiredType() != pd.getRequiredType()) {
                            if (match.getRequiredType() == PropertyType.UNDEFINED) {
                                // found better match
                                match = pd;
                            }
                        } else {
                            if (match.isMultiple() && !pd.isMultiple()) {
                                // found better match
                                match = pd;
                            }
                        }
                    }
                    if (match.getRequiredType() != PropertyType.UNDEFINED
                            && !match.isMultiple()) {
                        // found best possible match, get outta here
                        return match;
                    }
                }
            }
        }
        return match;
    }


    private QPropertyDefinition getMatchingPropDef(QPropertyDefinition[] defs, int type) {
        QPropertyDefinition match = null;
        for (QPropertyDefinition pd : defs) {
            int reqType = pd.getRequiredType();
            // match type
            if (reqType == PropertyType.UNDEFINED
                    || type == PropertyType.UNDEFINED
                    || reqType == type) {
                if (match == null) {
                    match = pd;
                } else {
                    // check if this definition is a better match than
                    // the one we've already got
                    if (match.getRequiredType() != pd.getRequiredType()) {
                        if (match.getRequiredType() == PropertyType.UNDEFINED) {
                            // found better match
                            match = pd;
                        }
                    } else {
                        if (match.isMultiple() && !pd.isMultiple()) {
                            // found better match
                            match = pd;
                        }
                    }
                }
                if (match.getRequiredType() != PropertyType.UNDEFINED
                        && !match.isMultiple()) {
                    // found best possible match, get outta here
                    return match;
                }
            }
        }
        return match;
    }


    public QNodeDefinition[] getAllQNodeDefinitions() {
        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size() + unnamedItemDefs.size());
        for (QItemDefinition qDef : unnamedItemDefs) {
            if (qDef.definesNode()) {
                defs.add(qDef);
            }
        }

        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (qDef.definesNode()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getAllQPropertyDefinitions() {
        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size() + unnamedItemDefs.size());
        for (QItemDefinition qDef : unnamedItemDefs) {
            if (!qDef.definesNode()) {
                defs.add(qDef);
            }
        }
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (!qDef.definesNode()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getAllNodeDefs() {
        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(namedItemDefs.size() + unnamedItemDefs.size());
        for (QItemDefinition def : unnamedItemDefs) {
            if (def.definesNode()) {
                defs.add((QNodeDefinition) def);
            }
        }
        for (List<QItemDefinition> list: namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (def.definesNode()) {
                    defs.add((QNodeDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getAllPropDefs() {
        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(namedItemDefs.size() + unnamedItemDefs.size());
        for (QItemDefinition def : unnamedItemDefs) {
            if (!def.definesNode()) {
                defs.add((QPropertyDefinition) def);
            }
        }
        for (List<QItemDefinition> list: namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (!def.definesNode()) {
                    defs.add((QPropertyDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getAutoCreateQNodeDefinitions() {
        // since auto-create items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (qDef.definesNode() && qDef.isAutoCreated()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getUnnamedPropDefs() {
        if (unnamedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(unnamedItemDefs.size());
        for (QItemDefinition def : unnamedItemDefs) {
            if (!def.definesNode()) {
                defs.add((QPropertyDefinition) def);
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getUnnamedQNodeDefinitions() {
        if (unnamedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(unnamedItemDefs.size());
        for (QItemDefinition qDef : unnamedItemDefs) {
            if (qDef.definesNode()) {
                defs.add(qDef);
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QNodeDefinition[] getAutoCreateNodeDefs() {
        // since auto-create items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (def.definesNode() && def.isAutoCreated()) {
                    defs.add((QNodeDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getNamedPropDefs() {
        if (namedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (!def.definesNode()) {
                    defs.add((QPropertyDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getAutoCreatePropDefs() {
        // since auto-create items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (!def.definesNode() && def.isAutoCreated()) {
                    defs.add((QPropertyDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getUnnamedNodeDefs() {
        if (unnamedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(unnamedItemDefs.size());
        for (QItemDefinition def : unnamedItemDefs) {
            if (def.definesNode()) {
                defs.add((QNodeDefinition) def);
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QNodeDefinition[] getNamedQNodeDefinitions(Name name) {
        List<QItemDefinition> list = namedItemDefs.get(name);
        if (list == null || list.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(list.size());
        for (QItemDefinition qDef : list) {
            if (qDef.definesNode()) {
                defs.add(qDef);
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getMandatoryPropDefs() {
        // since mandatory items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (!def.definesNode() && def.isMandatory()) {
                    defs.add((QPropertyDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getMandatoryNodeDefs() {
        // since mandatory items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (def.definesNode() && def.isMandatory()) {
                    defs.add((QNodeDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QNodeDefinition[] getNamedNodeDefs() {
        if (namedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition def : list) {
                if (def.definesNode()) {
                    defs.add((QNodeDefinition) def);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getNamedQPropertyDefinitions(Name name) {
        List<QItemDefinition> list = namedItemDefs.get(name);
        if (list == null || list.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(list.size());
        for (QItemDefinition qDef : list) {
            if (!qDef.definesNode()) {
                defs.add(qDef);
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getAutoCreateQPropertyDefinitions() {
        // since auto-create items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (!qDef.definesNode() && qDef.isAutoCreated()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getMandatoryQPropertyDefinitions() {
        // since mandatory items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (!qDef.definesNode() && qDef.isMandatory()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    private QItemDefinition[] getNamedItemDefs() {
        if (namedItemDefs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            defs.addAll(list);
        }
        if (defs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QItemDefinition[defs.size()]);
    }


    public QNodeDefinition[] getMandatoryQNodeDefinitions() {
        // since mandatory items must have a name,
        // we're only searching the named item definitions
        if (namedItemDefs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> list : namedItemDefs.values()) {
            for (QItemDefinition qDef : list) {
                if (qDef.definesNode() && qDef.isMandatory()) {
                    defs.add(qDef);
                }
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QItemDefinition[] getNamedItemDefs() {
        if (namedItemDefs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());
        for (List<QItemDefinition> itemDefs : namedItemDefs.values()) {
            defs.addAll(itemDefs);
        }
        if (defs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QItemDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getUnnamedQPropertyDefinitions() {
        if (unnamedItemDefs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(unnamedItemDefs.size());
        for (QItemDefinition qDef : unnamedItemDefs) {
            if (!qDef.definesNode()) {
                defs.add(qDef);
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QPropertyDefinition[] getNamedPropDefs(Name name) {
        List<QItemDefinition> list = namedItemDefs.get(name);
        if (list == null || list.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        ArrayList<QPropertyDefinition> defs = new ArrayList<QPropertyDefinition>(list.size());
        for (QItemDefinition def : list) {
            if (!def.definesNode()) {
                defs.add((QPropertyDefinition) def);
            }
        }
        if (defs.size() == 0) {
            return QPropertyDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QPropertyDefinition[defs.size()]);
    }


    public QNodeDefinition[] getNamedNodeDefs(Name name) {
        List<QItemDefinition> list = namedItemDefs.get(name);
        if (list == null || list.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        ArrayList<QNodeDefinition> defs = new ArrayList<QNodeDefinition>(list.size());
        for (QItemDefinition def : list) {
            if (def.definesNode()) {
                defs.add((QNodeDefinition) def);
            }
        }
        if (defs.size() == 0) {
            return QNodeDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QNodeDefinition[defs.size()]);
    }


    public QItemDefinition[] getAllItemDefs() {
        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size() + unnamedItemDefs.size());
        for (List<QItemDefinition> itemDefs : namedItemDefs.values()) {
            defs.addAll(itemDefs);
        }
        defs.addAll(unnamedItemDefs);
        if (defs.size() == 0) {
            return QItemDefinition.EMPTY_ARRAY;
        }
        return defs.toArray(new QItemDefinition[defs.size()]);
    }


    public NodeTypeImpl getNodeType(Name name) throws NoSuchNodeTypeException {
        synchronized (ntCache) {
            NodeTypeImpl nt = ntCache.get(name);
            if (nt == null) {
                EffectiveNodeType ent = entProvider().getEffectiveNodeType(name);
                QNodeTypeDefinition def = ntReg.getNodeTypeDefinition(name);
                nt = new NodeTypeImpl(ent, def, this, mgrProvider);
                ntCache.put(name, nt);
            }
            return nt;
        }
    }


    public NodeTypeImpl getNodeType(Name name) throws NoSuchNodeTypeException {
        synchronized (ntCache) {
            NodeTypeImpl nt = ntCache.get(name);
            if (nt == null) {
                NodeTypeRegistry registry = context.getNodeTypeRegistry();
                EffectiveNodeType ent = registry.getEffectiveNodeType(name);
                QNodeTypeDefinition def = registry.getNodeTypeDef(name);
                nt = new NodeTypeImpl(
                        ent, def, this, context,
                        context.getValueFactory(), context.getDataStore());
                ntCache.put(name, nt);
            }
            return nt;
        }
    }


    public NodeDefinition getNodeDefinition(QNodeDefinition def) {
        synchronized (ndCache) {
            NodeDefinition ndi = ndCache.get(def);
            if (ndi == null) {
                ndi = new NodeDefinitionImpl(def, this, getNamePathResolver());
                ndCache.put(def, ndi);
            }
            return ndi;
        }
    }


    public RecordProducer getProducer(String identifier) {
        synchronized (producers) {
            RecordProducer producer = producers.get(identifier);
            if (producer == null) {
                producer = createProducer(identifier);
                producers.put(identifier, producer);
            }
            return producer;
        }
    }


    public NodeDefinitionImpl getNodeDefinition(QNodeDefinition def) {
        synchronized (ndCache) {
            NodeDefinitionImpl ndi = ndCache.get(def);
            if (ndi == null) {
                ndi = new NodeDefinitionImpl(def, this, context);
                ndCache.put(def, ndi);
            }
            return ndi;
        }
    }


    public Object getObjectInstance(
            Object obj, Name name, Context nameCtx, Hashtable environment)
            throws RepositoryException {
        synchronized (cache) {
            Object instance = cache.get(obj);
            if (instance == null && obj instanceof Reference) {
                instance = new BindableRepository((Reference) obj);
                cache.put(obj, instance);
            }
            return instance;
        }
    }


    private SortedMap<Long, Long> getSkipMap() {
        synchronized (REVISION_SKIP_MAPS) {
            SortedMap<Long, Long> map = REVISION_SKIP_MAPS.get(journal);
            if (map == null) {
                map = new TreeMap<Long, Long>();
                REVISION_SKIP_MAPS.put(journal, map);
            }
            return map;
        }
    }


    public DataSource getDataSource(String logicalName) throws RepositoryException {
        synchronized (lock) {
            sanityCheck();
            DataSource ds = nameToDataSource.get(logicalName);
            if (ds == null) {
                throw new RepositoryException("DataSource with logicalName " + logicalName
                        + " has not been configured");
            }
            return ds;
        }
    }


    public Directory getDirectory(String name) {
        synchronized (directories) {
            Directory dir = directories.get(name);
            if (dir == null) {
                dir = new RAMDirectory();
                directories.put(name, dir);
            }
            return dir;
        }
    }


    public PropertyDefinition getPropertyDefinition(QPropertyDefinition def) {
        synchronized (pdCache) {
            PropertyDefinition pdi = pdCache.get(def);
            if (pdi == null) {
                pdi = new PropertyDefinitionImpl(def, this, getNamePathResolver(), valueFactory);
                pdCache.put(def, pdi);
            }
            return pdi;
        }
    }


    public PropertyDefinitionImpl getPropertyDefinition(QPropertyDefinition def) {
        synchronized (pdCache) {
            PropertyDefinitionImpl pdi = pdCache.get(def);
            if (pdi == null) {
                pdi = new PropertyDefinitionImpl(
                        def, this, context, context.getValueFactory());
                pdCache.put(def, pdi);
            }
            return pdi;
        }
    }


    void store(IndexReader reader, String field, String prefix, ValueIndex value) {
        synchronized (cache) {
            Map<Key, ValueIndex> readerCache = cache.get(reader);
            if (readerCache == null) {
                readerCache = new HashMap<Key, ValueIndex>();
                cache.put(reader, readerCache);
            }
            readerCache.put(new Key(field, prefix), value);
        }
    }


    public String getDataBaseType(String logicalName) throws RepositoryException {
        synchronized (lock) {
            sanityCheck();
            DataSourceDefinition def = nameToDataSourceDef.get(logicalName);
            if (def == null) {
                throw new RepositoryException("DataSource with logicalName " + logicalName
                        + " has not been configured");
            }
            return def.getDbType();
        }
    }


    public void nodeTypeReRegistered(Name ntName) {
        // flush all affected cache entries
        ntCache.remove(ntName);
        try {
            String name = getNamePathResolver().getJCRName(ntName);
            synchronized (pdCache) {
                Iterator<PropertyDefinition> iter = pdCache.values().iterator();
                while (iter.hasNext()) {
                    PropertyDefinition pd = iter.next();
                    if (name.equals(pd.getDeclaringNodeType().getName())) {
                        iter.remove();
                    }
                }
            }
            synchronized (ndCache) {
                Iterator<NodeDefinition> iter = ndCache.values().iterator();
                while (iter.hasNext()) {
                    NodeDefinition nd = iter.next();
                    if (name.equals(nd.getDeclaringNodeType().getName())) {
                        iter.remove();
                    }
                }
            }
        } catch (NamespaceException e) {
            log.warn(e.getMessage() + " -> clear definition cache." );
            synchronized (pdCache) {
                pdCache.clear();
            }
            synchronized (ndCache) {
                ndCache.clear();
            }
        }
    }


    public void nodeTypeUnregistered(Name ntName) {
        // flush all affected cache entries
        ntCache.remove(ntName);
        try {
            String name = getNamePathResolver().getJCRName(ntName);
            synchronized (pdCache) {
                Iterator<PropertyDefinition> iter = pdCache.values().iterator();
                while (iter.hasNext()) {
                    PropertyDefinition pd = iter.next();
                    if (name.equals(pd.getDeclaringNodeType().getName())) {
                        iter.remove();
                    }
                }
            }
            synchronized (ndCache) {
                Iterator<NodeDefinition> iter = ndCache.values().iterator();
                while (iter.hasNext()) {
                    NodeDefinition nd = iter.next();
                    if (name.equals(nd.getDeclaringNodeType().getName())) {
                        iter.remove();
                    }
                }
            }
        } catch (NamespaceException e) {
            log.warn(e.getMessage() + " -> clear definition cache." );
            synchronized (pdCache) {
                pdCache.clear();
            }
            synchronized (ndCache) {
                ndCache.clear();
            }
        }
    }


    public NodeTypeIterator getPrimaryNodeTypes() throws RepositoryException {
        Name[] ntNames = ntReg.getRegisteredNodeTypes();
        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
        for (Name ntName : ntNames) {
            NodeType nt = getNodeType(ntName);
            if (!nt.isMixin()) {
                list.add(nt);
            }
        }
        return new NodeTypeIteratorAdapter(list);
    }


    public NodeTypeIterator getMixinNodeTypes() throws RepositoryException {
        Name[] ntNames = ntReg.getRegisteredNodeTypes();
        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
        for (Name ntName : ntNames) {
            NodeType nt = getNodeType(ntName);
            if (nt.isMixin()) {
                list.add(nt);
            }
        }
        return new NodeTypeIteratorAdapter(list);
    }


    public NodeTypeIterator getMixinNodeTypes() throws RepositoryException {
        Name[] ntNames = context.getNodeTypeRegistry().getRegisteredNodeTypes();
        Arrays.sort(ntNames);
        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
        for (Name ntName : ntNames) {
            NodeType nt = getNodeType(ntName);
            if (nt.isMixin()) {
                list.add(nt);
            }
        }
        return new NodeTypeIteratorAdapter(list);
    }


    public NodeTypeIterator getPrimaryNodeTypes() throws RepositoryException {
        Name[] ntNames = context.getNodeTypeRegistry().getRegisteredNodeTypes();
        Arrays.sort(ntNames);
        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
        for (Name ntName : ntNames) {
            NodeType nt = getNodeType(ntName);
            if (!nt.isMixin()) {
                list.add(nt);
            }
        }
        return new NodeTypeIteratorAdapter(list);
    }


    private void checkForCircularInheritance(Name[] supertypes, Stack<Name> inheritanceChain, Map<Name, QNodeTypeDefinition> ntdMap)
        throws InvalidNodeTypeDefinitionException, RepositoryException {
        for (int i = 0; i < supertypes.length; i++) {
            Name stName = supertypes[i];
            int pos = inheritanceChain.lastIndexOf(stName);
            if (pos >= 0) {
                StringBuffer buf = new StringBuffer();
                for (int j = 0; j < inheritanceChain.size(); j++) {
                    if (j == pos) {
                        buf.append("--> ");
                    }
                    buf.append(inheritanceChain.get(j));
                    buf.append(" extends ");
                }
                buf.append("--> ");
                buf.append(stName);
                throw new InvalidNodeTypeDefinitionException("circular inheritance detected: " + buf.toString());
            }

            if (ntdMap.containsKey(stName)) {
                Name[] sta = ntdMap.get(stName).getSupertypes();
                if (sta.length > 0) {
                    // check recursively
                    inheritanceChain.push(stName);
                    checkForCircularInheritance(sta, inheritanceChain, ntdMap);
                    inheritanceChain.pop();
                }
            } else {
                throw new InvalidNodeTypeDefinitionException("Unknown supertype: " + stName);
            }
        }
    }


    static void checkForCircularInheritance(Name[] supertypes,
                                            Stack<Name> inheritanceChain,
                                            Map<Name, QNodeTypeDefinition> ntDefCache)
            throws InvalidNodeTypeDefException, RepositoryException {
        for (Name nt : supertypes) {
            int pos = inheritanceChain.lastIndexOf(nt);
            if (pos >= 0) {
                StringBuilder buf = new StringBuilder();
                for (int j = 0; j < inheritanceChain.size(); j++) {
                    if (j == pos) {
                        buf.append("--> ");
                    }
                    buf.append(inheritanceChain.get(j));
                    buf.append(" extends ");
                }
                buf.append("--> ");
                buf.append(nt);
                throw new InvalidNodeTypeDefException("circular inheritance detected: " + buf.toString());
            }

            try {
                QNodeTypeDefinition ntd = ntDefCache.get(nt);
                Name[] sta = ntd.getSupertypes();
                if (sta.length > 0) {
                    // check recursively
                    inheritanceChain.push(nt);
                    checkForCircularInheritance(sta, inheritanceChain, ntDefCache);
                    inheritanceChain.pop();
                }
            } catch (NoSuchNodeTypeException nsnte) {
                String msg = "unknown supertype: " + nt;
                log.debug(msg);
                throw new InvalidNodeTypeDefException(msg, nsnte);
            }
        }
    }


    private EffectiveNodeType getEffectiveNodeType(Name ntName,
                                                   EffectiveNodeTypeCache entCache,
                                                   Map<Name, QNodeTypeDefinition> ntdCache)
        throws NoSuchNodeTypeException {
        // 1. check if effective node type has already been built
        EffectiveNodeTypeCache.Key key = entCache.getKey(new Name[]{ntName});
        EffectiveNodeType ent = entCache.get(key);
        if (ent != null) {
            return ent;
        }

        // 2. make sure we've got the definition of the specified node type
        QNodeTypeDefinition ntd = ntdCache.get(ntName);
        if (ntd == null) {
            throw new NoSuchNodeTypeException(ntName.toString());
        }

        // 3. build effective node type
        synchronized (entCache) {
            try {
                ent = getEffectiveNodeType(ntd, ntdCache);
                // store new effective node type
                entCache.put(ent);
                return ent;
            } catch (ConstraintViolationException e) {
                // should never get here as all known node types should be valid!
                String msg = "Internal error: encountered invalid registered node type " + ntName;
                log.debug(msg);
                throw new NoSuchNodeTypeException(msg, e);
            }
        }
    }


    static EffectiveNodeType getEffectiveNodeType(Name ntName,
                                                  EffectiveNodeTypeCache entCache,
                                                  Map<Name, QNodeTypeDefinition> ntdCache)
            throws NoSuchNodeTypeException {
        // 1. check if effective node type has already been built
        EffectiveNodeTypeCache.Key key = entCache.getKey(new Name[]{ntName});
        EffectiveNodeType ent = entCache.get(key);
        if (ent != null) {
            return ent;
        }

        // 2. make sure we've got the definition of the specified node type
        QNodeTypeDefinition ntd = ntdCache.get(ntName);
        if (ntd == null) {
            throw new NoSuchNodeTypeException(ntName.toString());
        }

        // 3. build effective node type
        synchronized (entCache) {
            try {
                ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
                // store new effective node type
                entCache.put(ent);
                return ent;
            } catch (NodeTypeConflictException ntce) {
                // should never get here as all known node types should be valid!
                String msg = "internal error: encountered invalid registered node type " + ntName;
                log.debug(msg);
                throw new NoSuchNodeTypeException(msg, ntce);
            }
        }
    }


    private EffectiveNodeType getEffectiveNodeType(Name[] ntNames,
                                                   EffectiveNodeTypeCache entCache,
                                                   Map<Name, QNodeTypeDefinition> ntdCache)
        throws ConstraintViolationException, NoSuchNodeTypeException {

        EffectiveNodeTypeCache.Key key = entCache.getKey(ntNames);
        // 1. check if aggregate has already been built
        if (entCache.contains(key)) {
            return entCache.get(key);
        }

        // 2. make sure we've got the definitions of the specified node types
        for (Name ntName : ntNames) {
            if (!ntdCache.containsKey(ntName)) {
                throw new NoSuchNodeTypeException(ntName.toString());
            }
        }

        // 3. build aggregate
        EffectiveNodeTypeCache.Key requested = key;
        EffectiveNodeTypeImpl result = null;
        synchronized (entCache) {
            // build list of 'best' existing sub-aggregates
            while (key.getNames().length > 0) {
                // find the (sub) key that matches the current key the best
                EffectiveNodeTypeCache.Key subKey = entCache.findBest(key);
                if (subKey != null) {
                    EffectiveNodeTypeImpl ent = (EffectiveNodeTypeImpl) entCache.get(subKey);
                    if (result == null) {
                        result = ent;
                    } else {
                        result = result.merge(ent);
                        // store intermediate result
                        entCache.put(result);
                    }
                    // subtract the result from the temporary key
                    key = key.subtract(subKey);
                } else {
                    /**
                     * no matching sub-aggregates found:
                     * build aggregate of remaining node types through iteration
                     */
                    for (Name remainder : key.getNames()) {
                        QNodeTypeDefinition ntd = ntdCache.get(remainder);
                        EffectiveNodeType ent = getEffectiveNodeType(ntd, ntdCache);
                        // store new effective node type
                        entCache.put(ent);
                        if (result == null) {
                            result = (EffectiveNodeTypeImpl) ent;
                        } else {
                            result = result.merge((EffectiveNodeTypeImpl) ent);
                            // store intermediate result (sub-aggregate)
                            entCache.put(result);
                        }
                    }
                    break;
                }
            }
        }
        // also put the requested key, since the merge could have removed some
        // the redundant nodetypes
        if (!entCache.contains(requested)) {
            entCache.put(requested, result);
        }
        // we're done
        return result;
    }


    static EffectiveNodeType getEffectiveNodeType(Name[] ntNames,
                                                  EffectiveNodeTypeCache entCache,
                                                  Map<Name, QNodeTypeDefinition> ntdCache)
            throws NodeTypeConflictException, NoSuchNodeTypeException {

        EffectiveNodeTypeCache.Key key = entCache.getKey(ntNames);

        // 1. check if aggregate has already been built
        if (entCache.contains(key)) {
            return entCache.get(key);
        }

        // 2. make sure we've got the definitions of the specified node types
        for (Name ntName : ntNames) {
            if (!ntdCache.containsKey(ntName)) {
                throw new NoSuchNodeTypeException(ntName.toString());
            }
        }

        // 3. build aggregate
        EffectiveNodeTypeCache.Key requested = key;
        EffectiveNodeType result = null;
        synchronized (entCache) {
            // build list of 'best' existing sub-aggregates
            while (key.getNames().length > 0) {
                // find the (sub) key that matches the current key the best
                EffectiveNodeTypeCache.Key subKey = entCache.findBest(key);
                if (subKey != null) {
                    EffectiveNodeType ent = entCache.get(subKey);
                    if (result == null) {
                        result = ent;
                    } else {
                        result = result.merge(ent);
                        // store intermediate result
                        entCache.put(result);
                    }
                    // subtract the result from the temporary key
                    key = key.subtract(subKey);
                } else {
                    /**
                     * no matching sub-aggregates found:
                     * build aggregate of remaining node types through iteration
                     */
                    Name[] remainder = key.getNames();
                    for (Name aRemainder : remainder) {
                        QNodeTypeDefinition ntd = ntdCache.get(aRemainder);
                        EffectiveNodeType ent =
                                EffectiveNodeType.create(ntd, entCache, ntdCache);
                        // store new effective node type
                        entCache.put(ent);
                        if (result == null) {
                            result = ent;
                        } else {
                            result = result.merge(ent);
                            // store intermediate result (sub-aggregate)
                            entCache.put(result);
                        }
                    }
                    break;
                }
            }
        }
        // also put the requested key, since the merge could have removed some
        // the redundant nodetypes
        if (!entCache.contains(requested)) {
            entCache.put(requested, result);
        }
        // we're done
        return result;
    }


        private Set<Name> getDependentNodeTypes(Name nodeTypeName) throws NoSuchNodeTypeException {
            if (!nodetypeDefinitions.containsKey(nodeTypeName)) {
                throw new NoSuchNodeTypeException(nodeTypeName.toString());
            }
            // get names of those node types that have dependencies on the
            // node type with the given nodeTypeName.
            HashSet<Name> names = new HashSet<Name>();
            for (QNodeTypeDefinition ntd : getValues()) {
                if (ntd.getDependencies().contains(nodeTypeName)) {
                    names.add(ntd.getName());
                }
            }
            return names;
        }


    public Set<Name> getDependentNodeTypes(Name nodeTypeName)
            throws NoSuchNodeTypeException {
        if (!registeredNTDefs.containsKey(nodeTypeName)) {
            throw new NoSuchNodeTypeException(nodeTypeName.toString());
        }

        /**
         * collect names of those node types that have dependencies on the given
         * node type
         */
        HashSet<Name> names = new HashSet<Name>();
        for (QNodeTypeDefinition ntd : registeredNTDefs.values()) {
            if (ntd.getDependencies().contains(nodeTypeName)) {
                names.add(ntd.getName());
            }
        }
        return names;
    }


    public Key findBest(Key key) {
        // quick check for already cached key
        if (contains(key)) {
            return key;
        }
        for (Key k : sortedKeys) {
            if (key.contains(k)) {
                return k;
            }
        }
        return null;
    }


    public Key findBest(Key key) {
        // quick check for already cached key
        if (contains(key)) {
            return key;
        }
        // clone TreeSet first to prevent ConcurrentModificationException
        TreeSet<Key> keys = (TreeSet<Key>) sortedKeys.clone();
        Iterator<Key> iter = keys.iterator();
        while (iter.hasNext()) {
            Key k = iter.next();
            if (key.contains(k)) {
                return k;
            }
        }
        return null;
    }


    public Key findBest(Key key) {
        // quick check for already cached key
        if (contains(key)) {
            return key;
        }
        Iterator<Key> iter = sortedKeys.iterator();
        while (iter.hasNext()) {
            Key k = iter.next();
            // check if the existing aggregate is a 'subset' of the one we're
            // looking for
            if (key.contains(k)) {
                return k;
            }
        }
        return null;
    }


    private int getBitNumber(Name name) {
        Integer i = nameIndex.get(name);
        if (i == null) {
            synchronized (nameIndex) {
                i = nameIndex.get(name);
                if (i == null) {
                    int idx = nameIndex.size();
                    i = idx;
                    nameIndex.put(name, i);
                    if (idx >= names.length) {
                        Name[] newNames = new Name[names.length*2];
                        System.arraycopy(names, 0, newNames, 0, names.length);
                        names = newNames;
                    }
                    names[idx] = name;
                }
            }
        }
        return i;
    }


    private int getBitNumber(Name name) {
        Integer i = (Integer) nameIndex.get(name);
        if (i == null) {
            synchronized (nameIndex) {
                i = (Integer) nameIndex.get(name);
                if (i == null) {
                    int idx = nameIndex.size();
                    i = new Integer(idx);
                    nameIndex.put(name, i);
                    if (idx >= names.length) {
                        Name[] newNames = new Name[names.length * 2];
                        System.arraycopy(names, 0, newNames, 0, names.length);
                        names = newNames;
                    }
                    names[idx] = name;
                }
            }
        }
        return i.intValue();
    }


        public BitsetKey(Name[] names, int maxBit) {
            this.names = names;
            bits = new long[maxBit/BPW+1];

            for (int i=0; i<names.length; i++) {
                int n = getBitNumber(names[i]);
                bits[n/BPW] |= OR_MASK[n%BPW];
            }
            hashCode = calcHashCode();
        }


        public BitSetKey(Name[] names, int maxBit) {
            this.names = names;
            bits = new long[maxBit / BPW + 1];

            for (int i = 0; i < names.length; i++) {
                int n = getBitNumber(names[i]);
                bits[n / BPW] |= OR_MASK[n % BPW];
            }
            hashCode = calcHashCode();
        }


        private BitsetKey(long[] bits, int numBits) {
            this.bits = bits;
            names = new Name[numBits];
            int i = nextSetBit(0);
            int j=0;
            while (i >= 0) {
                names[j++] = BitsetENTCacheImpl.this.getName(i);
                i = nextSetBit(i+1);
            }
            hashCode = calcHashCode();
        }


        private BitSetKey(long[] bits, int numBits) {
            this.bits = bits;
            names = new Name[numBits];
            int i = nextSetBit(0);
            int j = 0;
            while (i >= 0) {
                names[j++] = BitSetENTCacheImpl.this.getName(i);
                i = nextSetBit(i + 1);
            }
            hashCode = calcHashCode();
        }


        private int nextSetBit(int fromIndex) {
            int addr = fromIndex/BPW;
            int off = fromIndex%BPW;
            while (addr < bits.length) {
                if (bits[addr] != 0) {
                    while (off < BPW) {
                        if ((bits[addr] & OR_MASK[off]) != 0) {
                            return addr * BPW + off;
                        }
                        off++;
                    }
                    off=0;
                }
                addr++;
            }
            return -1;
        }


        private int nextSetBit(int fromIndex) {
            int addr = fromIndex / BPW;
            int off = fromIndex % BPW;
            while (addr < bits.length) {
                if (bits[addr] != 0) {
                    while (off < BPW) {
                        if ((bits[addr] & OR_MASK[off]) != 0) {
                            return addr * BPW + off;
                        }
                        off++;
                    }
                    off = 0;
                }
                addr++;
            }
            return -1;
        }


        private int calcHashCode() {
            long h = 1234;
            int addr = bits.length -1;
            while (addr >=0 && bits[addr] == 0) {
                addr--;
            }
            while (addr >=0) {
                h ^= bits[addr] * (addr + 1);
                addr--;
            }
            return (int)((h >> 32) ^ h);
        }


        private int calcHashCode() {
            long h = 1234;
            int addr = bits.length - 1;
            while (addr >= 0 && bits[addr] == 0) {
                addr--;
            }
            while (addr >= 0) {
                h ^= bits[addr] * (addr + 1);
                addr--;
            }
            return (int) ((h >> 32) ^ h);
        }


        public boolean contains(Key otherKey) {
            /*
             * 0 - 0 => 0
             * 0 - 1 => 1
             * 1 - 0 => 0
             * 1 - 1 => 0
             * !a and b
             */
            BitsetKey other = (BitsetKey) otherKey;
            int len = Math.max(bits.length, other.bits.length);
            for (int i=0; i<len; i++) {
                long w1 = i < bits.length ? bits[i] : 0;
                long w2 = i < other.bits.length ? other.bits[i] : 0;
                long r = ~w1 & w2;
                if (r != 0) {
                    return false;
                }
            }
            return true;
        }


        public boolean contains(Key otherKey) {
            /*
             * 0 - 0 => 0
             * 0 - 1 => 1
             * 1 - 0 => 0
             * 1 - 1 => 0
             * !a and b
             */
            BitSetKey other = (BitSetKey) otherKey;
            int len = Math.max(bits.length, other.bits.length);
            for (int i = 0; i < len; i++) {
                long w1 = i < bits.length ? bits[i] : 0;
                long w2 = i < other.bits.length ? other.bits[i] : 0;
                long r = ~w1 & w2;
                if (r != 0) {
                    return false;
                }
            }
            return true;
        }


        public Key subtract(Key otherKey) {
            /*
             * 0 - 0 => 0
             * 0 - 1 => 0
             * 1 - 0 => 1
             * 1 - 1 => 0
             * a and !b
             */
            BitsetKey other = (BitsetKey) otherKey;
            int len = Math.max(bits.length, other.bits.length);
            long[] newBits = new long[len];
            int numBits = 0;
            for (int i=0; i<len; i++) {
                long w1 = i < bits.length ? bits[i] : 0;
                long w2 = i < other.bits.length ? other.bits[i] : 0;
                newBits[i] = w1 & ~w2;
                numBits += bitCount(newBits[i]);
            }
            return new BitsetKey(newBits, numBits);
        }


        public Key subtract(Key otherKey) {
            /*
             * 0 - 0 => 0
             * 0 - 1 => 0
             * 1 - 0 => 1
             * 1 - 1 => 0
             * a and !b
             */
            BitSetKey other = (BitSetKey) otherKey;
            int len = Math.max(bits.length, other.bits.length);
            long[] newBits = new long[len];
            int numBits = 0;
            for (int i = 0; i < len; i++) {
                long w1 = i < bits.length ? bits[i] : 0;
                long w2 = i < other.bits.length ? other.bits[i] : 0;
                newBits[i] = w1 & ~w2;
                numBits += bitCount(newBits[i]);
            }
            return new BitSetKey(newBits, numBits);
        }


        public int compareTo(Key other) {
            BitsetKey o = (BitsetKey) other;
            int res = o.names.length - names.length;
            if (res == 0) {
                int adr = Math.max(bits.length, o.bits.length) - 1;
                while (adr >= 0) {
                    long w1 = adr<bits.length ? bits[adr] : 0;
                    long w2 = adr<o.bits.length ? o.bits[adr] : 0;
                    if (w1 != w2) {
                        // some signed arithmetic here
                        long h1 = w1 >>> 32;
                        long h2 = w2 >>> 32;
                        if (h1 == h2) {
                            h1 = w1 & 0x0ffffffffL;
                            h2 = w2 & 0x0ffffffffL;
                        }
                        return Long.signum(h2 - h1);
                    }
                    adr--;
                }
            }
            return res;
        }


        public int compareTo(Key other) {
            BitSetKey o = (BitSetKey) other;
            int res = o.names.length - names.length;
            if (res == 0) {
                int adr = Math.max(bits.length, o.bits.length) - 1;
                while (adr >= 0) {
                    long w1 = adr < bits.length ? bits[adr] : 0;
                    long w2 = adr < o.bits.length ? o.bits[adr] : 0;
                    if (w1 != w2) {
                        // some signed arithmetic here
                        long h1 = w1 >>> 32;
                        long h2 = w2 >>> 32;
                        if (h1 == h2) {
                            h1 = w1 & 0x0ffffffffL;
                            h2 = w2 & 0x0ffffffffL;
                        }
                        return Long.signum(h2 - h1);
                    }
                    adr--;
                }
            }
            return res;
        }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof BitsetKey) {
                BitsetKey o = (BitsetKey) obj;
                if (names.length != o.names.length) {
                    return false;
                }
                int adr = Math.max(bits.length, o.bits.length) - 1;
                while (adr >= 0) {
                    long w1 = adr<bits.length ? bits[adr] : 0;
                    long w2 = adr<o.bits.length ? o.bits[adr] : 0;
                    if (w1 != w2) {
                        return false;
                    }
                    adr--;
                }
                return true;
            }
            return false;
        }


        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj instanceof BitSetKey) {
                BitSetKey o = (BitSetKey) obj;
                if (names.length != o.names.length) {
                    return false;
                }
                int adr = Math.max(bits.length, o.bits.length) - 1;
                while (adr >= 0) {
                    long w1 = adr < bits.length ? bits[adr] : 0;
                    long w2 = adr < o.bits.length ? o.bits[adr] : 0;
                    if (w1 != w2) {
                        return false;
                    }
                    adr--;
                }
                return true;
            }
            return false;
        }


        public String toString() {
            StringBuffer buf = new StringBuffer("w=");
            buf.append(names.length);
            int i = nextSetBit(0);
            while (i>=0) {
                buf.append(", ").append(i).append("=");
                buf.append(BitsetENTCacheImpl.this.getName(i));
                i = nextSetBit(i+1);
            }
            return buf.toString();
        }


        public String toString() {
            StringBuilder buf = new StringBuilder("w=");
            buf.append(names.length);
            int i = nextSetBit(0);
            while (i >= 0) {
                buf.append(", ").append(i).append("=");
                buf.append(BitSetENTCacheImpl.this.getName(i));
                i = nextSetBit(i + 1);
            }
            return buf.toString();
        }


    public Node getNode(String absPath) throws RepositoryException {
        checkIsAlive();
        try {
            Path qPath = getQPath(absPath).getNormalizedPath();
            ItemManager itemMgr = getItemManager();
            return itemMgr.getNode(qPath);
        } catch (AccessDeniedException ade) {
            throw new PathNotFoundException(absPath);
        }
    }


    public Property getProperty(String absPath) throws RepositoryException {
        checkIsAlive();
        try {
            Path qPath = getQPath(absPath).getNormalizedPath();
            ItemManager itemMgr = getItemManager();
            return itemMgr.getProperty(qPath);
        } catch (AccessDeniedException ade) {
            throw new PathNotFoundException(absPath);
        }
    }


    public Map<String, String> getInfo() throws RepositoryException {
        Map<String, String> jcrInfo = new HashMap<String, String>();
        for (Map.Entry<Name, QValue> entry : event.getInfo().entrySet()) {
            Name key = entry.getKey();
            QValue value = entry.getValue();
            String strValue = null;
            if (value != null) {
                strValue = ValueFormat.getJCRString(value, resolver);
            }
            jcrInfo.put(resolver.getJCRName(key), strValue);
        }
        return jcrInfo;
    }


    public Map<String, String> getInfo() throws RepositoryException {
        Map<String, String> info = new HashMap<String, String>();
        for (Map.Entry<String, InternalValue> entry : eventState.getInfo().entrySet()) {
            InternalValue value = entry.getValue();
            String strValue = null;
            if (value != null) {
                strValue = ValueFormat.getJCRString(value, session);
            }
            info.put(entry.getKey(), strValue);
        }
        return info;
    }


    public String toString() {
        if (stringValue == null) {
            StringBuffer sb = new StringBuffer();
            sb.append("Event: Path: ");
            try {
                sb.append(getPath());
            } catch (RepositoryException e) {
                log.error("Exception retrieving path: " + e);
                sb.append("[Error retrieving path]");
            }
            sb.append(", ").append(valueOf(getType())).append(": ");
            sb.append(", UserId: ").append(getUserID());
            stringValue = sb.toString();
        }
        return stringValue;
    }


    public String toString() {
        if (stringValue == null) {
            StringBuilder sb = new StringBuilder();
            sb.append("Event: Path: ");
            try {
                sb.append(getPath());
            } catch (RepositoryException e) {
                log.error("Exception retrieving path: " + e);
                sb.append("[Error retrieving path]");
            }
            sb.append(", ").append(EventState.valueOf(getType())).append(": ");
            sb.append(", UserId: ").append(getUserID());
            sb.append(", Timestamp: ").append(timestamp);
            sb.append(", UserData: ").append(userData);
            sb.append(", Info: ").append(eventState.getInfo());
            stringValue = sb.toString();
        }
        return stringValue;
    }


    private static String valueOf(int eventType) {
        if (eventType == Event.NODE_ADDED) {
            return "NodeAdded";
        } else if (eventType == Event.NODE_REMOVED) {
            return "NodeRemoved";
        } else if (eventType == Event.PROPERTY_ADDED) {
            return "PropertyAdded";
        } else if (eventType == Event.PROPERTY_CHANGED) {
            return "PropertyChanged";
        } else if (eventType == Event.PROPERTY_REMOVED) {
            return "PropertyRemoved";
        } else if (eventType == Event.NODE_MOVED) {
            return "NodeMoved";
        } else if (eventType == Event.PERSIST) {
            return "Persist";
        } else {
            return "UnknownEventType";
        }
    }


    public static String valueOf(int eventType) {
        if (eventType == Event.NODE_ADDED) {
            return "NodeAdded";
        } else if (eventType == Event.NODE_MOVED) {
            return "NodeMoved";
        } else if (eventType == Event.NODE_REMOVED) {
            return "NodeRemoved";
        } else if (eventType == Event.PROPERTY_ADDED) {
            return "PropertyAdded";
        } else if (eventType == Event.PROPERTY_CHANGED) {
            return "PropertyChanged";
        } else if (eventType == Event.PROPERTY_REMOVED) {
            return "PropertyRemoved";
        } else if (eventType == Event.PERSIST) {
            return "Persist";
        } else {
            return "UnknownEventType";
        }
    }


    public void save(ItemState state) throws ReferentialIntegrityException,
            InvalidItemStateException, RepositoryException {
        // shortcut, if no modifications are present
        if (!transientStateMgr.hasPendingChanges()) {
            return;
        }
        // collect the changes to be saved
        ChangeLog changeLog = transientStateMgr.getChangeLog(state, true);
        if (!changeLog.isEmpty()) {
            // only pass changelog if there are transient modifications available
            // for the specified item and its descendants.
            workspaceItemStateMgr.execute(changeLog);
            // remove states and operations just processed from the transient ISM
            transientStateMgr.dispose(changeLog);
            // now its save to clear the changeLog
            changeLog.reset();
        }
    }


    public void undo(ItemState itemState) throws ConstraintViolationException, RepositoryException {
        // short cut
        if (!transientStateMgr.hasPendingChanges()) {
            return;
        }
        ChangeLog changeLog = transientStateMgr.getChangeLog(itemState, false);
        if (!changeLog.isEmpty()) {
            // let changelog revert all changes
            changeLog.undo();
            // remove transient states and related operations from the t-statemanager
            transientStateMgr.dispose(changeLog);
            changeLog.reset();
        }
    }


    private void removeItemState(ItemState itemState, int options) throws RepositoryException {
        validator.checkRemoveItem(itemState, options);
        // recursively remove the given state and all child states.
        boolean success = false;
        try {
            itemState.getHierarchyEntry().transientRemove();
            success = true;
        } finally {
            if (!success) {
                // TODO: TOBEFIXED undo state modifications
            }
        }
    }


    public synchronized void store(ChangeLog changeLog)
            throws ItemStateException {
        boolean success = false;
        try {
            storeInternal(changeLog);
            success = true;
        } finally {
            if (!success) {
                bundles.clear();
            }
        }
    }


    NodeState createNewNodeState(Name nodeName, String uniqueID, Name nodeTypeName,
                                 QNodeDefinition definition, NodeState parent)
            throws RepositoryException {
        NodeEntry ne = ((NodeEntry) parent.getHierarchyEntry()).addNewNodeEntry(nodeName, uniqueID, nodeTypeName, definition);
        try {
            parent.markModified();
        } catch (RepositoryException e) {
            ne.remove();
            throw e;
        }
        return ne.getNodeState();
    }


    PropertyState createNewPropertyState(Name propName, NodeState parent,
                                         QPropertyDefinition definition,
                                         QValue[] values, int propertyType)
            throws ItemExistsException, ConstraintViolationException, RepositoryException {
        // NOTE: callers must make sure, the property type is not 'undefined'
        NodeEntry nodeEntry = (NodeEntry) parent.getHierarchyEntry();
        PropertyEntry pe = nodeEntry.addNewPropertyEntry(propName, definition, values, propertyType);
        try {
            parent.markModified();
        } catch (RepositoryException e) {
            pe.remove();
            throw e;
        }
        return pe.getPropertyState();
    }


    public NodeState createNodeState(NodeId nodeId, NodeEntry entry) throws ItemNotFoundException,
            RepositoryException {

        try {
            Entry<NodeInfo> cached = cache.getNodeInfo(nodeId);
            ItemInfo info;
            if (isUpToDate(cached, entry)) {
                info = cached.info;
            } else {
                // otherwise retrieve item info from service and cache the whole batch
                Iterator<? extends ItemInfo> infos = service.getItemInfos(sessionInfo, nodeId);
                info = first(infos, cache, entry.getGeneration());
                if (info == null || !info.denotesNode()) {
                    throw new ItemNotFoundException("NodeId: " + nodeId);
                }
            }

            assertMatchingPath(info, entry);
            return createNodeState((NodeInfo) info, entry);
        }
        catch (PathNotFoundException e) {
            throw new ItemNotFoundException(e);
        }
    }


    public PropertyState createPropertyState(PropertyId propertyId, PropertyEntry entry)
            throws ItemNotFoundException, RepositoryException {

        try {
            // Get item info from cache and use it if up to date
            Entry<PropertyInfo> cached = cache.getPropertyInfo(propertyId);
            ItemInfo info;
            if (isUpToDate(cached, entry)) {
                info = cached.info;
            } else {
                // otherwise retrieve item info from service and cache the whole batch
                Iterator<? extends ItemInfo> infos = service.getItemInfos(sessionInfo, propertyId);
                info = first(infos, cache, entry.getGeneration());
                if (info == null || info.denotesNode()) {
                    throw new ItemNotFoundException("PropertyId: " + propertyId);
                }
            }

            assertMatchingPath(info, entry);
            return createPropertyState((PropertyInfo) info, entry);
        }
        catch (PathNotFoundException e) {
            throw new ItemNotFoundException(e);
        }
    }


    public NodeState createDeepNodeState(NodeId nodeId, NodeEntry anyParent) throws ItemNotFoundException,
            RepositoryException {

        try {
            // Get item info from cache
            Iterator<? extends ItemInfo> infos = null;
            Entry<NodeInfo> cached = cache.getNodeInfo(nodeId);
            ItemInfo info;
            if (cached == null) {
                // or from service if not in cache
                infos = service.getItemInfos(sessionInfo, nodeId);
                info = first(infos, null, 0);
                if (info == null || !info.denotesNode()) {
                    throw new ItemNotFoundException("NodeId: " + nodeId);
                }
            } else {
                info = cached.info;
            }

            // Build the hierarchy entry for the item info
            HierarchyEntry entry = createHierarchyEntries(info, anyParent);
            if (entry == null || !entry.denotesNode()) {
                throw new ItemNotFoundException(
                        "HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
            } else {
                // Now we can check whether the item info from the cache is up to date
                long generation = entry.getGeneration();
                if (isOutdated(cached, entry)) {
                    // if not, retrieve the item info from the service and put the whole batch into the cache
                    infos = service.getItemInfos(sessionInfo, nodeId);
                    info = first(infos, cache, generation);
                } else if (infos != null) {
                    // Otherwise put the whole batch retrieved from the service earlier into the cache
                    cache.put(info, generation);
                    first(infos, cache, generation);
                }

                assertMatchingPath(info, entry);
                return createNodeState((NodeInfo) info, (NodeEntry) entry);
            }
        }
        catch (PathNotFoundException e) {
            throw new ItemNotFoundException(e);
        }
    }


    public PropertyState createDeepPropertyState(PropertyId propertyId, NodeEntry anyParent)
            throws RepositoryException {

        try {
            // Get item info from cache
            Iterator<? extends ItemInfo> infos = null;
            Entry<PropertyInfo> cached = cache.getPropertyInfo(propertyId);
            ItemInfo info;
            if (cached == null) {
                // or from service if not in cache
                infos = service.getItemInfos(sessionInfo, propertyId);
                info = first(infos, null, 0);
                if (info == null || info.denotesNode()) {
                    throw new ItemNotFoundException("PropertyId: " + propertyId);
                }
            } else {
                info = cached.info;
            }

            // Build the hierarchy entry for the item info
            HierarchyEntry entry = createHierarchyEntries(info, anyParent);
            if (entry == null || entry.denotesNode()) {
                throw new ItemNotFoundException(
                        "HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
            } else {
                long generation = entry.getGeneration();
                if (isOutdated(cached, entry)) {
                    // if not, retrieve the item info from the service and put the whole batch into the cache
                    infos = service.getItemInfos(sessionInfo, propertyId);
                    info = first(infos, cache, generation);
                } else if (infos != null) {
                    // Otherwise put the whole batch retrieved from the service earlier into the cache
                    cache.put(info, generation);
                    first(infos, cache, generation);
                }

                assertMatchingPath(info, entry);
                return createPropertyState((PropertyInfo) info, (PropertyEntry) entry);
            }

        } catch (PathNotFoundException e) {
            throw new ItemNotFoundException(e);
        }
    }


    public void testConcurrentLockUnlock() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                Node n = test.addNode("test");
                n.addMixin(mixLockable);
                session.save();

                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    n.lock(false, true);
                    n.unlock();
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentLock() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                Node n = test.addNode("test");
                n.addMixin(mixLockable);
                session.save();

                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    if (n.isLocked()) {
                        n.unlock();
                    }
                    n.lock(false, true);
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCheckin() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                Node n = test.addNode("test");
                n.addMixin(mixVersionable);
                session.save();
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    n.checkout();
                    n.checkin();
                }
                n.checkout();
            }
        }, CONCURRENCY);
    }


    public void testConcurrentAddVersionable() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                // add versionable nodes
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    Node n = test.addNode("test" + i);
                    n.addMixin(mixVersionable);
                    session.save();
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCreateAndLockUnlock() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                // add versionable nodes
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    Node n = test.addNode("test" + i);
                    n.addMixin(mixLockable);
                    session.save();
                    Lock l = n.lock(false, true);
                    l.refresh();
                    n.unlock();
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCreateAndCheckinCheckout() throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test) throws RepositoryException {
                // add versionable nodes
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    Node n = test.addNode("test" + i);
                    n.addMixin(mixVersionable);
                    session.save();
                    n.checkout();
                    n.checkin();
                    n.checkout();
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentRefreshInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                int i = 0;
                try {
                    Node n = test.addNode("test");
                    n.addMixin(mixLockable);
                    session.save();
                    for (i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                        Lock lock = n.lock(false, true);

                        final UserTransaction utx = new UserTransactionImpl(test.getSession());
                        utx.begin();
                        lock.refresh();
                        utx.commit();

                        n.unlock();
                    }
                } catch (Exception e) {
                    final String threadName = Thread.currentThread().getName();
                    final Throwable deepCause = getLevel2Cause(e);
                    if (deepCause != null && deepCause instanceof StaleItemStateException) {
                        // ignore
                    } else {
                        throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCreateAndCheckinCheckoutInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                // add versionable nodes
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    try {
                        final UserTransaction utx = new UserTransactionImpl(test.getSession());
                        utx.begin();
                        Node n = test.addNode("test" + i);
                        n.addMixin(mixVersionable);
                        session.save();
                        n.checkout();
                        n.checkin();
                        n.checkout();
                        utx.commit();
                    } catch (Exception e) {
                        final String threadName = Thread.currentThread().getName();
                        final Throwable deepCause = getLevel2Cause(e);
                        if (deepCause != null && deepCause instanceof StaleItemStateException) {
                            // ignore
                        } else {
                            throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                        }
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentRestoreInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                int i = 0;
                try {
                    Node n = test.addNode("test");
                    n.addMixin(mixVersionable);
                    session.save();
                    // create 3 version
                    List versions = new ArrayList();
                    for (i = 0; i < 3; i++) {
                        n.checkout();
                        versions.add(n.checkin());
                    }
                    // do random restores
                    Random rand = new Random();
                    for (i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                        Version v = (Version) versions.get(rand.nextInt(versions.size()));
                        n.restore(v, true);
                    }
                    n.checkout();
                } catch (Exception e) {
                    final String threadName = Thread.currentThread().getName();
                    final Throwable deepCause = getLevel2Cause(e);
                    if (deepCause != null && deepCause instanceof StaleItemStateException) {
                        // ignore
                    } else {
                        throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCreateAndLockUnLockInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                // add versionable nodes
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    try {
                        final UserTransaction utx = new UserTransactionImpl(test.getSession());
                        utx.begin();
                        Node n = test.addNode("test" + i);
                        n.addMixin(mixLockable);
                        session.save();
                        Lock l = n.lock(false, true);
                        n.unlock();
                        utx.commit();
                    } catch (Exception e) {
                        final String threadName = Thread.currentThread().getName();
                        final Throwable deepCause = getLevel2Cause(e);
                        if (deepCause != null && deepCause instanceof StaleItemStateException) {
                            // ignore
                        } else {
                            throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                        }
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentCheckinInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                int i = 0;
                try {
                    Node n = test.addNode("test");
                    n.addMixin(mixVersionable);
                    session.save();
                    for (i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                        final UserTransaction utx = new UserTransactionImpl(test.getSession());
                        utx.begin();
                        n.checkout();
                        n.checkin();
                        utx.commit();
                    }
                    n.checkout();
                } catch (Exception e) {
                    final String threadName = Thread.currentThread().getName();
                    final Throwable deepCause = getLevel2Cause(e);
                    if (deepCause != null && deepCause instanceof StaleItemStateException) {
                        // ignore
                    } else {
                        throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testConcurrentAddVersionableInTransaction()
            throws RepositoryException {
        runTask(new Task() {
            public void execute(Session session, Node test)
                    throws RepositoryException {
                // add versionable nodes
                final String threadName = Thread.currentThread().getName();
                Node parent = createParentNode(test, threadName);
                for (int i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {
                    try {
                        final UserTransaction utx = new UserTransactionImpl(test.getSession());
                        utx.begin();
                        final String nodeName = "test" + i;
                        Node n = parent.addNode(nodeName);
                        n.addMixin(mixVersionable);
                        session.save();
                        utx.commit();
                    } catch (InvalidItemStateException e) {
                        // ignore
                    } catch (Exception e) {
                        final Throwable deepCause = getLevel2Cause(e);
                        if (deepCause != null && deepCause instanceof StaleItemStateException) {
                            // ignore
                        } else {
                            throw new RepositoryException(threadName + ", i=" + i + ":" + e.getClass().getName(), e);
                        }
                    }
                }
            }
        }, CONCURRENCY);
    }


    public void testDeleteRecordWithParentCollision() throws Exception {
        FileDataStore fds = new FileDataStore();
        fds.init(testDir + "/fileDeleteCollision");

        String c1 = "06b2f82fd81b2c20";
        String c2 = "02c60cb75083ceef";
        DataRecord d1 = fds.addRecord(IOUtils.toInputStream(c1));
        DataRecord d2 = fds.addRecord(IOUtils.toInputStream(c2));
        fds.deleteRecord(d1.getIdentifier());
        DataRecord testRecord = fds.getRecordIfStored(d2.getIdentifier());

        assertNotNull(testRecord);
        assertEquals(d2.getIdentifier(), testRecord.getIdentifier());
        // Check the presence of the parent directory (relies on internal details of the FileDataStore)
        File parentDirD1 = new File(
            fds.getPath() + System.getProperty("file.separator") + d1.getIdentifier().toString().substring(0, 2));
        assertTrue(parentDirD1.exists());
    }


    public void testDeleteRecordWithoutParentCollision() throws Exception {
        FileDataStore fds = new FileDataStore();
        fds.init(testDir + "/fileDelete");

        String c1 = "idhfigjhehgkdfgk";
        String c2 = "02c60cb75083ceef";
        DataRecord d1 = fds.addRecord(IOUtils.toInputStream(c1));
        DataRecord d2 = fds.addRecord(IOUtils.toInputStream(c2));
        fds.deleteRecord(d1.getIdentifier());
        DataRecord testRecord = fds.getRecordIfStored(d2.getIdentifier());

        assertNotNull(testRecord);
        assertEquals(d2.getIdentifier(), testRecord.getIdentifier());
        // Check the absence of the parent directory (relies on internal details of the FileDataStore)
        File parentDirD1 = new File(
            fds.getPath() + System.getProperty("file.separator") + d1.getIdentifier().toString().substring(0, 2));
        assertFalse(parentDirD1.exists());
    }


    private void assertReference(
            byte[] expected, String reference, DataStore store)
            throws Exception {
        DataRecord record = store.getRecordFromReference(reference);
        assertNotNull(record);
        assertEquals(expected.length, record.getLength());

        InputStream stream = record.getStream();
        try {
            for (int i = 0; i < expected.length; i++) {
                assertEquals(expected[i] & 0xff, stream.read());
            }
            assertEquals(-1, stream.read());
        } finally {
            stream.close();
        }
    }


    protected void assertRecord(byte[] expected, DataRecord record)
            throws DataStoreException, IOException {
        InputStream stream = record.getStream();
        try {
            for (int i = 0; i < expected.length; i++) {
                assertEquals(expected[i] & 0xff, stream.read());
            }
            assertEquals(-1, stream.read());
        } finally {
            stream.close();
        }
    }


    private void doTestMultiThreaded(final DataStore ds, int threadCount) throws Exception {
        final Exception[] exception = new Exception[1];
        Thread[] threads = new Thread[threadCount];
        for (int i = 0; i < threadCount; i++) {
            final int x = i;
            Thread t = new Thread() {
                public void run() {
                    try {
                        doTest(ds, x);
                    } catch (Exception e) {
                        exception[0] = e;
                    }
                }
            };
            threads[i] = t;
            t.start();
        }
        for (int i = 0; i < threadCount; i++) {
            threads[i].join();
        }
        if (exception[0] != null) {
            throw exception[0];
        }
    }


    protected void doTestMultiThreaded(final DataStore ds, int threadCount)
            throws Exception {
        final Exception[] exception = new Exception[1];
        Thread[] threads = new Thread[threadCount];
        for (int i = 0; i < threadCount; i++) {
            final int x = i;
            Thread t = new Thread() {
                public void run() {
                    try {
                        doTest(ds, x);
                    } catch (Exception e) {
                        exception[0] = e;
                    }
                }
            };
            threads[i] = t;
            t.start();
        }
        for (int i = 0; i < threadCount; i++) {
            threads[i].join();
        }
        if (exception[0] != null) {
            throw exception[0];
        }
    }


    void doTest(DataStore ds, int offset) throws Exception {
        ArrayList<DataRecord> list = new ArrayList<DataRecord>();
        HashMap<DataRecord, Integer> map = new HashMap<DataRecord, Integer>();
        for (int i = 0; i < 100; i++) {
            int size = 100 + i * 10;
            RandomInputStream in = new RandomInputStream(size + offset, size);
            DataRecord rec = ds.addRecord(in);
            list.add(rec);
            map.put(rec, new Integer(size));
        }
        Random random = new Random(1);
        for (int i = 0; i < list.size(); i++) {
            int pos = random.nextInt(list.size());
            DataRecord rec = list.get(pos);
            int size = map.get(rec);
            rec = ds.getRecord(rec.getIdentifier());
            assertEquals(size, rec.getLength());
            InputStream in = rec.getStream();
            RandomInputStream expected = new RandomInputStream(size + offset, size);
            if (random.nextBoolean()) {
                in = readInputStreamRandomly(in, random);
            }
            assertEquals(expected, in);
            in.close();
        }
    }


    void doTest(DataStore ds, int offset) throws Exception {
        ArrayList<DataRecord> list = new ArrayList<DataRecord>();
        HashMap<DataRecord, Integer> map = new HashMap<DataRecord, Integer>();
        for (int i = 0; i < 10; i++) {
            int size = 100000 - (i * 100);
            RandomInputStream in = new RandomInputStream(size + offset, size);
            DataRecord rec = ds.addRecord(in);
            list.add(rec);
            map.put(rec, new Integer(size));
        }
        Random random = new Random(1);
        for (int i = 0; i < list.size(); i++) {
            int pos = random.nextInt(list.size());
            DataRecord rec = list.get(pos);
            int size = map.get(rec);
            rec = ds.getRecord(rec.getIdentifier());
            assertEquals(size, rec.getLength());
            RandomInputStream expected = new RandomInputStream(size + offset,
                size);
            InputStream in = rec.getStream();
            // Workaround for race condition that can happen with low cache size relative to the test
            // read immediately
            byte[] buffer = new byte[1];
            in.read(buffer);
            in = new SequenceInputStream(new ByteArrayInputStream(buffer), in);

            if (random.nextBoolean()) {
                in = readInputStreamRandomly(in, random);
            }
            assertEquals(expected, in);
        }
    }


    InputStream readInputStreamRandomly(InputStream in, Random random) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buffer = new byte[8000];
        while (true) {
            if (random.nextBoolean()) {
                int x = in.read();
                if (x < 0) {
                    break;
                }
                out.write(x);
            } else {
                if (random.nextBoolean()) {
                    int l = in.read(buffer);
                    if (l < 0) {
                        break;
                    }
                    out.write(buffer, 0, l);
                } else {
                    int offset = random.nextInt(buffer.length / 2);
                    int len = random.nextInt(buffer.length / 2);
                    int l = in.read(buffer, offset, len);
                    if (l < 0) {
                        break;
                    }
                    out.write(buffer, offset, l);
                }
            }
        }
        in.close();
        return new ByteArrayInputStream(out.toByteArray());
    }


    InputStream readInputStreamRandomly(InputStream in, Random random)
            throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buffer = new byte[8000];
        while (true) {
            if (random.nextBoolean()) {
                int x = in.read();
                if (x < 0) {
                    break;
                }
                out.write(x);
            } else {
                if (random.nextBoolean()) {
                    int l = in.read(buffer);
                    if (l < 0) {
                        break;
                    }
                    out.write(buffer, 0, l);
                } else {
                    int offset = random.nextInt(buffer.length / 2);
                    int len = random.nextInt(buffer.length / 2);
                    int l = in.read(buffer, offset, len);
                    if (l < 0) {
                        break;
                    }
                    out.write(buffer, offset, l);
                }
            }
        }
        in.close();
        return new ByteArrayInputStream(out.toByteArray());
    }


    void assertEquals(InputStream a, InputStream b) throws IOException {
        while (true) {
            int ai = a.read();
            int bi = b.read();
            assertEquals(ai, bi);
            if (ai < 0) {
                break;
            }
        }
    }


    protected void assertEquals(InputStream a, InputStream b)
                    throws IOException {
        while (true) {
            int ai = a.read();
            int bi = b.read();
            assertEquals(ai, bi);
            if (ai < 0) {
                break;
            }
        }
        IOUtils.closeQuietly(a);
        IOUtils.closeQuietly(b);
    }


    private static void verifyInputStream(InputStream in, InputStream in2) throws IOException {
        while (true) {
            int a = in.read();
            int b = in2.read();
            assertEquals(a, b);
            if (a < 0) {
                break;
            }
        }

    }


    public void testTwoGetStreams() throws Exception {
        Node root = superuser.getRootNode();
        ValueFactory vf = superuser.getValueFactory();
        root.setProperty("p1", vf.createBinary(new RandomInputStream(1, STREAM_LENGTH)));
        root.setProperty("p2", vf.createBinary(new RandomInputStream(2, STREAM_LENGTH)));
        superuser.save();

        InputStream i1 = root.getProperty("p1").getBinary().getStream();
        InputStream i2 = root.getProperty("p2").getBinary().getStream();
        assertEquals("p1", i1, new RandomInputStream(1, STREAM_LENGTH));
        assertEquals("p2", i2, new RandomInputStream(2, STREAM_LENGTH));
        try {
            i1.close();
        } catch (IOException e) {
            log.info("Could not close first input stream: ", e);
        }
        try {
            i2.close();
        } catch (IOException e) {
            log.info("Could not close second input stream: ", e);
        }
    }


    public void testTwoStreamsFromSamePropertyConcurrently() throws Exception {
        Node root = superuser.getRootNode();
        ValueFactory vf = superuser.getValueFactory();
        root.setProperty("p1", vf.createBinary(new RandomInputStream(1, STREAM_LENGTH)));
        superuser.save();

        InputStream i1 = root.getProperty("p1").getBinary().getStream();
        InputStream i2 = root.getProperty("p1").getBinary().getStream();
        assertEquals("Streams are different", i1, i2);
        try {
            i1.close();
        } catch (IOException e) {
            log.info("Could not close first input stream: ", e);
        }
        try {
            i2.close();
        } catch (IOException e) {
            log.info("Could not close second input stream: ", e);
        }
    }


    public void testTwoStreamsConcurrently() throws Exception {
        Node root = superuser.getRootNode();
        ValueFactory vf = superuser.getValueFactory();
        root.setProperty("p1", vf.createBinary(new RandomInputStream(1, STREAM_LENGTH)));
        root.setProperty("p2", vf.createBinary(new RandomInputStream(1, STREAM_LENGTH)));
        superuser.save();

        InputStream i1 = root.getProperty("p1").getBinary().getStream();
        InputStream i2 = root.getProperty("p2").getBinary().getStream();
        assertEquals("Streams are different", i1, i2);
        try {
            i1.close();
        } catch (IOException e) {
            log.info("Could not close first input stream: ", e);
        }
        try {
            i2.close();
        } catch (IOException e) {
            log.info("Could not close second input stream: ", e);
        }
    }


    private static int listIdentifiers(GarbageCollector gc) throws DataStoreException {
        LOG.debug("identifiers:");
        int count = 0;
        Iterator<DataIdentifier> it = gc.getDataStore().getAllIdentifiers();
        while (it.hasNext()) {
            DataIdentifier id = it.next();
            LOG.debug("  " + id);
            count++;
        }
        return count;
    }


    private int listIdentifiers(DataStoreGarbageCollector gc) throws DataStoreException {
        DataStore ds = ((GarbageCollector) gc).getDataStore();
        Iterator<DataIdentifier> it = ds.getAllIdentifiers();
        int count = 0;
        while (it.hasNext()) {
            DataIdentifier id = it.next();
            LOG.debug("  " + id);
            count++;
        }
        return count;
    }


    public void testFixAbandonedNode() throws RepositoryException, ClusterException {
        NodePropBundle bundle1 = new NodePropBundle(new NodeId(0, 0));
        NodePropBundle bundle2 = new NodePropBundle(new NodeId(0, 1));

        // node2 has a reference to node 1 as its parent, but node 1 doesn't have
        // a corresponding child node entry
        bundle2.setParentId(bundle1.getId());

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(bundle1, bundle2));
        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, master.createUpdateChannel("default"));

        // set up cluster event update listener
        final TestUpdateEventListener listener = new TestUpdateEventListener();
        final UpdateEventChannel slaveEventChannel = slave.createUpdateChannel("default");
        slaveEventChannel.setListener(listener);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.ABANDONED, reportItem.getType());
        assertEquals(bundle2.getId().toString(), reportItem.getNodeId());

        checker.repair();

        // node1 should now have a child node entry for node2
        bundle1 = pm.loadBundle(bundle1.getId());
        assertEquals(1, bundle1.getChildNodeEntries().size());
        assertEquals(bundle2.getId(), bundle1.getChildNodeEntries().get(0).getId());

        slave.sync();

        // verify events were correctly broadcast to cluster
        assertNotNull("Cluster node did not receive update event", listener.changes);
        assertTrue("Expected node1 to be modified", listener.changes.isModified(bundle1.getId()));
    }


    public void testFixDisconnectedNode() throws RepositoryException, ClusterException {
        NodePropBundle bundle1 = new NodePropBundle(new NodeId(0, 0));
        NodePropBundle bundle2 = new NodePropBundle(new NodeId(0, 1));
        NodePropBundle bundle3 = new NodePropBundle(new NodeId(1, 0));

        // node1 has child node3
        bundle1.addChildNodeEntry(nameFactory.create("", "test"), bundle3.getId());
        // node2 also has child node3
        bundle2.addChildNodeEntry(nameFactory.create("", "test"), bundle3.getId());
        // node3 has node2 as parent
        bundle3.setParentId(bundle2.getId());

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(bundle1, bundle2, bundle3));
        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, master.createUpdateChannel("default"));

        // set up cluster event update listener
        final TestUpdateEventListener listener = new TestUpdateEventListener();
        final UpdateEventChannel slaveEventChannel = slave.createUpdateChannel("default");
        slaveEventChannel.setListener(listener);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.DISCONNECTED, reportItem.getType());
        assertEquals(bundle1.getId().toString(), reportItem.getNodeId());

        checker.repair();

        bundle1 = pm.loadBundle(bundle1.getId());
        bundle2 = pm.loadBundle(bundle2.getId());
        bundle3 = pm.loadBundle(bundle3.getId());

        // node3 should have been removed as child node entry of node1
        assertEquals(0, bundle1.getChildNodeEntries().size());

        // node3 should still be a child of node2
        assertEquals(1, bundle2.getChildNodeEntries().size());
        assertEquals(bundle2.getId(), bundle3.getParentId());

        slave.sync();

        // verify events were correctly broadcast to cluster
        assertNotNull("Cluster node did not receive update event", listener.changes);
        assertTrue("Expected node1 to be modified", listener.changes.isModified(bundle1.getId()));
    }


    public void testDoubleCheckAbandonedNode() throws RepositoryException {
        NodePropBundle bundle1 = new NodePropBundle(new NodeId(0, 0));
        NodePropBundle bundle2 = new NodePropBundle(new NodeId(0, 1));

        // node2 has a reference to node 1 as its parent, but node 1 doesn't have
        // a corresponding child node entry
        bundle2.setParentId(bundle1.getId());

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(bundle1, bundle2));
        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, null);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.ABANDONED, reportItem.getType());
        assertEquals(bundle2.getId().toString(), reportItem.getNodeId());

        checker.doubleCheckErrors();

        assertFalse("Double check removed valid error", checker.getReport().getItems().isEmpty());

        // fix the error
        bundle1.addChildNodeEntry(nameFactory.create("", "test"), bundle2.getId());

        checker.doubleCheckErrors();

        assertTrue("Double check didn't remove invalid error", checker.getReport().getItems().isEmpty());
    }


    public void testDoubleCheckOrphanedNode() throws RepositoryException {
        NodePropBundle orphaned = new NodePropBundle(new NodeId(0, 1));
        orphaned.setParentId(new NodeId(1, 0));

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(orphaned));
        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, null);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.ORPHANED, reportItem.getType());
        assertEquals(orphaned.getId().toString(), reportItem.getNodeId());

        checker.doubleCheckErrors();

        assertFalse("Double check removed valid error", checker.getReport().getItems().isEmpty());

        // fix the error
        NodePropBundle parent = new NodePropBundle(orphaned.getParentId());
        pm.bundles.put(parent.getId(), parent);

        checker.doubleCheckErrors();

        assertTrue("Double check didn't remove invalid error", checker.getReport().getItems().isEmpty());
    }


    public void testDoubleCheckDisonnectedNode() throws RepositoryException {
        NodePropBundle bundle1 = new NodePropBundle(new NodeId(0, 0));
        NodePropBundle bundle2 = new NodePropBundle(new NodeId(0, 1));
        NodePropBundle bundle3 = new NodePropBundle(new NodeId(1, 0));

        // node1 has child node3
        bundle1.addChildNodeEntry(nameFactory.create("", "test"), bundle3.getId());
        // node2 also has child node3
        bundle2.addChildNodeEntry(nameFactory.create("", "test"), bundle3.getId());
        // node3 has node2 as parent
        bundle3.setParentId(bundle2.getId());

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(bundle1, bundle2, bundle3));
        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, null);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.DISCONNECTED, reportItem.getType());
        assertEquals(bundle1.getId().toString(), reportItem.getNodeId());

        checker.doubleCheckErrors();

        assertFalse("Double check removed valid error", checker.getReport().getItems().isEmpty());

        // fix the error
        bundle1.getChildNodeEntries().remove(0);

        checker.doubleCheckErrors();

        assertTrue("Double check didn't remove invalid error", checker.getReport().getItems().isEmpty());
    }


    public void testDoubleCheckMissingNode() throws RepositoryException {
        NodePropBundle bundle = new NodePropBundle(new NodeId(0, 0));
        final NodeId childNodeId = new NodeId(0, 1);
        bundle.addChildNodeEntry(nameFactory.create("", "test"), childNodeId);

        MockPersistenceManager pm = new MockPersistenceManager(Arrays.asList(bundle));

        ConsistencyCheckerImpl checker = new ConsistencyCheckerImpl(pm, null, null, null);

        checker.check(null, false);

        Set<ReportItem> reportItems = checker.getReport().getItems();
        assertEquals(1, reportItems.size());
        ReportItem reportItem = reportItems.iterator().next();
        assertEquals(ReportItem.Type.MISSING, reportItem.getType());
        assertEquals(bundle.getId().toString(), reportItem.getNodeId());

        checker.doubleCheckErrors();

        assertFalse("Double check removed valid error", checker.getReport().getItems().isEmpty());

        // fix the error
        NodePropBundle child = new NodePropBundle(childNodeId);
        pm.bundles.put(childNodeId, child);

        checker.doubleCheckErrors();

        assertTrue("Double check didn't remove invalid error", checker.getReport().getItems().isEmpty());

    }


    private ClusterNode createClusterNode(String id) throws Exception {
        final MemoryJournal journal = new MemoryJournal() {
            protected boolean syncAgainOnNewRecords() {
                return true;
            }
        };
        JournalFactory jf = new JournalFactory() {
            public Journal getJournal(NamespaceResolver resolver)
                    throws RepositoryException {
                return journal;
            }
        };
        ClusterConfig cc = new ClusterConfig(id, SYNC_DELAY, jf);
        SimpleClusterContext context = new SimpleClusterContext(cc);

        journal.setRepositoryHome(context.getRepositoryHome());
        journal.init(id, context.getNamespaceResolver());
        journal.setRecords(records);

        ClusterNode clusterNode = new ClusterNode();
        clusterNode.init(context);
        return clusterNode;
    }


    private ClusterNode createClusterNode(String id, boolean disableAutoSync) throws Exception {
        final MemoryJournal journal = new MemoryJournal() {
            protected boolean syncAgainOnNewRecords() {
                return true;
            }
        };
        JournalFactory jf = new JournalFactory() {
            public Journal getJournal(NamespaceResolver resolver)
                    throws RepositoryException {
                return journal;
            }
        };
        ClusterConfig cc = new ClusterConfig(id, SYNC_DELAY, jf);
        SimpleClusterContext context = new SimpleClusterContext(cc);

        journal.setRepositoryHome(context.getRepositoryHome());
        journal.init(id, context.getNamespaceResolver());
        journal.setRecords(records);
        
        ClusterNode clusterNode = new ClusterNode();
        clusterNode.init(context);
        if (disableAutoSync) {
            clusterNode.disableAutoSync();
        }
        return clusterNode;
    }


    private static Element parseXML(InputSource xml, boolean validate) throws ConfigurationException {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(validate);
            DocumentBuilder builder = factory.newDocumentBuilder();
            if (validate) {
                builder.setErrorHandler(new ConfigurationErrorHandler());
            }
            builder.setEntityResolver(ConfigurationEntityResolver.INSTANCE);
            Document document = builder.parse(xml);
            return document.getDocumentElement();
        } catch (ParserConfigurationException e) {
            throw new ConfigurationException("Unable to create configuration XML parser", e);
        } catch (SAXParseException e) {
            throw new ConfigurationException("Configuration file syntax error. (Line: " + e.getLineNumber() + " Column: " + e.getColumnNumber() + ")", e);
        } catch (SAXException e) {
            throw new ConfigurationException("Configuration file syntax error. ", e);
        } catch (IOException e) {
            throw new ConfigurationException("Configuration file could not be read.", e);
        }
    }


    private static Element parseXML(InputSource xml, boolean validate) throws ConfigurationException {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(validate);
            DocumentBuilder builder = factory.newDocumentBuilder();
            if (validate) {
                builder.setErrorHandler(new ConfigurationErrorHandler());
            }
            builder.setEntityResolver(ConfigurationEntityResolver.INSTANCE);
            Document document = builder.parse(xml);
            return document.getDocumentElement();
        } catch (ParserConfigurationException e) {
            throw new ConfigurationException("Unable to create configuration XML parser", e);
        } catch (SAXParseException e) {
            throw new ConfigurationException("Configuration file syntax error. (Line: " + e.getLineNumber() + " Column: " + e.getColumnNumber() + ")", e);
        } catch (SAXException e) {
            throw new ConfigurationException("Configuration file syntax error. ", e);
        } catch (IOException e) {
            throw new ConfigurationException("Configuration file could not be read.", e);
        }
    }


    private static Element parseXML(InputSource xml, boolean validate) throws ConfigurationException {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(validate);
            DocumentBuilder builder = factory.newDocumentBuilder();
            if (validate) {
                builder.setErrorHandler(new ConfigurationErrorHandler());
            }
            builder.setEntityResolver(ConfigurationEntityResolver.INSTANCE);
            Document document = builder.parse(xml);
            return document.getDocumentElement();
        } catch (ParserConfigurationException e) {
            throw new ConfigurationException("Unable to create configuration XML parser", e);
        } catch (SAXParseException e) {
            throw new ConfigurationException("Configuration file syntax error. (Line: " + e.getLineNumber() + " Column: " + e.getColumnNumber() + ")", e);
        } catch (SAXException e) {
            throw new ConfigurationException("Configuration file syntax error. ", e);
        } catch (IOException e) {
            throw new ConfigurationException("Configuration file could not be read.", e);
        }
    }


    protected Element parseXML(InputSource xml, boolean validate) throws ConfigurationException {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(validate);
            DocumentBuilder builder = factory.newDocumentBuilder();
            if (validate) {
                builder.setErrorHandler(getErrorHandler());
            }
            builder.setEntityResolver(getEntityResolver());
            Document document = builder.parse(xml);
            return postParseModificationHook(document).getDocumentElement();
        } catch (ParserConfigurationException e) {
            throw new ConfigurationException(
                    "Unable to create configuration XML parser", e);
        } catch (SAXParseException e) {
            throw new ConfigurationException(
                    "Configuration file syntax error. (Line: " + e.getLineNumber() + " Column: " + e.getColumnNumber() + ")", e);
        } catch (SAXException e) {
            throw new ConfigurationException(
                    "Configuration file syntax error. ", e);
        } catch (IOException e) {
            throw new ConfigurationException(
                    "Configuration file could not be read.", e);
        }
    }


    public void testLockUtility() throws RepositoryException {
        final Node lockable = testRootNode.addNode(nodeName1);
        lockable.addMixin(mixLockable);
        superuser.save();

        final List<Thread> worker = new ArrayList<Thread>();
        for (int i = 0; i < NUM_THREADS; i++) {
            worker.add(new Thread() {

                private final int threadNumber = worker.size();

                public void run() {
                    final Session s;
                    try {
                        s = getHelper().getSuperuserSession();
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                        return;
                    }
                    try {
                        for (int i = 0; i < NUM_CHANGES; i++) {
                            Node n = (Node) s.getItem(lockable.getPath());
                            new Locked() {
                                protected Object run(Node n)
                                        throws RepositoryException {
                                    String nodeName = "node" + threadNumber;
                                    if (n.hasNode(nodeName)) {
                                        n.getNode(nodeName).remove();
                                    } else {
                                        n.addNode(nodeName);
                                    }
                                    s.save();
                                    log.println("Thread" + threadNumber
                                            + ": saved modification");

                                    return null;
                                }
                            }.with(n, false);
                            // do a random wait
                            Thread.sleep(new Random().nextInt(100));
                        }
                    } catch (RepositoryException e) {
                        log.println("exception while running code with lock:"
                                + e.getMessage());
                    } catch (InterruptedException e) {
                        log.println(Thread.currentThread()
                                + " interrupted while waiting for lock");
                    } finally {
                        s.logout();
                    }
                }
            });
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            it.next().start();
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            try {
                it.next().join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    public void testSequence() throws RepositoryException {
        final Node counter = testRootNode.addNode(nodeName1);
        counter.setProperty("value", 0);
        counter.addMixin(mixLockable);
        superuser.save();

        final List<Thread> worker = new ArrayList<Thread>();
        for (int i = 0; i < NUM_THREADS; i++) {
            worker.add(new Thread() {

                private final int threadNumber = worker.size();

                public void run() {
                    final Session s;
                    try {
                        s = getHelper().getSuperuserSession();
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                        return;
                    }
                    try {
                        for (int i = 0; i < NUM_VALUE_GETS; i++) {
                            Node n = (Node) s.getItem(counter.getPath());
                            long currentValue = ((Long) new Locked() {
                                protected Object run(Node n)
                                        throws RepositoryException {
                                    Property seqProp = n.getProperty("value");
                                    long value = seqProp.getLong();
                                    seqProp.setValue(++value);
                                    s.save();
                                    return new Long(value);
                                }
                            }.with(n, false)).longValue();
                            log.println("Thread" + threadNumber
                                    + ": got sequence number: " + currentValue);
                            // do a random wait
                            Thread.sleep(new Random().nextInt(100));
                        }
                    } catch (RepositoryException e) {
                        log.println("exception while running code with lock:"
                                + e.getMessage());
                    } catch (InterruptedException e) {
                        log.println(Thread.currentThread()
                                + " interrupted while waiting for lock");
                    } finally {
                        s.logout();
                    }
                }
            });
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            it.next().start();
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            try {
                it.next().join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    public void testSequenceWithTimeout() throws RepositoryException {
        final Node counter = testRootNode.addNode(nodeName1);
        counter.setProperty("value", 0);
        counter.addMixin(mixLockable);
        superuser.save();

        final List<Thread> worker = new ArrayList<Thread>();
        for (int i = 0; i < NUM_THREADS; i++) {
            worker.add(new Thread() {

                private final int threadNumber = worker.size();

                public void run() {
                    final Session s;
                    try {
                        s = getHelper().getSuperuserSession();
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                        return;
                    }
                    try {
                        for (int i = 0; i < NUM_VALUE_GETS; i++) {
                            Node n = (Node) s.getItem(counter.getPath());
                            Object ret = new Locked() {
                                protected Object run(Node n)
                                        throws RepositoryException {
                                    Property seqProp = n.getProperty("value");
                                    long value = seqProp.getLong();
                                    seqProp.setValue(++value);
                                    s.save();
                                    return new Long(value);
                                }
                            }.with(n, false, 10 * 1000); // expect a value after
                                                         // ten seconds
                            if (ret == Locked.TIMED_OUT) {
                                log.println("Thread"
                                        + threadNumber
                                        + ": could not get a sequence number within 10 seconds");
                            } else {
                                long currentValue = ((Long) ret).longValue();
                                log.println("Thread" + threadNumber
                                        + ": got sequence number: "
                                        + currentValue);
                            }
                            // do a random wait
                            Thread.sleep(new Random().nextInt(100));
                        }
                    } catch (RepositoryException e) {
                        log.println("exception while running code with lock:"
                                + e.getMessage());
                    } catch (InterruptedException e) {
                        log.println(Thread.currentThread()
                                + " interrupted while waiting for lock");
                    } finally {
                        s.logout();
                    }
                }
            });
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            it.next().start();
        }

        for (Iterator<Thread> it = worker.iterator(); it.hasNext();) {
            try {
                it.next().join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


                                protected Object run(Node n)
                                        throws RepositoryException {
                                    String nodeName = "node" + threadNumber;
                                    if (n.hasNode(nodeName)) {
                                        n.getNode(nodeName).remove();
                                    } else {
                                        n.addNode(nodeName);
                                    }
                                    s.save();
                                    log.println("Thread" + threadNumber
                                            + ": saved modification");

                                    return null;
                                }


                            protected Void run(Node node)
                                    throws RepositoryException {
                                String nodeName = "node" + threadNumber;
                                if (node.hasNode(nodeName)) {
                                    node.getNode(nodeName).remove();
                                } else {
                                    node.addNode(nodeName);
                                }
                                s.save();
                                log.println("Thread" + threadNumber
                                        + ": saved modification");
                                return null;
                            }


    public void setUp() throws IOException, RepositoryException {
        File baseDir = new File(System.getProperty("basedir", "."));
        File repoBaseDir = new File(baseDir, "target/corruption-test3");
        FileUtils.deleteQuietly(repoBaseDir);

        repoDescriptor = new File(repoBaseDir, "repository.xml");
        repoHome = new File(repoBaseDir, "repository");
        repoHome.mkdirs();

        File repositoryDescriptor = new File(baseDir, "src/test/repository/repository.xml");
        FileUtils.copyFile(repositoryDescriptor, repoDescriptor);
    }


    public void setUp() throws IOException, RepositoryException {
        File baseDir = new File(System.getProperty("basedir", "."));
        File repoBaseDir = new File(baseDir, "target/ItemStateHierarchyManagerDeadlockTest");
        FileUtils.deleteQuietly(repoBaseDir);

        repoDescriptor = new File(repoBaseDir, "repository.xml");
        repoHome = new File(repoBaseDir, "repository");
        repoHome.mkdirs();

        File repositoryDescriptor = new File(baseDir, "src/test/repository/repository.xml");
        FileUtils.copyFile(repositoryDescriptor, repoDescriptor);
    }


    protected void tearDown() throws Exception {
        int count = 0;
        for (NodeIterator it = testRootNode.getNodes(); it.hasNext();) {
            it.nextNode().remove();
            count++;
            if (count % 10000 == 0) {
                testRootNode.getSession().save();
            }
        }
        testRootNode.getSession().save();
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        int count = 0;
        for (NodeIterator it = testRootNode.getNodes(); it.hasNext();) {
            it.nextNode().remove();
            count++;
            if (count % 10000 == 0) {
                session.save();
            }
        }
        session.save();
        super.tearDown();
    }


    private int createNodes(Node n, int nodesPerLevel, int levels, int count)
            throws RepositoryException {
        levels--;
        for (int i = 0; i < nodesPerLevel; i++) {
            Node child = n.addNode("node" + i);
            count++;
            if (count % 10000 == 0) {
                n.getSession().save();
            }
            if (levels > 0) {
                count = createNodes(child, nodesPerLevel, levels, count);
            }
        }
        return count;
    }


    private int createNodes(Node n, int nodesPerLevel, int levels, int count)
            throws RepositoryException {
        levels--;
        for (int i = 0; i < nodesPerLevel; i++) {
            Node child = n.addNode("node" + count);
            count++;
            if (count % 1000 == 0) {
                superuser.save();
            }
            if (levels > 0) {
                count = createNodes(child, nodesPerLevel, levels, count);
            }
        }
        return count;
    }


    private int createNodes(Node n, int nodesPerLevel, int levels, int count)
            throws RepositoryException {
        levels--;
        for (int i = 0; i < nodesPerLevel; i++) {
            Node child = n.addNode("node" + i);
            count++;
            if (count % 10000 == 0) {
                session.save();
            }
            if (levels > 0) {
                count = createNodes(child, nodesPerLevel, levels, count);
            }
        }
        return count;
    }


    private int createNodes(Node n, int nodesPerLevel, int levels, int count)
            throws RepositoryException {
        levels--;
        for (int i = 0; i < nodesPerLevel; i++) {
            Node child = n.addNode("node" + i);
            child.setProperty("count", count++);
            if (count % 1000 == 0) {
                superuser.save();
                log.println("Created " + (count / 1000) + "k nodes");
            }
            if (levels > 0) {
                count = createNodes(child, nodesPerLevel, levels, count);
            }
        }
        if (levels == 0) {
            // final save
            superuser.save();
        }
        return count;
    }


    private int createNodes(Node n, int nodesPerLevel, int levels, int count)
            throws RepositoryException {
        levels--;
        for (int i = 0; i < nodesPerLevel; i++) {
            Node child = n.addNode("node" + i);
            count++;
            addMixins(child);
            log.info("Create node {}", child.getPath());
            if (count % saveInterval == 0) {
                getSession().save();
                log.debug("Created " + (count / 1000) + "k nodes");
            }
            if (levels > 0) {
                count = createNodes(child, nodesPerLevel, levels, count);
            }
        }
        if (levels == 0) {
            // final save
            getSession().save();
        }
        return count;
    }


    public void testOrderByMVP() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");
        Node n4 = testRootNode.addNode("node4");
        Node n5 = testRootNode.addNode("node5");

        n1.setProperty("text", new String[] { "ccc" });
        n2.setProperty("text", new String[] { "eee", "bbb" });
        n3.setProperty("text", new String[] { "aaa" });
        n4.setProperty("text", new String[] { "bbb", "aaa" });
        n5.setProperty("text", new String[] { "eee", "aaa" });

        testRootNode.getSession().save();

        String sql = "SELECT value FROM [nt:unstructured] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY text";

        checkSeq(executeSQL2Query(sql), new Node[] { n3, n4, n1, n5, n2 });
    }


    public void testOrderByMVP() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");
        Node n4 = testRootNode.addNode("node4");
        Node n5 = testRootNode.addNode("node5");

        n1.setProperty("extra", new String[] { "12345" });
        n1.setProperty("text", new String[] { "ccc" });

        n2.setProperty("text", new String[] { "eee", "bbb" });
        n3.setProperty("text", new String[] { "aaa" });
        n4.setProperty("text", new String[] { "bbb", "aaa" });
        n5.setProperty("text", new String[] { "eee", "aaa" });

        testRootNode.getSession().save();

        String sql = "SELECT value FROM nt:unstructured WHERE "
                + "jcr:path LIKE '" + testRoot + "/%' ORDER BY text";
        checkResultSequence(executeQuery(sql).getRows(), new Node[] { n3, n4,
                n1, n5, n2 });

        String xpath = "/"
                + testRoot
                + "/*[@jcr:primaryType='nt:unstructured'] order by jcr:score(), @text";
        checkResultSequence(executeQuery(xpath).getRows(), new Node[] { n3, n4,
                n1, n5, n2 });
    }


    public void testOrderByVal() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("value", 3);
        n2.setProperty("value", 1);
        n3.setProperty("value", 2);

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY [value]");
        checkSeq(qr, new Node[] { n2, n3, n1 });
    }


    public void testOrderByValDesc() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("value", 3);
        n2.setProperty("value", 1);
        n3.setProperty("value", 2);

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY [value] desc");
        checkSeq(qr, new Node[] { n1, n3, n2 });
    }


    public void testOrderByValMult() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("value", 2);
        n1.setProperty("text", "b");

        n2.setProperty("value", 1);
        n2.setProperty("text", "x");

        n3.setProperty("value", 2);
        n3.setProperty("text", "a");

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY [value], [text]");
        checkSeq(qr, new Node[] { n2, n3, n1 });
    }


    public void testOrderByValMultDesc() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("value", 2);
        n1.setProperty("text", "b");

        n2.setProperty("value", 1);
        n2.setProperty("text", "x");

        n3.setProperty("value", 2);
        n3.setProperty("text", "a");

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY [value] desc, [text] desc");
        checkSeq(qr, new Node[] { n1, n3, n2 });
    }


    public void testOrderByValMultMix() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("value", 2);
        n1.setProperty("text", "b");

        n2.setProperty("value", 1);
        n2.setProperty("text", "x");

        n3.setProperty("value", 2);
        n3.setProperty("text", "a");

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY [value], [text] desc");
        checkSeq(qr, new Node[] { n2, n1, n3 });
    }


    public void testOrderByFnc() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1", "nt:unstructured");
        Node n2 = testRootNode.addNode("node2", "nt:unstructured");
        Node n3 = testRootNode.addNode("node3", "nt:unstructured");

        n1.setProperty("value", "aaa");
        n2.setProperty("value", "a");
        n3.setProperty("value", "aa");

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY LENGTH([value])");
        checkSeq(qr, new Node[] { n2, n3, n1 });
    }


    public void testOrderByFncDesc() throws RepositoryException {

        Node n1 = testRootNode.addNode("node1", "nt:unstructured");
        Node n2 = testRootNode.addNode("node2", "nt:unstructured");
        Node n3 = testRootNode.addNode("node3", "nt:unstructured");

        n1.setProperty("value", "aaa");
        n2.setProperty("value", "a");
        n3.setProperty("value", "aa");

        testRootNode.getSession().save();

        QueryResult qr = executeSQL2Query("SELECT * FROM [nt:base] WHERE ISCHILDNODE(["
                + testRoot + "]) ORDER BY LENGTH([value]) desc");
        checkSeq(qr, new Node[] { n1, n3, n2 });
    }


    public void testSimpleQuerySQL2() throws Exception {
        Node foo = testRootNode.addNode("foo");
        foo.setProperty("bla", new String[]{"bla"});
        Node bla = testRootNode.addNode("bla");
        bla.setProperty("bla", new String[]{"bla"});

        superuser.getRootNode().save();

        String sql = "SELECT * FROM nt:file" +
                " WHERE jcr:path LIKE '" + testRoot + "/%'"
                + " AND bla = 'bla'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 0);
    }


    public void testSimpleQuerySQL4() throws Exception {
        Node foo = testRootNode.addNode("foo");
        foo.setProperty("bla", new String[]{"bla"});
        Node bla = testRootNode.addNode("bla");
        bla.setProperty("bla", new String[]{"bla"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured WHERE jcr:path LIKE '" + testRoot + "/%'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 2);
    }


    public void testSimpleQuerySQL3() throws Exception {
        Node foo = testRootNode.addNode("foo");
        foo.setProperty("bla", new String[]{"bla"});
        Node bla = testRootNode.addNode("bla");
        bla.setProperty("bla", new String[]{"bla"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured" +
                " WHERE jcr:path LIKE '" + testRoot + "/%'"
                + " AND bla = 'bla'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 2);
    }


    public void testDoubleField() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(1.9928375d)});
        n = testRootNode.addNode("node2");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(0.0d)});
        n = testRootNode.addNode("node3");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(-1.42982475d)});

        testRootNode.save();

        String sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > 0.1e-0";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > -0.1";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > -1.5";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 3);
    }


    public void testLikePatternBetween() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("value", new String[]{"ping"});
        n = testRootNode.addNode("node2");
        n.setProperty("value", new String[]{"pong"});
        n = testRootNode.addNode("node3");
        n.setProperty("value", new String[]{"puung"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'ping'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'p_ng'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'p%ng'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 3);
    }


    public void testLongField() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(1)});
        n = testRootNode.addNode("node2");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(0)});
        n = testRootNode.addNode("node3");
        n.setProperty("value", new Value[]{superuser.getValueFactory().createValue(-1)});

        testRootNode.save();

        String sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > 0";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > -1";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value > -2";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 3);
    }


    public void testLikePattern() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("value", new String[]{"king"});
        n = testRootNode.addNode("node2");
        n.setProperty("value", new String[]{"ping"});
        n = testRootNode.addNode("node3");
        n.setProperty("value", new String[]{"ching"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'ping'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE '_ing'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE '%ing'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 3);
    }


    public void testLikePatternEnd() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("value", new String[]{"bli"});
        n = testRootNode.addNode("node2");
        n.setProperty("value", new String[]{"bla"});
        n = testRootNode.addNode("node3");
        n.setProperty("value", new String[]{"blub"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'bli'";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'bl_'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);

        sql = "SELECT * FROM nt:base WHERE jcr:path LIKE '" + testRoot + "/%' AND value LIKE 'bl%'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 3);
    }


    public void testNoConstraints() throws Exception {
        List<String> expected = new ArrayList<String>(c);
        Query q = newQuery();

        List<String> out = qrToPaths(q.execute());
        assertEquals(c.size(), out.size());
        for (String s : out) {
            assertTrue(expected.remove(s));
        }
        assertTrue(expected.isEmpty());
    }


    public void testLimitEqSize() throws Exception {
        List<String> expected = new ArrayList<String>(c);
        Query q = newQuery();
        q.setOffset(0);
        q.setLimit(c.size());

        List<String> out = qrToPaths(q.execute());
        assertEquals(c.size(), out.size());
        for (String s : out) {
            assertTrue(expected.remove(s));
        }
        assertTrue(expected.isEmpty());
    }


    public void testLimitGtSize() throws Exception {
        List<String> expected = new ArrayList<String>(c);
        Query q = newQuery();
        q.setOffset(0);
        q.setLimit(c.size() * 2);

        List<String> out = qrToPaths(q.execute());
        assertEquals(c.size(), out.size());
        for (String s : out) {
            assertTrue(expected.remove(s));
        }
        assertTrue(expected.isEmpty());
    }


    public void testGetSize() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000]";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            assertEquals("Wrong size of NodeIterator in result",
                    INITIAL_NODE_NUM - i, result.getNodes().getSize());
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testGetSizeOrderByScore() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000] order by jcr:score()";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            assertEquals("Wrong size of NodeIterator in result",
                    INITIAL_NODE_NUM - i, result.getNodes().getSize());
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testIteratorNext() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000]";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            int size = 0;
            for (NodeIterator it = result.getNodes(); it.hasNext(); ) {
                it.nextNode();
                size++;
            }
            assertEquals("Wrong size of NodeIterator in result",
                    INITIAL_NODE_NUM - i, size);
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testIteratorNextOrderByScore() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000] order by jcr:score()";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            int size = 0;
            for (NodeIterator it = result.getNodes(); it.hasNext(); ) {
                it.nextNode();
                size++;
            }
            assertEquals("Wrong size of NodeIterator in result",
                    INITIAL_NODE_NUM - i, size);
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testSkip() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000]";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            for (int j = 0; j < INITIAL_NODE_NUM - i; j++) {
                // skip to each node in the result
                NodeIterator it = result.getNodes();
                it.skip(j);
                long propValue = it.nextNode().getProperty(propertyName1).getLong();
                // expected = number of skipped nodes + number of deleted nodes
                long expected = j + i;
                assertEquals("Wrong node after skip()", expected, propValue);
            }
            try {
                NodeIterator it = result.getNodes();
                it.skip(it.getSize() + 1);
                fail("must throw NoSuchElementException");
            } catch (NoSuchElementException e) {
                // correct
            }
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testSkipOrderByProperty() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 +
                    " < 1000] order by @" + propertyName1;
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            for (int j = 0; j < INITIAL_NODE_NUM - i; j++) {
                // skip to each node in the result
                NodeIterator it = result.getNodes();
                it.skip(j);
                long propValue = it.nextNode().getProperty(propertyName1).getLong();
                // expected = number of skipped nodes + number of deleted nodes
                long expected = j + i;
                assertEquals("Wrong node after skip()", expected, propValue);
            }
            try {
                NodeIterator it = result.getNodes();
                it.skip(it.getSize() + 1);
                fail("must throw NoSuchElementException");
            } catch (NoSuchElementException e) {
                // correct
            }
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testGetPosition() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000]";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            NodeIterator it = result.getNodes();
            assertEquals("Wrong position", 0, it.getPosition());
            int count = 0;
            while (it.hasNext()) {
                long position = it.getPosition();
                it.nextNode();
                assertEquals("Wrong position", count++, position);
            }
            try {
                it.next();
                fail("must throw NoSuchElementException");
            } catch (Exception e) {
                // correct
            }
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testGetPositionOrderBy() throws RepositoryException {
        QueryManager qm = superuser.getWorkspace().getQueryManager();
        for (int i = 0; i < 10; i++) {
            String stmt = testPath + "/*[@" + propertyName1 + " < 1000] order by jcr:score()";
            QueryResult result = qm.createQuery(stmt, Query.XPATH).execute();
            NodeIterator it = result.getNodes();
            assertEquals("Wrong position", 0, it.getPosition());
            int count = 0;
            while (it.hasNext()) {
                long position = it.getPosition();
                it.nextNode();
                assertEquals("Wrong position", count++, position);
            }
            try {
                it.next();
                fail("must throw NoSuchElementException");
            } catch (Exception e) {
                // correct
            }
            // remove node for the next iteration
            testRootNode.getNode("node" + i).remove();
            testRootNode.save();
        }
    }


    public void testQuotedPhraseNoMatch() throws RepositoryException {
        String text = "one two three four";
        String excerpt = createExcerpt("one two three four");
        String terms = "\"five six\"";

        Node n = testRootNode.addNode(nodeName1);
        n.setProperty("text", text);
        n.setProperty("other", terms);
        superuser.save();

        String stmt = getStatement(terms);
        QueryResult result = executeQuery(stmt);
        RowIterator rows = result.getRows();
        assertEquals(1, rows.getSize());
        String ex = rows.nextRow().getValue("rep:excerpt(text)").getString();
        assertEquals("Expected " + excerpt + ", but got ", excerpt, ex);
    }


    public void testQuotedPhraseNoMatchScrambled() throws RepositoryException {
        String text = "one two three four";
        String excerpt = createExcerpt("one two three four");
        String terms = "\"three two\"";

        Node n = testRootNode.addNode(nodeName1);
        n.setProperty("text", text);
        n.setProperty("other", terms);
        superuser.save();

        String stmt = getStatement(terms);
        QueryResult result = executeQuery(stmt);
        RowIterator rows = result.getRows();
        assertEquals(1, rows.getSize());
        String ex = rows.nextRow().getValue("rep:excerpt(text)").getString();
        assertEquals("Expected " + excerpt + ", but got ", excerpt, ex);
    }


    public void testQuotedPhraseNoMatchGap() throws RepositoryException {
        String text = "one two three four";
        String excerpt = createExcerpt("one two three four");
        String terms = "\"two four\"";

        Node n = testRootNode.addNode(nodeName1);
        n.setProperty("text", text);
        n.setProperty("other", terms);
        superuser.save();

        String stmt = getStatement(terms);
        QueryResult result = executeQuery(stmt);
        RowIterator rows = result.getRows();
        assertEquals(1, rows.getSize());
        String ex = rows.nextRow().getValue("rep:excerpt(text)").getString();
        assertEquals("Expected " + excerpt + ", but got ", excerpt, ex);
    }


    public void testOrderByUpperCase() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("text", "Amundsen");
        n2.setProperty("text", "barents");
        n3.setProperty("text", "Wegener");

        testRootNode.save();

        String xpath = "/" + testRoot + "/*[@jcr:primaryType='nt:unstructured'] order by fn:upper-case(@text)";
        Query q = qm.createQuery(xpath, Query.XPATH);
        QueryResult result = q.execute();
        checkResult(result, new Node[]{n1, n2, n3});
    }


    public void testOrderByLowerCase() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");

        n1.setProperty("text", "Amundsen");
        n2.setProperty("text", "barents");
        n3.setProperty("text", "Wegener");

        testRootNode.save();

        String xpath = "/" + testRoot + "/*[@jcr:primaryType='nt:unstructured'] order by fn:lower-case(@text)";
        Query q = qm.createQuery(xpath, Query.XPATH);
        QueryResult result = q.execute();
        checkResult(result, new Node[]{n1, n2, n3});
    }


    public void testSelectSQL() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("myvalue", "foo");
        n = testRootNode.addNode("node2");
        n.setProperty("myvalue", "bar");
        n = testRootNode.addNode("node3");
        n.setProperty("yourvalue", "foo");

        testRootNode.save();

        String sql = "SELECT myvalue FROM " + ntBase + " WHERE " +
                "jcr:path LIKE '" + testRoot + "/%' AND myvalue IS NOT NULL";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 2);

        sql = "SELECT myvalue FROM " + ntBase
                + " WHERE jcr:path LIKE '" + testRoot + "/%'"
                + " AND yourvalue = 'foo' AND myvalue IS NOT NULL";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 0);

        sql = "SELECT myvalue FROM " + ntBase + " WHERE myvalue IS NOT NULL";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2);
    }


    public void testPropertyCountSQL() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("myvalue", "foo");
        n = testRootNode.addNode("node2");
        n.setProperty("myvalue", "bar");
        n = testRootNode.addNode("node3");
        n.setProperty("yourvalue", "foo");

        testRootNode.save();

        String sql = "SELECT myvalue FROM " + ntBase + " WHERE " +
                "jcr:path LIKE '" + testRoot + "/%' AND myvalue IS NOT NULL";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 2, 2);

        sql = "SELECT myvalue FROM " + ntBase
                + " WHERE jcr:path LIKE '" + testRoot + "/%'"
                + " AND yourvalue = 'foo' AND myvalue IS NOT NULL";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 0, 0);

        sql = "SELECT myvalue FROM " + ntBase + " WHERE myvalue IS NOT NULL";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2, 2);

        sql = "SELECT * FROM " + ntBase
                + " WHERE jcr:path LIKE '" + testRoot + "/%'"
                + " AND myvalue LIKE '%'";
        q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        result = q.execute();
        checkResult(result, 2, 2);
    }


    public void testFulltextMultiWordSQL() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"test text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"other text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE \"jcr:path\" LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(., 'fox test')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);
    }


    public void testFulltextExcludeSQL() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"test text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"other text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        superuser.getRootNode().save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE \"jcr:path\" LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(., 'text ''fox jumps'' -other')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);
    }


    public void testFulltextPhraseSQL() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"test text"});
        n.setProperty("mytext", new String[]{"the quick brown jumps fox over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"other text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE \"jcr:path\" LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(., 'text \"fox jumps\"')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 1);
    }


    public void testFulltextOrSQL() throws Exception {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"test text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"other text"});
        n.setProperty("mytext", new String[]{"the quick brown fox jumps over the lazy dog."});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE \"jcr:path\" LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(., '''fox jumps'' test OR other')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        QueryResult result = q.execute();
        checkResult(result, 2);
    }


    public void testContainsStarSQL() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"tEst text"});
        n.setProperty("mytext", new String[]{"The quick brown Fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"The quick brown Fox jumps over the lazy dog."});
        n.setProperty("mytext", new String[]{"text text"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE jcr:path LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(., 'fox jumps')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        checkResult(q.execute(), 2);
    }


    public void testContainsPropScopeSQL() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"tEst text"});
        n.setProperty("mytext", new String[]{"The quick brown Fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"The quick brown Fox jumps over the lazy dog."});
        n.setProperty("mytext", new String[]{"text text"});

        testRootNode.save();

        String sql = "SELECT * FROM nt:unstructured"
                + " WHERE jcr:path LIKE '" + testRoot + "/%"
                + "' AND CONTAINS(title, 'fox jumps')";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.SQL);
        checkResult(q.execute(), 1);
    }


    public void testContainsPropScopeXPath() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"tEst text"});
        n.setProperty("mytext", new String[]{"The quick brown Fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"The quick brown Fox jumps over the lazy dog."});
        n.setProperty("mytext", new String[]{"text text"});

        testRootNode.save();

        String sql = "/jcr:root" + testRoot + "/element(*, nt:unstructured)"
                + "[jcr:contains(@title, 'quick fox')]";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.XPATH);
        checkResult(q.execute(), 1);
    }


    public void testContainsStarXPath() throws RepositoryException {
        Node n = testRootNode.addNode("node1");
        n.setProperty("title", new String[]{"tEst text"});
        n.setProperty("mytext", new String[]{"The quick brown Fox jumps over the lazy dog."});

        n = testRootNode.addNode("node2");
        n.setProperty("title", new String[]{"The quick brown Fox jumps over the lazy dog."});
        n.setProperty("mytext", new String[]{"text text"});

        testRootNode.save();

        String sql = "/jcr:root" + testRoot + "/element(*, nt:unstructured)"
                + "[jcr:contains(., 'quick fox')]";
        Query q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.XPATH);
        checkResult(q.execute(), 2);
    }


    private void assertContainsQuery(String statement, boolean match)
            throws InvalidQueryException, RepositoryException {
        StringBuffer stmt = new StringBuffer();
        stmt.append("/jcr:root").append(testRoot).append("/*");
        stmt.append("[jcr:contains(., '").append(statement);
        stmt.append("')]");

        Query q = superuser.getWorkspace().getQueryManager().createQuery(stmt.toString(), Query.XPATH);
        checkResult(q.execute(), match ? 1 : 0);

        stmt = new StringBuffer();
        stmt.append("SELECT * FROM nt:base ");
        stmt.append("WHERE jcr:path LIKE '").append(testRoot).append("/%' ");
        stmt.append("AND CONTAINS(., '").append(statement).append("')");

        q = superuser.getWorkspace().getQueryManager().createQuery(stmt.toString(), Query.SQL);
        checkResult(q.execute(), match ? 1 : 0);
    }


    private void assertContainsQuery(String statement, boolean match)
            throws InvalidQueryException, RepositoryException {
        StringBuffer stmt = new StringBuffer();
        stmt.append("/jcr:root").append(testRoot).append("/*");
        stmt.append("[jcr:contains(., '").append(statement);
        stmt.append("')]");

        Query q = qm.createQuery(stmt.toString(), Query.XPATH);
        checkResult(q.execute(), match ? 1 : 0);

        stmt = new StringBuffer();
        stmt.append("SELECT * FROM nt:base ");
        stmt.append("WHERE jcr:path LIKE '").append(testRoot).append("/%' ");
        stmt.append("AND CONTAINS(., '").append(statement).append("')");

        q = qm.createQuery(stmt.toString(), Query.SQL);
        checkResult(q.execute(), match ? 1 : 0);
    }


    public void testRelationQuery() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1);
        n1.setProperty(propertyName1, 1);
        Node n2 = testRootNode.addNode(nodeName1);
        n2.setProperty(propertyName1, 2);
        Node n3 = testRootNode.addNode(nodeName1);
        n3.setProperty(propertyName1, 3);

        testRootNode.save();

        String base = testPath + "[" + nodeName1 + "/@" + propertyName1;
        executeXPathQuery(base + " = 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 4]", new Node[]{});
        executeXPathQuery(base + " > 0]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 3]", new Node[]{});
        executeXPathQuery(base + " >= 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 4]", new Node[]{});
        executeXPathQuery(base + " < 1]", new Node[]{});
        executeXPathQuery(base + " < 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " < 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " < 4]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 0]", new Node[]{});
        executeXPathQuery(base + " <= 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 0]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 3]", new Node[]{testRootNode});
    }


    public void testRelationQueryDeep() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1).addNode(nodeName2);
        Node n1 = n.addNode(nodeName3);
        n1.setProperty(propertyName1, 1);
        Node n2 = n.addNode(nodeName3);
        n2.setProperty(propertyName1, 2);
        Node n3 = n.addNode(nodeName3);
        n3.setProperty(propertyName1, 3);

        testRootNode.save();

        String base = testPath + "[" + nodeName1 + "/" + nodeName2 + "/" +
                nodeName3 + "/@" + propertyName1;
        executeXPathQuery(base + " = 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " = 4]", new Node[]{});
        executeXPathQuery(base + " > 0]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " > 3]", new Node[]{});
        executeXPathQuery(base + " >= 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " >= 4]", new Node[]{});
        executeXPathQuery(base + " < 1]", new Node[]{});
        executeXPathQuery(base + " < 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " < 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " < 4]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 0]", new Node[]{});
        executeXPathQuery(base + " <= 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " <= 3]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 0]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 1]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 2]", new Node[]{testRootNode});
        executeXPathQuery(base + " != 3]", new Node[]{testRootNode});
    }


    public void testContains() throws RepositoryException {
        Node level1 = testRootNode.addNode(nodeName1);
        level1.setProperty(propertyName1, "The quick brown fox jumps over the lazy dog.");
        Node level2 = level1.addNode(nodeName2);
        level2.setProperty(propertyName1, "Franz jagt im total verwahrlosten Taxi quer durch Bayern.");
        Node n1 = level2.addNode(nodeName3);
        n1.setProperty(propertyName2, 1);
        Node n2 = level2.addNode(nodeName3);
        n2.setProperty(propertyName2, 2);
        Node n3 = level2.addNode(nodeName3);
        n3.setProperty(propertyName2, 3);

        testRootNode.save();

        String base = testPath + "[jcr:contains(";
        executeXPathQuery(base + nodeName1 + "/@" + propertyName1 + ", 'lazy')" +
                " and " + nodeName1 + "/" + nodeName2 + "/" + nodeName3 + "/@" + propertyName2 + " = 2]",
                new Node[]{testRootNode});
        executeXPathQuery(base + nodeName1 + "/" + nodeName2 + "/@" + propertyName1 + ", 'franz')" +
                " and " + nodeName1 + "/" + nodeName2 + "/" + nodeName3 + "/@" + propertyName2 + " = 3]",
                new Node[]{testRootNode});
        executeXPathQuery(base + nodeName1 + ", 'lazy')" +
                " and " + nodeName1 + "/" + nodeName2 + "/" + nodeName3 + "/@" + propertyName2 + " = 1]",
                new Node[]{testRootNode});
        executeXPathQuery(base + nodeName1 + "/" + nodeName2 + ", 'franz')" +
                " and " + nodeName1 + "/" + nodeName2 + "/" + nodeName3 + "/@" + propertyName2 + " = 1]",
                new Node[]{testRootNode});
    }


    public void testStarNameTest() throws RepositoryException {
        Node level1 = testRootNode.addNode(nodeName1);
        level1.setProperty(propertyName1, "The quick brown fox jumps over the lazy dog.");
        Node level2 = level1.addNode(nodeName2);
        level2.setProperty(propertyName1, "Franz jagt im total verwahrlosten Taxi quer durch Bayern.");
        Node n1 = level2.addNode(nodeName3);
        n1.setProperty(propertyName2, 1);
        Node n2 = level2.addNode(nodeName3);
        n2.setProperty(propertyName2, 2);
        Node n3 = level2.addNode(nodeName4);
        n3.setProperty(propertyName2, 3);

        testRootNode.save();

        String base = testPath + "[jcr:contains(";
        executeXPathQuery(base + nodeName1 + "/@" + propertyName1 + ", 'lazy')" +
                " and " + nodeName1 + "/" + nodeName2 + "/" + nodeName3 + "/@" + propertyName2 + " = 3]",
                new Node[]{});
        executeXPathQuery(base + nodeName1 + "/@" + propertyName1 + ", 'lazy')" +
                " and " + nodeName1 + "/" + nodeName2 + "/*/@" + propertyName2 + " = 3]",
                new Node[]{testRootNode});

        executeXPathQuery(base + "*/@" + propertyName1 + ", 'lazy')]",
                new Node[]{testRootNode});
        executeXPathQuery(base + nodeName1 + "/*, 'franz')]",
                new Node[]{testRootNode});
        executeXPathQuery(base + "*/*, 'franz')]",
                new Node[]{testRootNode});
        executeXPathQuery(base + "*/*, 'lazy')]",
                new Node[]{});
    }


    public void testRemoveFirstNode() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        testRootNode.addNode("node2");
        testRootNode.addNode("node3");
        testRootNode.save();

        // query the workspace for all three nodes
        String stmt = testPath + "/*";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();

        // now remove the first node
        n1.remove();
        testRootNode.save();

        // iterate over nodes
        log.println("Result nodes:");
        int count = 0;
        for (NodeIterator it = res.getNodes(); it.hasNext(); ) {
            assertEquals("Wrong value for getPosition().", count++, it.getPosition());
            try {
                log.println(it.nextNode().getPath());
            } catch (InvalidItemStateException e) {
                // this is allowed
                log.println("Invalid: <deleted>");
            }
        }
    }


    public void testRemoveSomeNodeAfterHasNext() throws RepositoryException {
        testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        testRootNode.addNode("node3");
        testRootNode.save();

        // query the workspace for all three nodes
        String stmt = testPath + "/*";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();

        NodeIterator it = res.getNodes();
        it.hasNext();

        // now remove the second node
        n2.remove();
        testRootNode.save();

        // iterate over nodes
        int count = 0;
        log.println("Result nodes:");
        while (it.hasNext()) {
            assertEquals("Wrong value for getPosition().", count++, it.getPosition());
            try {
                log.println(it.nextNode().getPath());
            } catch (InvalidItemStateException e) {
                // this is allowed
                log.println("Invalid: <deleted>");
            }
        }
    }


    public void testRemoveLastNode() throws RepositoryException {
        testRootNode.addNode("node1");
        testRootNode.addNode("node2");
        Node n3 = testRootNode.addNode("node3");
        testRootNode.save();

        // query the workspace for all three nodes
        String stmt = testPath + "/*";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();

        // now remove the last node
        n3.remove();
        testRootNode.save();

        // iterate over nodes
        int count = 0;
        log.println("Result nodes:");
        for (NodeIterator it = res.getNodes(); it.hasNext(); ) {
            assertEquals("Wrong value for getPosition().", count++, it.getPosition());
            try {
                log.println(it.nextNode().getPath());
            } catch (InvalidItemStateException e) {
                // this is allowed
                log.println("Invalid: <deleted>");
            }
        }
    }


    public void testRemoveSomeNode() throws RepositoryException {
        testRootNode.addNode("node1");
        Node n2 = testRootNode.addNode("node2");
        testRootNode.addNode("node3");
        testRootNode.save();

        // query the workspace for all three nodes
        String stmt = testPath + "/*";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();

        // now remove the second node
        n2.remove();
        testRootNode.save();

        // iterate over nodes
        int count = 0;
        log.println("Result nodes:");
        for (NodeIterator it = res.getNodes(); it.hasNext(); ) {
            assertEquals("Wrong value for getPosition().", count++, it.getPosition());
            try {
                log.println(it.nextNode().getPath());
            } catch (InvalidItemStateException e) {
                // this is allowed
                log.println("Invalid: <deleted>");
            }
        }
    }


    public void testRemoveFirstNodeAfterHasNext() throws RepositoryException {
        Node n1 = testRootNode.addNode("node1");
        testRootNode.addNode("node2");
        testRootNode.addNode("node3");
        testRootNode.save();

        // query the workspace for all three nodes
        String stmt = testPath + "/*";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();

        NodeIterator it = res.getNodes();
        it.hasNext();

        // now remove the first node
        n1.remove();
        testRootNode.save();

        // iterate over nodes
        int count = 0;
        log.println("Result nodes:");
        while (it.hasNext()) {
            assertEquals("Wrong value for getPosition().", count++, it.getPosition());
            try {
                log.println(it.nextNode().getPath());
            } catch (InvalidItemStateException e) {
                // this is allowed
                log.println("Invalid: <deleted>");
            }
        }
    }


    public void testHasDirectory() throws Exception {
        execute(new Callable(){
            public void call(DirectoryManager directoryManager) throws Exception {
                Directory dir = directoryManager.getDirectory(TEST);
                assertTrue(directoryManager.hasDirectory(TEST));
                dir.close();
            }
        });
    }


    public void testDelete() throws Exception {
        execute(new Callable(){
            public void call(DirectoryManager directoryManager) throws Exception {
                directoryManager.getDirectory(TEST).close();
                directoryManager.delete(TEST);
                assertFalse(directoryManager.hasDirectory(TEST));
            }
        });
    }


    public void testRename() throws Exception {
        execute(new Callable(){
            public void call(DirectoryManager directoryManager) throws Exception {
                directoryManager.getDirectory(TEST).close();
                directoryManager.rename(TEST, RENAMED);
                assertTrue(directoryManager.hasDirectory(RENAMED));
                assertFalse(directoryManager.hasDirectory(TEST));
            }
        });
    }


    public void testDeepHierarchy() throws Exception {

        // this parameter IS the 'recursiveLimit' defined in the index
        // config file
        int definedRecursiveLimit = 10;
        int levelsDeep = 14;

        List<Node> allNodes = new ArrayList<Node>();
        List<Node> updatedNodes = new ArrayList<Node>();
        List<Node> staleNodes = new ArrayList<Node>();

        String sqlBase = "SELECT * FROM [nt:folder] as f WHERE ";
        String sqlCat = sqlBase + " CONTAINS (f.*, 'cat')";
        String sqlDog = sqlBase + " CONTAINS (f.*, 'dog')";

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(out, "UTF-8");
        writer.write("the quick brown fox jumps over the lazy dog.");
        writer.flush();

        Node folderRoot = testRootNode.addNode("myFolder", "nt:folder");
        Node folderChild = folderRoot;
        allNodes.add(folderChild);

        for (int i = 0; i < levelsDeep; i++) {
            folderChild.addNode("0" + i + "-dummy", "nt:folder");
            folderChild = folderChild.addNode("0" + i, "nt:folder");
            allNodes.add(folderChild);

            // -2 because:
            // 1 because 'i' starts at 0,
            // +
            // 1 because we are talking about same node type aggregation levels
            // extra to the current node that is updated
            if (i > levelsDeep - definedRecursiveLimit - 2) {
                updatedNodes.add(folderChild);
            }
        }
        staleNodes.addAll(CollectionUtils.disjunction(allNodes, updatedNodes));

        Node file = folderChild.addNode("myFile", "nt:file");
        Node resource = file.addNode("jcr:content", "nt:resource");
        resource.setProperty("jcr:lastModified", Calendar.getInstance());
        resource.setProperty("jcr:encoding", "UTF-8");
        resource.setProperty("jcr:mimeType", "text/plain");
        resource.setProperty("jcr:data", session.getValueFactory()
                .createBinary(new ByteArrayInputStream(out.toByteArray())));

        testRootNode.getSession().save();

        // because of the optimizations, the first save is expected to update
        // ALL nodes
        // executeSQL2Query(sqlDog, allNodes.toArray(new Node[] {}));

        // update jcr:data
        out.reset();
        writer.write("the quick brown fox jumps over the lazy cat.");
        writer.flush();
        resource.setProperty("jcr:data", session.getValueFactory()
                .createBinary(new ByteArrayInputStream(out.toByteArray())));
        testRootNode.getSession().save();
        executeSQL2Query(sqlDog, staleNodes.toArray(new Node[] {}));
        executeSQL2Query(sqlCat, updatedNodes.toArray(new Node[] {}));

        // replace jcr:content with unstructured
        resource.remove();
        Node unstrContent = file.addNode("jcr:content", "nt:unstructured");
        Node foo = unstrContent.addNode("foo");
        foo.setProperty("text", "the quick brown fox jumps over the lazy dog.");
        testRootNode.getSession().save();
        executeSQL2Query(sqlDog, allNodes.toArray(new Node[] {}));
        executeSQL2Query(sqlCat, new Node[] {});

        // remove foo
        foo.remove();
        testRootNode.getSession().save();
        executeSQL2Query(sqlDog, staleNodes.toArray(new Node[] {}));
        executeSQL2Query(sqlCat, new Node[] {});

    }


    public void testUnlimitedRecursiveAggregation() throws Exception {

        long levelsDeep = AggregateRuleImpl.RECURSIVE_AGGREGATION_LIMIT_DEFAULT + 10;
        List<Node> expectedNodes = new ArrayList<Node>();

        String sqlBase = "SELECT * FROM [nt:folder] as f WHERE ";
        String sqlCat = sqlBase + " CONTAINS (f.*, 'cat')";
        String sqlDog = sqlBase + " CONTAINS (f.*, 'dog')";

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(out, "UTF-8");
        writer.write("the quick brown fox jumps over the lazy dog.");
        writer.flush();

        Node folderRoot = testRootNode.addNode("myFolder", "nt:folder");
        Node folderChild = folderRoot;
        expectedNodes.add(folderChild);

        for (int i = 0; i < levelsDeep; i++) {
            folderChild.addNode("0" + i + "-dummy", "nt:folder");
            folderChild = folderChild.addNode("0" + i, "nt:folder");
            expectedNodes.add(folderChild);
        }

        Node file = folderChild.addNode("myFile", "nt:file");
        Node resource = file.addNode("jcr:content", "nt:resource");
        resource.setProperty("jcr:lastModified", Calendar.getInstance());
        resource.setProperty("jcr:encoding", "UTF-8");
        resource.setProperty("jcr:mimeType", "text/plain");
        resource.setProperty("jcr:data", session.getValueFactory()
                .createBinary(new ByteArrayInputStream(out.toByteArray())));

        testRootNode.getSession().save();
        waitForTextExtractionTasksToFinish();
        executeSQL2Query(sqlDog, expectedNodes.toArray(new Node[] {}));

        // update jcr:data
        out.reset();
        writer.write("the quick brown fox jumps over the lazy cat.");
        writer.flush();
        resource.setProperty("jcr:data", session.getValueFactory()
                .createBinary(new ByteArrayInputStream(out.toByteArray())));
        testRootNode.getSession().save();
        waitForTextExtractionTasksToFinish();
        executeSQL2Query(sqlDog, new Node[] {});
        executeSQL2Query(sqlCat, expectedNodes.toArray(new Node[] {}));

        // replace jcr:content with unstructured
        resource.remove();
        Node unstrContent = file.addNode("jcr:content", "nt:unstructured");
        Node foo = unstrContent.addNode("foo");
        foo.setProperty("text", "the quick brown fox jumps over the lazy dog.");
        testRootNode.getSession().save();
        waitForTextExtractionTasksToFinish();
        executeSQL2Query(sqlDog, expectedNodes.toArray(new Node[] {}));
        executeSQL2Query(sqlCat, new Node[] {});

        // remove foo
        foo.remove();
        testRootNode.getSession().save();
        waitForTextExtractionTasksToFinish();
        executeSQL2Query(sqlDog, new Node[] {});
        executeSQL2Query(sqlCat, new Node[] {});

    }


    public void testDefaultRecursiveAggregation() throws Exception {

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(out, "UTF-8");
        writer.write("the quick brown fox jumps over the lazy dog.");
        writer.flush();

        Node parent = testRootNode.addNode(
                "testDefaultRecursiveAggregation_parent",
                JcrConstants.NT_UNSTRUCTURED);

        Node child = parent.addNode("testDefaultRecursiveAggregation_child",
                JcrConstants.NT_UNSTRUCTURED);
        child.setProperty("type", "testnode");
        child.setProperty("jcr:encoding", "UTF-8");
        child.setProperty("jcr:mimeType", "text/plain");
        child.setProperty(
                "jcr:data",
                session.getValueFactory().createBinary(
                        new ByteArrayInputStream(out.toByteArray())));
        testRootNode.getSession().save();

        String sqlBase = "SELECT * FROM [nt:unstructured] as u WHERE CONTAINS (u.*, 'dog') ";
        String sqlParent = sqlBase + " AND ISCHILDNODE([" + testRoot + "])";
        String sqlChild = sqlBase + " AND ISCHILDNODE([" + parent.getPath()
                + "])";

        executeSQL2Query(sqlParent, new Node[] {});
        executeSQL2Query(sqlChild, new Node[] { child });
    }


    public void testNegativeRecursiveAggregationLimit() throws Exception {

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(out, "UTF-8");
        writer.write("the quick brown fox jumps over the lazy dog.");
        writer.flush();

        Node parent = testRootNode.addNode(
                "testDefaultRecursiveAggregation_parent",
                JcrConstants.NT_UNSTRUCTURED);

        Node child = parent.addNode("testDefaultRecursiveAggregation_child",
                JcrConstants.NT_UNSTRUCTURED);
        child.setProperty("type", "testnode");
        child.setProperty("jcr:encoding", "UTF-8");
        child.setProperty("jcr:mimeType", "text/plain");
        child.setProperty(
                "jcr:data",
                session.getValueFactory().createBinary(
                        new ByteArrayInputStream(out.toByteArray())));
        testRootNode.getSession().save();

        String sqlBase = "SELECT * FROM [nt:unstructured] as u WHERE CONTAINS (u.*, 'dog') ";
        String sqlParent = sqlBase + " AND ISCHILDNODE([" + testRoot + "])";
        String sqlChild = sqlBase + " AND ISCHILDNODE([" + parent.getPath()
                + "])";

        executeSQL2Query(sqlParent, new Node[] {});
        executeSQL2Query(sqlChild, new Node[] { child });
    }


    public void testRecursiveAggregationExclusion() throws Exception {

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(out, "UTF-8");
        writer.write("the quick brown fox jumps over the lazy dog.");
        writer.flush();

        Node parent = testRootNode.addNode(
                "testDefaultRecursiveAggregation_parent",
                JcrConstants.NT_UNSTRUCTURED);

        Node child = parent.addNode("aggregated-node",
                JcrConstants.NT_UNSTRUCTURED);
        child.setProperty("type", "testnode");
        child.setProperty("jcr:encoding", "UTF-8");
        child.setProperty("jcr:mimeType", "text/plain");
        child.setProperty(
                "jcr:data",
                session.getValueFactory().createBinary(
                        new ByteArrayInputStream(out.toByteArray())));
        testRootNode.getSession().save();

        String sqlBase = "SELECT * FROM [nt:unstructured] as u WHERE CONTAINS (u.*, 'dog') ";
        String sqlParent = sqlBase + " AND ISCHILDNODE([" + testRoot + "])";
        String sqlChild = sqlBase + " AND ISCHILDNODE([" + parent.getPath()
                + "])";
        executeSQL2Query(sqlParent, new Node[] {});
        executeSQL2Query(sqlChild, new Node[] { child });
    }


    public void testIndexMissesNode() throws Exception {

        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        Node foo = testRootNode.addNode("foo");
        testRootNode.getSession().save();
        NodeId fooId = new NodeId(foo.getIdentifier());

        Iterator<NodeId> remove = Collections.singletonList(fooId).iterator();
        Iterator<NodeState> add = Collections.<NodeState>emptyList().iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();
        assertEquals("Expected 1 index consistency error", 1, errors.size());

        ConsistencyCheckError error = errors.iterator().next();
        assertEquals("Different node was reported to be missing", error.id, fooId);

        consistencyCheck.repair(false);

        assertTrue("Index was not repaired properly", searchIndexContainsNode(searchIndex, fooId));

        assertTrue("Consistency check still reports errors", searchIndex.runConsistencyCheck().getErrors().isEmpty());
    }


    public void testMissingNodeDoubleCheck() throws Exception {
        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        Node foo = testRootNode.addNode("foo");
        testRootNode.getSession().save();
        NodeId fooId = new NodeId(foo.getIdentifier());

        Iterator<NodeId> remove = Collections.singletonList(fooId).iterator();
        Iterator<NodeState> add = Collections.<NodeState>emptyList().iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();
        assertEquals("Expected 1 index consistency error", 1, errors.size());

        // now add foo to the index again so that double check finds a false positive
        remove = Collections.<NodeId>emptyList().iterator();
        add = Collections.singletonList(new NodeState(fooId, null, null, 1, false)).iterator();

        searchIndex.updateNodes(remove, add);

        consistencyCheck.doubleCheckErrors();

        assertTrue("Consistency double check of missing node failed", consistencyCheck.getErrors().isEmpty());

    }


    public void testIndexMissesAncestor() throws Exception {
        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        Node foo = testRootNode.addNode("foo");
        Node bar = foo.addNode("bar");
        testRootNode.getSession().save();
        NodeId fooId = new NodeId(foo.getIdentifier());
        NodeId barId = new NodeId(bar.getIdentifier());

        Iterator<NodeId> remove = Collections.singletonList(fooId).iterator();
        Iterator<NodeState> add = Collections.<NodeState>emptyList().iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();

        assertEquals("Expected 2 index consistency errors", 2, errors.size());

        assertEquals("Different node was reported to have missing parent", errors.get(0).id, barId);
        assertEquals("Different node was reported to be missing", errors.get(1).id, fooId);

        consistencyCheck.repair(false);

        assertTrue("Index was not repaired properly", searchIndexContainsNode(searchIndex, fooId));

        assertTrue("Consistency check still reports errors", searchIndex.runConsistencyCheck().getErrors().isEmpty());
    }


    public void testIndexContainsUnknownNode() throws Exception {

        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        NodeId nodeId = new NodeId(0, 0);
        NodeState nodeState = new NodeState(nodeId, null, null, 1, false);

        Iterator<NodeId> remove = Collections.<NodeId>emptyList().iterator();
        Iterator<NodeState> add = Collections.singletonList(nodeState).iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();
        assertEquals("Expected 1 index consistency error", 1, errors.size());

        ConsistencyCheckError error = errors.iterator().next();
        assertEquals("Different node was reported to be unknown", error.id, nodeId);

        consistencyCheck.repair(false);

        assertFalse("Index was not repaired properly", searchIndexContainsNode(searchIndex, nodeId));

        assertTrue("Consistency check still reports errors", searchIndex.runConsistencyCheck().getErrors().isEmpty());
    }


    public void testMissingAncestorDoubleCheck() throws Exception {

        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        Node foo = testRootNode.addNode("foo");
        foo.addNode("bar");
        testRootNode.getSession().save();
        NodeId fooId = new NodeId(foo.getIdentifier());

        Iterator<NodeId> remove = Collections.singletonList(fooId).iterator();
        Iterator<NodeState> add = Collections.<NodeState>emptyList().iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();

        assertEquals("Expected 2 index consistency errors", 2, errors.size());

        remove = Collections.<NodeId>emptyList().iterator();
        add = Collections.singletonList(new NodeState(fooId, null, null, 1, true)).iterator();

        searchIndex.updateNodes(remove, add);

        consistencyCheck.doubleCheckErrors();

        assertTrue("Consistency double check of missing ancestor failed", consistencyCheck.getErrors().isEmpty());
    }


    public void testUnknownNodeDoubleCheck() throws Exception {

        Session s = getHelper().getSuperuserSession();
        SearchManager searchManager = TestHelper.getSearchManager(s);
        SearchIndex searchIndex = (SearchIndex) searchManager.getQueryHandler();

        NodeId nodeId = new NodeId(0, 0);
        NodeState nodeState = new NodeState(nodeId, null, null, 1, false);

        Iterator<NodeId> remove = Collections.<NodeId>emptyList().iterator();
        Iterator<NodeState> add = Collections.singletonList(nodeState).iterator();

        searchIndex.updateNodes(remove, add);

        ConsistencyCheck consistencyCheck = searchIndex.runConsistencyCheck();
        List<ConsistencyCheckError> errors = consistencyCheck.getErrors();
        assertEquals("Expected 1 index consistency error", 1, errors.size());

        // now remove the unknown node from the index again so that double check finds a false positive
        remove = Collections.singletonList(nodeId).iterator();
        add = Collections.<NodeState>emptyList().iterator();

        searchIndex.updateNodes(remove, add);

        consistencyCheck.doubleCheckErrors();

        assertTrue("Consistency double check of deleted node failed", consistencyCheck.getErrors().isEmpty());
    }


    private boolean searchIndexContainsNode(SearchIndex searchIndex, NodeId nodeId) throws IOException {
        final List<Integer> docs = new ArrayList<Integer>(1);
        final IndexReader reader = searchIndex.getIndexReader();
        try {
            IndexSearcher searcher = new IndexSearcher(reader);
            try {
                Query q = new TermQuery(new Term(FieldNames.UUID, nodeId.toString()));
                searcher.search(q, new AbstractHitCollector() {
                    @Override
                    protected void collect(final int doc, final float score) {
                        docs.add(doc);
                    }
                });
            } finally {
                searcher.close();
            }
        } finally {
            Util.closeOrRelease(reader);
        }
        return !docs.isEmpty();

    }


    List<Document> getNodeDocuments(NodeId id) throws RepositoryException, IOException {
        final List<Integer> docIds = new ArrayList<Integer>(1);
        final List<Document> docs = new ArrayList<Document>();
        final IndexReader reader = getIndexReader();
        try {
            IndexSearcher searcher = new IndexSearcher(reader);
            try {
                Query q = new TermQuery(new Term(FieldNames.UUID, id.toString()));
                searcher.search(q, new AbstractHitCollector() {
                    @Override
                    protected void collect(final int doc, final float score) {
                        docIds.add(doc);
                    }
                });
                for (Integer docId : docIds) {
                    docs.add(reader.document(docId, FieldSelectors.UUID_AND_PARENT));
                }
            } finally {
                searcher.close();
            }
        } finally {
            Util.closeOrRelease(reader);
        }
        return docs;
    }


    public Iterable<NodeId> getWeaklyReferringNodes(NodeId id)
            throws RepositoryException, IOException {
        final List<Integer> docs = new ArrayList<Integer>();
        final List<NodeId> ids = new ArrayList<NodeId>();
        final IndexReader reader = getIndexReader();
        try {
            IndexSearcher searcher = new IndexSearcher(reader);
            try {
                Query q = new TermQuery(new Term(
                        FieldNames.WEAK_REFS, id.toString()));
                searcher.search(q, new AbstractHitCollector() {
                    @Override
                    public void collect(int doc, float score) {
                        docs.add(doc);
                    }
                });
            } finally {
                searcher.close();
            }
            for (Integer doc : docs) {
                Document d = reader.document(doc, FieldSelectors.UUID);
                ids.add(new NodeId(d.get(FieldNames.UUID)));
            }
        } finally {
            Util.closeOrRelease(reader);
        }
        return ids;
    }


    protected void checkResult(QueryResult result, int hits, int columns)
            throws RepositoryException {
        checkResult(result, hits);
        // now check column count
        int count = 0;
        log.println("Properties:");
        String[] propNames = result.getColumnNames();
        for (RowIterator it = result.getRows(); it.hasNext(); count++) {
            StringBuffer msg = new StringBuffer();
            Value[] values = it.nextRow().getValues();
            for (int i = 0; i < propNames.length; i++) {
                msg.append("  ").append(propNames[i]).append(": ");
                if (values[i] == null) {
                    msg.append("null");
                } else {
                    msg.append(values[i].getString());
                }
            }
            log.println(msg);
        }
        if (count == 0) {
            log.println("  NONE");
        }
        assertEquals("Wrong column count.", columns, count);
    }


    protected void checkResult(QueryResult result, int hits, int properties)
            throws RepositoryException {
        checkResult(result, hits);
        // now check property count
        int count = 0;
        log.println("Properties:");
        String[] propNames = result.getColumnNames();
        for (RowIterator it = result.getRows(); it.hasNext();) {
            StringBuffer msg = new StringBuffer();
            Value[] values = it.nextRow().getValues();
            for (int i = 0; i < propNames.length; i++, count++) {
                msg.append("  ").append(propNames[i]).append(": ");
                if (values[i] == null) {
                    msg.append("null");
                } else {
                    msg.append(values[i].getString());
                }
            }
            log.println(msg);
        }
        if (count == 0) {
            log.println("  NONE");
        }
        assertEquals("Wrong property count.", properties, count);
    }


    public void testDoubleBackReference() throws Exception {
        Session session1 = createSession();
        Node bses1 = getTestRootNode(session1).getNode("A").getNode("B");
        getTestRootNode(session1).getNode("C").setProperty("ref to B", bses1);

        Session session2 = createSession();
        Node bses2 = getTestRootNode(session2).getNode("A").getNode("B");
        getTestRootNode(session2).getNode("C").setProperty("ref to B", bses2);

        saveAndlogout(session1, session2);
        assertRemoveTestNodes();
    }


    public void testMisdirectedBackRef() throws Exception {
        Session session2 = createSession();
        Node bses2 = getTestRootNode(session2).getNode("A").getNode("B");
        getTestRootNode(session2).getNode("C").setProperty("ref", bses2);

        Session session3 = createSession();
        Node ases3 = getTestRootNode(session3).getNode("A");
        getTestRootNode(session3).getNode("C").setProperty("ref", ases3);

        saveAndlogout(session2, session3);
        assertRemoveTestNodes();
    }


    public void testDoubleBackRefReferenceMultiValued() throws Exception {
        Session session2 = createSession();
        ValueFactory valFac2 = session2.getValueFactory();
        Node bses2 = getTestRootNode(session2).getNode("A").getNode("B");
        getTestRootNode(session2).getNode("C").setProperty("ref to B",
            new Value[]{valFac2.createValue(bses2), valFac2.createValue(bses2)});

        Session session3 = createSession();
        ValueFactory valFac3 = session3.getValueFactory();
        Node bses3 = getTestRootNode(session3).getNode("A").getNode("B");
        getTestRootNode(session3).getNode("C").setProperty("ref to B",
            new Value[]{valFac3.createValue(bses3), valFac3.createValue(bses3)});

        saveAndlogout(session2, session3);
        assertRemoveTestNodes();
    }


    public void testRegularReference() throws Exception {
        Session session1 = createSession();
        Node bses1 = getTestRootNode(session1).getNode("A").getNode("B");
        getTestRootNode(session1).getNode("A").setProperty("ref to B", bses1);

        Session session2 = createSession();
        ValueFactory valFac2 = session2.getValueFactory();
        Node bses2 = getTestRootNode(session2).getNode("A").getNode("B");
        getTestRootNode(session2).getNode("C").setProperty("ref to B",
            new Value[]{valFac2.createValue(bses2), valFac2.createValue(bses2)});
        getTestRootNode(session2).getNode("C").setProperty("another ref to B", bses2);

        saveAndlogout(session1, session2);
        assertRemoveTestNodes();
    }


    public void testMisdirectedBackRefMultiValued() throws Exception {
        Session session2 = createSession();
        ValueFactory valFac2 = session2.getValueFactory();
        Node ases2 = getTestRootNode(session2).getNode("A");
        getTestRootNode(session2).getNode("C").setProperty("ref",
            new Value[]{valFac2.createValue(ases2), valFac2.createValue(ases2)});

        Session session3 = createSession();
        ValueFactory valFac3 = session3.getValueFactory();
        Node bses3 = getTestRootNode(session3).getNode("A").getNode("B");
        getTestRootNode(session3).getNode("C").setProperty("ref", new Value[]{valFac3.createValue(bses3)});

        saveAndlogout(session2, session3);
        assertRemoveTestNodes();
    }


    public void testImportACL() throws Exception {
        NodeImpl target = (NodeImpl) testRootNode;
        try {

            InputStream in = new ByteArrayInputStream(XML_POLICY_TREE.getBytes("UTF-8"));
            SessionImporter importer = new SessionImporter(target, sImpl,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, new PseudoConfig());
            ImportHandler ih = new ImportHandler(importer, sImpl);
            new ParsingContentHandler(ih).parse(in);

            assertTrue(target.hasNode("test"));
            String path = target.getNode("test").getPath();

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(path);

            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof JackrabbitAccessControlList);

            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(1, entries.length);

            AccessControlEntry entry = entries[0];
            assertEquals("everyone", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if(entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }

        } finally {
            superuser.refresh(false);
        }
    }


    public void testImportACLOnly() throws Exception {
        try {
            NodeImpl target = (NodeImpl) testRootNode.addNode(nodeName1);
            target.addMixin("rep:AccessControllable");

            InputStream in = new ByteArrayInputStream(XML_POLICY_TREE_3.getBytes("UTF-8"));
            SessionImporter importer = new SessionImporter(target, sImpl,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, new PseudoConfig());
            ImportHandler ih = new ImportHandler(importer, sImpl);
            new ParsingContentHandler(ih).parse(in);

            String path = target.getPath();

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(path);

            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof JackrabbitAccessControlList);

            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(2, entries.length);

            AccessControlEntry entry = entries[0];
            assertEquals("everyone", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            entry = entries[1];
            assertEquals("admin", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if(entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }
        } finally {
            superuser.refresh(false);
        }
    }


    public void testImportACLRemoveACE() throws Exception {
        try {
            NodeImpl target = (NodeImpl) testRootNode.addNode(nodeName1);
            target.addMixin("rep:AccessControllable");

            InputStream in = new ByteArrayInputStream(XML_POLICY_TREE_3.getBytes("UTF-8"));
            SessionImporter importer = new SessionImporter(target, sImpl,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, new PseudoConfig());
            ImportHandler ih = new ImportHandler(importer, sImpl);
            new ParsingContentHandler(ih).parse(in);

            in = new ByteArrayInputStream(XML_POLICY_TREE_5.getBytes("UTF-8"));
            importer = new SessionImporter(target, sImpl,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, new PseudoConfig());
            ih = new ImportHandler(importer, sImpl);
            new ParsingContentHandler(ih).parse(in);

            String path = target.getPath();

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(path);

            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof JackrabbitAccessControlList);

            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(1, entries.length);

            AccessControlEntry entry = entries[0];
            assertEquals("admin", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if(entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }
        } finally {
            superuser.refresh(false);
        }
    }


    public void testImportACLUnknown() throws Exception {
        try {
            NodeImpl target = (NodeImpl) testRootNode.addNode(nodeName1);
            target.addMixin("rep:AccessControllable");

            InputStream in = new ByteArrayInputStream(XML_POLICY_TREE_4.getBytes("UTF-8"));
            SessionImporter importer = new SessionImporter(target, sImpl,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, new PseudoConfig());
            ImportHandler ih = new ImportHandler(importer, sImpl);
            new ParsingContentHandler(ih).parse(in);

            String path = target.getPath();

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(path);

            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof JackrabbitAccessControlList);

            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(2, entries.length);

            AccessControlEntry entry = entries[0];
            assertEquals("unknownprincipal", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            entry = entries[1];
            assertEquals("admin", entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if(entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }
        } finally {
            superuser.refresh(false);
        }
    }


    protected void setUp() throws Exception {
        final Properties sysProps = System.getProperties();
        if (!sysProps.containsKey("tests.oracle.url")
            || !sysProps.containsKey("tests.oracle.user")
            || !sysProps.containsKey("tests.oracle.password")
            || !sysProps.containsKey("tests.oracle.tablespace")
            || !sysProps.containsKey("tests.oracle.indexTablespace")) {
            throw new IllegalStateException("Missing system property for test");
        }
        dir = File.createTempFile("jackrabbit_", null, new File("target"));
        dir.delete();
        dir.mkdir();
        final InputStream in = getClass().getResourceAsStream(
                "/org/apache/jackrabbit/core/repository-oracle.xml");
        config = RepositoryConfig.create(in, dir.getPath());
    }


    protected void setUp() throws Exception {
        final Properties sysProps = System.getProperties();
        if (!sysProps.containsKey("tests.oracle.url")
            || !sysProps.containsKey("tests.oracle.user")
            || !sysProps.containsKey("tests.oracle.password")
            || !sysProps.containsKey("tests.oracle.tablespace")) {
            throw new IllegalStateException("Missing system property for test");
        }
        dir = File.createTempFile("jackrabbit_", null, new File("target"));
        dir.delete();
        dir.mkdir();
        final InputStream in = getClass().getResourceAsStream(
                "/org/apache/jackrabbit/core/repository-oracle-compat.xml");
        config = RepositoryConfig.create(in, dir.getPath());
    }


    public void testRemoveInvalidHold() throws RepositoryException, NotExecutableException {
        final Hold h = retentionMgr.addHold(testNodePath, getHoldName(), true);

        try {
            Hold invalidH = new Hold() {
                public boolean isDeep() throws RepositoryException {
                    return h.isDeep();
                }
                public String getName() throws RepositoryException {
                    return h.getName();
                }
            };
            retentionMgr.removeHold(testNodePath, invalidH);
            fail("An invalid hold impl. should not be removable.");

        } catch (RepositoryException e) {
            // success
        }
    }


    public void testRemoveInvalidHold2() throws RepositoryException, NotExecutableException {
        final Hold h = retentionMgr.addHold(testNodePath, getHoldName(), true);

        try {
            Hold invalidH = new Hold() {
                public boolean isDeep() throws RepositoryException {
                    return h.isDeep();
                }
                public String getName() throws RepositoryException {
                    return "anyName";
                }
            };
            retentionMgr.removeHold(testNodePath, invalidH);
            fail("An invalid hold impl. should not be removable.");

        } catch (RepositoryException e) {
            // success
        }
    }


    public void testRemoveInvalidHold3() throws RepositoryException, NotExecutableException {
        final Hold h = retentionMgr.addHold(testNodePath, getHoldName(), true);

        try {
            Hold invalidH = new Hold() {
                public boolean isDeep() throws RepositoryException {
                    return !h.isDeep();
                }
                public String getName() throws RepositoryException {
                    return h.getName();
                }
            };
            retentionMgr.removeHold(testNodePath, invalidH);
            fail("An invalid hold impl. should not be removable.");

        } catch (RepositoryException e) {
            // success
        }
    }


    public void testSetInvalidRetentionPolicy() {
        try {
            RetentionPolicy invalidRPolicy = new RetentionPolicy() {
                public String getName() throws RepositoryException {
                    return "anyName";
                }
            };
            retentionMgr.setRetentionPolicy(testNodePath, invalidRPolicy);
            fail("Setting an invalid retention policy must fail.");
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testInvalidName() {
        try {
            RetentionPolicy rp = new RetentionPolicy() {
                public String getName() throws RepositoryException {
                    return "*.[y]";
                }
            };
            retentionMgr.setRetentionPolicy(testNodePath, rp);
            fail("Setting a policy with an invalid JCR name must fail.");
        } catch (RepositoryException e) {
            // success
        } catch (IllegalArgumentException e) {
            // fine as well.
        }
    }


    public void testReadHoldFromFile() throws RepositoryException {
        PathResolver resolver = (SessionImpl) superuser;
        RetentionRegistryImpl re = new RetentionRegistryImpl((SessionImpl) superuser, createFileSystem());
        try {
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childN3.getPath()), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath + "/somechild"), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath + "/hold/is/deep"), false));

            assertFalse(re.hasEffectiveHold(resolver.getQPath(testNodePath), false));
            assertFalse(re.hasEffectiveHold(resolver.getQPath(childN2.getPath()), false));

        } finally {
            re.close();
        }
    }


    public void testWriteFile() throws RepositoryException {
        PathResolver resolver = (SessionImpl) superuser;
        FileSystem fs = createFileSystem();
        RetentionRegistryImpl re = new RetentionRegistryImpl((SessionImpl) superuser, fs);

        try {
            // write the changes to the fs
            re.close();

            // create a new dummy registry again.
            re = new RetentionRegistryImpl((SessionImpl) superuser, fs);

            // test holds
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childN3.getPath()), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath + "/somechild"), false));
            assertTrue(re.hasEffectiveHold(resolver.getQPath(childNPath + "/hold/is/deep"), false));

            // test policies
            assertTrue(re.hasEffectiveRetention(resolver.getQPath(childNPath), false));
            assertTrue(re.hasEffectiveRetention(resolver.getQPath(childNPath + "/somechild"), true));
        } finally {
            re.close();
        }
    }


    public void testAddHold() throws RepositoryException, NotExecutableException {
        SessionImpl s = (SessionImpl) getHelper().getSuperuserSession();
        RetentionRegistry re = s.getRetentionRegistry();
        Hold h = null;
        try {
            h = retentionMgr.addHold(childN2.getPath(), getHoldName(), false);
            // hold must not be effective yet
            assertFalse(re.hasEffectiveHold(s.getQPath(childN2.getPath()), false));

            superuser.save();
            assertTrue(re.hasEffectiveHold(s.getQPath(childN2.getPath()), false));

        } finally {
            s.logout();

            if (h != null) {
                retentionMgr.removeHold(childN2.getPath(), h);
                superuser.save();
            }
        }
    }


    public void testSetRetentionPolicy() throws RepositoryException, NotExecutableException {
        SessionImpl s = (SessionImpl) getHelper().getSuperuserSession();
        RetentionRegistry re = s.getRetentionRegistry();
        try {
            retentionMgr.setRetentionPolicy(childN2.getPath(), getApplicableRetentionPolicy("test2"));
            // retention must not be effective yet
            assertFalse(re.hasEffectiveRetention(s.getQPath(childN2.getPath()), false));

            superuser.save();
            assertTrue(re.hasEffectiveRetention(s.getQPath(childN2.getPath()), false));

        } finally {
            s.logout();

            retentionMgr.removeRetentionPolicy(childN2.getPath());
            superuser.save();
        }
    }


    public void testChangeRetentionPolicy() throws RepositoryException, NotExecutableException {
        SessionImpl s = (SessionImpl) getHelper().getSuperuserSession();
        RetentionRegistry re = s.getRetentionRegistry();
        try {
            retentionMgr.setRetentionPolicy(childN2.getPath(), getApplicableRetentionPolicy("test2"));
            superuser.save();
            retentionMgr.setRetentionPolicy(childN2.getPath(), getApplicableRetentionPolicy("test3"));
            superuser.save();

            assertTrue(re.hasEffectiveRetention(s.getQPath(childN2.getPath()), false));

        } finally {
            s.logout();

            retentionMgr.removeRetentionPolicy(childN2.getPath());
            superuser.save();
        }
    }


    public void testCanHandle() throws RepositoryException {
        Authentication a = new SimpleCredentialsAuthentication(user);
        assertFalse(a.canHandle(null));
        assertFalse(a.canHandle(creds));
        assertTrue(a.canHandle(simpleEmpty));
        assertTrue(a.canHandle(simpleNull));


        a = new SimpleCredentialsAuthentication(new DummyUserImpl(null));
        assertFalse(a.canHandle(null));
        assertFalse(a.canHandle(creds));
        assertFalse(a.canHandle(simpleEmpty));

        a = new SimpleCredentialsAuthentication(new DummyUserImpl(creds));
        assertFalse(a.canHandle(null));
        assertFalse(a.canHandle(creds));
        assertFalse(a.canHandle(simpleEmpty));

        a = new SimpleCredentialsAuthentication(new DummyUserImpl(simpleAA));
        assertFalse(a.canHandle(null));
        assertFalse(a.canHandle(creds));
        assertTrue(a.canHandle(simpleEmpty));
        assertTrue(a.canHandle(simpleNull));
        assertTrue(a.canHandle(simpleAB));
    }


    public void testAuthenticate() throws RepositoryException {
        Authentication a = new SimpleCredentialsAuthentication(user);
        assertFalse(a.authenticate(simpleEmpty));
        assertFalse(a.authenticate(simpleNull));
        assertFalse(a.authenticate(simpleAA));

        a = new SimpleCredentialsAuthentication(new DummyUserImpl(null));
        assertFalse(a.authenticate(simpleEmpty));
        assertFalse(a.authenticate(simpleAA));

        a = new SimpleCredentialsAuthentication(new DummyUserImpl(creds));
        assertFalse(a.authenticate(simpleEmpty));
        assertFalse(a.authenticate(simpleAA));

        a = new SimpleCredentialsAuthentication(new DummyUserImpl(simpleAA));
        assertFalse(a.authenticate(simpleEmpty));
        assertFalse(a.authenticate(simpleBB));
        assertFalse(a.authenticate(simpleAB));
        assertTrue(a.authenticate(simpleAA));
    }


    public void testDisabledTokenCredentials() throws Exception {
        simpleCredentials.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");
        try {
            AuthContext ac = getAuthContext(simpleCredentials, DISABLE_TOKEN_CONFIG);
            ac.login();

            Subject subject = ac.getSubject();

            assertFalse(subject.getPrincipals().isEmpty());
            assertFalse(subject.getPublicCredentials().isEmpty());
            assertFalse(subject.getPublicCredentials(SimpleCredentials.class).isEmpty());
            assertTrue(subject.getPublicCredentials(TokenCredentials.class).isEmpty());
            assertEquals(1, subject.getPublicCredentials(Credentials.class).size());

            ac.logout();
        } finally {
            simpleCredentials.removeAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE);
        }
    }


    public void testTokenConfigurationWithJaas() throws Exception {
        // define the location of the JAAS configuration
        System.setProperty(
                "java.security.auth.login.config",
                "target/test-classes/jaas.config");

        simpleCredentials.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");
        try {
            AuthContext ac = getJAASAuthContext(simpleCredentials, "defaultLoginModuleTest");
            ac.login();

            Subject subject = ac.getSubject();

            assertFalse(subject.getPrincipals().isEmpty());
            assertFalse(subject.getPublicCredentials().isEmpty());
            assertFalse(subject.getPublicCredentials(SimpleCredentials.class).isEmpty());

            assertTrue(subject.getPublicCredentials(TokenCredentials.class).isEmpty());

            assertEquals(1, subject.getPublicCredentials(Credentials.class).size());

            ac.logout();
        } finally {
            simpleCredentials.removeAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE);
        }
    }


    public void testConcurrentLogin() throws RepositoryException, NotExecutableException {
        final Exception[] exception = new Exception[1];
        List<Thread> testRunner = new ArrayList<Thread>();
        for (int i = 0; i < 10; i++) {
            testRunner.add(new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; i < 100; i++) {
                        try {
                            SimpleCredentials sc = new SimpleCredentials(testuser.getID(), testuser.getID().toCharArray());
                            sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");

                            Session s = getHelper().getRepository().login(sc);
                            try {
                                Set<TokenCredentials> tcs = ((SessionImpl) s).getSubject().getPublicCredentials(TokenCredentials.class);
                                assertFalse(tcs.isEmpty());
                            } finally {
                                s.logout();
                            }
                        } catch (Exception e) {
                            exception[0] = e;
                            break;
                        }
                    }
                }
            }));
        }

        // start threads
        for (Object aTestRunner : testRunner) {
            ((Thread) aTestRunner).start();
        }

        // join threads
        for (Object aTestRunner : testRunner) {
            try {
                ((Thread) aTestRunner).join();
            } catch (InterruptedException e) {
                fail(e.toString());
            }
        }

        if (exception[0] != null) {
            fail(exception[0].toString());
        }
    }


    public void testConcurrentLoginOfDifferentUsers() throws RepositoryException, NotExecutableException {
        final Exception[] exception = new Exception[1];
        List<Thread> testRunner = new ArrayList<Thread>();
        for (int i = 0; i < 10; i++) {
            testRunner.add(new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; i < 100; i++) {
                        try {
                            SimpleCredentials c;
                            double rand = 3 * Math.random();
                            int index = (int) Math.floor(rand);
                            switch (index) {
                                case 0:
                                    c = new SimpleCredentials(testuser.getID(), testuser.getID().toCharArray());
                                    break;
                                case 1:
                                    c = new SimpleCredentials(getHelper().getProperty(RepositoryStub.PROP_PREFIX + "." + RepositoryStub.PROP_SUPERUSER_NAME), getHelper().getProperty(RepositoryStub.PROP_PREFIX + "." + RepositoryStub.PROP_SUPERUSER_PWD).toCharArray());
                                    break;
                                default:
                                    c = new SimpleCredentials(getHelper().getProperty(RepositoryStub.PROP_PREFIX + "." + RepositoryStub.PROP_READONLY_NAME), getHelper().getProperty(RepositoryStub.PROP_PREFIX + "." + RepositoryStub.PROP_READONLY_PWD).toCharArray());
                                    break;
                            }
                            c.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");
                            Session s = getHelper().getRepository().login(c);
                            try {
                                Set<TokenCredentials> tcs = ((SessionImpl) s).getSubject().getPublicCredentials(TokenCredentials.class);
                                assertFalse(tcs.isEmpty());
                            } finally {
                                s.logout();
                            }
                        } catch (Exception e) {
                            exception[0] = e;
                            break;
                        }
                    }
                }
            }));
        }

        // start threads
        for (Object aTestRunner : testRunner) {
            ((Thread) aTestRunner).start();
        }

        // join threads
        for (Object aTestRunner : testRunner) {
            try {
                ((Thread) aTestRunner).join();
            } catch (InterruptedException e) {
                fail(e.toString());
            }
        }

        if (exception[0] != null) {
            fail(exception[0].toString());
        }
    }


                public void run() {
                    for (int i = 0; i < 100; i++) {
                        try {
                            SimpleCredentials sc = new SimpleCredentials(testuser.getID(), testuser.getID().toCharArray());
                            sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");

                            Session s = getHelper().getRepository().login(sc);
                            try {
                                Set<TokenCredentials> tcs = ((SessionImpl) s).getSubject().getPublicCredentials(TokenCredentials.class);
                                assertFalse(tcs.isEmpty());
                            } finally {
                                s.logout();
                            }
                        } catch (Exception e) {
                            exception[0] = e;
                            break;
                        }
                    }
                }


                public void run() {
                    for (int i = 0; i < 100; i++) {
                        try {
                            double rand = wspNames.size() * Math.random();
                            int index = (int) Math.floor(rand);
                            String wspName = wspNames.get(index);

                            SimpleCredentials sc = new SimpleCredentials(testID, testID.toCharArray());
                            sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");

                            Session s = getHelper().getRepository().login(sc, wspName);
                            try {
                                Set<TokenCredentials> tcs = ((SessionImpl) s).getSubject().getPublicCredentials(TokenCredentials.class);
                                assertFalse(tcs.isEmpty());
                            } finally {
                                s.logout();
                            }

                        } catch (Exception e) {
                            exception[0] = e;
                            break;
                        }
                    }
                }


    protected void setUp() throws Exception {
        super.setUp();

        if (superuser instanceof SessionImpl) {
            UserManager umgr = ((SessionImpl) superuser).getUserManager();
            if (!umgr.isAutoSave()) {
                umgr.autoSave(true);
            }
            String uid = "test";
            while (umgr.getAuthorizable(uid) != null) {
                uid += "_";
            }

            testuser = umgr.createUser(uid, uid);
            userId = testuser.getID();
        } else {
            throw new NotExecutableException();
        }

        if (superuser.nodeExists(((ItemBasedPrincipal) testuser.getPrincipal()).getPath())) {
            session = (SessionImpl) superuser;
        } else {
            session = (SessionImpl) getHelper().getSuperuserSession("security");
        }
        tokenProvider = new CompatTokenProvider((SessionImpl) session, TokenBasedAuthentication.TOKEN_EXPIRATION);
    }


    protected void setUp() throws Exception {
        super.setUp();

        if (superuser instanceof SessionImpl) {
            UserManager umgr = ((SessionImpl) superuser).getUserManager();
            if (!umgr.isAutoSave()) {
                umgr.autoSave(true);
            }
            String uid = "test";
            while (umgr.getAuthorizable(uid) != null) {
                uid += "_";
            }

            testuser = umgr.createUser(uid, uid);
            userId = testuser.getID();
        } else {
            throw new NotExecutableException();
        }

        if (superuser.nodeExists(((ItemBasedPrincipal) testuser.getPrincipal()).getPath())) {
            session = (SessionImpl) superuser;
        } else {
            session = (SessionImpl) getHelper().getSuperuserSession("security");
        }
        tokenProvider = new TokenProvider((SessionImpl) session, TokenBasedAuthentication.TOKEN_EXPIRATION);
    }


    public void testTokenNode() throws Exception {
        Map<String, String> privateAttributes = new HashMap<String, String>();
        privateAttributes.put(".token_exp", "value");
        privateAttributes.put(".tokenTest", "value");
        privateAttributes.put(".token_something", "value");

        Map<String, String> publicAttributes = new HashMap<String, String>();
        publicAttributes.put("any", "value");
        publicAttributes.put("another", "value");

        Map<String, String> attributes = new HashMap<String, String>();
        attributes.putAll(publicAttributes);
        attributes.putAll(privateAttributes);

        SimpleCredentials sc = new SimpleCredentials(userId, userId.toCharArray());
        for (String s : attributes.keySet()) {
            sc.setAttribute(s, attributes.get(s));
        }

        TokenInfo info = tokenProvider.createToken(testuser, sc);
        Node tokenNode = getTokenNode(info);
        Property prop = tokenNode.getProperty(".token.key");
        assertNotNull(prop);
        assertEquals(PropertyType.STRING, prop.getType());
        assertFalse(prop.getDefinition().isProtected());

        prop = tokenNode.getProperty(".token.exp");
        assertNotNull(prop);
        assertEquals(PropertyType.DATE, prop.getType());
        assertFalse(prop.getDefinition().isProtected());

        for (String key : privateAttributes.keySet()) {
            assertEquals(privateAttributes.get(key), tokenNode.getProperty(key).getString());
        }

        for (String key : publicAttributes.keySet()) {
            assertEquals(publicAttributes.get(key), tokenNode.getProperty(key).getString());
        }
    }


    public void testTokenNode() throws Exception {
        Map<String, String> privateAttributes = new HashMap<String, String>();
        privateAttributes.put(".token_exp", "value");
        privateAttributes.put(".tokenTest", "value");
        privateAttributes.put(".token_something", "value");

        Map<String, String> publicAttributes = new HashMap<String, String>();
        publicAttributes.put("any", "value");
        publicAttributes.put("another", "value");

        Map<String, String> attributes = new HashMap<String, String>();
        attributes.putAll(publicAttributes);
        attributes.putAll(privateAttributes);

        SimpleCredentials sc = new SimpleCredentials(userId, userId.toCharArray());
        for (String s : attributes.keySet()) {
            sc.setAttribute(s, attributes.get(s));
        }

        TokenInfo info = tokenProvider.createToken(testuser, sc);
        Node tokenNode = getTokenNode(info);
        Property prop = tokenNode.getProperty("rep:token.key");
        assertNotNull(prop);
        assertEquals(PropertyType.STRING, prop.getType());
        assertTrue(prop.getDefinition().isProtected());

        prop = tokenNode.getProperty("rep:token.exp");
        assertNotNull(prop);
        assertEquals(PropertyType.DATE, prop.getType());
        assertTrue(prop.getDefinition().isProtected());

        for (String key : privateAttributes.keySet()) {
            assertEquals(privateAttributes.get(key), tokenNode.getProperty(key).getString());
        }

        for (String key : publicAttributes.keySet()) {
            assertEquals(publicAttributes.get(key), tokenNode.getProperty(key).getString());
        }
    }


    public void testGetTokenInfoFromInvalidToken() throws Exception {
        List<String> invalid = new ArrayList<String>();
        invalid.add("/invalid");
        invalid.add(UUID.randomUUID().toString());

        try {
            for (String token : invalid) {
                TokenInfo info = tokenProvider.getTokenInfo(token);
                assertNull(info);
            }
        } catch (Exception e) {
            // success
        }
    }


    public void testGetTokenInfoFromInvalidToken() throws Exception {
        List<String> invalid = new ArrayList<String>();
        invalid.add("/invalid");
        invalid.add(UUID.randomUUID().toString());

        try {
            for (String token : invalid) {
                TokenInfo info = tokenProvider.getTokenInfo(token);
                assertNull(info);
            }
        } catch (Exception e) {
            // success
        }
    }


    public void testInvalidCredentials() throws RepositoryException {
        try {
            validTokenAuth.authenticate(creds);
            fail("RepositoryException expected");
        } catch (RepositoryException e) {
            // success
        }

        try {
            assertFalse(validTokenAuth.authenticate(simpleCreds));
            fail("RepositoryException expected");            
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testInvalidCredentials() throws RepositoryException {
        try {
            validTokenAuth.authenticate(creds);
            fail("RepositoryException expected");
        } catch (RepositoryException e) {
            // success
        }

        try {
            assertFalse(validTokenAuth.authenticate(simpleCreds));
            fail("RepositoryException expected");            
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testDoCreateToken() {
        assertFalse(TokenBasedAuthentication.doCreateToken(creds));
        assertFalse(TokenBasedAuthentication.doCreateToken(simpleCreds));
        assertFalse(TokenBasedAuthentication.doCreateToken(tokenCreds));

        SimpleCredentials sc = new SimpleCredentials("uid", "pw".toCharArray());
        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, null);

        assertFalse(TokenBasedAuthentication.doCreateToken(sc));

        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "somevalue");
        assertFalse(TokenBasedAuthentication.doCreateToken(sc));

        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");
        assertTrue(TokenBasedAuthentication.doCreateToken(sc));
    }


    public void testDoCreateToken() {
        assertFalse(TokenBasedAuthentication.doCreateToken(creds));
        assertFalse(TokenBasedAuthentication.doCreateToken(simpleCreds));
        assertFalse(TokenBasedAuthentication.doCreateToken(tokenCreds));

        SimpleCredentials sc = new SimpleCredentials("uid", "pw".toCharArray());
        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, null);

        assertFalse(TokenBasedAuthentication.doCreateToken(sc));

        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "somevalue");
        assertFalse(TokenBasedAuthentication.doCreateToken(sc));

        sc.setAttribute(TokenBasedAuthentication.TOKEN_ATTRIBUTE, "");
        assertTrue(TokenBasedAuthentication.doCreateToken(sc));
    }


        protected Authentication getAuthentication(Principal principal,
                                                   Credentials creds)
                throws RepositoryException {
            if (ignore) {
                return null;
            } else {
                return new Authentication() {
                    public boolean canHandle(Credentials credentials) {
                        return true;
                    }

                    public boolean authenticate(Credentials credentials)
                            throws RepositoryException {
                        return true;
                    }
                };
            }
        }


    protected Authentication getAuthentication(Principal principal, Credentials creds) throws RepositoryException {
        if (principal instanceof Group) {
            return null;
        }
        return new Authentication() {
            public boolean canHandle(Credentials credentials) {
                return true;
            }
            public boolean authenticate(Credentials credentials) throws RepositoryException {
                return true;
            }
        };
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create a first user and retrieve the UserManager from the session
        // created for that new user.
        Principal p = getTestPrincipal();
        UserImpl u = (UserImpl) userMgr.createUser(p.getName(), buildPassword(p));
        save(superuser);

        uID = u.getID();

        // create a second user
        p = getTestPrincipal();
        String pw = buildPassword(p);
        Credentials otherCreds = buildCredentials(p.getName(), pw);
        User other = userMgr.createUser(p.getName(), pw);
        save(superuser);

        otherUID = other.getID();

        // make other user a user-administrator:
        Authorizable ua = userMgr.getAuthorizable(UserConstants.USER_ADMIN_GROUP_NAME);
        if (ua == null || !ua.isGroup()) {
            throw new NotExecutableException("Cannot execute test. No user-administrator group found.");
        }
        uAdministrators = (Group) ua;
        uAdministrators.addMember(other);

        // create a session for the other user.
        otherSession = getHelper().getRepository().login(otherCreds);
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create a first user
        Principal p = getTestPrincipal();
        UserImpl pUser = (UserImpl) userMgr.createUser(p.getName(), buildPassword(p));
        save(superuser);
        otherUID = pUser.getID();

        // create a second user and make it group-admin
        p = getTestPrincipal();
        String pw = buildPassword(p);
        Credentials creds = buildCredentials(p.getName(), pw);
        User user = userMgr.createUser(p.getName(), pw);
        save(superuser);
        uID = user.getID();

        // make other user a group-administrator:
        Authorizable grAdmin = userMgr.getAuthorizable(UserConstants.GROUP_ADMIN_GROUP_NAME);
        if (grAdmin == null || !grAdmin.isGroup()) {
            throw new NotExecutableException("Cannot execute test. No group-administrator group found.");
        }
        groupAdmin = (Group) grAdmin;
        groupAdmin.addMember(user);
        save(superuser);
        grID = groupAdmin.getID();

        // create a session for the group-admin user.
        uSession = getHelper().getRepository().login(creds);

        groupsPath = (userMgr instanceof UserManagerImpl) ? ((UserManagerImpl) userMgr).getGroupsPath() : UserConstants.GROUPS_PATH;
    }


    public void testCreateUser() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(otherSession);
        UserImpl u = null;
        // create a new user -> must succeed.
        try {
            Principal p = getTestPrincipal();
            u = (UserImpl) umgr.createUser(p.getName(), buildPassword(p));
            save(otherSession);
        } finally {
            if (u != null) {
                u.remove();
                save(otherSession);
            }
        }
    }


    public void testCreateUser() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);
        UserImpl u = null;
        // create a new user -> must succeed and user must be create below 'other'
        try {
            Principal p = getTestPrincipal();
            u = (UserImpl) umgr.createUser(p.getName(), buildPassword(p));
            save(uSession);
            fail("Group administrator should not be allowed to create a new user.");
        } catch (AccessDeniedException e) {
            // success
        } finally {
            if (u != null) {
                u.remove();
                save(uSession);
            }
        }
    }


    public void testCreateGroupWithIntermediatePath() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);
        Group testGroup = null;
        try {
            testGroup = umgr.createGroup(getTestPrincipal(), "/any/intermediate/path");
            save(uSession);
            assertTrue(Text.isDescendant(groupsPath + "/any/intermediate/path", ((GroupImpl)testGroup).getNode().getPath()));
        } finally {
            if (testGroup != null) {
                testGroup.remove();
                save(uSession);
            }
        }
    }


    public void testRemoveGroup() throws NotExecutableException, RepositoryException {
        UserManager umgr = getUserManager(otherSession);
        Group g = null;
        try {
            g = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            umgr.getAuthorizable(g.getID()).remove();
            save(otherSession);

            fail("UserAdmin should not be allowed to remove a Group.");
        } catch (RepositoryException e) {
            // success.
        } finally {
            if (g != null) {
                g.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithId() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = p.getName();

        Group gr = null;
        try {

        	// assert group creation with exact ID
            gr = userMgr.createGroup(uid);
            save(superuser);
            assertEquals("Expect group with exact ID", uid, gr.getID());

        } finally {
            if (gr != null) {
                gr.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroup() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);
        Group testGroup = null;
        try {
            testGroup = umgr.createGroup(getTestPrincipal());
            save(uSession);
            assertTrue(Text.isDescendant(groupsPath, ((GroupImpl)testGroup).getNode().getPath()));
        } finally {
            if (testGroup != null) {
                testGroup.remove();
                save(uSession);
            }
        }
    }


    public void testPrincipalNameEqualsUserID() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        User u = null;
        try {
            u = userMgr.createUser(p.getName(), buildPassword(p));
            save(superuser);

            String msg = "Implementation specific: User.getID() must return the userID pass to createUser.";
            assertEquals(msg, u.getID(), p.getName());
        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testPersisted() throws NotExecutableException, RepositoryException {
        UserManager umgr = getUserManager(uSession);
        Group gr = null;
        try {
            Principal p = getTestPrincipal();
            gr = umgr.createGroup(p);
            save(uSession);

            // must be visible for the user-mgr attached to another session.
            Authorizable az = userMgr.getAuthorizable(gr.getID());
            assertNotNull(az);
            assertEquals(gr.getID(), az.getID());
        } finally {
            if (gr != null) {
                gr.remove();
                save(uSession);
            }
        }
    }


    public void testPersisted() throws NotExecutableException, RepositoryException {
        UserManager umgr = getUserManager(otherSession);
        UserImpl u = null;
        // create a new user -> must succeed.
        try {
            Principal p = getTestPrincipal();
            u = (UserImpl) umgr.createUser(p.getName(), buildPassword(p));
            save(otherSession);

            Authorizable az = userMgr.getAuthorizable(u.getID());
            assertNotNull(az);
            assertEquals(u.getID(), az.getID());
        } finally {
            if (u != null) {
                u.remove();
                save(otherSession);
            }
        }
    }


    public void testCreateNestedUsers() throws NotExecutableException, RepositoryException {
        UserManager umgr = getUserManager(otherSession);
        UserImpl u = null;

        String invalidIntermediatePath = ((UserImpl) umgr.getAuthorizable(otherUID)).getNode().getPath();
        try {
            Principal p = getTestPrincipal();
            u = (UserImpl) umgr.createUser(p.getName(), buildPassword(p), p, invalidIntermediatePath);
            save(otherSession);

            fail("An attempt to create a user below an existing user must fail.");
        } catch (RepositoryException e) {
            // success
        } finally {
            if (u != null) {
                u.remove();
                save(otherSession);
            }
        }
    }


    public void testAddItselfAsMember() throws RepositoryException, NotExecutableException {
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalse(newGroup.addMember(newGroup));
            save(superuser);
            newGroup.removeMember(newGroup);
            save(superuser);
        } finally {
            if (newGroup != null) {
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testAddMemberModifiesMemberOf() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalseMemberOfContainsGroup(auth.memberOf(), newGroup);
            assertTrue(newGroup.addMember(auth));
            save(superuser);

            assertTrueMemberOfContainsGroup(auth.declaredMemberOf(), newGroup);
            assertTrueMemberOfContainsGroup(auth.memberOf(), newGroup);
        } finally {
            if (newGroup != null) {
                newGroup.removeMember(auth);
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testAddMemberTwice() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertTrue(newGroup.addMember(auth));
            save(superuser);
            assertFalse(newGroup.addMember(auth));
            save(superuser);
            assertTrue(newGroup.isMember(auth));

        } finally {
            if (newGroup != null) {
                newGroup.removeMember(auth);
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testAddMemberModifiesGetMembers() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalseIsMember(newGroup.getMembers(), auth);
            assertFalseIsMember(newGroup.getDeclaredMembers(), auth);
            assertTrue(newGroup.addMember(auth));
            save(superuser);

            assertTrueIsMember(newGroup.getMembers(), auth);
            assertTrueIsMember(newGroup.getDeclaredMembers(), auth);
        } finally {
            if (newGroup != null) {
                newGroup.removeMember(auth);
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testRemoveMemberTwice() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertTrue(newGroup.addMember(auth));
            save(superuser);
            assertTrue(newGroup.removeMember(userMgr.getAuthorizable(auth.getID())));
            save(superuser);
            assertFalse(newGroup.removeMember(auth));
            save(superuser);
        } finally {
            if (newGroup != null) {
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithIdAndPrincipal() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = p.getName();

        Group gr = null;
        try {

        	// assert group creation with exact ID
            gr = userMgr.createGroup(uid, p, null);
            save(superuser);

            assertEquals("Expect group with exact ID", uid, gr.getID());
            assertEquals("Expected group with exact principal name", p.getName(), gr.getPrincipal().getName());

        } finally {
            if (gr != null) {
                gr.remove();
                save(superuser);
            }
        }
    }


    public void testRevokeImpersonation() throws RepositoryException, NotExecutableException {
        User u = null;
        Principal test = getTestPrincipal();
        try {
            u = userMgr.createUser(test.getName(), buildPassword(test));
            save(superuser);
            impersonation.grantImpersonation(test);
            save(superuser);

            assertTrue(impersonation.revokeImpersonation(test));
        }  finally {
            if (u != null) {
                u.remove();
            }
        }
    }


    public void testGrantImpersonation() throws RepositoryException, NotExecutableException {
        User u = null;
        Principal test = getTestPrincipal();
        try {
            u = userMgr.createUser(test.getName(), buildPassword(test));
            save(superuser);
            assertTrue("Admin should be allowed to edit impersonation and grant to another test-user.", impersonation.grantImpersonation(test));
        }  finally {
            impersonation.revokeImpersonation(test);
            if (u != null) {
                u.remove();
            }
            save(superuser);
        }
    }


    public void testGrantImpersonationTwice() throws RepositoryException, NotExecutableException {
        Principal test = getTestPrincipal();
        User u = null;
        try {
            u = userMgr.createUser(test.getName(), buildPassword(test));
            save(superuser);
            impersonation.grantImpersonation(test);
            save(superuser);
            // try again
            assertFalse("Granting impersonation twice should not succeed.", impersonation.grantImpersonation(test));
        }  finally {
            impersonation.revokeImpersonation(test);
            if (u != null) {
                u.remove();
            }
            save(superuser);
        }
    }


    public void testRevokeImpersonationTwice() throws RepositoryException, NotExecutableException {
        User u = null;
        Principal test = getTestPrincipal();
        try {
            u = userMgr.createUser(test.getName(), buildPassword(test));
            save(superuser);
            impersonation.grantImpersonation(test);
            save(superuser);
            impersonation.revokeImpersonation(test);
            save(superuser);
            // try again
            assertFalse("Revoking impersonation twice should not succeed.", impersonation.revokeImpersonation(test));
        }  finally {
            if (u != null) {
                u.remove();
            }
        }
    }


    public void testAddMember() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalse(newGroup.isMember(auth));
            assertFalse(newGroup.removeMember(auth));
            save(superuser);

            assertTrue(newGroup.addMember(auth));
            save(superuser);
            assertTrue(newGroup.isMember(auth));
            assertTrue(newGroup.isMember(userMgr.getAuthorizable(auth.getID())));

        } finally {
            if (newGroup != null) {
                newGroup.removeMember(auth);
                newGroup.remove();
                save(superuser);
            }
        }
    }


    public void testRemoveGroupIfMemberExist() throws RepositoryException, NotExecutableException {
        User auth = getTestUser(superuser);
        String newGroupId = null;

        try {
            Group newGroup = userMgr.createGroup(getTestPrincipal());
            save(superuser);
            newGroupId = newGroup.getID();

            assertTrue(newGroup.addMember(auth));
            newGroup.remove();
            save(superuser);
        } finally {
            Group gr = (Group) userMgr.getAuthorizable(newGroupId);
            if (gr != null) {
                gr.removeMember(auth);
                gr.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroup() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(otherSession);
        String grId = null;
        try {
            Group testGroup = umgr.createGroup(getTestPrincipal());
            save(otherSession);
            grId = testGroup.getID();

            fail("UserAdmin should not be allowed to create a new Group.");

        } catch (RepositoryException e) {
            // success.
        } finally {
            // let superuser clean up
            if (grId != null) {
                Authorizable gr = userMgr.getAuthorizable(grId);
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }
        }
    }


    public void testCreateGroupWithIntermediatePath() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(otherSession);
        String grId = null;
        try {
            Group testGroup = umgr.createGroup(getTestPrincipal(), "/any/intermediate/path");
            save(otherSession);
            grId = testGroup.getID();

            fail("UserAdmin should not be allowed to create a new Group with intermediate path.");

        } catch (RepositoryException e) {
            // success.
        } finally {
            // let superuser clean up
            if (grId != null) {
                Authorizable gr = userMgr.getAuthorizable(grId);
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }
        }
    }


    public void testRemoveHimSelf() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(otherSession);

        Authorizable himself = umgr.getAuthorizable(otherUID);
        try {
            himself.remove();
            save(otherSession);

            fail("A UserAdministrator should not be allowed to remove himself.");
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testRemoveGroupAdmin() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);

        Authorizable groupAdmin = umgr.getAuthorizable(grID);
        try {
            groupAdmin.remove();
            save(uSession);
            fail("A GroupAdministrator should not be allowed to remove the group admin.");
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testRemoveSelf() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);

        Authorizable himself = umgr.getAuthorizable(uID);
        try {
            himself.remove();
            save(uSession);
            fail("A GroupAdministrator should not be allowed to remove the own authorizable.");
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testAddToGroup() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);
        Authorizable cU = umgr.getAuthorizable(getYetAnotherID());
        Group gr = (Group) umgr.getAuthorizable(grID);

        // adding and removing the test user as member of a group must succeed.
        try {
            assertTrue("Modifying group membership requires GroupAdmin membership.",gr.addMember(cU));
            save(uSession);
        } finally {
            gr.removeMember(cU);
            save(uSession);
        }
    }


    public void testAddOtherUserToGroup() throws RepositoryException, NotExecutableException {
        UserManager umgr = getUserManager(uSession);

        Authorizable pU = umgr.getAuthorizable(otherUID);
        Group gr = (Group) umgr.getAuthorizable(groupAdmin.getID());

        try {
            assertTrue(gr.addMember(pU));
            save(uSession);
        } finally {
            gr.removeMember(pU);
            save(uSession);
        }
    }


    public void testAdminNodeCollidingWithAuthorizableFolder() throws RepositoryException, NotExecutableException {
        Authorizable admin = userMgr.getAuthorizable(adminId);

        if (admin == null || !(admin instanceof AuthorizableImpl)) {
            throw new NotExecutableException();
        }

        // access the node corresponding to the admin user and remove it
        NodeImpl adminNode = ((AuthorizableImpl) admin).getNode();
        String adminPath = adminNode.getPath();
        String adminNodeName = adminNode.getName();
        Node parentNode = adminNode.getParent();

        Session s = adminNode.getSession();
        adminNode.remove();
        // use session obtained from the node as usermgr may point to a dedicated
        // system workspace different from the superusers workspace.
        s.save();

        Session s2 = null;
        String collidingPath = null;
        try {
            // now create a colliding node:
            Node n = parentNode.addNode(adminNodeName, "rep:AuthorizableFolder");
            collidingPath = n.getPath();
            s.save();

            // force recreation of admin user.
            s2 = getHelper().getSuperuserSession();

            admin = userMgr.getAuthorizable(adminId);
            assertNotNull(admin);
            assertEquals(adminNodeName, ((AuthorizableImpl) admin).getNode().getName());
            assertFalse(adminPath.equals(((AuthorizableImpl) admin).getNode().getPath()));

        } finally {
            if (s2 != null) {
                s2.logout();
            }
            // remove the extra folder and the admin user (created underneath) again.
            if (collidingPath != null) {
                s.getNode(collidingPath).remove();
                s.save();
            }
        }
    }


    public void testChangeUserRootPath() throws RepositoryException, NotExecutableException {
        Authorizable admin = userMgr.getAuthorizable(adminId);

        if (admin == null || !(admin instanceof AuthorizableImpl)) {
            throw new NotExecutableException();
        }

        // access the node corresponding to the admin user and remove it
        NodeImpl adminNode = ((AuthorizableImpl) admin).getNode();

        Session s = adminNode.getSession();
        adminNode.remove();
        // use session obtained from the node as usermgr may point to a dedicated
        // system workspace different from the superusers workspace.
        s.save();

        Session s2 = null;
        String collidingPath = null;
        try {
            // create a colliding user node outside of the user tree
            Properties props = new Properties();
            props.setProperty("usersPath", "/testPath");
            UserManager um = new UserManagerImpl((SessionImpl) s, adminId, props);
            User collidingUser = um.createUser(adminId, adminId);
            collidingPath = ((AuthorizableImpl) collidingUser).getNode().getPath();
            s.save();

            // force recreation of admin user.
            s2 = getHelper().getSuperuserSession();

            admin = userMgr.getAuthorizable(adminId);
            assertNotNull(admin);
            // the colliding node must have been removed.
            assertFalse(s2.nodeExists(collidingPath));

        } finally {
            if (s2 != null) {
                s2.logout();
            }
            if (collidingPath != null && s.nodeExists(collidingPath)) {
                s.getNode(collidingPath).remove();
                s.save();
            }
        }
    }


    public void testAdminNodeCollidingWithRandomNode() throws RepositoryException, NotExecutableException {
        Authorizable admin = userMgr.getAuthorizable(adminId);

        if (admin == null || !(admin instanceof AuthorizableImpl)) {
            throw new NotExecutableException();
        }

        // access the node corresponding to the admin user and remove it
        NodeImpl adminNode = ((AuthorizableImpl) admin).getNode();
        NodeId nid = adminNode.getNodeId();

        Session s = adminNode.getSession();
        adminNode.remove();
        // use session obtained from the node as usermgr may point to a dedicated
        // system workspace different from the superusers workspace.
        s.save();

        Session s2 = null;
        String collidingPath = null;
        try {
            // create a colliding node outside of the user tree
            NameResolver nr = (SessionImpl) s;
            // NOTE: testRootNode will not be present if users are stored in a distinct wsp.
            //       therefore use root node as start...
            NodeImpl tr = (NodeImpl) s.getRootNode();
            Node n = tr.addNode(nr.getQName("tmpNode"), nr.getQName(testNodeType), nid);
            collidingPath = n.getPath();
            s.save();

            // force recreation of admin user.
            s2 = getHelper().getSuperuserSession();

            admin = userMgr.getAuthorizable(adminId);
            assertNotNull(admin);
            // the colliding node must have been removed.
            assertFalse(s2.nodeExists(collidingPath));

        } finally {
            if (s2 != null) {
                s2.logout();
            }
            if (collidingPath != null && s.nodeExists(collidingPath)) {
                s.getNode(collidingPath).remove();
                s.save();
            }
        }
    }


    public void testFindNodesNonExact() throws NotExecutableException, RepositoryException {
        UserImpl currentUser = getCurrentUser();
        Value vs = superuser.getValueFactory().createValue("value \\, containing backslash");
        currentUser.setProperty(propertyName1, vs);
        save();

        Name propName = ((SessionImpl) superuser).getQName(propertyName1);
        try {
            NodeResolver nr = createNodeResolver(currentUser.getNode().getSession());

            NodeIterator result = nr.findNodes(propName, "value \\, containing backslash", UserConstants.NT_REP_USER, false);
            assertTrue("expected result", result.hasNext());
            assertEquals(currentUser.getNode().getPath(), result.nextNode().getPath());
            assertFalse("expected no more results", result.hasNext());
        } finally {
            currentUser.removeProperty(propertyName1);
            save();
        }
    }


    public void testFindNodesNonExactWithApostrophe()
            throws NotExecutableException, RepositoryException {
        UserImpl currentUser = getCurrentUser();
        Value vs = superuser.getValueFactory().createValue("value ' with apostrophe");
        currentUser.setProperty(propertyName1, vs);
        save();

        Name propName = ((SessionImpl) superuser).getQName(propertyName1);
        try {
            NodeResolver nr = createNodeResolver(currentUser.getNode().getSession());

            NodeIterator result = nr.findNodes(propName, "value ' with apostrophe", UserConstants.NT_REP_USER, false);
            assertTrue("expected result", result.hasNext());
            assertEquals(currentUser.getNode().getPath(), result.nextNode().getPath());
            assertFalse("expected no more results", result.hasNext());
        } finally {
            currentUser.removeProperty(propertyName1);
            save();
        }
    }


    public void testFindNodesExactWithApostrophe()
            throws NotExecutableException, RepositoryException {
        UserImpl currentUser = getCurrentUser();
        Value vs = superuser.getValueFactory().createValue("value ' with apostrophe");
        currentUser.setProperty(propertyName1, vs);
        save();

        Name propName = ((SessionImpl) superuser).getQName(propertyName1);
        try {
            NodeResolver nr = createNodeResolver(currentUser.getNode().getSession());

            NodeIterator result = nr.findNodes(propName, "value ' with apostrophe", UserConstants.NT_REP_USER, true);
            assertTrue("expected result", result.hasNext());
            assertEquals(currentUser.getNode().getPath(), result.nextNode().getPath());
            assertFalse("expected no more results", result.hasNext());
        } finally {
            currentUser.removeProperty(propertyName1);
            save();
        }
    }


    protected void setUp() throws Exception {
        super.setUp();
        FileUtils.deleteDirectory(new File(REPO_HOME));
        RepositoryConfig config = RepositoryConfig.create(
                getClass().getResourceAsStream("repository-membersplit.xml"), REPO_HOME);
        repo = RepositoryImpl.create(config);
        session = createSession();
        userMgr = session.getUserManager();
        cache = ((UserManagerImpl) userMgr).getMembershipCache();
        boolean autoSave = userMgr.isAutoSave();
        userMgr.autoSave(false);
        // create test users and groups
        System.out.printf("Creating %d users...\n", NUM_USERS);
        List<User> users = new ArrayList<User>();
        for (int i = 0; i < NUM_USERS; i++) {
            users.add(userMgr.createUser(TEST_USER_PREFIX + i, "secret"));
        }
        System.out.printf("Creating %d groups...\n", NUM_GROUPS);
        for (int i = 0; i < NUM_GROUPS; i++) {
            Group g = userMgr.createGroup(TEST_GROUP_PREFIX + i);
            for (int j=0; j<NUM_USERS_PER_GROUP; j++) {
                g.addMember(users.get(j));
            }
            session.save();
            System.out.printf(".").flush();
        }
        userMgr.autoSave(autoSave);
        logger.info("Initial cache size: " + cache.getSize());
    }


    protected void setUp() throws Exception {
        super.setUp();
        FileUtils.deleteDirectory(new File(REPO_HOME));
        RepositoryConfig config = RepositoryConfig.create(
                getClass().getResourceAsStream("repository.xml"), REPO_HOME);
        repo = RepositoryImpl.create(config);
        session = createSession();
        userMgr = session.getUserManager();
        cache = ((UserManagerImpl) userMgr).getMembershipCache();
        boolean autoSave = userMgr.isAutoSave();
        userMgr.autoSave(false);
        // create test users and groups
        List<User> users = new ArrayList<User>();
        for (int i = 0; i < NUM_USERS; i++) {
            users.add(userMgr.createUser(TEST_USER_PREFIX + i, "secret"));
        }
        for (int i = 0; i < NUM_GROUPS; i++) {
            Group g = userMgr.createGroup("MembershipCacheTestGroup-" + i);
            for (User u : users) {
                g.addMember(u);
            }
        }
        session.save();
        userMgr.autoSave(autoSave);
        logger.info("Initial cache size: " + cache.getSize());
    }


    protected void tearDown() throws Exception {
        boolean autoSave = userMgr.isAutoSave();
        userMgr.autoSave(false);
        for (int i = 0; i < NUM_USERS; i++) {
            userMgr.getAuthorizable(TEST_USER_PREFIX + i).remove();
        }
        for (int i = 0; i < NUM_GROUPS; i++) {
            userMgr.getAuthorizable(TEST_GROUP_PREFIX + i).remove();
        }
        session.save();
        userMgr.autoSave(autoSave);
        userMgr = null;
        cache = null;
        session.logout();
        repo.shutdown();
        repo = null;
        FileUtils.deleteDirectory(new File(REPO_HOME));
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        boolean autoSave = userMgr.isAutoSave();
        userMgr.autoSave(false);
        for (int i = 0; i < NUM_USERS; i++) {
            userMgr.getAuthorizable(TEST_USER_PREFIX + i).remove();
        }
        for (int i = 0; i < NUM_GROUPS; i++) {
            userMgr.getAuthorizable("MembershipCacheTestGroup-" + i).remove();
        }
        session.save();
        userMgr.autoSave(autoSave);
        userMgr = null;
        cache = null;
        session.logout();
        repo.shutdown();
        repo = null;
        FileUtils.deleteDirectory(new File(REPO_HOME));
        super.tearDown();
    }


    public void testAnonymousAccessDenied() throws Exception {
        Map<String, String> config = new HashMap<String, String>();
        config.put(UserAccessControlProvider.PARAM_ANONYMOUS_ACCESS, "false");

        AccessControlProvider p2 = new UserAccessControlProvider();
        try {
            p2.init(s, config);

            Set<Principal> anonymousPrincipals = getAnonymousPrincipals();

            assertFalse(p2.canAccessRoot(anonymousPrincipals));

            CompiledPermissions cp = p2.compilePermissions(anonymousPrincipals);
            try {
                assertEquals(CompiledPermissions.NO_PERMISSION, cp);
                assertFalse(cp.canReadAll());
                assertFalse(cp.grants(((NodeImpl) s.getRootNode()).getPrimaryPath(), Permission.READ));
            } finally {
                cp.close();
            }
        } finally {
            p2.close();
        }
    }


    public void testAnonymousAccessDenied2() throws Exception {
        Map<String, String> config = new HashMap<String, String>();
        config.put(UserAccessControlProvider.PARAM_ANONYMOUS_ACCESS, "false");
        config.put(UserAccessControlProvider.PARAM_ANONYMOUS_ID, "abc");

        AccessControlProvider p2 = new UserAccessControlProvider();
        try {
            p2.init(s, config);

            Principal princ = new Principal() {
                public String getName() {
                    return "abc";
                }
            };
            Set<Principal> anonymousPrincipals = Collections.singleton(princ);

            assertFalse(p2.canAccessRoot(anonymousPrincipals));

            CompiledPermissions cp = p2.compilePermissions(anonymousPrincipals);
            try {
                assertEquals(CompiledPermissions.NO_PERMISSION, cp);
                assertFalse(cp.canReadAll());
                assertFalse(cp.grants(((NodeImpl) s.getRootNode()).getPrimaryPath(), Permission.READ));
            } finally {
                cp.close();
            }
        } finally {
            p2.close();
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        Principal p = getTestPrincipal();
        String pw = buildPassword(p);
        creds = new SimpleCredentials(p.getName(), pw.toCharArray());

        User u = userMgr.createUser(p.getName(), pw);
        save(superuser);

        uID = u.getID();
        uSession = getHelper().getRepository().login(creds);
        uMgr = getUserManager(uSession);
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create a first user and retrieve the UserManager from the session
        // created for that new user.
        Principal p = getTestPrincipal();
        String pw = buildPassword(p);

        UserImpl u = (UserImpl) userMgr.createUser(p.getName(), pw);
        save(superuser);
        
        uID = u.getID();

        // create a session for the other user.
        uSession = getHelper().getRepository().login(new SimpleCredentials(uID, pw.toCharArray()));
        uMgr = getUserManager(uSession);
    }


    public void testImportGroupIntoUsersTree() throws RepositoryException, IOException, SAXException, NotExecutableException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"g\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g</sv:value></sv:property>" +
                "</sv:node>";

        /*
         importing a group below the users-path:
         - nonProtected node rep:Group must be created.
         - protected properties are ignored
         - UserManager.getAuthorizable must return null.
         - saving changes must fail with ConstraintViolationEx.
         */

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            assertTrue(target.isModified());
            assertTrue(sImpl.hasPendingChanges());

            Authorizable newGroup = umgr.getAuthorizable("g");
            assertNull(newGroup);

            assertTrue(target.hasNode("g"));
            assertFalse(target.hasProperty("g/rep:principalName"));

            // saving changes of the import -> must fail as mandatory prop is missing
            try {
                sImpl.save();
                fail("Import must be incomplete. Saving changes must fail.");
            } catch (ConstraintViolationException e) {
                // success
            }

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("g")) {
                target.getNode("g").remove();
                sImpl.save();
            }
        }
    }


    public void testMultiValuedPassword() throws RepositoryException, IOException, SAXException, NotExecutableException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>t</sv:value></sv:property>" +
                "</sv:node>";
        /*
         importing a user with a multi-valued rep:password property
         - nonProtected node rep:User must be created.
         - property rep:password must be created regularly without being protected
         - saving changes must fail with ConstraintViolationEx. as the protected
           mandatory property rep:password is missing
         */
        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            assertTrue(target.isModified());
            assertTrue(sImpl.hasPendingChanges());

            Authorizable newUser = umgr.getAuthorizable("t");
            assertNotNull(newUser);

            assertTrue(target.hasNode("t"));
            assertTrue(target.hasProperty("t/rep:password"));
            assertFalse(target.getProperty("t/rep:password").getDefinition().isProtected());

            // saving changes of the import -> must fail as mandatory prop is missing
            try {
                sImpl.save();
                fail("Import must be incomplete. Saving changes must fail.");
            } catch (ConstraintViolationException e) {
                // success
            }

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("t")) {
                target.getNode("t").remove();
                sImpl.save();
            }
        }
    }


    public void testMultiValuedPrincipalName() throws RepositoryException, IOException, SAXException, NotExecutableException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"g\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g</sv:value><sv:value>g2</sv:value><sv:value>g</sv:value></sv:property></sv:node>";

        /*
         importing a group with a multi-valued rep:principalName property
         - nonProtected node rep:Group must be created.
         - property rep:principalName must be created regularly without being protected
         - saving changes must fail with ConstraintViolationEx. as the protected
           mandatory property rep:principalName is missing
         */
        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);

            assertTrue(target.isModified());
            assertTrue(sImpl.hasPendingChanges());

            Authorizable newGroup = umgr.getAuthorizable("g");
            assertNotNull(newGroup);

            assertTrue(target.hasNode("g"));
            assertTrue(target.hasProperty("g/rep:principalName"));
            assertFalse(target.getProperty("g/rep:principalName").getDefinition().isProtected());

            // saving changes of the import -> must fail as mandatory prop is missing
            try {
                sImpl.save();
                fail("Import must be incomplete. Saving changes must fail.");
            } catch (ConstraintViolationException e) {
                // success
            }

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("g")) {
                target.getNode("g").remove();
                sImpl.save();
            }
        }
    }


    public void testIncompleteGroup() throws IOException, RepositoryException, SAXException, NotExecutableException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<sv:node sv:name=\"g\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "</sv:node>";

        /*
         importing a group without rep:principalName property
         - saving changes must fail with ConstraintViolationEx.
         */
        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);
            // saving changes of the import -> must fail as mandatory prop is missing
            try {
                sImpl.save();
                fail("Import must be incomplete. Saving changes must fail.");
            } catch (ConstraintViolationException e) {
                // success
            }

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("g")) {
                target.getNode("g").remove();
                sImpl.save();
            }
        }
    }


    public void testImportNewMembers() throws IOException, RepositoryException, SAXException, NotExecutableException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<sv:node sv:name=\"gFolder\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "<sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\">" +
                "   <sv:value>rep:AuthorizableFolder</sv:value>" +
                "</sv:property>" +
                "<sv:node sv:name=\"g\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g</sv:value></sv:property>" +
                "</sv:node>" +
                "<sv:node sv:name=\"g1\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>0120a4f9-196a-3f9e-b9f5-23f31f914da7</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g1</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:members\" sv:type=\"WeakReference\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "</sv:node>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);

            Group g = (Group) umgr.getAuthorizable("g");
            assertNotNull(g);
            Group g1 = (Group) umgr.getAuthorizable("g1");
            assertNotNull(g1);

            NodeImpl n = ((AuthorizableImpl) g1).getNode();
            assertTrue(n.hasProperty(UserConstants.P_MEMBERS) || n.hasNode(UserConstants.N_MEMBERS));

            // getWeakReferences only works upon save.
            sImpl.save();

            assertTrue(g1.isMember(g));

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("gFolder")) {
                target.getNode("gFolder").remove();
            }
            sImpl.save();
        }
    }


    public void testImportNewMembersReverseOrder() throws IOException, RepositoryException, SAXException, NotExecutableException {
        // group is imported before the member
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<sv:node sv:name=\"gFolder\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property>" +
                "   <sv:node sv:name=\"g1\">" +
                "       <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "       <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>0120a4f9-196a-3f9e-b9f5-23f31f914da7</sv:value></sv:property>" +
                "       <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g1</sv:value></sv:property>" +
                "       <sv:property sv:name=\"rep:members\" sv:type=\"WeakReference\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   </sv:node>" +
                "   <sv:node sv:name=\"g\">" +
                "       <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "       <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "       <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g</sv:value></sv:property>" +
                "   </sv:node>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);

            Group g = (Group) umgr.getAuthorizable("g");
            assertNotNull(g);
            Group g1 = (Group) umgr.getAuthorizable("g1");
            assertNotNull(g1);

            NodeImpl n = ((AuthorizableImpl) g1).getNode();
            assertTrue(n.hasProperty(UserConstants.P_MEMBERS) || n.hasNode(UserConstants.N_MEMBERS));

            // getWeakReferences only works upon save.
            sImpl.save();

            assertTrue(g1.isMember(g));

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("gFolder")) {
                target.getNode("gFolder").remove();
            }
            sImpl.save();
        }
    }


    public void testImportNonExistingMemberIgnore() throws IOException, RepositoryException, SAXException, NotExecutableException {
        Node n = testRootNode.addNode(nodeName1, ntUnstructured);
        n.addMixin(mixReferenceable);

        List<String> invalid = new ArrayList<String>();
        invalid.add(UUID.randomUUID().toString()); // random uuid
        invalid.add(n.getUUID()); // uuid of non-authorizable node

        for (String id : invalid) {
            String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                    "<sv:node sv:name=\"gFolder\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                    "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property>" +
                        "<sv:node sv:name=\"g1\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>0120a4f9-196a-3f9e-b9f5-23f31f914da7</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g1</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"rep:members\" sv:type=\"WeakReference\"><sv:value>" +id+ "</sv:value></sv:property>" +
                        "</sv:node>" +
                    "</sv:node>";
            NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
            try {
                // there should be no exception during import,
                // but invalid members must be ignored.
                doImport(target, xml, UserImporter.ImportBehavior.IGNORE);
                Authorizable a = umgr.getAuthorizable("g1");
                if (a.isGroup()) {
                    assertNotDeclaredMember((Group) a, id);
                } else {
                    fail("'g1' was not imported as Group.");
                }
            } finally {
                sImpl.refresh(false);
            }
        }
    }


    public void testImportNonExistingMemberAbort() throws IOException, RepositoryException, SAXException, NotExecutableException {
        Node n = testRootNode.addNode(nodeName1, ntUnstructured);
        n.addMixin(mixReferenceable);

        List<String> invalid = new ArrayList<String>();
        invalid.add(UUID.randomUUID().toString()); // random uuid
        invalid.add(n.getUUID()); // uuid of non-authorizable node

        for (String id : invalid) {
            String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                    "<sv:node sv:name=\"gFolder\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                    "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property>" +
                        "<sv:node sv:name=\"g1\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>0120a4f9-196a-3f9e-b9f5-23f31f914da7</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>g1</sv:value></sv:property>" +
                        "   <sv:property sv:name=\"rep:members\" sv:type=\"WeakReference\"><sv:value>" +id+ "</sv:value></sv:property>" +
                        "</sv:node>" +
                    "</sv:node>";
            NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
            try {
                doImport(target, xml, UserImporter.ImportBehavior.ABORT);
                // import behavior ABORT -> should throw.
                fail("importing invalid members -> must throw.");
            } catch (SAXException e) {
                // success as well
            } finally {
                sImpl.refresh(false);
            }
        }
    }


    public void testImportUuidCollisionRemoveExisting() throws RepositoryException, IOException, SAXException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>t</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            // re-import should succeed if UUID-behavior is set accordingly
            doImport(target, xml, ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING, UserImporter.ImportBehavior.BESTEFFORT);

            // saving changes of the import -> must succeed. add mandatory
            // props should have been created.
            sImpl.save();

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("t")) {
                target.getNode("t").remove();
                sImpl.save();
            }
        }
    }


    public void testImportUuidCollisionThrow() throws RepositoryException, IOException, SAXException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>t</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            doImport(target, xml, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW, UserImporter.ImportBehavior.BESTEFFORT);
            fail("UUID collision must be handled according to the uuid behavior.");

        } catch (SAXException e) {
            assertTrue(e.getException() instanceof ItemExistsException);
            // success.
        } finally {
            sImpl.refresh(false);
            if (target.hasNode("t")) {
                target.getNode("t").remove();
                sImpl.save();
            }
        }
    }


    public void testImportUuidCollisionRemoveExisting2() throws RepositoryException, IOException, SAXException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>t</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);
            sImpl.save();

            // re-import should succeed if UUID-behavior is set accordingly
            doImport(target, xml, ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING, UserImporter.ImportBehavior.BESTEFFORT);

            // saving changes of the import -> must succeed. add mandatory
            // props should have been created.
            sImpl.save();

        } finally {
            sImpl.refresh(false);
            if (target.hasNode("t")) {
                target.getNode("t").remove();
                sImpl.save();
            }
        }
    }


    public void testImportGroupMembersFromNodes() throws RepositoryException, IOException, SAXException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><sv:node sv:name=\"s\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:sling=\"http://sling.apache.org/jcr/sling/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\"><sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:node sv:name=\"sh\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\"><sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:node sv:name=\"shrimps\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property><sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>08429aec-6f09-30db-8c83-1a2a57fc760c</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\">" +                     "<sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>shrimps</sv:value></sv:property><sv:node sv:name=\"rep:members\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"adi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"adi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"adi\" sv:type=\"WeakReference\"><sv:value>c46335eb-267e-3e1c-9e5b-017acb4cd799</sv:value></sv:property><sv:property sv:name=\"admin\" sv:type=\"WeakReference\"><sv:value>21232f29-7a57-35a7-8389-4a0e4a801fc3</sv:value></sv:property></sv:node><sv:node sv:name=\"angi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"angi\" sv:type=\"WeakReference\"><sv:value>a468b64f-b1df-377c-b325-20d97aaa1ad9</sv:value></sv:property><sv:property sv:name=\"anonymous\" sv:type=\"WeakReference\"><sv:value>294de355-7d9d-30b3-92d8-a1e6aab028cf</sv:value></sv:property><sv:property sv:name=\"cati\" sv:type=\"WeakReference\"><sv:value>f08910b6-41c8-3cb9-a648-1dddd14b132d</sv:value></sv:property></sv:node></sv:node><sv:n" +                     "ode sv:name=\"debbi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"debbi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"debbi\" sv:type=\"WeakReference\"><sv:value>d53bedf9-ebb8-3117-a8b8-162d32b4bee2</sv:value></sv:property><sv:property sv:name=\"eddi\" sv:type=\"WeakReference\"><sv:value>1795fa1a-3d20-3a64-996e-eaaeb520a01e</sv:value></sv:property><sv:property sv:name=\"gabi\" sv:type=\"WeakReference\"><sv:value>a0d499c7-5105-3663-8611-a32779a57104</sv:value></sv:property><sv:property sv:name=\"hansi\" sv:type=\"WeakReference\"><sv:value>9ea4d671-8ed1-399a-8401-59487a14d00a</sv:value></sv:property></sv:node><sv:node sv:name=\"hari\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"hari\" sv:type=\"WeakReference\"><sv:value>a9bcf1e4-d7b9-3a22-a297-5c812d938889</sv:value></sv:property><sv:property sv:name=\"lisi\" sv:type=\"WeakReference\"><sv:value>dc3a8f16-70d6-3bea-a9b7-b65048a0ac40</sv:value></sv:property></sv:node><sv:node sv:name=\"luzi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"luzi\" sv:type=\"WeakReference\"><sv:value>9ec299fd-3461-3f1a-9749-92a76f2516eb</sv:value></sv:property><sv:property sv:name=\"pipi\" sv:type=" +                     "\"WeakReference\"><sv:value>16d5d24f-5b09-3199-9bd4-e5f57bf11237</sv:value></sv:property><sv:property sv:name=\"susi\" sv:type=\"WeakReference\"><sv:value>536931d8-0dec-318c-b3db-9612bdd004d4</sv:value></sv:property></sv:node></sv:node></sv:node></sv:node></sv:node></sv:node>";

        List<String> createdUsers = new LinkedList<String>();
        NodeImpl groupsNode = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            String[] users = {"angi", "adi", "hansi", "lisi", "luzi", "susi", "pipi", "hari", "gabi", "eddi",
                              "debbi", "cati", "admin", "anonymous"};

            for (String user : users) {
                if (umgr.getAuthorizable(user) == null) {
                    umgr.createUser(user, user);
                    createdUsers.add(user);
                }
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }

            doImport(groupsNode, xml);
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }

            Authorizable aShrimps = umgr.getAuthorizable("shrimps");
            assertNotNull(aShrimps);
            assertTrue(aShrimps.isGroup());

            Group gShrimps = (Group) aShrimps;
            for (String user : users) {
                assertTrue(user + " should be member of " + gShrimps, gShrimps.isMember(umgr.getAuthorizable(user)));
            }


        } finally {
            sImpl.refresh(false);
            for (String user : createdUsers) {
                Authorizable a = umgr.getAuthorizable(user);
                if (a != null && !a.isGroup()) {
                    a.remove();
                }
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }
            for (NodeIterator it = groupsNode.getNodes(); it.hasNext(); ) {
                it.nextNode().remove();
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }
        }
    }


    public void testImportGroupMembersFromNodesBestEffort() throws RepositoryException, IOException, SAXException {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><sv:node sv:name=\"s\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:sling=\"http://sling.apache.org/jcr/sling/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\"><sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:node sv:name=\"sh\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:AuthorizableFolder</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\"><sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:node sv:name=\"shrimps\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property><sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>08429aec-6f09-30db-8c83-1a2a57fc760c</sv:value></sv:property><sv:property sv:name=\"jcr:created\" sv:type=\"Date\">" +                     "<sv:value>2010-08-17T18:22:20.086+02:00</sv:value></sv:property><sv:property sv:name=\"jcr:createdBy\" sv:type=\"String\"><sv:value>admin</sv:value></sv:property><sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>shrimps</sv:value></sv:property><sv:node sv:name=\"rep:members\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"adi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"adi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"adi\" sv:type=\"WeakReference\"><sv:value>c46335eb-267e-3e1c-9e5b-017acb4cd799</sv:value></sv:property><sv:property sv:name=\"admin\" sv:type=\"WeakReference\"><sv:value>21232f29-7a57-35a7-8389-4a0e4a801fc3</sv:value></sv:property></sv:node><sv:node sv:name=\"angi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"angi\" sv:type=\"WeakReference\"><sv:value>a468b64f-b1df-377c-b325-20d97aaa1ad9</sv:value></sv:property><sv:property sv:name=\"anonymous\" sv:type=\"WeakReference\"><sv:value>294de355-7d9d-30b3-92d8-a1e6aab028cf</sv:value></sv:property><sv:property sv:name=\"cati\" sv:type=\"WeakReference\"><sv:value>f08910b6-41c8-3cb9-a648-1dddd14b132d</sv:value></sv:property></sv:node></sv:node><sv:n" +                     "ode sv:name=\"debbi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:node sv:name=\"debbi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"debbi\" sv:type=\"WeakReference\"><sv:value>d53bedf9-ebb8-3117-a8b8-162d32b4bee2</sv:value></sv:property><sv:property sv:name=\"eddi\" sv:type=\"WeakReference\"><sv:value>1795fa1a-3d20-3a64-996e-eaaeb520a01e</sv:value></sv:property><sv:property sv:name=\"gabi\" sv:type=\"WeakReference\"><sv:value>a0d499c7-5105-3663-8611-a32779a57104</sv:value></sv:property><sv:property sv:name=\"hansi\" sv:type=\"WeakReference\"><sv:value>9ea4d671-8ed1-399a-8401-59487a14d00a</sv:value></sv:property></sv:node><sv:node sv:name=\"hari\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"hari\" sv:type=\"WeakReference\"><sv:value>a9bcf1e4-d7b9-3a22-a297-5c812d938889</sv:value></sv:property><sv:property sv:name=\"lisi\" sv:type=\"WeakReference\"><sv:value>dc3a8f16-70d6-3bea-a9b7-b65048a0ac40</sv:value></sv:property></sv:node><sv:node sv:name=\"luzi\"><sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Members</sv:value></sv:property><sv:property sv:name=\"luzi\" sv:type=\"WeakReference\"><sv:value>9ec299fd-3461-3f1a-9749-92a76f2516eb</sv:value></sv:property><sv:property sv:name=\"pipi\" sv:type=" +                     "\"WeakReference\"><sv:value>16d5d24f-5b09-3199-9bd4-e5f57bf11237</sv:value></sv:property><sv:property sv:name=\"susi\" sv:type=\"WeakReference\"><sv:value>536931d8-0dec-318c-b3db-9612bdd004d4</sv:value></sv:property></sv:node></sv:node></sv:node></sv:node></sv:node></sv:node>";

        List<String> createdUsers = new LinkedList<String>();
        NodeImpl groupsNode = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            String[] users = {"angi", "adi", "hansi", "lisi", "luzi", "susi", "pipi", "hari", "gabi", "eddi",
                              "debbi", "cati", "admin", "anonymous"};

            doImport(groupsNode, xml, UserImporter.ImportBehavior.BESTEFFORT);
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }

            for (String user : users) {
                if (umgr.getAuthorizable(user) == null) {
                    umgr.createUser(user, user);
                    createdUsers.add(user);
                }
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }

            Authorizable aShrimps = umgr.getAuthorizable("shrimps");
            assertNotNull(aShrimps);
            assertTrue(aShrimps.isGroup());

            Group gShrimps = (Group) aShrimps;
            for (String user : users) {
                assertTrue(user + " should be member of " + gShrimps, gShrimps.isMember(umgr.getAuthorizable(user)));
            }


        } finally {
            sImpl.refresh(false);
            for (String user : createdUsers) {
                Authorizable a = umgr.getAuthorizable(user);
                if (a != null && !a.isGroup()) {
                    a.remove();
                }
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }
            for (NodeIterator it = groupsNode.getNodes(); it.hasNext(); ) {
                it.nextNode().remove();
            }
            if (!umgr.isAutoSave()) {
                sImpl.save();
            }
        }
    }


    public void testActionExecutionForUser() throws Exception {
        TestAction testAction = new TestAction();

        umgr.setAuthorizableActions(new AuthorizableAction[] {testAction});

        // import user
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>pw</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>tPrincipal</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);
            assertEquals(testAction.id, "t");
            assertEquals(testAction.pw, "pw");
        } finally {
            sImpl.refresh(false);
        }
    }


    public void testActionExecutionForGroup() throws Exception {
        TestAction testAction = new TestAction();

        umgr.setAuthorizableActions(new AuthorizableAction[] {testAction});

        // import group
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"g\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>gPrincipal</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);
            assertEquals(testAction.id, "g");
            assertNull(testAction.pw);
        } finally {
            sImpl.refresh(false);
        }
    }


    public void testAccessControlActionExecutionForUser() throws Exception {
        AccessControlAction a1 = new AccessControlAction();
        a1.setUserPrivilegeNames(Privilege.JCR_ALL);

        umgr.setAuthorizableActions(new AuthorizableAction[] {a1});

        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>tPrincipal</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            Authorizable a = umgr.getAuthorizable("t");
            assertNotNull(a);
            assertFalse(a.isGroup());

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());
            assertNotNull(policies);
            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof AccessControlList);

            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(1, aces.length);
            assertEquals("tPrincipal", aces[0].getPrincipal().getName());

        } finally {
            sImpl.refresh(false);
        }
    }


    public void testAccessControlActionExecutionForGroup() throws Exception {
        AccessControlAction a1 = new AccessControlAction();
        a1.setGroupPrivilegeNames(Privilege.JCR_READ);

        umgr.setAuthorizableActions(new AuthorizableAction[] {a1});

        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"g\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:Group</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>gPrincipal</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getGroupsPath());
        try {
            doImport(target, xml);

            Authorizable a = umgr.getAuthorizable("g");
            assertNotNull(a);
            assertTrue(a.isGroup());

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());
            assertNotNull(policies);
            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof AccessControlList);

            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(1, aces.length);
            assertEquals("gPrincipal", aces[0].getPrincipal().getName());

        } finally {
            sImpl.refresh(false);
        }
    }


    public void testAccessControlActionExecutionForUser2() throws Exception {
        AccessControlAction a1 = new AccessControlAction();
        a1.setUserPrivilegeNames(Privilege.JCR_ALL);

        umgr.setAuthorizableActions(new AuthorizableAction[] {a1});

        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                "<sv:node sv:name=\"t\" xmlns:mix=\"http://www.jcp.org/jcr/mix/1.0\" xmlns:nt=\"http://www.jcp.org/jcr/nt/1.0\" xmlns:fn_old=\"http://www.w3.org/2004/10/xpath-functions\" xmlns:fn=\"http://www.w3.org/2005/xpath-functions\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sv=\"http://www.jcp.org/jcr/sv/1.0\" xmlns:rep=\"internal\" xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">" +
                "   <sv:property sv:name=\"jcr:primaryType\" sv:type=\"Name\"><sv:value>rep:User</sv:value></sv:property>" +
                "   <sv:property sv:name=\"jcr:uuid\" sv:type=\"String\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:principalName\" sv:type=\"String\"><sv:value>tPrincipal</sv:value></sv:property>" +
                "   <sv:property sv:name=\"rep:password\" sv:type=\"String\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375</sv:value></sv:property>" +
                "</sv:node>";

        NodeImpl target = (NodeImpl) sImpl.getNode(umgr.getUsersPath());
        try {
            doImport(target, xml);

            Authorizable a = umgr.getAuthorizable("t");
            assertNotNull(a);
            assertFalse(a.isGroup());

            AccessControlManager acMgr = sImpl.getAccessControlManager();
            AccessControlPolicy[] policies = acMgr.getPolicies(a.getPath());
            assertNotNull(policies);
            assertEquals(1, policies.length);
            assertTrue(policies[0] instanceof AccessControlList);

            AccessControlEntry[] aces = ((AccessControlList) policies[0]).getAccessControlEntries();
            assertEquals(1, aces.length);
            assertEquals("tPrincipal", aces[0].getPrincipal().getName());

        } finally {
            sImpl.refresh(false);
        }
    }


    public void testPasswordAction() throws Exception {
        User u = null;

        try {
            TestAction action = new TestAction();
            setActions(action);

            String uid = getTestPrincipal().getName();
            u = impl.createUser(uid, buildPassword(uid));

            u.changePassword("pw1");
            assertEquals(1, action.called);

            u.changePassword("pw2", "pw1");
            assertEquals(2, action.called);
        } finally {
            if (u != null) {
                u.remove();
            }
            save(superuser);
        }
    }


    public void testPasswordValidationActionIgnoresHashedPwStringOnCreate() throws Exception {
        User u = null;

        try {
            PasswordValidationAction pwAction = new PasswordValidationAction();
            pwAction.setConstraint("^.*(?=.{8,})(?=.*[a-z])(?=.*[A-Z]).*");
            setActions(pwAction);

            String uid = getTestPrincipal().getName();
            String hashed = PasswordUtility.buildPasswordHash("DWkej32H");
            u = impl.createUser(uid, hashed);

        } finally {
            if (u != null) {
                u.remove();
            }
            save(superuser);
        }
    }


    public void testCreateUser() throws NotExecutableException {
        try {
            Principal p = getTestPrincipal();
            User u = uMgr.createUser(p.getName(), buildPassword(p));
            save(uSession);

            fail("A non-UserAdmin should not be allowed to create a new User.");

            // clean-up: let superuser remove the user created by fault.
            userMgr.getAuthorizable(u.getID()).remove();
        } catch (AuthorizableExistsException e) {
            // should never get here.
            fail(e.getMessage());
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testCreateUserWithItermediatePath() throws NotExecutableException {
        try {
            Principal p = getTestPrincipal();
            User u = uMgr.createUser(p.getName(), buildPassword(p), p, "/any/intermediate/path");
            save(uSession);

            fail("A non-UserAdmin should not be allowed to create a new User.");

            // clean-up: let superuser remove the user created by fault.
            userMgr.getAuthorizable(u.getID()).remove();
        } catch (AuthorizableExistsException e) {
            // should never get here.
            fail(e.getMessage());
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testRemoveUser() throws RepositoryException, NotExecutableException {
        // let superuser create another user.
        Principal p = getTestPrincipal();
        String user2ID = userMgr.createUser(p.getName(), buildPassword(p)).getID();
        save(superuser);

        try {
            Authorizable a = uMgr.getAuthorizable(user2ID);
            a.remove();
            save(uSession);

            fail("A non-administrator user should not be allowed to remove another user.");
        } catch (AccessDeniedException e) {
            // success
        }

        // let superuser do clean up.
        Authorizable user2 = userMgr.getAuthorizable(user2ID);
        if (user2 != null) {
            user2.remove();
            save(superuser);
        }
    }


    public void testRemoveOtherUser() throws RepositoryException, NotExecutableException {
        // let superuser create another user.
        Principal p = getTestPrincipal();
        String user2ID = userMgr.createUser(p.getName(), buildPassword(p), p, "/any/intermediate/path").getID();
        save(superuser);

        try {
            Authorizable a = uMgr.getAuthorizable(user2ID);
            a.remove();
            save(uSession);

            fail("A non-administrator user should not be allowed to remove another user.");
        } catch (AccessDeniedException e) {
            // success
        }

        // let superuser do clean up.
        Authorizable user2 = userMgr.getAuthorizable(user2ID);
        if (user2 != null) {
            user2.remove();
            save(superuser);
        }
    }


    public void testModifyImpersonationOfAnotherUser() throws RepositoryException, NotExecutableException {
        // let superuser create another user.
        Principal p = getTestPrincipal();
        String user2ID = userMgr.createUser(p.getName(), buildPassword(p)).getID();
        save(superuser);

        try {
            Authorizable a = uMgr.getAuthorizable(user2ID);

            Impersonation impers = ((User) a).getImpersonation();
            Principal himselfP = uMgr.getAuthorizable(uID).getPrincipal();
            assertFalse(impers.allows(buildSubject(himselfP)));
            impers.grantImpersonation(himselfP);
            save(uSession);

            fail("A non-administrator user should not be allowed modify Impersonation of another user.");
        } catch (AccessDeniedException e) {
            // success
        }

        // let superuser do clean up.
        Authorizable user2 = userMgr.getAuthorizable(user2ID);
        if (user2 != null) {
            user2.remove();
            save(superuser);
        }
    }


    public void testUserIDFromSession() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        User u = null;
        Session uSession = null;
        try {
            String uid = p.getName();
            String pw = buildPassword(p);
            u = userMgr.createUser(uid, pw);
            save(superuser);

            uSession = superuser.getRepository().login(new SimpleCredentials(uid, pw.toCharArray()));
            assertEquals(u.getID(), uSession.getUserID());
        } finally {
            if (uSession != null) {
                uSession.logout();
            }
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testNewUserCanLogin() throws RepositoryException, NotExecutableException {
        String uid = getTestPrincipal().getName();
        String pw = buildPassword(uid);

        User u = null;
        Session s = null;
        try {
            u = userMgr.createUser(uid, pw);
            save(superuser);

            Credentials creds = new SimpleCredentials(uid, pw.toCharArray());
            s = superuser.getRepository().login(creds);
        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
            if (s != null) {
                s.logout();
            }
        }
    }


    public void testCreateGroupWithExistingPrincipal() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = p.getName();

        User u = null;
        try {
        	// create a user with the given ID
            u = userMgr.createUser(uid, buildPassword(uid), p, null);
            save(superuser);

            // assert AuthorizableExistsException for principal that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(p);
            	fail("Principal " + p.getName() + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }

        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithExistingPrincipal2() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = getTestUserId(p);

        assertFalse(uid.equals(p.getName()));

        User u = null;
        try {
        	// create a user with the given ID
            u = userMgr.createUser(uid, buildPassword(uid), p, null);
            save(superuser);

            // assert AuthorizableExistsException for principal that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(p);
            	fail("Principal " + p.getName() + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }

        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithExistingGroupID() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = getTestUserId(p);

        Group g = null;
        try {
        	// create a user with the given ID
            g = userMgr.createGroup(uid);
            save(superuser);

            // assert AuthorizableExistsException for id that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(uid);
            	fail("ID " + uid + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }

        } finally {
            if (g != null) {
                g.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithExistingPrincipal3() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = getTestUserId(p);

        assertFalse(uid.equals(p.getName()));

        User u = null;
        try {
        	// create a user with the given ID
            u = userMgr.createUser(uid, buildPassword(uid), p, null);
            save(superuser);

            // assert AuthorizableExistsException for principal that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(getTestPrincipal().getName(), p, null);
            	fail("Principal " + p.getName() + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }

        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithExistingUserID() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = getTestUserId(p);

        User u = null;
        try {
        	// create a user with the given ID
            u = userMgr.createUser(uid, buildPassword(uid), p, null);
            save(superuser);
            
            // assert AuthorizableExistsException for id that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(uid);
            	fail("ID " + uid + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }
            
        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testCreateGroupWithExistingGroupID2() throws RepositoryException, NotExecutableException {
        Principal p = getTestPrincipal();
        String uid = getTestUserId(p);

        Group g = null;
        try {
        	// create a user with the given ID
            g = userMgr.createGroup(uid, p, null);
            save(superuser);

            // assert AuthorizableExistsException for id that is already in use
            Group gr = null;
            try {
            	gr = userMgr.createGroup(uid, getTestPrincipal(), null);
            	fail("ID " + uid + " is already in use -> must throw AuthorizableExistsException.");
            } catch (AuthorizableExistsException aee) {
            	// expected this
            } finally {
                if (gr != null) {
                    gr.remove();
                    save(superuser);
                }
            }

        } finally {
            if (g != null) {
                g.remove();
                save(superuser);
            }
        }
    }


    public void testFindUser() throws RepositoryException, NotExecutableException {
        User u = null;
        try {
            Principal p = getTestPrincipal();
            String uid = "UID" + p.getName();
            u = userMgr.createUser(uid, buildPassword(uid), p, null);
            save(superuser);

            boolean found = false;
            Iterator<Authorizable> it = userMgr.findAuthorizables(pPrincipalName, null, UserManager.SEARCH_TYPE_USER);
            while (it.hasNext() && !found) {
                User nu = (User) it.next();
                found = nu.getID().equals(uid);
            }
            assertTrue("Searching for 'null' must find the created user.", found);

            it = userMgr.findAuthorizables(pPrincipalName, p.getName(), UserManager.SEARCH_TYPE_USER);
            found = false;
            while (it.hasNext() && !found) {
                User nu = (User) it.next();
                found = nu.getPrincipal().getName().equals(p.getName());
            }
            assertTrue("Searching for principal-name must find the created user.", found);

            // but search groups should not find anything
            it = userMgr.findAuthorizables(pPrincipalName, p.getName(), UserManager.SEARCH_TYPE_GROUP);
            assertFalse(it.hasNext());

            it = userMgr.findAuthorizables(pPrincipalName, null, UserManager.SEARCH_TYPE_GROUP);
            while (it.hasNext()) {
                if (it.next().getPrincipal().getName().equals(p.getName())) {
                    fail("Searching for Groups should never find a user");
                }
            }
        } finally {
            if (u != null) {
                u.remove();
                save(superuser);
            }
        }
    }


    public void testFindGroup() throws RepositoryException, NotExecutableException {
        Group gr = null;
        try {
            Principal p = getTestPrincipal();
            gr = userMgr.createGroup(p);
            save(superuser);

            boolean found = false;
            Iterator<Authorizable> it = userMgr.findAuthorizables(pPrincipalName, null, UserManager.SEARCH_TYPE_GROUP);
            while (it.hasNext() && !found) {
                Group ng = (Group) it.next();
                found = ng.getPrincipal().getName().equals(p.getName());
            }
            assertTrue("Searching for \"\" must find the created group.", found);

            it = userMgr.findAuthorizables(pPrincipalName, p.getName(), UserManager.SEARCH_TYPE_GROUP);
            assertTrue(it.hasNext());
            Group ng = (Group) it.next();
            assertEquals("Searching for principal-name must find the created group.", p.getName(), ng.getPrincipal().getName());
            assertFalse("Only a single group must be found for a given principal name.", it.hasNext());

            // but search users should not find anything
            it = userMgr.findAuthorizables(pPrincipalName, p.getName(), UserManager.SEARCH_TYPE_USER);
            assertFalse(it.hasNext());

            it = userMgr.findAuthorizables(pPrincipalName, null, UserManager.SEARCH_TYPE_USER);
            while (it.hasNext()) {
                if (it.next().getPrincipal().getName().equals(p.getName())) {
                    fail("Searching for Users should never find a group");
                }
            }
        } finally {
            if (gr != null) {
                gr.remove();
                save(superuser);
            }
        }
    }


    public void testCleanup() throws RepositoryException, NotExecutableException {
        Session s = getHelper().getSuperuserSession();
        try {
            UserManager umgr = getUserManager(s);
            s.logout();

            // after logging out the session, the user manager must have been
            // released as well and it's underlying session must not be available
            // any more -> accessing users must fail.
            try {
                umgr.getAuthorizable("any userid");
                fail("After having logged out the original session, the user manager must not be live any more.");
            } catch (RepositoryException e) {
                // success
            }
        } finally {
            if (s.isLive()) {
                s.logout();
            }
        }
    }


    public void testCleanupForAllWorkspaces() throws RepositoryException, NotExecutableException {
        String[] workspaceNames = superuser.getWorkspace().getAccessibleWorkspaceNames();

        for (String workspaceName1 : workspaceNames) {
            Session s = getHelper().getSuperuserSession(workspaceName1);
            try {
                UserManager umgr = getUserManager(s);
                s.logout();

                // after logging out the session, the user manager must have been
                // released as well and it's underlying session must not be available
                // any more -> accessing users must fail.
                try {
                    umgr.getAuthorizable("any userid");
                    fail("After having logged out the original session, the user manager must not be live any more.");
                } catch (RepositoryException e) {
                    // success
                }
            } finally {
                if (s.isLive()) {
                    s.logout();
                }
            }
        }
    }


    public void testSetSpecialProperties() throws NotExecutableException, RepositoryException {
        Value v = superuser.getValueFactory().createValue("any_value");

        User u = getTestUser(superuser);
        for (String pName : protectedUserProps) {
            try {
                u.setProperty(pName, v);
                save(superuser);
                fail("changing the '" + pName + "' property on a User should fail.");
            } catch (RepositoryException e) {
                // success
            }
        }
        
        Group g = getTestGroup(superuser);
        for (String pName : protectedGroupProps) {
            try {
                g.setProperty(pName, v);
                save(superuser);
                fail("changing the '" + pName + "' property on a Group should fail.");
            } catch (RepositoryException e) {
                // success
            }
        }
    }


    public void testRemoveSpecialProperties() throws NotExecutableException, RepositoryException {
        User u = getTestUser(superuser);
        for (String pName : protectedUserProps) {
            try {
                u.removeProperty(pName);
                save(superuser);
                fail("removing the '" + pName + "' property on a User should fail.");
            } catch (RepositoryException e) {
                // success
            }
        }
        Group g = getTestGroup(superuser);
        for (String pName : protectedGroupProps) {
            try {
                g.removeProperty(pName);
                save(superuser);
                fail("removing the '" + pName + "' property on a Group should fail.");
            } catch (RepositoryException e) {
                // success
            }
        }
    }


    public void testProtectedUserProperties() throws NotExecutableException, RepositoryException {
        UserImpl user = (UserImpl) getTestUser(superuser);
        NodeImpl n = user.getNode();

        checkProtected(n.getProperty(UserConstants.P_PASSWORD));
        if (n.hasProperty(UserConstants.P_PRINCIPAL_NAME)) {
            checkProtected(n.getProperty(UserConstants.P_PRINCIPAL_NAME));
        }
        if (n.hasProperty(UserConstants.P_IMPERSONATORS)) {
           checkProtected(n.getProperty(UserConstants.P_IMPERSONATORS));
        }
    }


    public void testProtectedGroupProperties() throws NotExecutableException, RepositoryException {
        GroupImpl gr = (GroupImpl) getTestGroup(superuser);
        NodeImpl n = gr.getNode();

        if (n.hasProperty(UserConstants.P_PRINCIPAL_NAME)) {
            checkProtected(n.getProperty(UserConstants.P_PRINCIPAL_NAME));
        }
        if (n.hasProperty(UserConstants.P_MEMBERS)) {
            checkProtected(n.getProperty(UserConstants.P_MEMBERS));
        }
    }


    public void testRemoveSpecialUserPropertiesDirectly() throws RepositoryException, NotExecutableException {
        AuthorizableImpl g = (AuthorizableImpl) getTestUser(superuser);
        NodeImpl n = g.getNode();
        try {
            n.getProperty(UserConstants.P_PASSWORD).remove();
            fail("Attempt to remove protected property rep:password should fail.");
        } catch (ConstraintViolationException e) {
            // ok.
        }
        try {
            if (n.hasProperty(UserConstants.P_PRINCIPAL_NAME)) {
                n.getProperty(UserConstants.P_PRINCIPAL_NAME).remove();
                fail("Attempt to remove protected property rep:principalName should fail.");
            }
        } catch (ConstraintViolationException e) {
            // ok.
        }
    }


    public void testRemoveSpecialGroupPropertiesDirectly() throws RepositoryException, NotExecutableException {
        AuthorizableImpl g = (AuthorizableImpl) getTestGroup(superuser);
        NodeImpl n = g.getNode();
        try {
            if (n.hasProperty(UserConstants.P_PRINCIPAL_NAME)) {
                n.getProperty(UserConstants.P_PRINCIPAL_NAME).remove();
                fail("Attempt to remove protected property rep:principalName should fail.");
            }
        } catch (ConstraintViolationException e) {
            // ok.
        }
        try {
            if (n.hasProperty(UserConstants.P_MEMBERS)) {
                n.getProperty(UserConstants.P_MEMBERS).remove();
                fail("Attempt to remove protected property rep:members should fail.");
            }
        } catch (ConstraintViolationException e) {
            // ok.
        }
    }


    public void testUserGetProperties() throws RepositoryException, NotExecutableException {
        AuthorizableImpl user = (AuthorizableImpl) getTestUser(superuser);
        NodeImpl n = user.getNode();

        for (PropertyIterator it = n.getProperties(); it.hasNext();) {
            PropertyImpl p = (PropertyImpl) it.nextProperty();
            if (p.getDefinition().isProtected()) {
                assertFalse(user.hasProperty(p.getName()));
                assertNull(user.getProperty(p.getName()));
            } else {
                // authorizable defined property
                assertTrue(user.hasProperty(p.getName()));
                assertNotNull(user.getProperty(p.getName()));
            }
        }
    }


    public void testGroupGetProperties() throws RepositoryException, NotExecutableException {
        AuthorizableImpl group = (AuthorizableImpl) getTestGroup(superuser);
        NodeImpl n = group.getNode();

        for (PropertyIterator it = n.getProperties(); it.hasNext();) {
            PropertyImpl p = (PropertyImpl) it.nextProperty();
            if (p.getDefinition().isProtected()) {
                assertFalse(group.hasProperty(p.getName()));
                assertNull(group.getProperty(p.getName()));
            } else {
                // authorizable defined property
                assertTrue(group.hasProperty(p.getName()));
                assertNotNull(group.getProperty(p.getName()));
            }
        }
    }


    public void testSingleToMultiValued() throws Exception {
        AuthorizableImpl user = (AuthorizableImpl) getTestUser(superuser);
        UserManager uMgr = getUserManager(superuser);
        try {
            Value v = superuser.getValueFactory().createValue("anyValue");
            user.setProperty("someProp", v);
            if (!uMgr.isAutoSave()) {
                superuser.save();
            }
            Value[] vs = new Value[] {v, v};
            user.setProperty("someProp", vs);
            if (!uMgr.isAutoSave()) {
                superuser.save();
            }
        } finally {
            if (user.removeProperty("someProp") && !uMgr.isAutoSave()) {
                superuser.save();
            }
        }
    }


    public void testMultiValuedToSingle() throws Exception {
        AuthorizableImpl user = (AuthorizableImpl) getTestUser(superuser);
        UserManager uMgr = getUserManager(superuser);
        try {
            Value v = superuser.getValueFactory().createValue("anyValue");
            Value[] vs = new Value[] {v, v};
            user.setProperty("someProp", vs);
            if (!uMgr.isAutoSave()) {
                superuser.save();
            }
            user.setProperty("someProp", v);
            if (!uMgr.isAutoSave()) {
                superuser.save();
            }
        } finally {
            if (user.removeProperty("someProp") && !uMgr.isAutoSave()) {
                superuser.save();
            }
        }
    }


    protected static UserManager getUserManager(Session session) throws
            NotExecutableException {
        if (!(session instanceof JackrabbitSession)) {
            throw new NotExecutableException();
        }
        try {
            return ((JackrabbitSession) session).getUserManager();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }
    }


    private static UserManager getUserManager(Session session) throws
            NotExecutableException {
        if (!(session instanceof JackrabbitSession)) {
            throw new NotExecutableException();
        }
        try {
            return ((JackrabbitSession) session).getUserManager();
        } catch (RepositoryException e) {
            throw new NotExecutableException();
        }
    }


    public void testEmptyGlobRestriction()throws Exception{
        Node grandchild = superuser.getNode(childNPath).addNode("child");
        String ccPath = grandchild.getPath();
        superuser.save();

        // first deny access to 'path' (read-access is granted in the test setup)
        Privilege[] read = privilegesFromName(Privilege.JCR_READ);
        withdrawPrivileges(path, read, Collections.EMPTY_MAP);

        Session testSession = getTestSession();
        assertFalse(testSession.nodeExists(path));
        assertFalse(canGetNode(testSession, path));
        assertFalse(testSession.nodeExists(childNPath));
        assertFalse(canGetNode(testSession, childNPath));
        assertFalse(testSession.nodeExists(ccPath));
        assertFalse(canGetNode(testSession, ccPath));
        assertFalse(testSession.propertyExists(childNPath + '/' + JcrConstants.JCR_PRIMARYTYPE));

        Map<String, Value> emptyStringRestriction = new HashMap<String, Value>(getRestrictions(superuser, childNPath));
        emptyStringRestriction.put(AccessControlConstants.P_GLOB.toString(), vf.createValue(""));

        givePrivileges(childNPath, read, emptyStringRestriction);
        assertFalse(testSession.nodeExists(path));
        assertFalse(canGetNode(testSession, path));
        assertTrue(testSession.nodeExists(childNPath));
        assertTrue(canGetNode(testSession, childNPath));
        assertFalse(testSession.nodeExists(ccPath));
        assertFalse(canGetNode(testSession, ccPath));
        assertFalse(testSession.propertyExists(childNPath + '/' + JcrConstants.JCR_PRIMARYTYPE));

        givePrivileges(ccPath, read, Collections.EMPTY_MAP);
        assertTrue(testSession.nodeExists(ccPath));
        assertTrue(canGetNode(testSession, ccPath));
        assertTrue(testSession.propertyExists(ccPath + '/' + JcrConstants.JCR_PRIMARYTYPE));
    }


    public void testEmptyGlobRestriction2()throws Exception{
        Node grandchild = superuser.getNode(childNPath).addNode("child");
        String ccPath = grandchild.getPath();
        superuser.save();

        // first deny access to 'path' (read-access is granted in the test setup)
        Privilege[] read = privilegesFromName(Privilege.JCR_READ);
        withdrawPrivileges(path, read, Collections.EMPTY_MAP);

        Session testSession = getTestSession();
        assertFalse(testSession.nodeExists(path));
        assertFalse(canGetNode(testSession, path));
        assertFalse(testSession.nodeExists(childNPath));
        assertFalse(canGetNode(testSession, childNPath));
        assertFalse(testSession.nodeExists(ccPath));
        assertFalse(canGetNode(testSession, ccPath));
        assertFalse(testSession.propertyExists(childNPath + '/' + JcrConstants.JCR_PRIMARYTYPE));

        Map<String, Value> emptyStringRestriction = new HashMap<String, Value>(getRestrictions(superuser, path));
        emptyStringRestriction.put(AccessControlConstants.P_GLOB.toString(), vf.createValue(""));

        givePrivileges(path, read, emptyStringRestriction);
        assertTrue(testSession.nodeExists(path));
        assertTrue(canGetNode(testSession, path));
        assertFalse(testSession.nodeExists(childNPath));
        assertFalse(canGetNode(testSession, childNPath));
        assertFalse(testSession.nodeExists(ccPath));
        assertFalse(canGetNode(testSession, ccPath));
        assertFalse(testSession.propertyExists(childNPath + '/' + JcrConstants.JCR_PRIMARYTYPE));
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create some nodes below the test root in order to apply ac-stuff
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        Node cn1 = node.addNode(nodeName2, testNodeType);
        Property cp1 = node.setProperty(propertyName1, "anyValue");
        Node cn2 = node.addNode(nodeName3, testNodeType);

        Property ccp1 = cn1.setProperty(propertyName1, "childNodeProperty");

        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        path = node.getPath();
        childNPath = cn1.getPath();
        childNPath2 = cn2.getPath();
        childPPath = cp1.getPath();
        childchildPPath = ccp1.getPath();
        siblingPath = n2.getPath();
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create some nodes below the test root in order to apply ac-stuff
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        Node cn1 = node.addNode(nodeName2, testNodeType);
        Property cp1 = node.setProperty(propertyName1, "anyValue");
        Node cn2 = node.addNode(nodeName3, testNodeType);

        Property ccp1 = cn1.setProperty(propertyName1, "childNodeProperty");

        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        path = node.getPath();
        childNPath = cn1.getPath();
        childNPath2 = cn2.getPath();
        childPPath = cp1.getPath();
        childchildPPath = ccp1.getPath();
        siblingPath = n2.getPath();
    }


    protected void setUp() throws Exception {
        super.setUp();

        // create some nodes below the test root in order to apply ac-stuff
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        Node cn1 = node.addNode(nodeName2, testNodeType);
        Property cp1 = node.setProperty(propertyName1, "anyValue");
        Node cn2 = node.addNode(nodeName3, testNodeType);
        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        path = node.getPath();
        childNPath = cn1.getPath();
        childNPath2 = cn2.getPath();
        siblingPath = n2.getPath();
    }


    public void testMoveAccessControlledNode() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();

        /*
        precondition:
        testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node node3 = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        String node3Path = node3.getPath();
        Privilege[] privileges = privilegesFromName(NameConstants.JCR_READ.toString());

        // permissions defined @ childNode
        // -> revoke read permission
        withdrawPrivileges(childNPath, privileges, getRestrictions(superuser, childNPath));

        assertFalse(testSession.nodeExists(childNPath));
        assertFalse(testAcMgr.hasPrivileges(childNPath, privileges));
        assertFalse(testSession.nodeExists(node3Path));
        assertFalse(testAcMgr.hasPrivileges(node3Path, privileges));

        // move the ancestor node
        String movedChildNPath = path + "/movedNode";
        String movedNode3Path = movedChildNPath + "/" + nodeName3;

        superuser.move(childNPath, movedChildNPath);
        superuser.save();

        // expected behavior:
        // the AC-content present on childNode is still enforced both on
        // the node itself and on the subtree.
        assertFalse(testSession.nodeExists(movedChildNPath));
        assertFalse(testAcMgr.hasPrivileges(movedChildNPath, privileges));
        assertFalse(testSession.nodeExists(movedNode3Path));
        assertFalse(testAcMgr.hasPrivileges(movedNode3Path, privileges));
    }


    public void testMoveWithDifferentEffectiveAc() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();

        /*
        precondition:
        testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node node3 = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        String node3Path = node3.getPath();
        Privilege[] privileges = privilegesFromName(NameConstants.JCR_READ.toString());

        // @path read is denied, @childNode its allowed again
        withdrawPrivileges(path, privileges, getRestrictions(superuser, path));
        givePrivileges(childNPath, privileges, getRestrictions(superuser, childNPath));

        assertTrue(testSession.nodeExists(node3Path));
        assertTrue(testAcMgr.hasPrivileges(node3Path, privileges));

        // move the ancestor node
        String movedPath = path + "/movedNode";

        superuser.move(node3Path, movedPath);
        superuser.save();

        // expected behavior:
        // due to move node3 should not e visible any more
        assertFalse(testSession.nodeExists(movedPath));
        assertFalse(testAcMgr.hasPrivileges(movedPath, privileges));
    }


    public void testMoveNodeWithGlobRestriction() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();

        /*
        precondition:
        testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node node3 = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        String node3Path = node3.getPath();
        Privilege[] privileges = privilegesFromName(NameConstants.JCR_READ.toString());

        // permissions defined @ path
        // restriction: remove read priv to nodeName3 node
        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, childNPath));
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/"+nodeName3));
        withdrawPrivileges(childNPath, privileges, restrictions);

        assertFalse(testSession.nodeExists(node3Path));
        assertFalse(testAcMgr.hasPrivileges(node3Path, privileges));

        String movedChildNPath = path + "/movedNode";
        String movedNode3Path = movedChildNPath + "/" + node3.getName();

        superuser.move(childNPath, movedChildNPath);
        superuser.save();

        assertFalse(testSession.nodeExists(movedNode3Path));
        assertFalse(testAcMgr.hasPrivileges(movedNode3Path, privileges));
    }


    public void testMoveAccessControlledNodeInSubtree() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();

        /*
        precondition:
        testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node node3 = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        String node3Path = node3.getPath();
        Privilege[] privileges = privilegesFromName(NameConstants.JCR_READ.toString());

        // permissions defined @ node3Path
        // -> revoke read permission
        withdrawPrivileges(node3Path, privileges, getRestrictions(superuser, node3Path));

        assertFalse(testSession.nodeExists(node3Path));
        assertFalse(testAcMgr.hasPrivileges(node3Path, privileges));

        // move the ancestor node
        String movedChildNPath = path + "/movedNode";
        String movedNode3Path = movedChildNPath + "/" + nodeName3;

        superuser.move(childNPath, movedChildNPath);
        superuser.save();

        // expected behavior:
        // the AC-content present on node3 is still enforced
        assertFalse(testSession.nodeExists(movedNode3Path));
        assertFalse(testAcMgr.hasPrivileges(movedNode3Path, privileges));
    }


    public void testMoveNodeWithGlobRestriction2() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();

        /*
        precondition:
        testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node node3 = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        Privilege[] privileges = privilegesFromName(NameConstants.JCR_READ.toString());

        // permissions defined @ path
        // restriction: remove read priv to nodeName3 node
        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, childNPath));
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/"+nodeName3));
        withdrawPrivileges(childNPath, privileges, restrictions);

        // don't fill the per-session read-cache by calling Session.nodeExists
        assertFalse(testAcMgr.hasPrivileges(node3.getPath(), privileges));

        String movedChildNPath = path + "/movedNode";
        String movedNode3Path = movedChildNPath + "/" + node3.getName();

        superuser.move(childNPath, movedChildNPath);
        superuser.save();

        assertFalse(testSession.nodeExists(movedNode3Path));
        assertFalse(testAcMgr.hasPrivileges(movedNode3Path, privileges));
    }


    public void testRemovePermission9() throws NotExecutableException, RepositoryException {
        AccessControlManager testAcMgr = getTestACManager();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Privilege[] rmChildNodes = privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES);
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        // add 'remove_child_nodes' at 'path and allow 'remove_node' at childNPath
        givePrivileges(path, rmChildNodes, getRestrictions(superuser, path));
        givePrivileges(childNPath, rmNode, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - rep:policy node can still not be remove for it is access-control
           content that requires jcr:modifyAccessControl privilege instead.
         */
        String policyPath = childNPath + "/rep:policy";
        assertFalse(getTestSession().hasPermission(policyPath, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testAcMgr.hasPrivileges(policyPath, new Privilege[] {rmChildNodes[0], rmNode[0]}));
    }


    public void testRemovePermission4() throws NotExecutableException, RepositoryException {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Privilege[] rmChildNodes = privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES);
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        // add 'remove_child_nodes' privilege at 'path'...
        givePrivileges(path, rmChildNodes, getRestrictions(superuser, path));
        // ... and add 'remove_node' privilege at 'childNPath'
        givePrivileges(childNPath, rmNode, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - remove not allowed for node at path
         - remove-permission present for node at childNPath
         - both remove_node and remove_childNodes privilege present at childNPath
         */
        assertFalse(testSession.hasPermission(path, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testAcMgr.hasPrivileges(childNPath, new Privilege[] {rmChildNodes[0], rmNode[0]}));
    }


    public void testRemovePermission8() throws NotExecutableException, RepositoryException {
        AccessControlManager testAcMgr = getTestACManager();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Privilege[] rmChildNodes = privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES);
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        // add 'remove_child_nodes' at 'path
        givePrivileges(path, rmChildNodes, getRestrictions(superuser, path));
        // deny 'remove_node' at 'path'
        withdrawPrivileges(path, rmNode, getRestrictions(superuser, path));
        // and allow 'remove_node' at childNPath
        givePrivileges(childNPath, rmNode, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - remove permission must be granted at childNPath
         */
        assertTrue(getTestSession().hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testAcMgr.hasPrivileges(childNPath, new Privilege[] {rmChildNodes[0], rmNode[0]}));
    }


    public void testRemovePermission7() throws NotExecutableException, RepositoryException {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Privilege[] rmChildNodes = privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES);
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        // deny 'remove_child_nodes' at 'path'
        withdrawPrivileges(path, rmChildNodes, getRestrictions(superuser, path));
        // ... but allow 'remove_node' at childNPath
        givePrivileges(childNPath, rmNode, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - node at childNPath can't be removed.
         */
        assertFalse(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));

        // additionally add remove_child_nodes privilege at 'childNPath'
        givePrivileges(childNPath, rmChildNodes, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - node at childNPath still can't be removed.
         - but both privileges (remove_node, remove_child_nodes) are present.
         */
        assertFalse(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testAcMgr.hasPrivileges(childNPath, new Privilege[] {rmChildNodes[0], rmNode[0]}));
    }


    public void testRemovePermission6() throws NotExecutableException, RepositoryException {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Privilege[] privs = privilegesFromNames(new String[] {
                Privilege.JCR_REMOVE_CHILD_NODES, Privilege.JCR_REMOVE_NODE
        });
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        // add 'remove_child_nodes' and 'remove_node' privilege at 'path'
        givePrivileges(path, privs, getRestrictions(superuser, path));
        // ... but deny 'remove_node' at childNPath
        withdrawPrivileges(childNPath, rmNode, getRestrictions(superuser, childNPath));
        /*
         expected result:
         - neither node at path nor at childNPath could be removed.
         - no remove_node privilege at childNPath
         - read, remove_child_nodes privilege at childNPath
         */
        assertFalse(testSession.hasPermission(path, javax.jcr.Session.ACTION_REMOVE));
        assertFalse(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));
        assertTrue(testAcMgr.hasPrivileges(childNPath, privilegesFromNames(new String[] {Privilege.JCR_READ, Privilege.JCR_REMOVE_CHILD_NODES})));
        assertFalse(testAcMgr.hasPrivileges(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE)));
    }


    public void testMultipleGroupPermissionsOnNode() throws NotExecutableException, RepositoryException {
        Group testGroup = getTestGroup();

        /* create a second group the test user is member of */
        Principal principal = new TestPrincipal("testGroup" + UUID.randomUUID());
        UserManager umgr = getUserManager(superuser);
        Group group2 = umgr.createGroup(principal);
        try {
            group2.addMember(testUser);
            if (!umgr.isAutoSave() && superuser.hasPendingChanges()) {
                superuser.save();
            }

            /* add privileges for the Group the test-user is member of */
            Privilege[] privileges = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
            givePrivileges(path, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));

            withdrawPrivileges(path, group2.getPrincipal(), privileges, getRestrictions(superuser, path));

            /*
             testuser must get the permissions/privileges inherited from
             the group it is member of.
             the denial of group2 must succeed
            */
            String actions = javax.jcr.Session.ACTION_SET_PROPERTY + "," + javax.jcr.Session.ACTION_READ;

            AccessControlManager testAcMgr = getTestACManager();

            assertFalse(getTestSession().hasPermission(path, actions));
            Privilege[] privs = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
            assertFalse(testAcMgr.hasPrivileges(path, privs));
        } finally {
            group2.remove();
        }
    }


    public void testMultipleGroupPermissionsOnNode2() throws NotExecutableException, RepositoryException {
        Group testGroup = getTestGroup();

        /* create a second group the test user is member of */
        Principal principal = new TestPrincipal("testGroup" + UUID.randomUUID());
        UserManager umgr = getUserManager(superuser);
        Group group2 = umgr.createGroup(principal);

        try {
            group2.addMember(testUser);
            if (!umgr.isAutoSave() && superuser.hasPendingChanges()) {
                superuser.save();
            }

            /* add privileges for the Group the test-user is member of */
            Privilege[] privileges = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
            withdrawPrivileges(path, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));

            givePrivileges(path, group2.getPrincipal(), privileges, getRestrictions(superuser, path));

            /*
             testuser must get the permissions/privileges inherited from
             the group it is member of.
             granting permissions for group2 must be effective
            */
            String actions = javax.jcr.Session.ACTION_SET_PROPERTY + "," + javax.jcr.Session.ACTION_READ;

            AccessControlManager testAcMgr = getTestACManager();
            assertTrue(getTestSession().hasPermission(path, actions));
            Privilege[] privs = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
            assertTrue(testAcMgr.hasPrivileges(path, privs));
        } finally {
            group2.remove();
        }
    }


    public void testWriteIfReadingParentIsDenied() throws Exception {
        Privilege[] privileges = privilegesFromNames(new String[] {Privilege.JCR_READ, Privilege.JCR_WRITE});

        /* deny READ/WRITE privilege for testUser at 'path' */
        withdrawPrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));
        /*
        allow READ/WRITE privilege for testUser at 'childNPath'
        */
        givePrivileges(childNPath, testUser.getPrincipal(), privileges, getRestrictions(superuser, childNPath));


        Session testSession = getTestSession();

        assertFalse(testSession.nodeExists(path));

        // reading the node and it's definition must succeed.
        assertTrue(testSession.nodeExists(childNPath));
        Node n = testSession.getNode(childNPath);

        n.addNode("someChild");
        n.save();
    }


    public void testRemoveNodeWithPolicy() throws Exception {
        Privilege[] privileges = privilegesFromNames(new String[] {Privilege.JCR_READ, Privilege.JCR_WRITE});

        /* allow READ/WRITE privilege for testUser at 'path' */
        givePrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));
        /* allow READ/WRITE privilege for testUser at 'childPath' */
        givePrivileges(childNPath, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));

        Session testSession = getTestSession();

        assertTrue(testSession.nodeExists(childNPath));
        assertTrue(testSession.hasPermission(childNPath, Session.ACTION_REMOVE));

        Node n = testSession.getNode(childNPath);

        // removing the child node must succeed as both remove-node and
        // remove-child-nodes are granted to testsession.
        // the policy node underneath childNPath should silently be removed
        // as the editing session has no knowledge about it's existence.
        n.remove();
        testSession.save();
    }


    public void testRemoveNodeWithInvisibleChild() throws Exception {
        Privilege[] privileges = privilegesFromNames(new String[] {Privilege.JCR_READ, Privilege.JCR_WRITE});

        Node invisible = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        /* allow READ/WRITE privilege for testUser at 'path' */
        givePrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));
        /* deny READ privilege at invisible node. (removal is still granted) */
        withdrawPrivileges(invisible.getPath(), testUser.getPrincipal(),
                privilegesFromNames(new String[] {Privilege.JCR_READ}),
                getRestrictions(superuser, path));

        Session testSession = getTestSession();

        assertTrue(testSession.nodeExists(childNPath));
        assertTrue(testSession.hasPermission(childNPath, Session.ACTION_REMOVE));

        Node n = testSession.getNode(childNPath);

        // removing the child node must succeed as both remove-node and
        // remove-child-nodes are granted to testsession.
        // the policy node underneath childNPath should silently be removed
        // as the editing session has no knowledge about it's existence.
        n.remove();
        testSession.save();
    }


    public void testRemoveNodeWithInvisibleNonRemovableChild() throws Exception {
        Privilege[] privileges = privilegesFromNames(new String[] {Privilege.JCR_READ, Privilege.JCR_WRITE});

        Node invisible = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();

        /* allow READ/WRITE privilege for testUser at 'path' */
        givePrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));
        /* deny READ privilege at invisible node. (removal is still granted) */
        withdrawPrivileges(invisible.getPath(), testUser.getPrincipal(),
                privileges,
                getRestrictions(superuser, path));

        Session testSession = getTestSession();

        assertTrue(testSession.nodeExists(childNPath));
        assertTrue(testSession.hasPermission(childNPath, Session.ACTION_REMOVE));

        Node n = testSession.getNode(childNPath);

        // removing the child node must fail as a hidden child node cannot
        // be removed.
        try {
            n.remove();
            testSession.save();
            fail();
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testUpdateEntry() throws RepositoryException, NotExecutableException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());

        Privilege[] readPriv = privilegesFromName(Privilege.JCR_READ);
        Privilege[] writePriv = privilegesFromName(Privilege.JCR_WRITE);

        Principal principal2 = principalMgr.getEveryone();

        pt.addEntry(testPrincipal, readPriv, true, emptyRestrictions);
        pt.addEntry(principal2, readPriv, true, emptyRestrictions);
        pt.addEntry(testPrincipal, writePriv, false, emptyRestrictions);

        // adding an entry that should update the existing allow-entry for everyone.
        pt.addEntry(principal2, writePriv, true, emptyRestrictions);

        AccessControlEntry[] entries = pt.getAccessControlEntries();
        assertEquals(3, entries.length);
        JackrabbitAccessControlEntry princ2AllowEntry = (JackrabbitAccessControlEntry) entries[1];
        assertEquals(principal2, princ2AllowEntry.getPrincipal());
        assertTrue(princ2AllowEntry.isAllow());
        assertSamePrivileges(new Privilege[] {readPriv[0], writePriv[0]}, princ2AllowEntry.getPrivileges());
    }


    public void testUpdateComplementaryEntry() throws RepositoryException, NotExecutableException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());

        Privilege[] readPriv = privilegesFromName(Privilege.JCR_READ);
        Privilege[] writePriv = privilegesFromName(Privilege.JCR_WRITE);
        Principal principal2 = principalMgr.getEveryone();

        pt.addEntry(testPrincipal, readPriv, true, emptyRestrictions);
        pt.addEntry(principal2, readPriv, true, emptyRestrictions);
        pt.addEntry(testPrincipal, writePriv, false, emptyRestrictions);
        pt.addEntry(principal2, writePriv, true, emptyRestrictions);
        // entry complementary to the first entry
        // -> must remove the allow-READ entry and update the deny-WRITE entry.
        pt.addEntry(testPrincipal, readPriv, false, emptyRestrictions);

        AccessControlEntry[] entries = pt.getAccessControlEntries();

        assertEquals(2, entries.length);

        JackrabbitAccessControlEntry first = (JackrabbitAccessControlEntry) entries[0];
        assertEquals(principal2, first.getPrincipal());

        JackrabbitAccessControlEntry second = (JackrabbitAccessControlEntry) entries[1];
        assertEquals(testPrincipal, second.getPrincipal());
        assertFalse(second.isAllow());
        assertSamePrivileges(new Privilege[] {readPriv[0], writePriv[0]}, second.getPrivileges());
    }


    public void testInsertionOrder() throws Exception {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());

        Privilege[] readPriv = privilegesFromName(Privilege.JCR_READ);
        Privilege[] writePriv = privilegesFromName(Privilege.JCR_WRITE);
        Privilege[] addNodePriv = privilegesFromName(Privilege.JCR_ADD_CHILD_NODES);

        String restrName = ((SessionImpl) superuser).getJCRName(ACLTemplate.P_GLOB);
        Map<String,Value> restrictions = Collections.singletonMap(restrName, superuser.getValueFactory().createValue("/.*"));

        pt.addEntry(testPrincipal, readPriv, true, emptyRestrictions);
        pt.addEntry(testPrincipal, writePriv, false, emptyRestrictions);
        pt.addEntry(testPrincipal, addNodePriv, true, restrictions);

        AccessControlEntry[] entries = pt.getAccessControlEntries();
        assertTrue(Arrays.equals(readPriv, entries[0].getPrivileges()));
        assertTrue(Arrays.equals(writePriv, entries[1].getPrivileges()));
        assertTrue(Arrays.equals(addNodePriv, entries[2].getPrivileges()));
    }


    public void testInsertionOrder2() throws Exception {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());

        Privilege[] readPriv = privilegesFromName(Privilege.JCR_READ);
        Privilege[] writePriv = privilegesFromName(Privilege.JCR_WRITE);
        Privilege[] addNodePriv = privilegesFromName(Privilege.JCR_ADD_CHILD_NODES);

        String restrName = ((SessionImpl) superuser).getJCRName(ACLTemplate.P_GLOB);
        Map<String,Value> restrictions = Collections.singletonMap(restrName, superuser.getValueFactory().createValue("/.*"));

        pt.addEntry(testPrincipal, readPriv, true, emptyRestrictions);
        pt.addEntry(testPrincipal, addNodePriv, true, restrictions);
        pt.addEntry(testPrincipal, writePriv, false, emptyRestrictions);

        AccessControlEntry[] entries = pt.getAccessControlEntries();
        assertTrue(Arrays.equals(readPriv, entries[0].getPrivileges()));
        assertTrue(Arrays.equals(addNodePriv, entries[1].getPrivileges()));
        assertTrue(Arrays.equals(writePriv, entries[2].getPrivileges()));
    }


    public void testEffectivePoliciesByPath() throws RepositoryException, NotExecutableException {
        /*
         precondition:
         testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);

        // give 'testUser' READ_AC privileges at 'path'
        Privilege[] privileges = privilegesFromNames(new String[] {
                Privilege.JCR_READ_ACCESS_CONTROL,
        });

        givePrivileges(path, privileges, getRestrictions(superuser, path));

        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();

        assertFalse(testAcMgr.hasPrivileges("/", privileges));
        assertTrue(testAcMgr.hasPrivileges(path, privileges));

        // since read-ac access is denied on the root that by default is
        // access controlled, getEffectivePolicies must fail due to missing
        // permissions to view all the effective policies.
        try {
            testAcMgr.getEffectivePolicies(path);
            fail();
        } catch (AccessDeniedException e) {
            // success
        }

        // ... and same on childNPath.
        try {
            testAcMgr.getEffectivePolicies(childNPath);
            fail();
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testGetEffectivePoliciesByPrincipal() throws Exception {
        /*
         precondition:
         testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);

        // give 'testUser' READ_AC privileges at 'path'
        Privilege[] privileges = privilegesFromNames(new String[] {
                Privilege.JCR_READ_ACCESS_CONTROL,
        });

        givePrivileges(path, privileges, getRestrictions(superuser, path));

        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();

        // effective policies for testPrinicpal only on path -> must succeed.
        ((JackrabbitAccessControlManager) testAcMgr).getEffectivePolicies(Collections.singleton(testUser.getPrincipal()));

        // effective policies for a combination of principals -> must fail since
        // policy for 'everyone' at root node cannot be read by testuser
        Set<Principal> principals = ((SessionImpl) testSession).getSubject().getPrincipals();
        try {
            ((JackrabbitAccessControlManager) testAcMgr).getEffectivePolicies(principals);
            fail();
        } catch (AccessDeniedException e) {
            // success
        }

        withdrawPrivileges(childNPath, privileges, getRestrictions(superuser, childNPath));

        // the effective policies included the allowed acl at 'path' and
        // the denied acl at 'childNPath' -> must fail
        try {
            ((JackrabbitAccessControlManager) testAcMgr).getEffectivePolicies(Collections.singleton(testUser.getPrincipal()));
            fail();
        } catch (AccessDeniedException e) {
            // success
        }
    }


    static boolean isExecutable(AccessControlManager acMgr) {
        try {
            AccessControlPolicy[] rootPolicies = acMgr.getPolicies("/");
            if (rootPolicies.length > 0 && rootPolicies[0] instanceof ACLTemplate) {
                return true;
            }
        } catch (RepositoryException e) {
            // ignore
        }
        return false;
    }


    private boolean isMultiple() {
        try {
            if (exists() && ((Property)item).isMultiple()) {
                return true;
            }
        } catch (RepositoryException e) {
            log.error("Error while retrieving property definition: " + e.getMessage());
        }
        return false;
    }


    public void testGetAll() throws RepositoryException {

        PrivilegeDefinition[] defs = privilegeRegistry.getAll();

        List<PrivilegeDefinition> l = new ArrayList<PrivilegeDefinition>(Arrays.asList(defs));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_READ)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_ADD_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_REMOVE_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_MODIFY_PROPERTIES)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_REMOVE_NODE)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_WRITE)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_ALL)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_NODE_TYPE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_VERSION_MANAGEMENT)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_NAMESPACE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(NameConstants.JCR_WORKSPACE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.get(resolver.getQName(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT))));
        // and aggregates
        assertTrue(l.remove(privilegeRegistry.get(resolver.getQName(PrivilegeRegistry.REP_WRITE))));
                
        assertTrue(l.isEmpty());
    }


    public void testRegisteredPrivileges() throws RepositoryException {
        Privilege[] ps = privilegeRegistry.getRegisteredPrivileges();

        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(ps));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_REMOVE_NODE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_ALL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));        
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));
        assertTrue(l.isEmpty());
    }


    public void testRegisteredPrivileges() throws RepositoryException {
        Privilege[] ps = privilegeMgr.getRegisteredPrivileges();

        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(ps));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_NODE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ALL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));

        assertTrue(l.isEmpty());
    }


    public void testJcrWrite() throws RepositoryException {
        Name rw = resolver.getQName(PrivilegeRegistry.REP_WRITE);
        PrivilegeDefinition p = privilegeRegistry.get(rw);

        assertEquals(p.getName(), rw);
        assertFalse(p.getDeclaredAggregateNames().isEmpty());
        assertFalse(p.isAbstract());

        Set<Name> l = new HashSet<Name>(p.getDeclaredAggregateNames());
        assertTrue(l.remove(NameConstants.JCR_WRITE));
        assertTrue(l.remove(NameConstants.JCR_NODE_TYPE_MANAGEMENT));
        assertTrue(l.isEmpty());
    }


    public void testRepWrite() throws RepositoryException {
        PrivilegeDefinition p = privilegeRegistry.get(NameConstants.JCR_WRITE);
        assertEquals(p.getName(), NameConstants.JCR_WRITE);
        assertFalse(p.getDeclaredAggregateNames().isEmpty());
        assertFalse(p.isAbstract());

        Set<Name> l = new HashSet<Name>(p.getDeclaredAggregateNames());
        assertTrue(l.remove(NameConstants.JCR_MODIFY_PROPERTIES));
        assertTrue(l.remove(NameConstants.JCR_ADD_CHILD_NODES));
        assertTrue(l.remove(NameConstants.JCR_REMOVE_CHILD_NODES));
        assertTrue(l.remove(NameConstants.JCR_REMOVE_NODE));
        assertTrue(l.isEmpty());
    }


    public void testAllPrivilege() throws RepositoryException {
        Privilege p = privilegeRegistry.getPrivilege(Privilege.JCR_ALL);
        assertSamePrivilegeName(p.getName(), Privilege.JCR_ALL);
        assertTrue(p.isAggregate());
        assertFalse(p.isAbstract());

        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(p.getAggregatePrivileges()));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_REMOVE_NODE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));        
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));
        assertTrue(l.isEmpty());

        l = new ArrayList<Privilege>(Arrays.asList(p.getDeclaredAggregatePrivileges()));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeRegistry.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));
        assertTrue(l.isEmpty());
    }


    public void testAllPrivilege() throws RepositoryException {
        Privilege p = privilegeMgr.getPrivilege(Privilege.JCR_ALL);
        assertSamePrivilegeName(p.getName(), Privilege.JCR_ALL);
        assertTrue(p.isAggregate());
        assertFalse(p.isAbstract());

        List<Privilege> l = new ArrayList<Privilege>(Arrays.asList(p.getAggregatePrivileges()));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_ADD_CHILD_NODES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_CHILD_NODES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_PROPERTIES)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_REMOVE_NODE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));
        
        assertTrue(l.isEmpty());

        l = new ArrayList<Privilege>(Arrays.asList(p.getDeclaredAggregatePrivileges()));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_WRITE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_WRITE)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_READ_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_MODIFY_ACCESS_CONTROL)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_LOCK_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_RETENTION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_VERSION_MANAGEMENT)));
        assertTrue(l.remove(privilegeMgr.getPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT)));
        // including repo-level operation privileges
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_NODE_TYPE_DEFINITION_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT.toString())));
        assertTrue(l.remove(privilegeMgr.getPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT)));
        
        assertTrue(l.isEmpty());
    }


    public void testGetPrivilegeFromName() throws AccessControlException, RepositoryException {
        Privilege p = privilegeRegistry.getPrivilege(Privilege.JCR_READ);

        assertTrue(p != null);
        assertSamePrivilegeName(Privilege.JCR_READ, p.getName());
        assertFalse(p.isAggregate());

        p = privilegeRegistry.getPrivilege(Privilege.JCR_WRITE);

        assertTrue(p != null);
        assertSamePrivilegeName(p.getName(), Privilege.JCR_WRITE);
        assertTrue(p.isAggregate());
    }


    public void testGetPrivilegeFromName() throws AccessControlException, RepositoryException {
        Privilege p = privilegeMgr.getPrivilege(Privilege.JCR_READ);

        assertTrue(p != null);
        assertSamePrivilegeName(Privilege.JCR_READ, p.getName());
        assertFalse(p.isAggregate());

        p = privilegeMgr.getPrivilege(Privilege.JCR_WRITE);

        assertTrue(p != null);
        assertSamePrivilegeName(p.getName(), Privilege.JCR_WRITE);
        assertTrue(p.isAggregate());
    }


    private Privilege buildUnregisteredPrivilege(final String name, final Privilege declaredAggr) {
        return new Privilege() {

            public String getName() {
                return name;
            }
            public boolean isAbstract() {
                return false;
            }
            public boolean isAggregate() {
                return declaredAggr != null;
            }
            public Privilege[] getDeclaredAggregatePrivileges() {
                return (declaredAggr ==  null) ? new Privilege[0] : new Privilege[] {declaredAggr};
            }
            public Privilege[] getAggregatePrivileges() {
                return (declaredAggr ==  null) ? new Privilege[0] : declaredAggr.getAggregatePrivileges();
            }
        };
    }


    private Privilege buildCustomPrivilege(final String name, final Privilege declaredAggr) {
        return new Privilege() {

            public String getName() {
                return name;
            }
            public boolean isAbstract() {
                return false;
            }
            public boolean isAggregate() {
                return declaredAggr != null;
            }
            public Privilege[] getDeclaredAggregatePrivileges() {
                return (declaredAggr ==  null) ? new Privilege[0] : new Privilege[] {declaredAggr};
            }
            public Privilege[] getAggregatePrivileges() {
                return (declaredAggr ==  null) ? new Privilege[0] : declaredAggr.getAggregatePrivileges();
            }
        };
    }


    public void testRemoveInvalidEntry() throws RepositoryException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());
        try {
            pt.removeAccessControlEntry(new JackrabbitAccessControlEntry() {
                public boolean isAllow() {
                    return false;
                }
                public String[] getRestrictionNames() {
                    return new String[0];
                }
                public Value getRestriction(String restrictionName) {
                    return null;
                }

                public Value[] getRestrictions(String restrictionName) throws RepositoryException {
                    return null;
                }

                public Principal getPrincipal() {
                    return testPrincipal;
                }

                public Privilege[] getPrivileges() {
                    try {
                        return privilegesFromName(Privilege.JCR_READ);
                    } catch (Exception e) {
                        return new Privilege[0];
                    }
                }
            });
            fail("Passing an unknown ACE should fail");
        } catch (AccessControlException e) {
            // success
        }
    }


    public void testRemoveInvalidEntry2() throws RepositoryException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());
        try {
            pt.removeAccessControlEntry(new JackrabbitAccessControlEntry() {
                public boolean isAllow() {
                    return false;
                }
                public int getPrivilegeBits() {
                    return 0;
                }
                public String[] getRestrictionNames() {
                    return new String[0];
                }
                public Value getRestriction(String restrictionName) {
                    return null;
                }

                public Value[] getRestrictions(String restrictionName) throws RepositoryException {
                    return null;
                }

                public Principal getPrincipal() {
                    return testPrincipal;
                }
                public Privilege[] getPrivileges() {
                    return new Privilege[0];
                }
            });
            fail("Passing a ACE with invalid privileges should fail");
        } catch (AccessControlException e) {
            // success
        }
    }


    public void testEffect() throws RepositoryException, NotExecutableException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());
        Privilege[] read = privilegesFromName(Privilege.JCR_READ);
        Privilege[] modProp = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);

        pt.addAccessControlEntry(testPrincipal, read);

        // add deny entry for mod_props
        assertTrue(pt.addEntry(testPrincipal, modProp, false, null));

        // test net-effect
        PrivilegeBits allows = PrivilegeBits.getInstance();
        PrivilegeBits denies = PrivilegeBits.getInstance();
        AccessControlEntry[] entries = pt.getAccessControlEntries();
        for (AccessControlEntry ace : entries) {
            if (testPrincipal.equals(ace.getPrincipal()) && ace instanceof JackrabbitAccessControlEntry) {
                PrivilegeBits entryBits = privilegeMgr.getBits(ace.getPrivileges());
                if (((JackrabbitAccessControlEntry) ace).isAllow()) {
                    allows.addDifference(entryBits, denies);
                } else {
                    denies.addDifference(entryBits, allows);
                }
            }
        }
        assertEquals(privilegeMgr.getBits(read), allows);
        assertEquals(privilegeMgr.getBits(modProp), denies);
    }


    public void testEffect2() throws RepositoryException, NotExecutableException {
        JackrabbitAccessControlList pt = createEmptyTemplate(getTestPath());
        pt.addEntry(testPrincipal, privilegesFromName(Privilege.JCR_READ), true, Collections.<String, Value>emptyMap());

        // same entry but with revers 'isAllow' flag
        assertTrue(pt.addEntry(testPrincipal, privilegesFromName(Privilege.JCR_READ), false, Collections.<String, Value>emptyMap()));

        // test net-effect
        PrivilegeBits allows = PrivilegeBits.getInstance();
        PrivilegeBits denies = PrivilegeBits.getInstance();
        AccessControlEntry[] entries = pt.getAccessControlEntries();
        for (AccessControlEntry ace : entries) {
            if (testPrincipal.equals(ace.getPrincipal()) && ace instanceof JackrabbitAccessControlEntry) {
                PrivilegeBits entryBits = privilegeMgr.getBits(ace.getPrivileges());
                if (((JackrabbitAccessControlEntry) ace).isAllow()) {
                    allows.addDifference(entryBits, denies);
                } else {
                    denies.addDifference(entryBits, allows);
                }
            }
        }

        assertTrue(allows.isEmpty());
        assertEquals(privilegeMgr.getBits(privilegesFromName(Privilege.JCR_READ)), denies);
    }


    public void testCustomDefinitionsWithCyclicReferences() throws RepositoryException, FileSystemException, IOException {
        // setup the custom privilege file with cyclic references
        FileSystem fs = ((RepositoryImpl) superuser.getRepository()).getConfig().getFileSystem();
        FileSystemResource resource = new FileSystemResource(fs, "/privileges/custom_privileges.xml");
        if (!resource.exists()) {
            resource.makeParentDirs();
        }

        NameFactory nf = NameFactoryImpl.getInstance();
        Name test = nf.create(Name.NS_DEFAULT_URI, "test");
        Name test2 = nf.create(Name.NS_DEFAULT_URI, "test2");
        Name test3 = nf.create(Name.NS_DEFAULT_URI, "test3");
        Name test4 = nf.create(Name.NS_DEFAULT_URI, "test4");
        Name test5 = nf.create(Name.NS_DEFAULT_URI, "test5");

        OutputStream out = resource.getOutputStream();
        try {
            List<PrivilegeDefinition> defs = new ArrayList<PrivilegeDefinition>();
            defs.add(new PrivilegeDefinitionImpl(test, false, Collections.singleton(test2)));
            defs.add(new PrivilegeDefinitionImpl(test4, true, Collections.singleton(test5)));
            defs.add(new PrivilegeDefinitionImpl(test5, false, Collections.singleton(test3)));
            defs.add(new PrivilegeDefinitionImpl(test3, false, Collections.singleton(test)));
            defs.add(new PrivilegeDefinitionImpl(test2, false, Collections.singleton(test4)));
            PrivilegeDefinitionWriter pdw = new PrivilegeDefinitionWriter("text/xml");
            pdw.writeDefinitions(out, defs.toArray(new PrivilegeDefinition[defs.size()]), Collections.<String, String>emptyMap());

            new PrivilegeRegistry(superuser.getWorkspace().getNamespaceRegistry(), fs);
            fail("Cyclic definitions must be detected upon registry startup.");
        } catch (RepositoryException e) {
            // success
        } finally {
            out.close();
            fs.deleteFolder("/privileges");
        }
    }


    public void testCustomEquivalentDefinitions() throws RepositoryException, FileSystemException, IOException {
        // setup the custom privilege file with cyclic references
        FileSystem fs = ((RepositoryImpl) superuser.getRepository()).getConfig().getFileSystem();
        FileSystemResource resource = new FileSystemResource(fs, "/privileges/custom_privileges.xml");
        if (!resource.exists()) {
            resource.makeParentDirs();
        }

        NameFactory nf = NameFactoryImpl.getInstance();
        Name test = nf.create(Name.NS_DEFAULT_URI, "test");
        Name test2 = nf.create(Name.NS_DEFAULT_URI, "test2");
        Name test3 = nf.create(Name.NS_DEFAULT_URI, "test3");
        Name test4 = nf.create(Name.NS_DEFAULT_URI, "test4");
        Name test5 = nf.create(Name.NS_DEFAULT_URI, "test5");
        Name test6 = nf.create(Name.NS_DEFAULT_URI, "test6");

        OutputStream out = resource.getOutputStream();
        try {
            List<PrivilegeDefinition> defs = new ArrayList<PrivilegeDefinition>();
            defs.add(new PrivilegeDefinitionImpl(test, false, createNameSet(test2, test3)));
            defs.add(new PrivilegeDefinitionImpl(test2, true, Collections.singleton(test4)));
            defs.add(new PrivilegeDefinitionImpl(test3, true, Collections.singleton(test5)));
            defs.add(new PrivilegeDefinitionImpl(test4, true, Collections.<Name>emptySet()));
            defs.add(new PrivilegeDefinitionImpl(test5, true, Collections.<Name>emptySet()));

            // the equivalent definition to 'test'
            defs.add(new PrivilegeDefinitionImpl(test6, false, createNameSet(test2, test5)));

            PrivilegeDefinitionWriter pdw = new PrivilegeDefinitionWriter("text/xml");
            pdw.writeDefinitions(out, defs.toArray(new PrivilegeDefinition[defs.size()]), Collections.<String, String>emptyMap());

            new PrivilegeRegistry(superuser.getWorkspace().getNamespaceRegistry(), fs);
            fail("Equivalent definitions must be detected upon registry startup.");
        } catch (RepositoryException e) {
            // success
        } finally {
            out.close();
            fs.deleteFolder("/privileges");
        }
    }


    public void testAddMixin() throws RepositoryException, NotExecutableException {
        checkReadOnly(childNode.getPath());

        try {
            childNode.addMixin(mixinName);
            childNode.save();
            fail("TestSession does not have sufficient privileges to add a mixin type.");
        } catch (AccessDeniedException e) {
            // success
        }

        modifyPrivileges(childNode.getPath(), Privilege.JCR_NODE_TYPE_MANAGEMENT, true);
        childNode.addMixin(mixinName);
        childNode.save();
    }


    public void testRemoveMixin() throws RepositoryException, NotExecutableException {
        ((Node) superuser.getItem(childNode.getPath())).addMixin(mixinName);
        superuser.save();

        checkReadOnly(childNode.getPath());

        try {
            childNode.removeMixin(mixinName);
            childNode.save();
            fail("TestSession does not have sufficient privileges to remove a mixin type.");
        } catch (AccessDeniedException e) {
            // success
        }

        modifyPrivileges(childNode.getPath(), Privilege.JCR_NODE_TYPE_MANAGEMENT, true);
        childNode.removeMixin(mixinName);
        childNode.save();
    }


    public void testCopy() throws RepositoryException, NotExecutableException {
        Workspace wsp = getTestSession().getWorkspace();
        String parentPath = childNode.getParent().getPath();
        String srcPath = childNode.getPath();
        String destPath = parentPath + "/"+ nodeName3;

        checkReadOnly(parentPath);
        try {
            wsp.copy(srcPath, destPath);
            fail("Missing write privilege.");
        } catch (AccessDeniedException e) {
            // success
        }

        // with simple write privilege copying a node is not allowed.
        modifyPrivileges(parentPath, Privilege.JCR_WRITE, true);
        try {
            wsp.copy(srcPath, destPath);
            fail("Missing privilege jcr:nodeTypeManagement.");
        } catch (AccessDeniedException e) {
            // success
        }

        // adding jcr:nodeTypeManagement privilege will grant permission to copy.
        modifyPrivileges(parentPath, PrivilegeRegistry.REP_WRITE, true);
        wsp.copy(srcPath, destPath);
    }


    public void testWorkspaceImportXML() throws RepositoryException, NotExecutableException, IOException {
        Workspace wsp = getTestSession().getWorkspace();
        String parentPath = childNode.getPath();

        checkReadOnly(parentPath);
        try {
            wsp.importXML(parentPath, getXmlForImport(), ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
            fail("Missing write privilege.");
        } catch (AccessDeniedException e) {
            // success
        }

        // with simple write privilege moving a node is not allowed.
        modifyPrivileges(parentPath, Privilege.JCR_WRITE, true);
        try {
            wsp.importXML(parentPath, getXmlForImport(), ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
            fail("Missing privilege jcr:nodeTypeManagement.");
        } catch (AccessDeniedException e) {
            // success
        }

        // adding jcr:nodeTypeManagement privilege will grant permission to move.
        modifyPrivileges(parentPath, PrivilegeRegistry.REP_WRITE, true);
        wsp.importXML(parentPath, getXmlForImport(), ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
    }


    public void testWorkspaceMove() throws RepositoryException, NotExecutableException {
        Workspace wsp = getTestSession().getWorkspace();
        String parentPath = childNode.getParent().getPath();
        String srcPath = childNode.getPath();
        String destPath = parentPath + "/"+ nodeName3;

        checkReadOnly(parentPath);
        try {
            wsp.move(srcPath, destPath);
            fail("Missing write privilege.");
        } catch (AccessDeniedException e) {
            // success
        }

        // with simple write privilege moving a node is not allowed.
        modifyPrivileges(parentPath, Privilege.JCR_WRITE, true);
        try {
            wsp.move(srcPath, destPath);
            fail("Missing privilege jcr:nodeTypeManagement.");
        } catch (AccessDeniedException e) {
            // success
        }

        // adding jcr:nodeTypeManagement privilege will grant permission to move.
        modifyPrivileges(parentPath, PrivilegeRegistry.REP_WRITE, true);
        wsp.move(srcPath, destPath);
    }


    public void testSessionMove() throws RepositoryException, NotExecutableException {
        Session s = getTestSession();
        String parentPath = childNode.getParent().getPath();
        String srcPath = childNode.getPath();
        String destPath = parentPath + "/"+ nodeName3;

        checkReadOnly(parentPath);
        try {
            s.move(srcPath, destPath);
            s.save();
            fail("Missing write privilege.");
        } catch (AccessDeniedException e) {
            // success
        }

        // with simple write privilege moving a node is not allowed.
        modifyPrivileges(parentPath, Privilege.JCR_WRITE, true);
        try {
            s.move(srcPath, destPath);
            s.save();
            fail("Missing privilege jcr:nodeTypeManagement.");
        } catch (AccessDeniedException e) {
            // success
        }

        // adding jcr:nodeTypeManagement privilege will grant permission to move.
        modifyPrivileges(parentPath, PrivilegeRegistry.REP_WRITE, true);
        s.move(srcPath, destPath);
        s.save();
    }


    protected Node createVersionableNode(Node parent) throws RepositoryException, NotExecutableException {
        Node n = parent.addNode(nodeName1);
        if (n.canAddMixin(mixVersionable)) {
            n.addMixin(mixVersionable);
        } else {
            throw new NotExecutableException();
        }
        parent.save();
        return n;
    }


    private Node createLockableNode(Node parent) throws RepositoryException, NotExecutableException {
        Node n = parent.addNode(nodeName1);
        if (!n.isNodeType(mixLockable)) {
            if (n.canAddMixin(mixLockable)) {
                n.addMixin(mixLockable);
            } else {
                throw new NotExecutableException();
            }
            parent.save();
        }
        return n;
    }


    public void testRemoveVersion() throws RepositoryException, NotExecutableException {
        Node trn = getTestNode();
        Node n = createVersionableNode(testRootNode);
        modifyPrivileges(trn.getPath(), Privilege.JCR_VERSION_MANAGEMENT, true);

        // test session should now be able to create versionable nodes, checkout
        // and checkin them, read the version/v-histories.

        Node testNode = trn.getNode(nodeName1);
        Version v = testNode.checkin();
        testNode.checkout();
        testNode.checkin();

        // remove ability to edit version information
        // -> VersionHistory.removeVersion must not be allowed.
        modifyPrivileges(trn.getPath(), Privilege.JCR_VERSION_MANAGEMENT, false);
        try {
            testNode.getVersionHistory().removeVersion(v.getName());
            fail("TestSession without remove privilege on the v-storage must not be able to remove a version.");
        } catch (AccessDeniedException e) {
            // success
            log.debug(e.getMessage());
        }
    }


    public void testRemoveVersion2() throws RepositoryException, NotExecutableException {
        Node trn = getTestNode();
        Node n = createVersionableNode(testRootNode);
        modifyPrivileges(trn.getPath(), Privilege.JCR_VERSION_MANAGEMENT, true);

        Node testNode = trn.getNode(nodeName1);
        Version v = testNode.checkin();
        testNode.checkout();
        testNode.checkin();

        // -> VersionHistory.removeVersion must not be allowed.
        try {
            testNode.getVersionHistory().removeVersion(v.getName());
            fail("TestSession without remove privilege on the v-storage must not be able to remove a version.");
        } catch (AccessDeniedException e) {
            // success
            log.debug(e.getMessage());
        }        
    }


    private JackrabbitAccessControlList givePrivileges(String nPath,
                                                       Principal principal,
                                                       Privilege[] privileges,
                                                       Map<String, Value> restrictions,
                                                       boolean nodeBased) throws NotExecutableException, RepositoryException {
        if (nodeBased) {
            return givePrivileges(nPath, principal, privileges, getRestrictions(superuser, nPath));
        } else {
            JackrabbitAccessControlList tmpl = getPrincipalBasedPolicy(acMgr, nPath, principal);
            tmpl.addEntry(principal, privileges, true, restrictions);
            acMgr.setPolicy(tmpl.getPath(), tmpl);
            superuser.save();
            return tmpl;
        }
    }


    private JackrabbitAccessControlList withdrawPrivileges(String nPath,
                                                       Principal principal,
                                                       Privilege[] privileges,
                                                       Map<String, Value> restrictions,
                                                       boolean nodeBased) throws NotExecutableException, RepositoryException {
        if (nodeBased) {
            return withdrawPrivileges(nPath, principal, privileges, getRestrictions(superuser, nPath));
        } else {
            JackrabbitAccessControlList tmpl = getPrincipalBasedPolicy(acMgr, nPath, principal);
            tmpl.addEntry(principal, privileges, false, restrictions);
            acMgr.setPolicy(tmpl.getPath(), tmpl);
            superuser.save();
            return tmpl;
        }
    }


    public void testNotEquals() throws RepositoryException, NotExecutableException  {
        JackrabbitAccessControlEntry ace = createEntry(new String[] {Privilege.JCR_ALL}, true);
        List<JackrabbitAccessControlEntry> otherAces = new ArrayList<JackrabbitAccessControlEntry>();

        try {
            // ACE template with different principal
            Principal princ = new Principal() {
                public String getName() {
                    return "a name";
                }
            };
            Privilege[] privs = new Privilege[] {
                    acMgr.privilegeFromName(Privilege.JCR_ALL)
            };
            otherAces.add(createEntry(princ, privs, true));
        } catch (RepositoryException e) {
        }

        // ACE template with different privileges
        try {
            otherAces.add(createEntry(new String[] {Privilege.JCR_READ}, true));
        } catch (RepositoryException e) {
        }
        // ACE template with different 'allow' flag
        try {
            otherAces.add(createEntry(new String[] {Privilege.JCR_ALL}, false));
        } catch (RepositoryException e) {
        }
        // ACE template with different privileges and 'allows
        try {
            otherAces.add(createEntry(new String[] {PrivilegeRegistry.REP_WRITE}, false));
        } catch (RepositoryException e) {
        }

        // other ace impl
        final Privilege[] privs = new Privilege[] {
                acMgr.privilegeFromName(Privilege.JCR_ALL)
        };

        JackrabbitAccessControlEntry pe = new JackrabbitAccessControlEntry() {
            public boolean isAllow() {
                return true;
            }
            public String[] getRestrictionNames() {
                return new String[0];
            }
            public Value getRestriction(String restrictionName) {
                return null;
            }

            public Value[] getRestrictions(String restrictionName) throws RepositoryException {
                return null;
            }

            public Principal getPrincipal() {
                return testPrincipal;
            }
            public Privilege[] getPrivileges() {
                return privs;
            }
        };
        otherAces.add(pe);

        for (JackrabbitAccessControlEntry otherAce : otherAces) {
            assertFalse(ace.equals(otherAce));
        }
    }


    public void testHashCode() throws RepositoryException, NotExecutableException  {

        Map<AccessControlEntry, AccessControlEntry> equivalent = new HashMap<AccessControlEntry, AccessControlEntry>();
        JackrabbitAccessControlEntry ace = createEntry(new String[] {Privilege.JCR_ALL}, true);
        // create same entry again
        equivalent.put(ace, createEntry(new String[] {Privilege.JCR_ALL}, true));
        // create entry with declared aggregate privileges
        Privilege[] declaredAllPrivs = acMgr.privilegeFromName(Privilege.JCR_ALL).getDeclaredAggregatePrivileges();
        equivalent.put(ace, createEntry(testPrincipal, declaredAllPrivs, true));
        // create entry with aggregate privileges
        Privilege[] aggregateAllPrivs = acMgr.privilegeFromName(Privilege.JCR_ALL).getAggregatePrivileges();
        equivalent.put(ace, createEntry(testPrincipal, aggregateAllPrivs, true));
        // create entry with different privilege order
        List<Privilege> reordered = new ArrayList<Privilege>(Arrays.asList(aggregateAllPrivs));
        reordered.add(reordered.remove(0));
        equivalent.put(createEntry(testPrincipal, reordered.toArray(new Privilege[reordered.size()]), true),
                      createEntry(testPrincipal, aggregateAllPrivs, true));
        // even if entries are build with aggregated or declared aggregate privileges
        equivalent.put(createEntry(testPrincipal, declaredAllPrivs, true),
                      createEntry(testPrincipal, aggregateAllPrivs, true));

        for (AccessControlEntry entry : equivalent.keySet()) {
            assertEquals(entry.hashCode(), equivalent.get(entry).hashCode());
        }

        // and the opposite:
        List<JackrabbitAccessControlEntry> otherAces = new ArrayList<JackrabbitAccessControlEntry>();
        try {
            // ACE template with different principal
            Principal princ = new Principal() {
                public String getName() {
                    return "a name";
                }
            };
            Privilege[] privs = new Privilege[] {
                    acMgr.privilegeFromName(Privilege.JCR_ALL)
            };
            otherAces.add(createEntry(princ, privs, true));
        } catch (RepositoryException e) {
        }
        // ACE template with different privileges
        try {
            otherAces.add(createEntry(new String[] {Privilege.JCR_READ}, true));
        } catch (RepositoryException e) {
        }
        // ACE template with different 'allow' flag
        try {
            otherAces.add(createEntry(new String[] {Privilege.JCR_ALL}, false));
        } catch (RepositoryException e) {
        }
        // ACE template with different privileges and 'allows
        try {
            otherAces.add(createEntry(new String[] {PrivilegeRegistry.REP_WRITE}, false));
        } catch (RepositoryException e) {
        }
        // other ace impl
        final Privilege[] privs = new Privilege[] {
                acMgr.privilegeFromName(Privilege.JCR_ALL)
        };
        JackrabbitAccessControlEntry pe = new JackrabbitAccessControlEntry() {
            public boolean isAllow() {
                return true;
            }
            public String[] getRestrictionNames() {
                return new String[0];
            }
            public Value getRestriction(String restrictionName) {
                return null;
            }

            public Value[] getRestrictions(String restrictionName) throws RepositoryException {
                return null;
            }

            public Principal getPrincipal() {
                return testPrincipal;
            }
            public Privilege[] getPrivileges() {
                return privs;
            }
        };
        otherAces.add(pe);

        for (JackrabbitAccessControlEntry otherAce : otherAces) {
            assertFalse(ace.hashCode() == otherAce.hashCode());
        }

    }


    public void testWorkspaceCreationWithPrivilege() throws Exception {
        assertDefaultPrivileges(NameConstants.JCR_WORKSPACE_MANAGEMENT);
        assertPermission(Permission.WORKSPACE_MNGMT, false);

        modifyPrivileges(null, NameConstants.JCR_WORKSPACE_MANAGEMENT.toString(), true);
        // assert that permission have changed:
        assertPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT, true);
        assertPermission(Permission.WORKSPACE_MNGMT, true);

        try {
            Workspace testWsp = getTestWorkspace();
            testWsp.createWorkspace(getNewWorkspaceName(superuser.getWorkspace()));
        } finally {
            modifyPrivileges(null, NameConstants.JCR_WORKSPACE_MANAGEMENT.toString(), false);
        }

        assertPrivilege(NameConstants.JCR_WORKSPACE_MANAGEMENT, false);
        assertPermission(Permission.WORKSPACE_MNGMT, false);
    }


    public void testRegisterPrivilegeWithPrivilege() throws Exception {
        assertDefaultPrivileges(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME);
        assertPermission(Permission.PRIVILEGE_MNGMT, false);

        modifyPrivileges(null, PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME.toString(), true);
        assertPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME, true);
        assertPermission(Permission.PRIVILEGE_MNGMT, true);

        try {
            Workspace testWsp = getTestWorkspace();
            ((JackrabbitWorkspace) testWsp).getPrivilegeManager().registerPrivilege(getNewPrivilegeName(testWsp), false, new String[0]);        } finally {
            modifyPrivileges(null, PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME.toString(), false);
        }

        assertPrivilege(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME, false);
        assertPermission(Permission.PRIVILEGE_MNGMT, false);
    }


    public void testRegisterNamespaceWithPrivilege() throws Exception {
        assertDefaultPrivileges(NameConstants.JCR_NAMESPACE_MANAGEMENT);
        assertPermission(Permission.NAMESPACE_MNGMT, false);

        modifyPrivileges(null, NameConstants.JCR_NAMESPACE_MANAGEMENT.toString(), true);
        assertPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT, true);
        assertPermission(Permission.NAMESPACE_MNGMT, true);

        try {
            Workspace testWsp = getTestWorkspace();
            testWsp.getNamespaceRegistry().registerNamespace(getNewNamespacePrefix(testWsp), getNewNamespaceURI(testWsp));
        } finally {
            modifyPrivileges(null, NameConstants.JCR_NAMESPACE_MANAGEMENT.toString(), false);
        }

        assertPrivilege(NameConstants.JCR_NAMESPACE_MANAGEMENT, false);
        assertPermission(Permission.NAMESPACE_MNGMT, false);
    }


    public void testRegisterNamespace() throws Exception {
        assertDefaultPrivileges(NameConstants.JCR_NAMESPACE_MANAGEMENT);
        assertPermission(Permission.NODE_TYPE_DEF_MNGMT, false);

        try {
            Workspace testWsp = getTestWorkspace();
            testWsp.getNamespaceRegistry().registerNamespace(getNewNamespacePrefix(testWsp), getNewNamespaceURI(testWsp));
            fail("Namespace registration should be denied.");
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testRegisterPrivilege() throws Exception {
        assertDefaultPrivileges(PrivilegeRegistry.REP_PRIVILEGE_MANAGEMENT_NAME);
        assertPermission(Permission.PRIVILEGE_MNGMT, false);

        try {
            Workspace testWsp = getTestWorkspace();
            ((JackrabbitWorkspace) testWsp).getPrivilegeManager().registerPrivilege(getNewPrivilegeName(testWsp), false, new String[0]);
            fail("Privilege registration should be denied.");
        } catch (AccessDeniedException e) {
            // success
        }
    }


    public void testSessionMove() throws RepositoryException, NotExecutableException {
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);
        Session testSession = getTestSession();

        String destPath = path + "/" + nodeName1;

        // give 'add_child_nodes' and 'nt-management' privilege
        // -> not sufficient privileges for a move
        givePrivileges(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES, Privilege.JCR_NODE_TYPE_MANAGEMENT}), getRestrictions(superuser, path));
        try {
            testSession.move(childNPath, destPath);
            testSession.save();
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }

        // add 'remove_child_nodes' at 'path
        // -> not sufficient for a move since 'remove_node' privilege is missing
        //    on the move-target
        givePrivileges(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES), getRestrictions(superuser, path));
        try {
            testSession.move(childNPath, destPath);
            testSession.save();
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }

        // allow 'remove_node' at childNPath
        // -> now move must succeed
        givePrivileges(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE), getRestrictions(superuser, childNPath));
        testSession.move(childNPath, destPath);
        testSession.save();

        // withdraw  'add_child_nodes' privilege on former src-parent
        // -> moving child-node back must fail
        withdrawPrivileges(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES), getRestrictions(superuser, path));
        try {
            testSession.move(destPath, childNPath);
            testSession.save();
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }
    }


    public void testWorkspaceMove() throws RepositoryException, NotExecutableException {
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);
        Session testSession = getTestSession();

        String destPath = path + "/" + nodeName1;

        // give 'add_child_nodes', 'nt-mgmt' privilege
        // -> not sufficient privileges for a move.
        givePrivileges(path, privilegesFromNames(new String[] {Privilege.JCR_ADD_CHILD_NODES,
                Privilege.JCR_NODE_TYPE_MANAGEMENT}), getRestrictions(superuser, path));
        try {
            testSession.getWorkspace().move(childNPath, destPath);
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }

        // add 'remove_child_nodes' at 'path
        // -> no sufficient for a move since 'remove_node' privilege is missing
        //    on the move-target
        givePrivileges(path, privilegesFromName(Privilege.JCR_REMOVE_CHILD_NODES), getRestrictions(superuser, path));
        try {
            testSession.getWorkspace().move(childNPath, destPath);
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }

        // allow 'remove_node' at childNPath
        // -> now move must succeed
        givePrivileges(childNPath, privilegesFromName(Privilege.JCR_REMOVE_NODE),
                getRestrictions(superuser, childNPath));
        testSession.getWorkspace().move(childNPath, destPath);

        // withdraw  'add_child_nodes' privilege on former src-parent
        // -> moving child-node back must fail
        withdrawPrivileges(path, privilegesFromName(Privilege.JCR_ADD_CHILD_NODES), getRestrictions(superuser, path));
        try {
            testSession.getWorkspace().move(destPath, childNPath);
            fail("Move requires add and remove permission.");
        } catch (AccessDeniedException e) {
            // success.
        }
    }


    public void testGroupPermissions() throws NotExecutableException, RepositoryException {
        Group testGroup = getTestGroup();
        AccessControlManager testAcMgr = getTestACManager();
        /*
         precondition:
         testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);

        /* add privileges for the Group the test-user is member of */
        Privilege[] privileges = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
        givePrivileges(path, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));

        /* testuser must get the permissions/privileges inherited from
           the group it is member of.
         */
        String actions = javax.jcr.Session.ACTION_SET_PROPERTY + "," + javax.jcr.Session.ACTION_READ;

        assertTrue(getTestSession().hasPermission(path, actions));
        Privilege[] privs = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
        assertTrue(testAcMgr.hasPrivileges(path, privs));
    }


    public void testMixedUserGroupPermissions() throws NotExecutableException, RepositoryException {
        Group testGroup = getTestGroup();
        AccessControlManager testAcMgr = getTestACManager();
        /*
         precondition:
         testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);

        /* explicitly withdraw MODIFY_PROPERTIES for the user */
        Privilege[] privileges = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);
        withdrawPrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));
        /* give MODIFY_PROPERTIES privilege for a Group the test-user is member of */
        givePrivileges(path, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));
        /*
         since user-permissions overrule the group permissions, testuser must
         not have set_property action / modify_properties privilege.
         */
        String actions = javax.jcr.Session.ACTION_SET_PROPERTY;
        assertFalse(getTestSession().hasPermission(path, actions));
        assertFalse(testAcMgr.hasPrivileges(path, privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES)));
    }


    public void testInheritanceAndMixedUserGroupPermissions() throws RepositoryException, NotExecutableException {
        Group testGroup = getTestGroup();
        AccessControlManager testAcMgr = getTestACManager();
        /*
         precondition:
         testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);

        Privilege[] privileges = privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES);

        /* give MODIFY_PROPERTIES privilege for testGroup at 'path' */
        givePrivileges(path, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));

        /* withdraw MODIFY_PROPERTIES for the user at 'path' */
        withdrawPrivileges(path, testUser.getPrincipal(), privileges, getRestrictions(superuser, path));

        /*
         since user-permissions overrule the group permissions, testuser must
         not have set_property action / modify_properties privilege.
         */
        assertFalse(testAcMgr.hasPrivileges(path, privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES)));

        /*
         give MODIFY_PROPERTIES privilege for everyone at 'childNPath'
         -> user-privileges still overrule group privileges
         */
        givePrivileges(childNPath, testGroup.getPrincipal(), privileges, getRestrictions(superuser, path));
        assertFalse(testAcMgr.hasPrivileges(childNPath, privilegesFromName(Privilege.JCR_MODIFY_PROPERTIES)));
    }


    public void testGlobRestriction() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node child = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();
        String childchildPath = child.getPath();

        Privilege[] write = privilegesFromName(PrivilegeRegistry.REP_WRITE);
        String writeActions = Session.ACTION_ADD_NODE +","+Session.ACTION_REMOVE +","+ Session.ACTION_SET_PROPERTY;


        // permissions defined @ path
        // restriction: grants write priv to all nodeName3 children
        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, path));
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/*"+nodeName3));
        givePrivileges(path, write, restrictions);

        assertFalse(testAcMgr.hasPrivileges(path, write));
        assertFalse(testSession.hasPermission(path, javax.jcr.Session.ACTION_SET_PROPERTY));

        assertFalse(testAcMgr.hasPrivileges(childNPath, write));
        assertFalse(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_SET_PROPERTY));

        assertTrue(testAcMgr.hasPrivileges(childNPath2, write));
        assertTrue(testSession.hasPermission(childNPath2, Session.ACTION_SET_PROPERTY));
        assertFalse(testSession.hasPermission(childNPath2, writeActions)); // removal req. rmchildnode privilege on parent.

        assertTrue(testAcMgr.hasPrivileges(childchildPath, write));
    }


    public void testGlobRestriction3() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node child = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();
        String childchildPath = child.getPath();

        Privilege[] write = privilegesFromName(PrivilegeRegistry.REP_WRITE);
        Privilege[] addNode = privilegesFromName(Privilege.JCR_ADD_CHILD_NODES);
        String writeActions = Session.ACTION_ADD_NODE +","+Session.ACTION_REMOVE +","+ Session.ACTION_SET_PROPERTY;

        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, path));

        // permissions defined @ path
        // restriction: allows write to nodeName3 children
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/*/"+nodeName3));
        givePrivileges(path, write, restrictions);
        // and grant add-node only at path (no glob restriction)
        givePrivileges(path, addNode, getRestrictions(superuser, path));

        assertFalse(testAcMgr.hasPrivileges(path, write));
        assertTrue(testAcMgr.hasPrivileges(path, addNode));

        assertFalse(testAcMgr.hasPrivileges(childNPath, write));
        assertTrue(testAcMgr.hasPrivileges(childNPath, addNode));

        assertFalse(testAcMgr.hasPrivileges(childNPath2, write));
        assertTrue(testAcMgr.hasPrivileges(childchildPath, write));
    }


    public void testGlobRestriction4() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node child = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();
        String childchildPath = child.getPath();

        Privilege[] write = privilegesFromName(PrivilegeRegistry.REP_WRITE);
        Privilege[] addNode = privilegesFromName(Privilege.JCR_ADD_CHILD_NODES);

        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, path));
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/*"+nodeName3));
        givePrivileges(path, write, restrictions);

        withdrawPrivileges(childNPath2, addNode, getRestrictions(superuser, childNPath2));

        assertFalse(testAcMgr.hasPrivileges(path, write));
        assertFalse(testSession.hasPermission(path, javax.jcr.Session.ACTION_REMOVE));

        assertFalse(testAcMgr.hasPrivileges(childNPath, write));
        assertFalse(testSession.hasPermission(childNPath, javax.jcr.Session.ACTION_REMOVE));

        assertFalse(testAcMgr.hasPrivileges(childNPath2, write));

        assertTrue(testAcMgr.hasPrivileges(childchildPath, write));
    }


    public void testGlobRestriction2() throws Exception {
        Session testSession = getTestSession();
        AccessControlManager testAcMgr = getTestACManager();
        ValueFactory vf = superuser.getValueFactory();
        /*
          precondition:
          testuser must have READ-only permission on test-node and below
        */
        checkReadOnly(path);
        checkReadOnly(childNPath);

        Node child = superuser.getNode(childNPath).addNode(nodeName3);
        superuser.save();
        String childchildPath = child.getPath();

        Privilege[] write = privilegesFromName(PrivilegeRegistry.REP_WRITE);
        Privilege[] addNode = privilegesFromName(Privilege.JCR_ADD_CHILD_NODES);
        Privilege[] rmNode = privilegesFromName(Privilege.JCR_REMOVE_NODE);

        Map<String, Value> restrictions = new HashMap<String, Value>(getRestrictions(superuser, path));

        // permissions defined @ path
        // restriction: grants write-priv to nodeName3 grand-children but not direct nodeName3 children.
        restrictions.put(AccessControlConstants.P_GLOB.toString(), vf.createValue("/*/"+nodeName3));
        givePrivileges(path, write, restrictions);

        assertFalse(testAcMgr.hasPrivileges(path, write));
        assertFalse(testAcMgr.hasPrivileges(path, rmNode));

        assertFalse(testAcMgr.hasPrivileges(childNPath, addNode));

        assertFalse(testAcMgr.hasPrivileges(childNPath2, write));

        assertTrue(testAcMgr.hasPrivileges(childchildPath, write));
    }


    private static UserManager getUserManager(Session session) throws RepositoryException, NotExecutableException {
        if (!(session instanceof JackrabbitSession)) {
            throw new NotExecutableException();
        }
        try {
            return ((JackrabbitSession) session).getUserManager();
        } catch (UnsupportedRepositoryOperationException e) {
            throw new NotExecutableException(e.getMessage());
        } catch (UnsupportedOperationException e) {
            throw new NotExecutableException(e.getMessage());
        }
    }


    protected static UserManager getUserManager(Session session) throws RepositoryException, NotExecutableException {
        if (!(session instanceof JackrabbitSession)) {
            throw new NotExecutableException();
        }
        try {
            return ((JackrabbitSession) session).getUserManager();
        } catch (UnsupportedRepositoryOperationException e) {
            throw new NotExecutableException(e.getMessage());
        } catch (UnsupportedOperationException e) {
            throw new NotExecutableException(e.getMessage());
        }
    }


    public void testCheckPermissionReadOnlySession() throws RepositoryException, NotExecutableException {
        Session s = getHelper().getReadOnlySession();
        try {
            AccessManager acMgr = getAccessManager(s);

            NodeId id = (NodeId) getItemId(s.getItem(testRootNode.getPath()));

            acMgr.checkPermission(id, AccessManager.READ);
            try {
                acMgr.checkPermission(id, AccessManager.WRITE);
                fail();
            } catch (AccessDeniedException e) {
                // success
            }

            try {
                acMgr.checkPermission(id, AccessManager.WRITE | AccessManager.REMOVE);
                fail();
            } catch (AccessDeniedException e) {
                // success
            }
        } finally {
            s.logout();
        }
    }


    public void testReadOnlySession() throws NotExecutableException, RepositoryException {
        Session s = getHelper().getReadOnlySession();
        try {
            RetentionManager rmgr = getRetentionManager(s);
            try {
                rmgr.getRetentionPolicy(testNodePath);
                fail("Read-only session doesn't have sufficient privileges to retrieve retention policy.");
            } catch (AccessDeniedException e) {
                // success
            }
            try {
                rmgr.setRetentionPolicy(testNodePath, getApplicableRetentionPolicy());
                fail("Read-only session doesn't have sufficient privileges to retrieve retention policy.");
            } catch (AccessDeniedException e) {
                // success
            }
        } finally {
            s.logout();
        }
    }


    public void testReadOnlySession() throws NotExecutableException, RepositoryException {
        javax.jcr.Session s = getHelper().getReadOnlySession();
        try {
            RetentionManager rmgr = getRetentionManager(s);
            try {
                rmgr.getHolds(testNodePath);
                fail("Read-only session doesn't have sufficient privileges to retrieve holds.");
            } catch (AccessDeniedException e) {
                // success
            }
            try {
                rmgr.addHold(testNodePath, getHoldName(), false);
                fail("Read-only session doesn't have sufficient privileges to retrieve holds.");
            } catch (AccessDeniedException e) {
                // success
            }
        } finally {
            s.logout();
        }
    }


    public void testIsGranted() throws RepositoryException, NotExecutableException {
        Session s = getHelper().getReadOnlySession();
        try {
            AccessManager acMgr = getAccessManager(s);

            NodeId id = (NodeId) getItemId(s.getItem(testRootNode.getPath()));
            assertTrue(acMgr.isGranted(id, AccessManager.READ));
            assertFalse(acMgr.isGranted(id, AccessManager.WRITE));
            assertFalse(acMgr.isGranted(id, AccessManager.WRITE | AccessManager.REMOVE));
        } finally {
            s.logout();
        }
    }


    public void testIsGrantedOnNewNode() throws RepositoryException, NotExecutableException {
        Session s = getHelper().getReadWriteSession();
        try {
            AccessManager acMgr = getAccessManager(s);

            Node newNode = ((Node) s.getItem(testRoot)).addNode(nodeName2, testNodeType);
            NodeId id = (NodeId) getItemId(newNode);

            assertTrue(acMgr.isGranted(id, AccessManager.READ));
            assertTrue(acMgr.isGranted(id, AccessManager.WRITE));
            assertTrue(acMgr.isGranted(id, AccessManager.WRITE | AccessManager.REMOVE));
        } finally {
            s.logout();
        }
    }


    public void testIsGrantedOnProperty() throws RepositoryException, NotExecutableException {
        Session s = getHelper().getReadOnlySession();
        try {
            AccessManager acMgr = getAccessManager(s);

            PropertyId id = (PropertyId) getItemId(testRootNode.getProperty(jcrPrimaryType));

            assertTrue(acMgr.isGranted(id, AccessManager.READ));
            assertFalse(acMgr.isGranted(id, AccessManager.WRITE));
            assertFalse(acMgr.isGranted(id, AccessManager.WRITE | AccessManager.REMOVE));
        } finally {
            s.logout();
        }
    }


    public void testIsGrantedReadOnlySession() throws NotExecutableException, RepositoryException {
        Session s = getHelper().getReadOnlySession();
        try {
            AccessManager acMgr = getAccessManager(s);
            Path p = PathFactoryImpl.getInstance().getRootPath();

            // existing node-path
            assertTrue(acMgr.isGranted(p, Permission.READ));
            // not existing property:
            assertTrue(acMgr.isGranted(p, NameConstants.JCR_CREATED, Permission.READ));

            // existing node-path
            assertFalse(acMgr.isGranted(p, Permission.ALL));
            // not existing property:
            assertFalse(acMgr.isGranted(p, NameConstants.JCR_CREATED, Permission.ALL));
        } finally {
            s.logout();
        }
    }


    public static Principal getReadOnlyPrincipal(RepositoryHelper helper) throws RepositoryException, NotExecutableException {
        SessionImpl s = (SessionImpl) helper.getReadOnlySession();
        try {
            for (Principal p : s.getSubject().getPrincipals()) {
                if (!(p instanceof Group)) {
                    return p;
                }
            }
        } finally {
            s.logout();
        }
        throw new NotExecutableException();
    }


    private static Principal findKnownPrincipal(Repository repo)
            throws RepositoryException {
        SessionImpl session = (SessionImpl) repo.login(
                new SimpleCredentials("admin", "admin".toCharArray()));
        try {
            for (Principal principal : session.getSubject().getPrincipals()) {
                if (!(principal instanceof Group)) {
                    return principal;
                }
            }
            throw new RepositoryException("Known principal not found");
        } finally {
            session.logout();
        }
    }


    protected FileSystem getFileSystem() throws Exception {
        connectionFactory = new ConnectionFactory();
        final OracleFileSystem fs = new OracleFileSystem();
        fs.setConnectionFactory(connectionFactory);
        fs.setUrl(System.getProperty("tests.oracle.url"));
        fs.setUser(System.getProperty("tests.oracle.user"));
        fs.setPassword(System.getProperty("tests.oracle.password"));
        fs.setDriver(System.getProperty("tests.oracle.driver", "oracle.jdbc.driver.OracleDriver"));
        fs.setSchemaObjectPrefix(System.getProperty("tests.oracle.schemaObjectPrefix", ""));
        fs.setTablespace(System.getProperty("tests.oracle.tablespace"));
        fs.setSchema("oracle");
        return fs;
    }


    protected FileSystem getFileSystem() throws Exception {
        connectionFactory = new ConnectionFactory();
        final OracleFileSystem fs = new OracleFileSystem();
        fs.setConnectionFactory(connectionFactory);
        fs.setUrl(System.getProperty("tests.oracle.url"));
        fs.setUser(System.getProperty("tests.oracle.user"));
        fs.setPassword(System.getProperty("tests.oracle.password"));
        fs.setDriver(System.getProperty("tests.oracle.driver", "oracle.jdbc.driver.OracleDriver"));
        fs.setSchemaObjectPrefix(System.getProperty("tests.oracle.schemaObjectPrefix", ""));
        fs.setTablespace(System.getProperty("tests.oracle.tablespace"));
        fs.setIndexTablespace(System.getProperty("tests.oracle.indexTablespace"));
        fs.setSchema("oracle");
        return fs;
    }


    protected void tearDown() throws Exception {
        workspace = null;

        // remove all test nodes in second workspace
        if (superuserW2 != null) {
            try {
                if (!isReadOnly) {
                    // do a 'rollback'
                    cleanUpTestRoot(superuserW2);
                }
            } finally {
                superuserW2.logout();
                superuserW2 = null;
            }
        }
        if (rwSessionW2 != null) {
            rwSessionW2.logout();
            rwSessionW2 = null;
        }
        workspaceW2 = null;
        testRootNodeW2 = null;
        node1W2 = null;
        node2W2 = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        // remove all test nodes in second workspace
        if (superuserW2 != null) {
            try {
                if (!isReadOnly) {
                    // do a 'rollback'
                    cleanUpTestRoot(superuserW2);
                }
            } finally {
                superuserW2.logout();
                superuserW2 = null;
            }
        }
        if (rwSessionW2 != null) {
            rwSessionW2.logout();
            rwSessionW2 = null;
        }
        workspaceW2 = null;
        testRootNodeW2 = null;
        node1W2 = null;
        node2W2 = null;
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        // remove all test nodes in second workspace
        if (superuserW2 != null) {
            try {
                if (!isReadOnly) {
                    cleanUpTestRoot(superuserW2);
                }
            } finally {
                superuserW2.logout();
                superuserW2 = null;
            }
        }
        workspace = null;
        workspaceW2 = null;
        testRootNodeW2 = null;

        super.tearDown();
    }


    protected void cleanUp() throws Exception {
        if (superuser != null) {
            try {
                if (!isReadOnly && isSupported(Repository.LEVEL_2_SUPPORTED)) {
                    cleanUpTestRoot(superuser);
                }
            } catch (Exception e) {
                log.println("Exception in tearDown: " + e.toString());
            } finally {
                superuser.logout();
                superuser = null;
                vf = null;
            }
        }
        testRootNode = null;
    }


    protected void initNodesW2() throws RepositoryException {

        // testroot
        if (superuserW2.getRootNode().hasNode(testPath)) {
            testRootNodeW2 = superuserW2.getRootNode().getNode(testPath);
            // clean test root
            for (NodeIterator it = testRootNodeW2.getNodes(); it.hasNext(); ) {
                it.nextNode().remove();
            }
            testRootNodeW2.save();
        } else {
            testRootNodeW2 = superuserW2.getRootNode().addNode(testPath, testNodeType);
            superuserW2.save();
        }
    }


    protected void initNodesW2() throws RepositoryException {

        // testroot
        if (superuserW2.getRootNode().hasNode(testPath)) {
            testRootNodeW2 = superuserW2.getRootNode().getNode(testPath);
            // clean test root
            for (NodeIterator it = testRootNodeW2.getNodes(); it.hasNext(); ) {
                it.nextNode().remove();
            }
            testRootNodeW2.save();
        } else {
            testRootNodeW2 = superuserW2.getRootNode().addNode(testPath, testNodeType);
            superuserW2.save();
        }

        // some test nodes
        superuserW2.getWorkspace().copy(workspace.getName(), node1.getPath(), node1.getPath());
        node1W2 = testRootNodeW2.getNode(node1.getName());

        superuserW2.getWorkspace().copy(workspace.getName(), node2.getPath(), node2.getPath());
        node2W2 = testRootNodeW2.getNode(node2.getName());
    }


    public void testAddSNS() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a = ism.addNode(ism.getRoot(), "a");
        NodeState b1 = ism.addNode(a, "b");
        Path path = cache.getPath(b1.getNodeId());
        assertEquals(toPath("/a/b"), path);
        NodeState b2 = ism.addNode(a, "b");
        ism.orderBefore(b2, b1);
        assertTrue(cache.isCached(b1.getNodeId(), null));
        path = cache.getPath(b1.getNodeId());
        assertEquals(toPath("/a/b[2]"), path);
    }


    public void testOrderBefore() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a = ism.addNode(ism.getRoot(), "a");
        NodeState b1 = ism.addNode(a, "b");
        NodeState b2 = ism.addNode(a, "b");
        NodeState b3 = ism.addNode(a, "b");
        Path path = cache.getPath(b1.getNodeId());
        assertEquals(toPath("/a/b"), path);
        ism.orderBefore(b2, b1);
        ism.orderBefore(b1, b3);
        path = cache.getPath(b1.getNodeId());
        assertEquals(toPath("/a/b[2]"), path);
    }


    public void testCloneAndRemove() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a1 = ism.addNode(ism.getRoot(), "a1");
        NodeState a2 = ism.addNode(ism.getRoot(), "a2");
        NodeState b1 = ism.addNode(a1, "b1");
        b1.addShare(b1.getParentId());
        ism.cloneNode(b1, a2, "b2");

        Path path1 = toPath("/a1/b1");
        Path path2 = toPath("/a2/b2");

        assertNotNull(cache.resolvePath(path1));
        assertTrue(cache.isCached(b1.getNodeId(), path1));

        ism.removeNode(b1);

        assertNull(cache.resolvePath(path1));
        assertNotNull(cache.resolvePath(path2));
    }


    public void testCloneAndAddChildAndMove() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a1 = ism.addNode(ism.getRoot(), "a1");
        NodeState a2 = ism.addNode(ism.getRoot(), "a2");
        NodeState b1 = ism.addNode(a1, "b1");
        b1.addShare(b1.getParentId());
        ism.cloneNode(b1, a2, "b2");
        NodeState c = ism.addNode(b1, "c");

        Path path1 = toPath("/a1/b1/c");
        Path path2 = toPath("/a2/b2/c");

        assertNotNull(cache.resolvePath(path1));
        assertTrue(cache.isCached(c.getNodeId(), path1));
        assertNotNull(cache.resolvePath(path2));
        assertTrue(cache.isCached(c.getNodeId(), path2));

        ism.moveNode(c, a1, "c");

        assertNull(cache.resolvePath(path1));
        assertNull(cache.resolvePath(path2));
    }


    public void testRemoveSNS() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a = ism.addNode(ism.getRoot(), "a");
        NodeState b1 = ism.addNode(a, "b");
        NodeState b2 = ism.addNode(a, "b");
        Path path = cache.getPath(b2.getNodeId());
        assertEquals(toPath("/a/b[2]"), path);
        ism.removeNode(b1);
        path = cache.getPath(b2.getNodeId());
        assertEquals(toPath("/a/b"), path);
    }


    public void testRemoveSNSWithCachedPath() throws Exception {
        StaticItemStateManager ism = new StaticItemStateManager();
        cache = new CachingHierarchyManager(ism.getRootNodeId(), ism);
        ism.setContainer(cache);
        NodeState a = ism.addNode(ism.getRoot(), "a");
        NodeState b1 = ism.addNode(a, "b");
        NodeState b2 = ism.addNode(a, "b");
        cache.getPath(b1.getNodeId());
        Path path = cache.getPath(b2.getNodeId());
        assertEquals(toPath("/a/b[2]"), path);
        ism.removeNode(b1);
        path = cache.getPath(b2.getNodeId());
        assertEquals(toPath("/a/b"), path);
    }


        public NodeState addNode(NodeState parent, String name) {
            NodeId id = nextNodeId();
            NodeState child = new NodeState(id, NameConstants.NT_UNSTRUCTURED,
                    parent.getNodeId(), NodeState.STATUS_EXISTING, false);
            if (listener != null) {
                child.setContainer(listener);
            }
            states.put(id, child);
            parent.addChildNodeEntry(toName(name), child.getNodeId());
            return child;
        }


        public PropertyState addProperty(NodeState parent, String name) {
            PropertyId id = new PropertyId(parent.getNodeId(), toName(name));
            PropertyState child = new PropertyState(id,
                    PropertyState.STATUS_EXISTING, false);
            if (listener != null) {
                child.setContainer(listener);
            }
            states.put(id, child);
            parent.addPropertyName(toName(name));
            return child;
        }


    private static Set<Name> randomNameSet(Random r) {
        if (r.nextInt(100) == 0) {
            return null;
        }
        int size = randomSize(r);
        HashSet<Name> set = new HashSet<Name>();
        for(int i=0; i<size; i++) {
            set.add(randomName(r));
        }
        return set;
    }


    private static Set<NodeId> randomNodeIdSet(Random r) {
        if (r.nextInt(100) == 0) {
            return null;
        } else if (r.nextInt(10) == 0) {
            return Collections.emptySet();
        }
        int size = randomSize(r);
        HashSet<NodeId> set = new HashSet<NodeId>();
        for(int i=0; i<size; i++) {
            set.add(randomNodeId(r));
        }
        return set;
    }


    private String getAlternativeWorkspaceName() throws RepositoryException {
        String altWsp = null;
        String[] wsps = superuser.getWorkspace().getAccessibleWorkspaceNames();
        if (wsps.length == 1) {
            superuser.getWorkspace().createWorkspace("tmp");
            altWsp = "tmp";
        } else {
            for (String name : wsps) {
                if (!name.equals(superuser.getWorkspace().getName())) {
                    altWsp = name;
                    break;
                }
            }
        }
        return altWsp;
    }


    private String getAlternativeWorkspaceName() throws RepositoryException {
        String altWsp = null;
        String[] wsps = superuser.getWorkspace().getAccessibleWorkspaceNames();
        if (wsps.length == 1) {
            superuser.getWorkspace().createWorkspace("tmp");
            altWsp = "tmp";
        } else {
            for (String name : wsps) {
                if (!name.equals(superuser.getWorkspace().getName())) {
                    altWsp = name;
                    break;
                }
            }
        }
        return altWsp;
    }


    public void testMissingVHR() throws Exception {

        // new repository
        TransientRepository rep = new TransientRepository(new File(TEST_DIR));
        Session s = openSession(rep, false);

        String oldVersionRecoveryProp = System
                .getProperty("org.apache.jackrabbit.version.recovery");

        try {
            Node root = s.getRootNode();

            Node test = root.addNode("test");
            test.addMixin("mix:versionable");

            s.save();

            Node vhr = s.getWorkspace().getVersionManager()
                    .getVersionHistory(test.getPath());

            assertNotNull(vhr);

            Node brokenNode = vhr;
            String vhrRootVersionId = vhr.getNode("jcr:rootVersion").getIdentifier();
            UUID destroy = UUID.fromString(brokenNode.getIdentifier());
            s.logout();

            destroyBundle(destroy, "version");

            s = openSession(rep, false);

            ConsistencyReport report = TestHelper.checkVersionStoreConsistency(s, false, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());

            try {
                test = s.getRootNode().getNode("test");
                vhr = s.getWorkspace().getVersionManager()
                        .getVersionHistory(test.getPath());
                fail("should not get here");
            } catch (Exception ex) {
                // expected
            }

            s.logout();

            System.setProperty("org.apache.jackrabbit.version.recovery", "true");

            s = openSession(rep, false);

            test = s.getRootNode().getNode("test");
            // versioning should be disabled now
            assertFalse(test.isNodeType("mix:versionable"));

            try {
                // try to enable versioning again
                test.addMixin("mix:versionable");
                s.save();

                fail("enabling versioning succeeded unexpectedly");
            }
            catch (Exception e) {
                // we expect this to fail
            }

            s.logout();

            // now redo after running fixup on versioning storage
            s = openSession(rep, false);

            report = TestHelper.checkVersionStoreConsistency(s, true, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());
            int reportitems = report.getItems().size();

            // problems should now be fixed
            report = TestHelper.checkVersionStoreConsistency(s, false, null);
            assertTrue("Some problems should have been fixed but are not: " + report, report.getItems().size() < reportitems);

            // get a fresh session
            s.logout();
            s = openSession(rep, false);

            test = s.getRootNode().getNode("test");
            // versioning should be disabled now
            assertFalse(test.isNodeType("mix:versionable"));

            // try to enable versioning again
            test.addMixin("mix:versionable");
            s.save();

            Node oldRootVersion = s.getNodeByIdentifier(vhrRootVersionId);
            try {
                String path = oldRootVersion.getPath();
                fail("got path " + path + " for a node believed to be orphaned");
            }
            catch (ItemNotFoundException ex) {
                // orphaned
            }

            Node newRootVersion = s.getWorkspace().getVersionManager()
                    .getVersionHistory(test.getPath()).getRootVersion();
            assertFalse(
                    "new root version should be a different node than the one destroyed by the test case",
                    newRootVersion.getIdentifier().equals(vhrRootVersionId));
            assertNotNull("new root version should have a intact path",
                    newRootVersion.getPath());
        } finally {
            s.logout();
            System.setProperty("org.apache.jackrabbit.version.recovery",
                    oldVersionRecoveryProp == null ? ""
                            : oldVersionRecoveryProp);
        }
    }


    public void testMissingRootVersion() throws Exception {

        // new repository
        TransientRepository rep = new TransientRepository(new File(TEST_DIR));
        Session s = openSession(rep, false);

        String oldVersionRecoveryProp = System
                .getProperty("org.apache.jackrabbit.version.recovery");

        try {
            Node root = s.getRootNode();

            // add nodes /test and /test/missing
            Node test = root.addNode("test", "nt:file");
            test.addNode("jcr:content", "nt:unstructured");
            test.addMixin("mix:versionable");

            s.save();

            Node vhr = s.getWorkspace().getVersionManager()
                    .getVersionHistory(test.getPath());

            assertNotNull(vhr);

            Node brokenNode = vhr.getNode("jcr:rootVersion");
            String vhrId = vhr.getIdentifier();

            UUID destroy = UUID.fromString(brokenNode.getIdentifier());
            s.logout();

            destroyBundle(destroy, "version");

            s = openSession(rep, false);

            ConsistencyReport report = TestHelper.checkVersionStoreConsistency(s, false, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());

            try {
                test = s.getRootNode().getNode("test");
                vhr = s.getWorkspace().getVersionManager()
                        .getVersionHistory(test.getPath());
                fail("should not get here");
            } catch (Exception ex) {
                // expected
            }

            s.logout();

            System.setProperty("org.apache.jackrabbit.version.recovery", "true");

            s = openSession(rep, false);

            test = s.getRootNode().getNode("test");
            // versioning should be disabled now
            assertFalse(test.isNodeType("mix:versionable"));

            try {
                // try to enable versioning again
                test.addMixin("mix:versionable");
                s.save();

                fail("enabling versioning succeeded unexpectedly");
            }
            catch (Exception e) {
                // we expect this to fail
            }

            s.logout();

            // now redo after running fixup on versioning storage
            s = openSession(rep, false);

            report = TestHelper.checkVersionStoreConsistency(s, true, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());
            int reportitems = report.getItems().size();

            // problems should now be fixed
            report = TestHelper.checkVersionStoreConsistency(s, false, null);
            assertTrue("Some problems should have been fixed but are not: " + report, report.getItems().size() < reportitems);

            test = s.getRootNode().getNode("test");
            // versioning should be disabled now
            assertFalse(test.isNodeType("mix:versionable"));
            // jcr:uuid property should still be present
            assertTrue(test.hasProperty("jcr:uuid"));
            // ...and have a proper definition
            assertNotNull(test.getProperty("jcr:uuid").getDefinition().getName());
            // try to enable versioning again
            test.addMixin("mix:versionable");
            s.save();

            Node oldVHR = s.getNodeByIdentifier(vhrId);
            Node newVHR = s.getWorkspace().getVersionManager().getVersionHistory(test.getPath());

            assertTrue("old and new version history path should be different: "
                    + oldVHR.getPath() + " vs " + newVHR.getPath(), !oldVHR
                    .getPath().equals(newVHR.getPath()));

            // name should be same plus suffix
            assertTrue(oldVHR.getName().startsWith(newVHR.getName()));

            // try a checkout / checkin
            s.getWorkspace().getVersionManager().checkout(test.getPath());
            s.getWorkspace().getVersionManager().checkin(test.getPath());

        } finally {
            s.logout();
            System.setProperty("org.apache.jackrabbit.version.recovery",
                    oldVersionRecoveryProp == null ? ""
                            : oldVersionRecoveryProp);
        }
    }


    public void testMissingRootVersion2() throws Exception {

        // new repository
        TransientRepository rep = new TransientRepository(new File(TEST_DIR));
        Session s = openSession(rep, false);

        String oldVersionRecoveryProp = System
                .getProperty("org.apache.jackrabbit.version.recovery");

        try {
            Node root = s.getRootNode();

            // add nodes /test and /test/missing
            Node test = root.addNode("test");
            test.addMixin("mix:versionable");

            s.save();

            Node vhr = s.getWorkspace().getVersionManager()
                    .getVersionHistory(test.getPath());

            assertNotNull(vhr);

            Node brokenNode = vhr.getNode("jcr:rootVersion");
            String vhrId = vhr.getIdentifier();

            UUID destroy = UUID.fromString(brokenNode.getIdentifier());

            // disable versioning
            test.removeMixin("mix:versionable");
            s.save();

            s.logout();


            destroyBundle(destroy, "version");

            s = openSession(rep, false);

            ConsistencyReport report = TestHelper.checkVersionStoreConsistency(s, false, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());

            s.logout();

            System.setProperty("org.apache.jackrabbit.version.recovery", "true");

            s = openSession(rep, false);
            s.logout();

            s = openSession(rep, false);

            test = s.getRootNode().getNode("test");
            // versioning should still be disabled
            assertFalse(test.isNodeType("mix:versionable"));

            // try to enable versioning again
            test.addMixin("mix:versionable");
            s.save();

            Node oldVHR = s.getNodeByIdentifier(vhrId);
            Node newVHR = s.getWorkspace().getVersionManager().getVersionHistory(test.getPath());

            assertTrue("old and new version history path should be different: "
                    + oldVHR.getPath() + " vs " + newVHR.getPath(), !oldVHR
                    .getPath().equals(newVHR.getPath()));

            // name should be same plus suffix
            assertTrue(oldVHR.getName().startsWith(newVHR.getName()));

            // try a checkout / checkin
            s.getWorkspace().getVersionManager().checkout(test.getPath());
            s.getWorkspace().getVersionManager().checkin(test.getPath());
        } finally {
            s.logout();
            System.setProperty("org.apache.jackrabbit.version.recovery",
                    oldVersionRecoveryProp == null ? ""
                            : oldVersionRecoveryProp);
        }
    }


    public void testBrokenVhrParent() throws Exception {

        // new repository
        TransientRepository rep = new TransientRepository(new File(TEST_DIR));
        Session s = openSession(rep, false);

        try {
            Node root = s.getRootNode();

            // add node /test
            Node test = root.addNode("test");
            test.addMixin("mix:versionable");

            s.save();

            Node vhr = s.getWorkspace().getVersionManager().getVersionHistory(test.getPath());

            assertNotNull(vhr);

            Node brokenNode = vhr.getParent().getParent();

            UUID destroy = UUID.fromString(brokenNode.getIdentifier());

            // disable versioning
            test.removeMixin("mix:versionable");
            s.save();

            s.logout();

            destroyBundle(destroy, "version");

            s = openSession(rep, false);

            ConsistencyReport report = TestHelper.checkVersionStoreConsistency(s, true, null);
            assertTrue("Report should have reported broken nodes", !report.getItems().isEmpty());

            s.logout();

            s = openSession(rep, false);

            test = s.getRootNode().getNode("test");
            // versioning should still be disabled
            assertFalse(test.isNodeType("mix:versionable"));

            // try to enable versioning again
            test.addMixin("mix:versionable");
            s.save();

            // try a checkout / checkin
            s.getWorkspace().getVersionManager().checkout(test.getPath());
            s.getWorkspace().getVersionManager().checkin(test.getPath());
        } finally {
            s.logout();
        }
    }


    public void testCloneUser() throws Exception {
        String altWsp = getAlternativeWorkspaceName();
        if (altWsp == null) {
            throw new NotExecutableException();
        }

        UserManager uMgr = ((JackrabbitSession) superuser).getUserManager();

        Session s = getHelper().getSuperuserSession(altWsp);
        User u = null;
        try {
            // other users created in the default workspace...
            u = uMgr.createUser("testUser", "testUser");
            superuser.save();

            String userPath = null;
            if (u.getPrincipal() instanceof ItemBasedPrincipal) {
                userPath = ((ItemBasedPrincipal) u.getPrincipal()).getPath();
                assertTrue(superuser.nodeExists(userPath));
            } else {
                throw new NotExecutableException();
            }

            // ... must not be present in the alternate-workspace
            UserManager umgr = ((JackrabbitSession) s).getUserManager();
            assertNull(umgr.getAuthorizable("testUser"));
            assertFalse(s.nodeExists(userPath));

            String clonePath = userPath;
            String parentPath = Text.getRelativeParent(clonePath, 1);
            while (!s.nodeExists(parentPath)) {
                clonePath = parentPath;
                parentPath = Text.getRelativeParent(parentPath, 1);
            }

            // clone the user into the second workspace
            s.getWorkspace().clone(superuser.getWorkspace().getName(), clonePath, clonePath, true);

            // ... now the user must be visible
            assertNotNull(umgr.getAuthorizable("testUser"));
            if (userPath != null) {
                assertTrue(s.nodeExists(userPath));                
            }
            // ... and able to login to that workspace
            Session us = getHelper().getRepository().login(new SimpleCredentials("testUser", "testUser".toCharArray()), altWsp);
            us.logout();

        } finally {
            // remove the test user in the second workspace
            Authorizable dest = ((JackrabbitSession) s).getUserManager().getAuthorizable("testUser");
            if (dest != null) {
                dest.remove();
                s.save();
            }
            // logout the session
            s.logout();
            if (u != null) {
                // remove as well in the first workspace
                u.remove();
                superuser.save();
            }
        }
    }


    public void testUpdateUser() throws NotExecutableException, RepositoryException {
        // create the same use in 2 different workspace must make the 'corresponding'
        // and updating must succeed
        String altWsp = getAlternativeWorkspaceName();
        if (altWsp == null) {
            throw new NotExecutableException();
        }

        UserManager uMgr = ((JackrabbitSession) superuser).getUserManager();

        Session s = getHelper().getSuperuserSession(altWsp);
        User u = null;
        try {
            // other users created in the default workspace...
            u = uMgr.createUser("testUser", "testUser");
            superuser.save();

            String userPath = null;
            if (u.getPrincipal() instanceof ItemBasedPrincipal) {
                userPath = ((ItemBasedPrincipal) u.getPrincipal()).getPath();
                assertTrue(superuser.nodeExists(userPath));
            } else {
                throw new NotExecutableException();
            }

            // ... must not be present in the alternate-workspace
            UserManager umgr = ((JackrabbitSession) s).getUserManager();
            assertNull(umgr.getAuthorizable("testUser"));
            assertFalse(s.nodeExists(userPath));

            User u2 = umgr.createUser("testUser", "testUser");
            s.save();
            assertTrue(s.nodeExists(userPath));

            Value value = superuser.getValueFactory().createValue("anyValue");
            u.setProperty(propertyName1, value);
            superuser.save();

            // no automatic sync.
            assertFalse(u2.hasProperty(propertyName1));

            // update nodes
            Node n2 = s.getNode(userPath);
            n2.update(superuser.getWorkspace().getName());

            // now the value must be visible
            assertTrue(u2.hasProperty(propertyName1));
            assertEquals(value.getString(), u2.getProperty(propertyName1)[0].getString());
            
        } finally {
            // remove the test user in the destination workspace
            Authorizable dest = ((JackrabbitSession) s).getUserManager().getAuthorizable("testUser");
            if (dest != null) {
                dest.remove();
                s.save();
            }
            // logout the session to the destination workspace
            s.logout();
            if (u != null) {
                // and remove it in the default workspace as well
                u.remove();
                superuser.save();
            }
        }
    }


    public void testInvalidXMLNodeTypes() throws Exception {
        JackrabbitNodeTypeManager ntm = (JackrabbitNodeTypeManager)
            superuser.getWorkspace().getNodeTypeManager();
        try {
            ntm.registerNodeTypes(
                TestAll.class.getResourceAsStream(TEST_SAME_NT_NAME_XML_NODETYPES),
                JackrabbitNodeTypeManager.TEXT_XML);
            fail("Importing multiple node types with the same name must fail");
        } catch (RepositoryException e) {
            if (e.getCause() instanceof InvalidNodeTypeDefException) {
               // Expected
            } else {
               throw e;
            }
        }
    }


    public void testInvalidCNDNodeTypes() throws Exception {
        JackrabbitNodeTypeManager ntm = (JackrabbitNodeTypeManager)
            superuser.getWorkspace().getNodeTypeManager();
        try {
            ntm.registerNodeTypes(
                TestAll.class.getResourceAsStream(TEST_SAME_NT_NAME_CND_NODETYPES),
                JackrabbitNodeTypeManager.TEXT_X_JCR_CND);
            fail("Importing multiple node types with the same name must fail");
        } catch (RepositoryException e) {
            if (e.getCause() instanceof InvalidNodeTypeDefException) {
               // Expected
            } else {
               throw e;
            }
        }
    }


    private void assertPredecessors(String expected, Version version)
            throws Exception {
        Set predecessors = new HashSet();
        if (expected.length() > 0) {
            predecessors.addAll(Arrays.asList(expected.split(" ")));
        }
        Version[] versions = version.getPredecessors();
        for (int i = 0; i < versions.length; i++) {
            if (!predecessors.remove(versions[i].getName())) {
                fail("Version " + version.getName()
                        + " has an unexpected predessor "
                        + versions[i].getName());
            }
        }
        if (!predecessors.isEmpty()) {
            fail("Version " + version.getName()
                    + " does not have all expected predecessors");
        }
    }


    private void assertSuccessors(String expected, Version version)
            throws Exception {
        Set successors = new HashSet();
        if (expected.length() > 0) {
            successors.addAll(Arrays.asList(expected.split(" ")));
        }
        Version[] versions = version.getSuccessors();
        for (int i = 0; i < versions.length; i++) {
            if (!successors.remove(versions[i].getName())) {
                fail("Version " + version.getName()
                        + " has an unexpected successor "
                        + versions[i].getName());
            }
        }
        if (!successors.isEmpty()) {
            fail("Version " + version.getName()
                    + " does not have all expected successors");
        }
    }


    public void testRangeQuery() throws RepositoryException {
        int count = 0;
        for (int i = 0; i < 20; i++) {
            Node child = testRootNode.addNode("node" + i);
            for (int j = 0; j < 100; j++) {
                Node n = child.addNode("node" + j);
                n.setProperty("foo", count++);
            }
            // save every 100 nodes
            testRootNode.save();
        }

        QueryManager qm = superuser.getWorkspace().getQueryManager();
        String stmt = testPath + "//*[@foo >= 0]";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();
        checkResult(res, 2000);
    }


    public void testWildcardQuery() throws RepositoryException {
        int count = 0;
        for (int i = 0; i < 20; i++) {
            Node child = testRootNode.addNode("node" + i);
            for (int j = 0; j < 100; j++) {
                Node n = child.addNode("node" + j);
                n.setProperty("foo", "" + count + "foo");
                n.setProperty("bar", "bar" + count++);
            }
            // save every 100 nodes
            testRootNode.save();
        }

        QueryManager qm = superuser.getWorkspace().getQueryManager();
        String stmt = testPath + "//*[jcr:contains(., '*foo')]";
        QueryResult res = qm.createQuery(stmt, Query.XPATH).execute();
        checkResult(res, 2000);

        stmt = testPath + "//*[jcr:contains(., 'bar*')]";
        res = qm.createQuery(stmt, Query.XPATH).execute();
        checkResult(res, 2000);
    }


    private static Iterator<Property> removeIgnored(Iterator<Property> properties) {
        return filterIterator(properties, new Predicate<Property>() {
            public boolean evaluate(Property property) {
                try {
                    return !JcrConstants.JCR_PRIMARYTYPE.equals(property.getName());
                }
                catch (RepositoryException e) {
                    throw (AssertionFailedError) new AssertionFailedError().initCause(e);
                }
            }
        });
    }


    private static Iterator<String> property2Path(Iterator<Property> properties) {
        return transformIterator(properties, new Transformer<Property, String>() {
            public String transform(Property property) {
                try {
                    return property.getPath();
                }
                catch (RepositoryException e) {
                    throw (AssertionFailedError) new AssertionFailedError().initCause(e);
                }
            }
        });
    }


    public void testConcurrentQueryWithWrite() throws Exception {

        final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());
        List<QueryWorker> readers = new ArrayList<QueryWorker>();
        String query = "/jcr:root" + testRoot + "//*[@testprop = 'foo']";
        for (Session s : readSessions) {
            readers.add(new QueryWorker(s, query, exceptions, log));
        }

        Thread writer = new Thread() {
            public void run() {
                try {
                    for (int i = 0; i < 20; i++) {
                        Node n = testRootNode.addNode("node" + i);
                        for (int j = 0; j < 10; j++) {
                            Node n1 = n.addNode("node" + j);
                            for (int k = 0; k < 5; k++) {
                                n1.addNode("node" + k).setProperty("testprop", "foo");
                            }
                            testRootNode.save();
                        }
                    }
                } catch (RepositoryException e) {
                    exceptions.add(e);
                }
            }
        };

        // start the threads
        writer.start();
        for (Thread t : readers ) {
            t.start();
        }

        // wait for writer thread to finish its work
        writer.join();

        // request readers to finish
        for (QueryWorker t : readers) {
            t.finish();
            t.join();
        }

        // fail in case of exceptions
        if (exceptions.size() > 0) {
            fail(exceptions.get(0).toString());
        }
    }


    public void testConcurrentQueryWithDeletes() throws Exception {

        // create 1000 nodes
        for (int i = 0; i < 20; i++) {
            Node n = testRootNode.addNode("node" + i);
            for (int j = 0; j < 10; j++) {
                Node n1 = n.addNode("node" + j);
                for (int k = 0; k < 5; k++) {
                    n1.addNode("node" + k).setProperty("testprop", "foo");
                }
            }
            testRootNode.save();
        }

        final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());
        List<QueryWorker> readers = new ArrayList<QueryWorker>();
        String query = "/jcr:root" + testRoot + "//*[@testprop = 'foo']";
        for (Session s : readSessions) {
            readers.add(new QueryWorker(s, query, exceptions, log));
        }

        Thread writer = new Thread() {
            public void run() {
                try {
                    for (int i = 0; i < 20; i++) {
                        Node n = testRootNode.getNode("node" + i);
                        for (int j = 0; j < 10; j++) {
                            Node n1 = n.getNode("node" + j);
                            for (int k = 0; k < 5; k++) {
                                n1.getNode("node" + k).remove();
                            }
                            testRootNode.save();
                        }
                    }
                } catch (Exception e) {
                    exceptions.add(e);
                }
            }
        };

        // start the threads
        writer.start();
        for (Thread t : readers) {
            t.start();
        }

        // wait for writer thread to finish its work
        writer.join();

        // request readers to finish
        for (QueryWorker t : readers) {
            t.finish();
            t.join();
        }

        // fail in case of exceptions
        if (!exceptions.isEmpty()) {
            fail(exceptions.get(0).toString());
        }
    }


    public void testEmptyNodeSequence() throws RepositoryException {
        Comparator<String> order = Rank.<String>comparableComparator();
        TreeManager treeManager = new BTreeManager(testNode, 5, 10, order, true);
        NodeSequence nodes = ItemSequence.createNodeSequence(treeManager, errorHandler);

        Iterator<Node> nodeIt = nodes.iterator();
        assertTrue(nodeIt.hasNext());
        assertTrue(treeManager.isRoot(nodeIt.next()));
        assertFalse(nodeIt.hasNext());

        checkTreeProperty(testNode, 5, 10, order);
        checkOrder(nodes, order);
        assertEmpty(nodes);
    }


    public void testSingletonNodeSequence() throws RepositoryException {
        Comparator<String> order = Rank.<String>comparableComparator();
        TreeManager treeManager = new BTreeManager(testNode, 5, 10, order, true);
        NodeSequence nodes = ItemSequence.createNodeSequence(treeManager, errorHandler);

        nodes.addNode("key", NodeType.NT_UNSTRUCTURED);
        assertTrue(nodes.hasItem("key"));

        Iterator<Node> nodeIt = nodes.iterator();
        assertTrue(nodeIt.hasNext());
        assertEquals("key", nodeIt.next().getName());
        assertFalse(nodeIt.hasNext());

        checkTreeProperty(testNode, 5, 10, order);
        checkOrder(nodes, order);

        nodes.removeNode("key");
        assertEmpty(nodes);
    }


    public void testSingletonPropertySequence() throws RepositoryException {
        Comparator<String> order = Rank.<String>comparableComparator();
        TreeManager treeManager = new BTreeManager(testNode, 2, 4, order, true);
        PropertySequence properties = ItemSequence.createPropertySequence(treeManager, errorHandler);

        ValueFactory vFactory = testNode.getSession().getValueFactory();
        properties.addProperty("key", vFactory.createValue("key_"));
        assertTrue(properties.hasItem("key"));

        Iterator<Property> propertyIt = properties.iterator();
        assertTrue(propertyIt.hasNext());
        assertEquals("key", propertyIt.next().getName());
        assertFalse(propertyIt.hasNext());

        properties.removeProperty("key");
        assertEmpty(properties);
    }


    public void testNodeSequence() throws RepositoryException, IOException {
        Comparator<String> order = Rank.<String>comparableComparator();
        TreeManager treeManager = new BTreeManager(testNode, 5, 10, order, true);
        NodeSequence nodes = ItemSequence.createNodeSequence(treeManager, errorHandler);

        List<String> words = loadWords();
        Collections.shuffle(words);

        addAll(nodes, words);
        checkTreeProperty(testNode, 5, 10, order);
        checkOrder(nodes, order);

        Collections.shuffle(words);
        checkLookup(nodes, words);

        Collections.shuffle(words);
        List<String> toRemove = take(words.size()/5, words);
        removeAll(nodes, toRemove);
        checkNotFound(nodes, toRemove);
        checkLookup(nodes, words);

        removeAll(nodes, words);
        assertEmpty(nodes);
    }


    public void testPropertySequence() throws RepositoryException, IOException {
        Comparator<String> order = Rank.<String>comparableComparator();
        TreeManager treeManager = new BTreeManager(testNode, 2, 4, order, true);
        PropertySequence properties = ItemSequence.createPropertySequence(treeManager, errorHandler);

        List<String> words = loadWords();
        Collections.shuffle(words);

        ValueFactory vFactory = testNode.getSession().getValueFactory();
        addAll(properties, words, vFactory);
        checkTreeProperty(testNode, 2, 4, order);

        Collections.shuffle(words);
        checkLookup(properties, words);

        Collections.shuffle(words);
        List<String> toRemove = take(words.size()/5, words);
        removeAll(properties, toRemove);
        checkNotFound(properties, toRemove);
        checkLookup(properties, words);

        removeAll(properties, words);
        assertEmpty(properties);
    }


    private static void checkNotFound(NodeSequence nodes, List<String> keys) throws RepositoryException {
        for (String key : keys) {
            assertFalse("NodeSequence should not contain key " + key, nodes.hasItem(key));
            try {
                nodes.getItem(key);
                fail("NodeSequence should not contain key " + key);
            }
            catch (RepositoryException expected) { }
        }
    }


    private static void checkNotFound(PropertySequence properties, List<String> keys) throws RepositoryException {
        for (String key : keys) {
            assertFalse("PropertySequence should not contain key " + key, properties.hasItem(key));
            try {
                properties.getItem(key);
                fail("PropertySequence should not contain key " + key);
            }
            catch (RepositoryException expected) { }
        }
    }


    public void testType() throws RepositoryException {
        Node file = addFile(testRootNode, "file1.txt", SAMPLE_CONTENT);
        Node node = testRootNode.addNode("node1");
        node.setProperty("text", SAMPLE_CONTENT);
        superuser.save();
        // only nt:resource
        String stmt = createStatement("quick type:\"nt:resource\"");
        checkResultWithRetries(stmt, null, new Node[]{file.getNode("jcr:content")});
        // only nt:unstructured
        stmt = createStatement("quick type:\"nt:unstructured\"");
        RowIterator rows = GQL.execute(stmt, superuser);
        checkResult(rows, new Node[]{node});
    }


    public void testAutoPrefixType() throws RepositoryException {
        Node file = addFile(testRootNode, "file1.txt", SAMPLE_CONTENT);
        Node node = testRootNode.addNode("node1");
        node.setProperty("text", SAMPLE_CONTENT);
        superuser.save();
        // only nt:resource
        String stmt = createStatement("quick type:resource");
        checkResultWithRetries(stmt, null, new Node[]{file.getNode("jcr:content")});
        // only nt:unstructured
        stmt = createStatement("quick type:unstructured");
        RowIterator rows = GQL.execute(stmt, superuser);
        checkResult(rows, new Node[]{node});
    }


    public void testFilter() throws RepositoryException {
        final Node n1 = testRootNode.addNode("node1");
        n1.setProperty("jcr:title", "a");
        Node n2 = testRootNode.addNode("node2");
        n2.setProperty("jcr:title", "b");
        Node n3 = testRootNode.addNode("node3");
        n3.setProperty("jcr:title", "c");
        superuser.save();
        String stmt = createStatement("order:jcr:title");
        RowIterator rows = GQL.execute(stmt, superuser, null, new GQL.Filter() {
            public boolean include(Row row) throws RepositoryException {
                return !n1.getPath().equals(row.getValue("jcr:path").getString());
            }
        });
        checkResultSequence(rows, new Node[]{n2, n3});
    }


    public void testFilterLimit() throws RepositoryException {
        final Node n1 = testRootNode.addNode("node1");
        n1.setProperty("jcr:title", "a");
        Node n2 = testRootNode.addNode("node2");
        n2.setProperty("jcr:title", "b");
        Node n3 = testRootNode.addNode("node3");
        n3.setProperty("jcr:title", "c");
        superuser.save();
        String stmt = createStatement("order:jcr:title limit:1");
        RowIterator rows = GQL.execute(stmt, superuser, null, new GQL.Filter() {
            public boolean include(Row row) throws RepositoryException {
                return !n1.getPath().equals(row.getValue("jcr:path").getString());
            }
        });
        checkResultSequence(rows, new Node[]{n2});
    }


    public void testConcurrentUpdates() throws RepositoryException,
            InterruptedException {

        final Node lockable = testRootNode.addNode(nodeName1);
        lockable.addMixin(mixLockable);
        superuser.save();

        List<Future<?>> futures = new ArrayList<Future<?>>();
        ExecutorService e = Executors.newFixedThreadPool(NUM_THREADS);
        for (int i = 0; i < NUM_THREADS; i++) {
            futures.add(e.submit(buildNewConcurrentUpdateCallable(i,
                    lockable.getPath(), false)));
        }
        e.shutdown();
        assertTrue(e.awaitTermination(10 * 60, TimeUnit.SECONDS));

        for (Future<?> future : futures) {
            try {
                future.get();
            } catch (ExecutionException ex) {
                fail(ex.getMessage());
            }
        }
    }


    public void testConcurrentUpdatesWithSessionRefresh()
            throws RepositoryException, InterruptedException {

        final Node lockable = testRootNode.addNode(nodeName1);
        lockable.addMixin(mixLockable);
        superuser.save();

        List<Future<?>> futures = new ArrayList<Future<?>>();
        ExecutorService e = Executors.newFixedThreadPool(NUM_THREADS);
        for (int i = 0; i < NUM_THREADS; i++) {
            futures.add(e.submit(buildNewConcurrentUpdateCallable(i,
                    lockable.getPath(), true)));
        }
        e.shutdown();
        assertTrue(e.awaitTermination(10 * 60, TimeUnit.SECONDS));

        for (Future<?> future : futures) {
            try {
                future.get();
            } catch (ExecutionException ex) {
                fail(ex.getMessage());
            }
        }
    }


    public void testSequence() throws RepositoryException, InterruptedException {

        counter = new AtomicInteger(0);

        final Node lockable = testRootNode.addNode(nodeName1);
        lockable.setProperty("value", counter.getAndIncrement());
        lockable.addMixin(mixLockable);
        superuser.save();

        List<Future<Long>> futures = new ArrayList<Future<Long>>();
        ExecutorService e = Executors.newFixedThreadPool(NUM_THREADS);
        for (int i = 0; i < NUM_THREADS * NUM_VALUE_GETS; i++) {
            futures.add(e.submit(buildNewSequenceUpdateCallable(
                    lockable.getPath(), false)));
        }
        e.shutdown();
        assertTrue(e.awaitTermination(10 * 60, TimeUnit.SECONDS));

        for (Future<Long> future : futures) {
            try {
                Long v = future.get();
                log.println("Got sequence number: " + v);
            } catch (ExecutionException ex) {
                fail(ex.getMessage());
            }
        }
    }


    public void testSequenceWithSessionRefresh() throws RepositoryException,
            InterruptedException {

        counter = new AtomicInteger(0);

        final Node lockable = testRootNode.addNode(nodeName1);
        lockable.setProperty("value", counter.getAndIncrement());
        lockable.addMixin(mixLockable);
        superuser.save();

        List<Future<Long>> futures = new ArrayList<Future<Long>>();
        ExecutorService e = Executors.newFixedThreadPool(NUM_THREADS);
        for (int i = 0; i < NUM_THREADS * NUM_VALUE_GETS; i++) {
            futures.add(e.submit(buildNewSequenceUpdateCallable(
                    lockable.getPath(), true)));
        }
        e.shutdown();
        assertTrue(e.awaitTermination(10 * 60, TimeUnit.SECONDS));

        for (Future<Long> future : futures) {
            try {
                Long v = future.get();
                log.println("Got sequence number: " + v);
            } catch (ExecutionException ex) {
                fail(ex.getMessage());
            }
        }
    }


    public void testSetPropertyCommit() throws Exception {
        // prerequisite: non-existing property
        if (testRootNode.hasProperty(propertyName1)) {
            testRootNode.getProperty(propertyName1).remove();
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // set property and save
        testRootNode.setProperty(propertyName1, "0");
        testRootNode.save();

        // assertion: property exists in this session
        assertTrue(testRootNode.hasProperty(propertyName1));

        // assertion: property does not exist in other session
        Session otherSuperuser = getHelper().getSuperuserSession();
        Node otherRootNode = otherSuperuser.getRootNode().getNode(testPath);
        assertFalse(otherRootNode.hasProperty(propertyName1));

        // commit
        utx.commit();

        // assertion: property exists in this session
        assertTrue(testRootNode.hasProperty(propertyName1));

        // assertion: property also exists in other session
        assertTrue(otherRootNode.hasProperty(propertyName1));

        // logout
        otherSuperuser.logout();
    }


    public void testSetPropertyRollback() throws Exception {
        // prerequisite: non-existing property
        if (testRootNode.hasProperty(propertyName1)) {
            testRootNode.getProperty(propertyName1).remove();
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // set property and save
        testRootNode.setProperty(propertyName1, "0");
        testRootNode.save();

        // assertion: property exists in this session
        assertTrue(testRootNode.hasProperty(propertyName1));

        // rollback
        utx.rollback();

        // assertion: property does not exist in this session
        assertFalse(testRootNode.hasProperty(propertyName1));
    }


    public void testRemovePropertyRollback() throws Exception {
        // prerequisite: existing property
        if (!testRootNode.hasProperty(propertyName1)) {
            testRootNode.setProperty(propertyName1, "0");
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // remove property and save
        testRootNode.getProperty(propertyName1).remove();
        testRootNode.save();

        // assertion: property no longer exists
        assertFalse(testRootNode.hasProperty(propertyName1));

        // rollback
        utx.rollback();

        // assertion: property exists and reference valid
        assertTrue(testRootNode.hasProperty(propertyName1));
    }


    public void testPropertyIsNew() throws Exception {
        // prerequisite: non-existing property
        if (testRootNode.hasProperty(propertyName1)) {
            testRootNode.getProperty(propertyName1).remove();
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // 'add' property and save
        testRootNode.setProperty(propertyName1, "0");

        assertTrue("New property must be new.", testRootNode.getProperty(propertyName1).isNew());

        testRootNode.save();

        assertFalse("Saved property must not be new.", testRootNode.getProperty(propertyName1).isNew());

        // commit
        utx.commit();
    }


    public void testAddAndSetProperty() throws Exception {
        // prerequisite: non-existing property
        if (testRootNode.hasProperty(propertyName1)) {
            testRootNode.getProperty(propertyName1).remove();
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // 'add' property and save
        testRootNode.setProperty(propertyName1, "0");
        testRootNode.save();

        // 'modify' property and save
        testRootNode.setProperty(propertyName1, "1");
        testRootNode.save();

        // commit
        utx.commit();

        // check property value
        Session otherSuperuser = getHelper().getSuperuserSession();
        Node n = (Node) otherSuperuser.getItem(testRootNode.getPath());
        assertEquals(n.getProperty(propertyName1).getString(), "1");
        otherSuperuser.logout();
    }


    public void testDeleteAndAddProperty() throws Exception {
        // prerequisite: existing property
        testRootNode.setProperty(propertyName1, "0");
        testRootNode.save();

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // 'delete' property and save
        testRootNode.getProperty(propertyName1).remove();
        testRootNode.save();

        // 'add' property and save
        testRootNode.setProperty(propertyName1, "1");
        testRootNode.save();

        // commit
        utx.commit();

        // check property value
        Session otherSuperuser = getHelper().getSuperuserSession();
        Node n = (Node) otherSuperuser.getItem(testRootNode.getPath());
        assertEquals(n.getProperty(propertyName1).getString(), "1");
        otherSuperuser.logout();
    }


    public void testAddAndDeleteProperty() throws Exception {
        // prerequisite: non-existing property
        if (testRootNode.hasProperty(propertyName1)) {
            testRootNode.getProperty(propertyName1).remove();
            testRootNode.save();
        }

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // 'add' property and save
        testRootNode.setProperty(propertyName1, "1");
        testRootNode.save();

        // 'delete' property and save
        testRootNode.getProperty(propertyName1).remove();
        testRootNode.save();

        // commit
        utx.commit();

        // check property value
        Session otherSuperuser = getHelper().getSuperuserSession();
        Node n = (Node) otherSuperuser.getItem(testRootNode.getPath());
        assertFalse("Property must be deleted.", n.hasProperty(propertyName1));
        otherSuperuser.logout();
    }


    public void testModifyAndDeleteProperty() throws Exception {
        // prerequisite: existing property
        testRootNode.setProperty(propertyName1, "0");
        testRootNode.save();

        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // 'modify' property and save
        testRootNode.setProperty(propertyName1, "1");
        testRootNode.save();

        // 'delete' property and save
        testRootNode.getProperty(propertyName1).remove();
        testRootNode.save();

        // commit
        utx.commit();

        // check property value
        Session otherSuperuser = getHelper().getSuperuserSession();
        Node n = (Node) otherSuperuser.getItem(testRootNode.getPath());
        assertFalse("Property must be deleted.", n.hasProperty(propertyName1));
        otherSuperuser.logout();
    }


    public void testAddNodeRollback() throws Exception {
        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // start transaction
        utx.begin();

        // add node and save
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        // assertion: node exists in this session
        String uuid = n.getUUID();

        try {
            superuser.getNodeByUUID(uuid);
        } catch (ItemNotFoundException e) {
            fail("New node not visible after save()");
        }

        // rollback
        utx.rollback();

        // assertion: node does not exist in this session
        try {
            superuser.getNodeByUUID(uuid);
            fail("Node still visible after rollback()");
        } catch (ItemNotFoundException e) {
            /* expected */
        }
    }


    public void testDistributedThreadAccess() throws Exception {
        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser, true);
        //utx.setTransactionTimeout(50);
        // start transaction
        utx.begin();

        // add node and save
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        // assertion: node exists in this session
        try {
            superuser.getNodeByUUID(n.getUUID());
        } catch (ItemNotFoundException e) {
            fail("New node not visible after save()");
        }

        // commit
        utx.commit();

        // assertion: node exists in this session
        try {
            superuser.getNodeByUUID(n.getUUID());
        } catch (ItemNotFoundException e) {
            fail("Committed node not visible in this session");
        }
    }


    public void testGetReferencesAddedRef() throws Exception {
        // create one referenceable node
        Node target = testRootNode.addNode(nodeName1);
        target.addMixin(mixReferenceable);
        // second node, which will later reference the target node
        Node n = testRootNode.addNode(nodeName2);
        testRootNode.save();

        UserTransactionImpl tx = new UserTransactionImpl(superuser);
        tx.begin();
        try {
            // create reference
            n.setProperty(propertyName1, target);
            testRootNode.save();
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", target.getReferences().hasNext());
        } finally {
            tx.rollback();
        }
    }


    public void testGetReferencesModifiedRefNewValueReferenceable() throws Exception {
        // create one referenceable node
        Node target = testRootNode.addNode(nodeName1);
        target.addMixin(mixReferenceable);
        Node n = testRootNode.addNode(nodeName2);
        // create string property
        n.setProperty(propertyName1, "foo");
        testRootNode.save();

        UserTransactionImpl tx = new UserTransactionImpl(superuser);
        tx.begin();
        try {
            // change string into a reference
            n.setProperty(propertyName1, target);
            testRootNode.save();
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", target.getReferences().hasNext());
        } finally {
            tx.rollback();
        }
    }


    public void testGetReferencesModifiedRefOldValueReferenceable() throws Exception {
        // create one referenceable node
        Node target = testRootNode.addNode(nodeName1);
        target.addMixin(mixReferenceable);
        Node n = testRootNode.addNode(nodeName2);
        // create reference
        n.setProperty(propertyName1, target);
        testRootNode.save();

        UserTransactionImpl tx = new UserTransactionImpl(superuser);
        tx.begin();
        try {
            // change reference to a string value
            n.setProperty(propertyName1, "foo");
            testRootNode.save();
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", !target.getReferences().hasNext());
        } finally {
            tx.rollback();
        }
    }


    public void testGetReferencesRemovedRef() throws Exception {
        // create one referenceable node
        Node target = testRootNode.addNode(nodeName1);
        target.addMixin(mixReferenceable);
        // second node, which reference the target node
        Node n = testRootNode.addNode(nodeName2);
        // create reference
        n.setProperty(propertyName1, target);
        testRootNode.save();

        UserTransactionImpl tx = new UserTransactionImpl(superuser);
        tx.begin();
        try {
            n.getProperty(propertyName1).remove();
            testRootNode.save();
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", !target.getReferences().hasNext());
        } finally {
            tx.rollback();
        }
    }


    public void testGetReferencesModifiedRef() throws Exception {
        // create two referenceable node
        Node target1 = testRootNode.addNode(nodeName1);
        target1.addMixin(mixReferenceable);
        // second node, which reference the target1 node
        Node target2 = testRootNode.addNode(nodeName2);
        target2.addMixin(mixReferenceable);
        Node n = testRootNode.addNode(nodeName3);
        // create reference
        n.setProperty(propertyName1, target1);
        testRootNode.save();

        UserTransactionImpl tx = new UserTransactionImpl(superuser);
        tx.begin();
        try {
            // change reference
            n.setProperty(propertyName1, target2);
            testRootNode.save();
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", !target1.getReferences().hasNext());
            assertTrue("Node.getReferences() must reflect references that have " +
                    "been saved but not yet committed", target2.getReferences().hasNext());
        } finally {
            tx.rollback();
        }
    }


    public void testLockCommit() throws Exception {
        Session other = getHelper().getSuperuserSession();
        try {
            // add node that is both lockable and referenceable, save
            Node n = testRootNode.addNode(nodeName1);
            n.addMixin(mixLockable);
            n.addMixin(mixReferenceable);
            testRootNode.save();

            // reference node in second session
            Node nOther = other.getNodeByUUID(n.getUUID());

            // verify node is not locked in either session
            assertFalse("Node not locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            // get user transaction object, start and lock node
            UserTransaction utx = new UserTransactionImpl(superuser);
            utx.begin();
            n.lock(false, true);

            // verify node is locked in first session only
            assertTrue("Node locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            // commit in first session
            utx.commit();

            // verify node is locked in both sessions
            assertTrue("Node locked in session 1", n.isLocked());
            assertTrue("Node locked in session 2", nOther.isLocked());
        } finally {
            // logout
            other.logout();
        }
    }


    public void testLockRollback() throws Exception {
        Session other = getHelper().getSuperuserSession();
        try {
            // add node that is both lockable and referenceable, save
            Node n = testRootNode.addNode(nodeName1);
            n.addMixin(mixLockable);
            n.addMixin(mixReferenceable);
            testRootNode.save();

            // reference node in second session
            Node nOther = other.getNodeByUUID(n.getUUID());

            // verify node is not locked in either session
            assertFalse("Node not locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            // get user transaction object, start and lock node
            UserTransaction utx = new UserTransactionImpl(superuser);
            utx.begin();
            n.lock(false, true);

            // verify node is locked in first session only
            assertTrue("Node locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());
            assertFalse("Node not locked in session 2", nOther.hasProperty(jcrLockOwner));

            // rollback in first session
            utx.rollback();

            // verify node is not locked in either session
            assertFalse("Node not locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());
            assertFalse("Node not locked in session 2", nOther.hasProperty(jcrlockIsDeep));
        } finally {
            // logout
            other.logout();
        }
    }


    public void testLockUnlockCommit() throws Exception {
        Session other = getHelper().getSuperuserSession();
        try {
            // add node that is both lockable and referenceable, save
            Node n = testRootNode.addNode(nodeName1);
            n.addMixin(mixLockable);
            n.addMixin(mixReferenceable);
            testRootNode.save();

            // reference node in second session
            Node nOther = other.getNodeByUUID(n.getUUID());

            // verify node is not locked in either session
            assertFalse("Node not locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            // get user transaction object, start and lock node
            UserTransaction utx = new UserTransactionImpl(superuser);
            utx.begin();
            n.lock(false, true);

            // verify node is locked in first session only
            assertTrue("Node locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            n.unlock();
            // commit in first session
            utx.commit();

            // verify node is locked in both sessions
            assertFalse("Node locked in session 1", n.isLocked());
            assertFalse("Node locked in session 2", nOther.isLocked());
        } finally {
            // logout
            other.logout();
        }
    }


    public void testLockTwice() throws Exception {
        Session other = getHelper().getSuperuserSession();
        try {
            // add node that is both lockable and referenceable, save
            Node n = testRootNode.addNode(nodeName1);
            n.addMixin(mixLockable);
            n.addMixin(mixReferenceable);
            testRootNode.save();

            // reference node in second session
            Node nOther = other.getNodeByUUID(n.getUUID());

            // verify node is not locked in either session
            assertFalse("Node not locked in session 1", n.isLocked());
            assertFalse("Node not locked in session 2", nOther.isLocked());

            // get user transaction object, start and lock node
            UserTransaction utx = new UserTransactionImpl(superuser);
            utx.begin();
            n.lock(false, true);

            // lock node in non-transactional session, too
            nOther.lock(false, true);

            // verify node is locked in both sessions
            assertTrue("Node locked in session 1", n.isLocked());
            assertTrue("Node locked in session 2", nOther.isLocked());
            assertTrue("Node locked in session 2", nOther.hasProperty(jcrLockOwner));

            // assertion: commit must fail since node has already been locked
            try {
                utx.commit();
                fail("Commit succeeds with double locking");
            } catch (RollbackException e) {
                /* expected */
            }

            // verify node is locked in both sessions
            assertTrue("Node locked in session 1", n.isLocked());
            assertTrue("Node locked in session 2", nOther.isLocked());
            assertTrue("Node locked in session 2", nOther.hasProperty(jcrlockIsDeep));

        } finally {
            // logout
            other.logout();
        }
    }


    public void testCreateLockUnlockInDifferentTransactions() throws Exception {
        // create new node and lock it
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // add node that is both lockable and referenceable, save
        Node rootNode = superuser.getRootNode(); 
        Node n = rootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        rootNode.save();
        
        String uuid = n.getUUID();
        
        // commit
        utx.commit();
        
        // start new Transaction and try to add lock token
        utx = new UserTransactionImpl(superuser);
        utx.begin();
        
        n = superuser.getNodeByUUID(uuid);
        // lock this new node
        Lock lock = n.lock(true, false);
        
        // verify node is locked
        assertTrue("Node not locked", n.isLocked());
        
        String lockToken = lock.getLockToken();
        // assert: session must get a non-null lock token
        assertNotNull("session must get a non-null lock token", lockToken);
        // assert: session must hold lock token
        assertTrue("session must hold lock token", containsLockToken(superuser, lockToken));

        n.save();

        superuser.removeLockToken(lockToken);

        String nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        assertFalse("session must not hold lock token", containsLockToken(superuser, lockToken));
        
        // commit
        utx.commit();

        nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        assertFalse("session must not hold lock token", containsLockToken(superuser, lockToken));

        // start new Transaction and try to unlock
        utx = new UserTransactionImpl(superuser);
        utx.begin();

        n = superuser.getNodeByUUID(uuid);

        // verify node is locked
        assertTrue("Node not locked", n.isLocked());
        // assert: session must not hold lock token
        assertFalse("session must not hold lock token", containsLockToken(superuser, lockToken));
        
        superuser.addLockToken(lockToken);
        
        // assert: session must not hold lock token
        assertTrue("session must hold lock token", containsLockToken(superuser, lockToken));

        n.unlock();
        
        // commit
        utx.commit();
    }


    public void testAddLockTokenRemoveNode() throws Exception {
        // create new node and lock it
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // add node that is both lockable and referenceable, save
        Node rootNode = superuser.getRootNode(); 
        Node n = rootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        rootNode.save();

        String uuid = n.getUUID();
        
        // lock this new node
        Lock lock = n.lock(true, false);
        String lockToken = lock.getLockToken();
        
        // assert: session must get a non-null lock token
        assertNotNull("session must get a non-null lock token", lockToken);

        // assert: session must hold lock token
        assertTrue("session must hold lock token", containsLockToken(superuser, lockToken));

        superuser.removeLockToken(lockToken);

        String nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        // commit
        utx.commit();
        
        // refresh Lock Info
        lock = n.getLock();

        nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        Session other = getHelper().getSuperuserSession();
        // start new Transaction and try to add lock token unlock the node and then remove it
        utx = new UserTransactionImpl(other);
        utx.begin();
        
        Node otherNode = other.getNodeByUUID(uuid); 
        assertTrue("Node not locked", otherNode.isLocked());
        // add lock token
        other.addLockToken(lockToken);
      
        // refresh Lock Info
        lock = otherNode.getLock();

        // assert: session must hold lock token
        assertTrue("session must hold lock token", containsLockToken(other, lock.getLockToken()));        
        
        otherNode.unlock();
        
        assertFalse("Node is locked", otherNode.isLocked());
        
        otherNode.remove();
        other.save();
        utx.commit();
    }


    public void testAddRemoveLockToken() throws Exception {
        // create new node and lock it
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // add node that is both lockable and referenceable, save
        Node rootNode = superuser.getRootNode();
        Node n = rootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        rootNode.save();

        String uuid = n.getUUID();

        // lock this new node
        Lock lock = n.lock(true, false);
        String lockToken = lock.getLockToken();

        // assert: session must get a non-null lock token
        assertNotNull("session must get a non-null lock token", lockToken);

        // assert: session must hold lock token
        assertTrue("session must hold lock token", containsLockToken(superuser, lockToken));

        superuser.removeLockToken(lockToken);

        String nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        // commit
        utx.commit();

        // refresh Lock Info
        lock = n.getLock();

        nlt = lock.getLockToken();
        assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                nlt == null || nlt.equals(lockToken));

        Session other = getHelper().getSuperuserSession();
        try {
            // start new Transaction and try to add lock token
            utx = new UserTransactionImpl(other);
            utx.begin();

            Node otherNode = other.getNodeByUUID(uuid);
            assertTrue("Node not locked", otherNode.isLocked());
            try {
                otherNode.setProperty(propertyName1, "foo");
                fail("Lock exception should be thrown");
            } catch (LockException e) {
                // expected
            }

            // add lock token
            other.addLockToken(lockToken);

            // refresh Lock Info
            lock = otherNode.getLock();

            // assert: session must hold lock token
            assertTrue("session must hold lock token", containsLockToken(other, lock.getLockToken()));

            otherNode.unlock();

            assertFalse("Node is locked", otherNode.isLocked());

            otherNode.setProperty(propertyName1, "foo");
            other.save();
            utx.commit();
        } finally {
            other.logout();
        }
    }


    public void testAddLockTokenRemoveNode2() throws Exception {
        // create new node and lock it
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // add node that is both lockable and referenceable, save
        Node rootNode = superuser.getRootNode(); 
        Node n = rootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        rootNode.save();

        String uuid = n.getUUID();
        
        // lock this new node
        Lock lock = n.lock(true, false);
        String lockToken = lock.getLockToken();
        
        // commit
        utx.commit();
        
        
        // refresh Lock Info
        lock = n.getLock();

        // start new Transaction and try to add lock token unlock the node and then remove it
        utx = new UserTransactionImpl(superuser);
        utx.begin();
        
        Node otherNode = superuser.getNodeByUUID(uuid); 
        assertTrue("Node not locked", otherNode.isLocked());
        // add lock token
        superuser.addLockToken(lockToken);
      
        // refresh Lock Info
        lock = otherNode.getLock();

        // assert: session must hold lock token
        assertTrue("session must hold lock token", containsLockToken(superuser, lockToken));        
        
        otherNode.unlock();
        
        assertFalse("Node is locked", otherNode.isLocked());
        
        otherNode.remove();
        superuser.save();
        utx.commit();
    }


    public void testLockUnlock() throws Exception {
        // add node that is both lockable and referenceable, save
        Node n = testRootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        // verify node is not locked in this session
        assertFalse("Node not locked", n.isLocked());

        // get user transaction object, start and lock node
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();
        n.lock(false, true);

        // verify node is locked
        assertTrue("Node locked", n.isLocked());

        // unlock node
        n.unlock();

        // commit
        utx.commit();

        // verify node is not locked
        assertFalse("Node not locked", n.isLocked());
    }


    public void testLockBehaviour2() throws Exception {
        // add node that is both lockable and referenceable, save
        Node n = testRootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        Lock lock = n.lock(false, true);

        // get user transaction object, start
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // verify lock is live
        assertTrue("Lock live", lock.isLive());

        // unlock
        n.unlock();

        // verify lock is no longer live
        assertFalse("Lock not live", lock.isLive());

        // rollback
        utx.rollback();

        // verify lock is live again
        assertTrue("Lock live", lock.isLive());
    }


    public void testLockBehaviour() throws Exception {
        // add node that is both lockable and referenceable, save
        Node n = testRootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        // get user transaction object, start and lock node
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();
        Lock lock = n.lock(false, true);

        // verify lock is live
        assertTrue("Lock live", lock.isLive());

        // rollback
        utx.rollback();

        // verify lock is not live anymore
        assertFalse("Lock not live", lock.isLive());
    }


    public void testLockProperties2() throws Exception {
        // add node that is both lockable and referenceable, save
        Node n = testRootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        Lock lock = n.lock(false, true);
        try {
            // get user transaction object, start
            UserTransaction utx = new UserTransactionImpl(superuser);
            utx.begin();

            // verify that the lock properties are present
            assertTrue(n.hasProperty(jcrLockOwner));
            assertTrue(n.hasProperty(jcrlockIsDeep));

            // unlock
            n.unlock();

            // verify that the lock properties have been removed.
            assertFalse(n.hasProperty(jcrLockOwner));
            assertFalse(n.hasProperty(jcrlockIsDeep));

            // rollback
            utx.rollback();

            // verify lock is live again -> properties must be present
            assertTrue(n.hasProperty(jcrLockOwner));
            assertTrue(n.hasProperty(jcrlockIsDeep));
        } finally {
            n.unlock();
        }
    }


    public void testLockProperties3() throws Exception {
        // add node that is both lockable and referenceable, save
        Node n = testRootNode.addNode(nodeName1);
        n.addMixin(mixLockable);
        n.addMixin(mixReferenceable);
        testRootNode.save();

        Lock lock = n.lock(false, true);

        // get user transaction object, start
        UserTransaction utx = new UserTransactionImpl(superuser);
        utx.begin();

        // unlock
        n.unlock();

        Node n2 = (Node) otherSuperuser.getItem(n.getPath());
        assertTrue(n2.isLocked());
        assertTrue(n2.hasProperty(jcrLockOwner));
        assertTrue(n2.hasProperty(jcrlockIsDeep));
        Lock lock2 = n2.getLock();

        // complete transaction
        utx.commit();

        // unlock must now be visible to other session
        n2.refresh(false);
        assertFalse(lock2.isLive());
        assertFalse(n2.isLocked());
        assertFalse(n2.hasProperty(jcrLockOwner));
        assertFalse(n2.hasProperty(jcrlockIsDeep));
    }


    public void testConflictingCheckin() throws Exception {
        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // add node and save
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addMixin(mixVersionable);
        testRootNode.save();

        // reference node in other session
        Node nOther = otherSuperuser.getNodeByUUID(n.getUUID());

        // start transaction
        utx.begin();

        // checkin node inside tx
        n.checkin();

        // checkin node outside tx
        nOther.checkin();

        // commit
        try {
            utx.commit();
            fail("Commit failing with modified version history.");
        } catch (RollbackException e) {
            // expected
        }
    }


    public void testRemoveVersion() throws Exception {
        // get user transaction object
        UserTransaction utx = new UserTransactionImpl(superuser);

        // add node and save
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addMixin(mixVersionable);
        testRootNode.save();

        // reference node in other session
        Node nOther = otherSuperuser.getNodeByUUID(n.getUUID());

        // create two versions, reference first version in other session
        n.checkin();
        Version vOther = nOther.getBaseVersion();
        n.checkout();
        n.checkin();

        // start transaction
        utx.begin();

        // remove version and commit
        n.getVersionHistory().removeVersion(vOther.getName());

        // commit
        utx.commit();

        // assert: version has become invalid
        try {
            vOther.getPredecessors();
            fail("Removed version still operational.");
        } catch (RepositoryException e) {
            // expected
        }
    }


    private boolean containsLockToken(Session session, String lockToken) {
        String[] lt = session.getLockTokens();
        for (int i = 0; i < lt.length; i++) {
            if (lt[i].equals(lockToken)) {
                return true;
            }
        }
        return false;
    }


    private boolean containsLockToken(Session session, String lockToken) {
        String[] lt = session.getLockTokens();
        for (int i = 0; i < lt.length; i++) {
            if (lt[i].equals(lockToken)) {
                return true;
            }
        }
        return false;
    }


    public void testSingleMixin() throws RepositoryException {
        testRootNode.addNode(nodeName1, testNodeType).addMixin(mixReferenceable);
        testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.addNode(nodeName3, testNodeType).addMixin(mixReferenceable);
        testRootNode.save();

        EventResult propertyAddedListener = new EventResult(log);
        addEventListener(propertyAddedListener, new String[]{mixReferenceable}, Event.PROPERTY_ADDED);
        try {
            testRootNode.getNode(nodeName1).setProperty(propertyName1, "test");
            testRootNode.getNode(nodeName2).setProperty(propertyName1, "test");
            testRootNode.getNode(nodeName3).setProperty(propertyName1, "test");
            testRootNode.save();

            Event[] added = propertyAddedListener.getEvents(DEFAULT_WAIT_TIMEOUT);
            checkPropertyAdded(added, new String[]{nodeName1 + "/" + propertyName1,
                                                   nodeName3 + "/" + propertyName1});
        } finally {
            removeEventListener(propertyAddedListener);
        }
    }


    public void testMultipleMixin() throws RepositoryException {
        testRootNode.addNode(nodeName1, testNodeType).addMixin(mixReferenceable);
        testRootNode.addNode(nodeName2, testNodeType).addMixin(mixLockable);
        testRootNode.addNode(nodeName3, testNodeType).addMixin(mixReferenceable);
        testRootNode.save();

        EventResult propertyAddedListener = new EventResult(log);
        addEventListener(propertyAddedListener, new String[]{mixReferenceable, mixLockable}, Event.PROPERTY_ADDED);
        try {
            testRootNode.getNode(nodeName1).setProperty(propertyName1, "test");
            testRootNode.getNode(nodeName2).setProperty(propertyName1, "test");
            testRootNode.getNode(nodeName3).setProperty(propertyName1, "test");
            testRootNode.save();

            Event[] added = propertyAddedListener.getEvents(DEFAULT_WAIT_TIMEOUT);
            checkPropertyAdded(added, new String[]{nodeName1 + "/" + propertyName1,
                                                   nodeName2 + "/" + propertyName1,
                                                   nodeName3 + "/" + propertyName1});
        } finally {
            removeEventListener(propertyAddedListener);
        }
    }


    public void testAddShare() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1);
        Node n2 = testRootNode.addNode(nodeName2);
        Node s = n1.addNode(nodeName3);
        s.addMixin(mixShareable);
        testRootNode.save();

        EventResult result = new EventResult(log);
        addEventListener(result);

        Workspace wsp = superuser.getWorkspace();
        wsp.clone(wsp.getName(), s.getPath(), n2.getPath() + "/" + s.getName(), false);

        checkNodeAdded(result.getEvents(DEFAULT_WAIT_TIMEOUT),
                new String[]{nodeName2 + "/" + nodeName3},
                new String[0]);
    }


    public void testRemoveShare() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1);
        Node n2 = testRootNode.addNode(nodeName2);
        Node s = n1.addNode(nodeName3);
        s.addMixin(mixShareable);
        testRootNode.save();

        Workspace wsp = superuser.getWorkspace();
        wsp.clone(wsp.getName(), s.getPath(), n2.getPath() + "/" + s.getName(), false);

        EventResult result = new EventResult(log);
        addEventListener(result);

        removeFromSharedSet(n2.getNode(nodeName3));
        testRootNode.save();

        checkNodeRemoved(result.getEvents(DEFAULT_WAIT_TIMEOUT),
                new String[]{nodeName2 + "/" + nodeName3},
                new String[0]);
    }


    public void testCheckin() throws RepositoryException {
        // create versionable node
        Node n1 = testRootNode.addNode(nodeName1);
        n1.addMixin(mixVersionable);
        testRootNode.save();

        EventResult listener = new EventResult(log);
        addEventListener(listener, Event.NODE_ADDED);
        Version v = n1.checkin();
        removeEventListener(listener);

        Event[] events = listener.getEvents(1000);
        Set paths = new HashSet();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }

        assertTrue("missing 'node added' event: " + v.getPath(), paths.contains(v.getPath()));
        String frozenPath = v.getPath() + "/" + jcrFrozenNode;
        assertTrue("missing 'node added' event: " + frozenPath, paths.contains(frozenPath));
    }


    public void testXACheckin() throws Exception {
        // create versionable node
        Node n1 = testRootNode.addNode(nodeName1);
        n1.addMixin(mixVersionable);
        testRootNode.save();

        EventResult listener = new EventResult(log);
        addEventListener(listener, Event.NODE_ADDED);

        // use a transaction
        UserTransaction utx = new UserTransactionImpl(superuser);
        // start transaction
        utx.begin();
        Version v = n1.checkin();
        // commit transaction
        utx.commit();

        removeEventListener(listener);

        Event[] events = listener.getEvents(1000);
        Set paths = new HashSet();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }

        assertTrue("missing 'node added' event: " + v.getPath(), paths.contains(v.getPath()));
        String frozenPath = v.getPath() + "/" + jcrFrozenNode;
        assertTrue("missing 'node added' event: " + frozenPath, paths.contains(frozenPath));
    }


    public void testRemoveVersion() throws RepositoryException {
        // create versionable node
        Node n1 = testRootNode.addNode(nodeName1);
        n1.addMixin(mixVersionable);
        testRootNode.save();

        Version v = n1.checkin();
        String versionPath = v.getPath();

        n1.remove();
        testRootNode.save();

        EventResult listener = new EventResult(log);
        addEventListener(listener, Event.NODE_REMOVED);
        v.getContainingHistory().removeVersion(v.getName());
        removeEventListener(listener);

        Event[] events = listener.getEvents(1000);
        Set paths = new HashSet();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }

        assertTrue("missing 'node removed' event: " + versionPath, paths.contains(versionPath));
        String frozenPath = versionPath + "/" + jcrFrozenNode;
        assertTrue("missing 'node removed' event: " + frozenPath, paths.contains(frozenPath));
    }


    public void testXARemoveVersion() throws Exception {
        // create versionable node
        Node n1 = testRootNode.addNode(nodeName1);
        n1.addMixin(mixVersionable);
        testRootNode.save();

        Version v = n1.checkin();
        String versionPath = v.getPath();

        n1.remove();
        testRootNode.save();

        EventResult listener = new EventResult(log);
        addEventListener(listener, Event.NODE_REMOVED);

        // use a transaction
        UserTransaction utx = new UserTransactionImpl(superuser);
        // start transaction
        utx.begin();
        v.getContainingHistory().removeVersion(v.getName());
        // commit transaction
        utx.commit();

        removeEventListener(listener);

        Event[] events = listener.getEvents(1000);
        Set paths = new HashSet();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }

        assertTrue("missing 'node removed' event: " + versionPath, paths.contains(versionPath));
        String frozenPath = versionPath + "/" + jcrFrozenNode;
        assertTrue("missing 'node removed' event: " + frozenPath, paths.contains(frozenPath));
    }


    public static ConsistencyReport checkConsistency(Session session, boolean runFix, String lostNFoundId)
            throws NotExecutableException, RepositoryException {
        Repository r = session.getRepository();
        if (!(r instanceof RepositoryImpl)) {
            throw new NotExecutableException();
        } else {
            RepositoryImpl ri = (RepositoryImpl) r;
            PersistenceManager pm = ri.getWorkspaceInfo(
                    session.getWorkspace().getName()).getPersistenceManager();
            if (!(pm instanceof ConsistencyChecker)) {
                throw new NotExecutableException();
            } else {
                return ((ConsistencyChecker) pm).check(null, true, runFix, lostNFoundId, null);
            }
        }
    }


    public static ConsistencyReport checkVersionStoreConsistency(Session session, boolean runFix, String lostNFoundId)
            throws NotExecutableException, RepositoryException {
        Repository r = session.getRepository();
        if (!(r instanceof RepositoryImpl)) {
            throw new NotExecutableException();
        } else {
            RepositoryImpl ri = (RepositoryImpl) r;
            PersistenceManager pm = ri.getRepositoryContext()
                    .getInternalVersionManager().getPersistenceManager();
            if (!(pm instanceof ConsistencyChecker)) {
                throw new NotExecutableException();
            } else {
                return ((ConsistencyChecker) pm).check(null, true, runFix, lostNFoundId, null);
            }
        }
    }


    protected final Thread startWriterThread(final ISMLocking lock, final ChangeLog changeLog) {
        Thread t = new Thread(new Runnable() {

            public void run() {
                try {
                    lock.acquireWriteLock(changeLog).release();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        t.start();
        return t;
    }


    protected final Thread startReaderThread(final ISMLocking lock, final ItemId id) {
        Thread t = new Thread(new Runnable() {

            public void run() {
                try {
                    lock.acquireReadLock(id).release();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        t.start();
        return t;
    }


    public void testAddSameMixinToSessionsAB2() throws RepositoryException {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNode.addMixin("test:mixinProp_1");
        testNode.setProperty("test:prop_double", 124);

        testNodeB.addMixin("test:mixinProp_1");
        testNodeB.setProperty("test:prop_string", "abc");
        sessionB.save();

        superuser.save();

        assertEquals("abc", testNode.getProperty("test:prop_string").getString());
        testNodeB.refresh(false);
        assertEquals(124, testNodeB.getProperty("test:prop_double").getLong());
    }


    public void testAddSameMixinToSessionsAB3() throws RepositoryException {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNode.addMixin("test:mixinProp_1");
        testNode.setProperty("test:prop_double", 124);

        testNodeB.addMixin("test:mixinProp_1");
        testNodeB.setProperty("test:prop_double", 134);
        sessionB.save();

        superuser.save();

        assertEquals(124, testNode.getProperty("test:prop_double").getLong());
        testNodeB.refresh(false);
        assertEquals(124, testNodeB.getProperty("test:prop_double").getLong());
    }


    public void testAddSameMixinToSessionsAB4() throws RepositoryException {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNode.addMixin("test:mixinProp_1");
        testNode.setProperty("test:prop_double", 124);

        testNodeB.addMixin("test:mixinProp_1");
        testNodeB.setProperty("test:prop_double", 134);
        testNodeB.setProperty("more", "yes");
        sessionB.save();

        superuser.save();

        assertEquals(124, testNode.getProperty("test:prop_double").getLong());
        testNodeB.refresh(false);
        assertEquals(124, testNodeB.getProperty("test:prop_double").getLong());
    }


    public void testAddedInSessionAConflictsWithChildItemsInSessionB() throws RepositoryException {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));
        
        testNode.addMixin("test:mixinProp_5"); // has an autocreated property

        testNodeB.setProperty("test:prop_long_p", "conflict");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
            assertFalse(testNodeB.isNodeType("test:mixinProp_5"));
            testNodeB.refresh(false);
            assertEquals("conflict", testNodeB.getProperty("test:prop_long_p").getString());
        }
    }


    public void testMixinModifiedAddInSessionBWithConflictingChanges3() throws Exception {
        testNode.addMixin(mixReferenceable);
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // conflicting modification in SessionA
        testNode.setProperty("test:prop_long_p", "non-long-value");

        testNodeB.addMixin("test:mixinProp_5");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinAddedInSessionBWithConflictingChanges() throws Exception {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));
        
        testNode.addNode(nodeName2);
        testNode.setProperty("test:prop_long_p", "value");

        testNodeB.addMixin("test:mixinProp_5");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedAddInSessionBWithConflictingChanges() throws Exception {
        testNode.addMixin(mixReferenceable);
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));
   
        // conflicting modification in SessionA
        testNode.setProperty(propertyName1, "value");
        testNode.addNode("test:child_1");

        testNodeB.addMixin("test:mixinNode_1");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedAddInSessionBWithConflictingChanges4() throws Exception {
        testNode.addMixin(mixReferenceable);
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // conflicting modification in session1
        testNode.setProperty("test:prop_long_p", "non-long-value");        
        testNode.addNode("test:child_1");

        testNodeB.addMixin("test:mixinProp_5");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedInSessionAB() throws Exception {
        testNode.addMixin("test:mixinProp_5");
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // modify the mixin types
        testNode.addMixin("test:mixinProp_1");

        testNodeB.addMixin("test:mixinProp_1");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedAddInSessionBWithConflictingChanges2() throws Exception {
        testNode.addMixin(mixReferenceable);
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // conflicting modification in SessionA
        testNode.addNode("test:child_1");

        testNodeB.addMixin("test:mixinNode_1");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedInSessionB() throws Exception {
        for (String mixin : testMixins) {
            testNode.addMixin(mixin);
        }
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // modification in SessionA
        testNode.setProperty(propertyName1, "value");

        // mixin-removal in the SessionB
        testNodeB.addMixin(mixReferenceable);
        testNodeB.removeMixin("test:mixinProp_2");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedRemovedInSessionB() throws Exception {
        for (String mixin : testMixins) {
            testNode.addMixin(mixin);
        }
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));


        // modification in session1
        testNode.setProperty(propertyName1, "value");

        // mixin-removal in the session2
        testNodeB.removeMixin("test:mixinProp_1");
        testNodeB.removeMixin("test:mixinProp_2");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedInSessionAB4() throws Exception {
        testNode.addMixin("test:mixinProp_5");
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // modify the mixin types
        testNode.addMixin("test:mixinProp_1");

        testNodeB.addMixin("test:mixinProp_2");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        } 
    }


    public void testMixinModifiedRemovedInSessionB2() throws Exception {
        for (String mixin : testMixins) {
            testNode.addMixin(mixin);
        }
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));


        // modification in SessionA
        testNode.setProperty(propertyName1, "value");
        testNode.addNode(nodeName2);

        // mixin-removal in SessionB
        testNodeB.removeMixin("test:mixinProp_1");
        testNodeB.removeMixin("test:mixinProp_2");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinModifiedInSessionAB2() throws Exception {
        testNode.addMixin("test:mixinProp_5");
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // modify the mixin types
        testNode.addMixin("test:mixinProp_1");

        testNodeB.removeMixin("test:mixinProp_5");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
            assertTrue(testNode.hasProperty("jcr:mixinTypes"));
            assertTrue(testNode.isNodeType("test:mixinProp_1"));
            assertTrue(testNode.isNodeType("test:mixinProp_5"));
            assertEquals(2, testNode.getMixinNodeTypes().length);
        }
    }


    public void testMixinModifiedInSessionAB3() throws Exception {
        testNode.addMixin("test:mixinProp_5");
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // modify the mixin types
        testNode.addMixin("test:mixinProp_1");
        testNode.setProperty(propertyName1, "value");

        testNodeB.removeMixin("test:mixinProp_5");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
            assertTrue(testNode.hasProperty("jcr:mixinTypes"));
            assertTrue(testNode.isNodeType("test:mixinProp_1"));
            assertTrue(testNode.isNodeType("test:mixinProp_5"));
            assertEquals(2, testNode.getMixinNodeTypes().length);
        }
    }


    public void testMixinRemovedInSessionA() throws Exception {
        for (int i = 1; i<=5; i++) {
            testNode.addMixin("test:mixinProp_" + i);
        }    
        superuser.save();
        testNodeB.refresh(false);

        // remove all mixin types
        for (NodeType mixin : testNode.getMixinNodeTypes()) {
            testNode.removeMixin(mixin.getName());
        }
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNodeB.addNode(nodeName1, "nt:unstructured");
        testNodeB.setProperty(propertyName1, "anyValue");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinRemovedInSessionB() throws Exception {
        for (int i = 1; i<=5; i++) {
            testNode.addMixin("test:mixinProp_" + i);
        }
        superuser.save();
        testNodeB.refresh(false);

        testNode.addNode(nodeName1, "nt:unstructured");
        testNode.setProperty(propertyName1, "anyValue");

        // remove all mixin types
        for (NodeType mixin : testNodeB.getMixinNodeTypes()) {
            testNodeB.removeMixin(mixin.getName());
        }
        assertFalse(testNodeB.hasProperty("jcr:mixinTypes"));
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinRemovedInSessionA2() throws Exception {
        for (int i = 1; i<=4; i++) {
            testNode.addMixin("test:mixinNode_" + i);
        }
        superuser.save();
        testNodeB.refresh(false);

        // remove all mixin types
        for (NodeType mixin : testNode.getMixinNodeTypes()) {
            testNode.removeMixin(mixin.getName());
        }
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNodeB.addNode(nodeName1, "nt:unstructured");
        testNodeB.setProperty(propertyName1, "anyValue");
        sessionB.save();

        try {
            superuser.save();
            fail();
        } catch (InvalidItemStateException e) {
            // expected
        }
    }


    public void testMixinAddedInSessionB() throws Exception {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNode.addNode(nodeName2);

        testNodeB.addMixin("test:mixinProp_1");
        sessionB.save();

        superuser.save();

        assertTrue(testNode.isNodeType("test:mixinProp_1"));
        assertTrue(testNode.hasProperty("jcr:mixinTypes"));

        assertTrue(testNodeB.hasNode(nodeName2));
    }


    public void testMixinAddedInSessionB2() throws Exception {
        assertFalse(testNode.hasProperty("jcr:mixinTypes"));

        testNode.addNode(nodeName2);
        testNode.setProperty(propertyName1, "value");

        testNodeB.addMixin("test:mixinProp_1");
        sessionB.save();

        superuser.save();

        assertTrue(testNode.isNodeType("test:mixinProp_1"));
        assertTrue(testNode.hasProperty("jcr:mixinTypes"));

        assertTrue(testNodeB.hasNode(nodeName2));
    }


    public void testMixinModifiedAddInSessionB() throws Exception {
        for (int i = 1; i<=5; i++) {
            testNode.addMixin("test:mixinProp_" + i);
        }
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // non-conflicting modification in SessionA
        testNode.setProperty(propertyName1, "value");

        testNodeB.addMixin("test:mixinNode_1");
        sessionB.save();

        superuser.save();

        assertTrue(testNode.isNodeType("test:mixinNode_1"));
        List<NodeType> mx = Arrays.asList(testNode.getMixinNodeTypes());
        assertTrue(mx.contains(superuser.getWorkspace().getNodeTypeManager().getNodeType("test:mixinNode_1")));

        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty(propertyName1));
    }


    public void testMixinModifiedAddInSessionB2() throws Exception {
        for (int i = 1; i<=5; i++) {
            testNode.addMixin("test:mixinProp_" + i);
        }
        superuser.save();
        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty("jcr:mixinTypes"));

        // non-conflicting modification in SessionA
        testNode.setProperty(propertyName1, "value");
        testNode.addNode(nodeName2);

        testNodeB.addMixin("test:mixinNode_1");
        sessionB.save();

        superuser.save();
        assertTrue(testNode.isNodeType("test:mixinNode_1"));
        List<NodeType> mx = Arrays.asList(testNode.getMixinNodeTypes());
        assertTrue(mx.contains(superuser.getWorkspace().getNodeTypeManager().getNodeType("test:mixinNode_1")));

        testNodeB.refresh(false);
        assertTrue(testNodeB.hasProperty(propertyName1));
        assertTrue(testNodeB.hasNode(nodeName2));
    }


    public void testNormalUsage() throws RepositoryException {
        System.setProperty(NodeIdFactory.SEQUENTIAL_NODE_ID, "true");
        NodeIdFactory f = new NodeIdFactory(factoryDir);
        f.open();
        assertTrue(f.newNodeId().toString().endsWith("-0000-000000000000"));
        f.close();
        f = new NodeIdFactory(factoryDir);
        f.open();
        assertTrue(f.newNodeId().toString().endsWith("-0000-000000000001"));
        f.close();
    }


    public void testOffset() throws RepositoryException {
        System.setProperty(NodeIdFactory.SEQUENTIAL_NODE_ID, "ab/0");
        NodeIdFactory f = new NodeIdFactory(factoryDir);
        f.open();
        assertEquals("00000000-0000-00ab-0000-000000000000", f.newNodeId().toString());
        f.close();
        f = new NodeIdFactory(factoryDir);
        f.open();
        assertEquals("00000000-0000-00ab-0000-000000000001", f.newNodeId().toString());
        f.close();
    }


    public UpdateEvent createUpdateOperation() {
        NodeState n1 = createNodeState();
        NodeState n2 = createNodeState();
        NodeState n3 = createNodeState();
        PropertyState p1 = createPropertyState(n1.getNodeId(), "{}a");
        PropertyState p2 = createPropertyState(n2.getNodeId(), "{}b");

        ChangeLog changes = new ChangeLog();
        changes.added(n1);
        changes.added(p1);
        changes.deleted(p2);
        changes.modified(n2);
        changes.deleted(n3);

        List events = new ArrayList();
        events.add(createEventState(n1, Event.NODE_ADDED, "{}n1", session));
        events.add(createEventState(p1, n1, Event.PROPERTY_ADDED, session));
        events.add(createEventState(p2, n2, Event.PROPERTY_REMOVED, session));
        events.add(createEventState(n3, Event.NODE_REMOVED, "{}n3", session));

        return new UpdateEvent(changes, events, System.currentTimeMillis(), "user-data");
    }


    public UpdateEvent createUpdateOperationWithNullUserId() {
        NodeState n1 = createNodeState();
        NodeState n2 = createNodeState();
        NodeState n3 = createNodeState();
        PropertyState p1 = createPropertyState(n1.getNodeId(), "{}a");
        PropertyState p2 = createPropertyState(n2.getNodeId(), "{}b");

        ChangeLog changes = new ChangeLog();
        changes.added(n1);
        changes.added(p1);
        changes.deleted(p2);
        changes.modified(n2);
        changes.deleted(n3);

        Session s = new ClusterSession(null);
        List events = new ArrayList();
        events.add(createEventState(n1, Event.NODE_ADDED, "{}n1", s));
        events.add(createEventState(p1, n1, Event.PROPERTY_ADDED, s));
        events.add(createEventState(p2, n2, Event.PROPERTY_REMOVED, s));
        events.add(createEventState(n3, Event.NODE_REMOVED, "{}n3", s));

        return new UpdateEvent(changes, events, System.currentTimeMillis(), "user-data");
    }


    public void testUpdate() throws Exception {
        Session s = repo.login(new SimpleCredentials("admin", "admin".toCharArray()));
        Node root = s.getRootNode();
        root.addNode("foo");
        s.save();
        root.addNode("bar");
        TestJournal.refuseLock = true;
        try {
            s.save();
            fail("Session.save() must fail with RepositoryException when Journal cannot be locked.");
        } catch (RepositoryException e) {
            // expected
        } finally {
            TestJournal.refuseLock = false;
        }
    }


    public void testFailedWrite() throws Exception {
        Session s = repo.login(new SimpleCredentials("admin", "admin".toCharArray()));
        Node root = s.getRootNode();
        root.addNode("foo");
        s.save();
        root.addNode("bar");
        TestJournal.failRecordWrite = true;
        try {
            s.save();
            fail("Session.save() must fail with RepositoryException when Journal write fails.");
        } catch (RepositoryException e) {
            // expected
        } finally {
            TestJournal.failRecordWrite = false;
        }
        // must succeed after refresh
        s.refresh(false);
        root.addNode("bar");
        s.save();
    }


    public void testUpdateOperation() throws Exception {
        UpdateEvent update = factory.createUpdateOperation();

        UpdateEventChannel channel = master.createUpdateChannel(DEFAULT_WORKSPACE);
        channel.updateCreated(update);
        channel.updatePrepared(update);
        channel.updateCommitted(update, null);

        SimpleEventListener listener = new SimpleEventListener();
        slave.createUpdateChannel(DEFAULT_WORKSPACE).setListener(listener);
        slave.sync();

        assertEquals(1, listener.getClusterEvents().size());
        assertEquals(listener.getClusterEvents().get(0), update);
    }


    public void testUpdateOperationWithNullUserId() throws Exception {
        UpdateEvent update = factory.createUpdateOperationWithNullUserId();

        UpdateEventChannel channel = master.createUpdateChannel(DEFAULT_WORKSPACE);
        channel.updateCreated(update);
        channel.updatePrepared(update);
        channel.updateCommitted(update, null);

        SimpleEventListener listener = new SimpleEventListener();
        slave.createUpdateChannel(DEFAULT_WORKSPACE).setListener(listener);
        slave.sync();

        assertEquals(1, listener.getClusterEvents().size());
        assertEquals(listener.getClusterEvents().get(0), update);
    }


    public void testNodeTypeRegistration() throws Exception {
        QNodeTypeDefinitionBuilder ntd = new QNodeTypeDefinitionBuilder();
        ntd.setName(NameFactoryImpl.getInstance().create("", "test"));
        ntd.setSupertypes(new Name[]{NameConstants.NT_BASE});

        ArrayList<QNodeTypeDefinition> list = new ArrayList<QNodeTypeDefinition>();
        list.add(ntd.build());

        NodeTypeEvent event = new NodeTypeEvent(NodeTypeEvent.REGISTER, list);
        master.registered(event.getCollection());

        SimpleEventListener listener = new SimpleEventListener();
        slave.setListener((NodeTypeEventListener) listener);
        slave.sync();

        assertEquals(1, listener.getClusterEvents().size());
        assertEquals(listener.getClusterEvents().get(0), event);
    }


    public void testNodeTypeReregistration() throws Exception {
        QNodeTypeDefinitionBuilder ntd = new QNodeTypeDefinitionBuilder();
        ntd.setName(NameFactoryImpl.getInstance().create("", "test"));
        ntd.setSupertypes(new Name[]{NameConstants.NT_BASE});

        ArrayList<QNodeTypeDefinition> list = new ArrayList<QNodeTypeDefinition>();
        list.add(ntd.build());

        NodeTypeEvent event = new NodeTypeEvent(NodeTypeEvent.REREGISTER, list);
        master.reregistered(ntd.build());

        SimpleEventListener listener = new SimpleEventListener();
        slave.setListener((NodeTypeEventListener) listener);
        slave.sync();

        assertEquals(1, listener.getClusterEvents().size());
        assertEquals(listener.getClusterEvents().get(0), event);
    }


    protected void tearDown() throws Exception {
        // remove all created groups again
        for (Object createdUser : createdUsers) {
            Authorizable auth = (Authorizable) createdUser;
            try {
                auth.remove();
                superuser.save();
            } catch (RepositoryException e) {
                log.warn("Failed to remove User " + auth.getID() + " during tearDown.");
            }
        }
        super.tearDown();
    }


    protected void tearDown() throws Exception {
        // remove all created groups again
        for (Authorizable createdGroup : createdGroups) {
            try {
                createdGroup.remove();
                superuser.save();
            } catch (RepositoryException e) {
                log.error("Failed to remove Group " + createdGroup.getID() + " during tearDown.");
            }
        }

        super.tearDown();
    }


    protected void tearDown() throws Exception {

        try {
            for (String id : userIDs) {
                Authorizable a = ((JackrabbitSession) superuser)
                        .getUserManager().getAuthorizable(id);
                a.remove();
                superuser.save();
            }
        } catch (Exception e) {
            // this is best effort
        }

        super.tearDown();
    }


    public void testCreateUserWithNullParamerters() throws RepositoryException {
        try {
            User user = createUser(null, null);
            createdUsers.add(user);

            fail("A User cannot be built from 'null' parameters");
        } catch (Exception e) {
            // ok
        }

        try {
            User user = createUser(null, null, null, null);
            createdUsers.add(user);

            fail("A User cannot be built from 'null' parameters");
        } catch (Exception e) {
            // ok
        }
    }


    public void testCreateGroupWithNullPrincipal() throws RepositoryException {
        try {
            Group gr = createGroup(null);
            createdGroups.add(gr);

            fail("A Group cannot be built from 'null' Principal");
        } catch (Exception e) {
            // ok
        }

        try {
            Group gr = createGroup(null, "/any/path/to/the/new/group");
            createdGroups.add(gr);

            fail("A Group cannot be built from 'null' Principal");
        } catch (Exception e) {
            // ok
        }
    }


    public void testCreateUserWithEmptyUserID() throws RepositoryException {
        try {
            User user = createUser("", "anyPW");
            createdUsers.add(user);

            fail("A User cannot be built with \"\" userID");
        } catch (Exception e) {
            // ok
        }
        try {
            User user = createUser("", "anyPW", getTestPrincipal(), null);
            createdUsers.add(user);

            fail("A User cannot be built with \"\" userID");
        } catch (Exception e) {
            // ok
        }
    }


    public void checkImportDocumentView_IMPORT_UUID_COLLISION_REMOVE_EXISTING()
            throws Exception {

        String uuid = createReferenceableNode(referenced);
        // import a document with a element having the same uuid as the node referenced
        importRefNodeDocument(refTarget, uuid, ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING,
                withWorkspace, withHandler);

        try {
            // should be removed now
            testRootNode.getNode(referenced);
            fail("UUID behavior IMPORT_UUID_COLLISION_REMOVE_EXISTING test is failed: " +
                    "existing node not removed");
        } catch (PathNotFoundException pnfe) {
            // ok
        }
        try {
            // should be there
            refTargetNode.getNode(rootElem);
        } catch (PathNotFoundException pnfe) {
            fail("UUID behavior IMPORT_UUID_COLLISION_REMOVE_EXISTING test is failed: " +
                    "imported node not in its correct place.");
        }
    }


    public void testCreateUserWithNullPrincipal() throws RepositoryException {
        try {
            Principal p = getTestPrincipal();
            String uid = p.getName();
            User user = createUser(uid, buildPassword(uid), null, "/a/b/c");
            createdUsers.add(user);

            fail("A User cannot be built with 'null' Principal");
        } catch (Exception e) {
            // ok
        }
    }


    public void testCheckinWithPendingChangesJcr2() throws RepositoryException {
        try {
            // modify node without calling save()
            versionableNode.setProperty(propertyName1, propertyValue);
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkin(path);

            fail("InvalidItemStateException must be thrown on attempt to checkin a node having any unsaved changes pending.");
        } catch (InvalidItemStateException e) {
            // ok
        }
    }


    public void testCheckinWithPendingChangesJcr2() throws RepositoryException {
        try {
            // modify node without calling save()
            versionableNode.setProperty(propertyName1, propertyValue);
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkin(path);

            fail("InvalidItemStateException must be thrown on attempt to checkin a node having any unsaved changes pending.");
        } catch (InvalidItemStateException e) {
            // ok
        }
    }


    public void testRestorePropJcr2() throws RepositoryException {
        try {
            VersionManager versionManager = p.getSession().getWorkspace().getVersionManager();
            String path = p.getParent().getPath();
            versionManager.checkout(path);
            versionManager.checkin(path);
            fail("On checkin of N which has a property with OnParentVersion ABORT defined, an UnsupportedRepositoryOperationException must be thrown.");
        } catch (VersionException e) {
            // success
        }
    }


    public void testWorkspaceRestoreWithPendingChanges() throws RepositoryException {
        versionableNode.checkout();
        try {
            // modify node without calling save()
            versionableNode.setProperty(propertyName1, propertyValue);

            // create version in second workspace
            Version v = wVersionableNode.checkin();
            // try to restore that version
            superuser.getWorkspace().restore(new Version[]{v}, false);

            fail("InvalidItemStateException must be thrown on attempt to call Workspace.restore(Version[], boolean) in a session having any unsaved changes pending.");
        } catch (InvalidItemStateException e) {
            // success
        }
    }


    protected void close() {
        super.close();
        try {
            ObservationManager observationMgr = systemSession.getWorkspace().getObservationManager();
            observationMgr.removeEventListener(this);
            observationMgr.removeEventListener(moveListener);
        } catch (RepositoryException e) {
            log.error("Unexpected error while closing CachingEntryCollector", e);
        }
    }


    public void testWorkspaceRestoreWithPendingChangesJcr2() throws RepositoryException {
        versionableNode.getSession().getWorkspace().getVersionManager().checkout(versionableNode.getPath());
        try {
            // modify node without calling save()
            versionableNode.setProperty(propertyName1, propertyValue);

            // create version in second workspace
            Version v = wVersionableNode.getSession().getWorkspace().getVersionManager().checkin(wVersionableNode.getPath());
            // try to restore that version
            superuser.getWorkspace().getVersionManager().restore(new Version[]{v}, false);

            fail("InvalidItemStateException must be thrown on attempt to call Workspace.restore(Version[], boolean) in a session having any unsaved changes pending.");
        } catch (InvalidItemStateException e) {
            // success
        }
    }


    protected void initProperties() {
        super.initProperties();
        try {
            // init workspace specific properties
            NamespaceRegistry nsReg = getRepositorySession().getWorkspace().getNamespaceRegistry();
            DavProperty<?> namespacesProp = new NamespacesProperty(nsReg);
            properties.add(namespacesProp);
        } catch (RepositoryException e) {
            log.error("Failed to access NamespaceRegistry: " + e.getMessage());
        }
    }


    public void testAutoSave() throws RepositoryException {
        boolean autosave = userMgr.isAutoSave();
        if (autosave) {
            try {
                userMgr.autoSave(false);
                autosave = false;
            } catch (RepositoryException e) {
                // cannot change autosave behavior
                // ignore -> test will behave differently.
            }
        }

        Principal p = getTestPrincipal();
        String uid = p.getName();

        User user = userMgr.createUser(uid, buildPassword(uid));
        superuser.refresh(false);

        if (!autosave) {
            // transient changes must be gone after the refresh-call.
            assertNull(userMgr.getAuthorizable(uid));
            assertNull(userMgr.getAuthorizable(p));
        } else {
            // changes are persisted automatically -> must not be gone.
            createdUsers.add(user);
            assertNotNull(userMgr.getAuthorizable(uid));
            assertNotNull(userMgr.getAuthorizable(p));
        }
    }


    public void testAutoSave() throws RepositoryException {
        boolean autosave = userMgr.isAutoSave();
        if (autosave) {
            try {
                userMgr.autoSave(false);
                autosave = false;
            } catch (RepositoryException e) {
                // cannot change autosave behavior
                // ignore -> test will behave differently.
            }
        }

        Principal p = getTestPrincipal();
        Group gr = userMgr.createGroup(p);
        String id = gr.getID();
        superuser.refresh(false);

        if (!autosave) {
            // transient changes must be gone after the refresh-call.
            assertNull(userMgr.getAuthorizable(id));
            assertNull(userMgr.getAuthorizable(p));
        } else {
            // no transient changes as autosave could not be disabled.
            createdGroups.add(gr);            
            assertNotNull(userMgr.getAuthorizable(id));
            assertNotNull(userMgr.getAuthorizable(p));
        }
    }


    public void testSetProperty() throws NotExecutableException, RepositoryException {
        Authorizable auth = getTestUser(superuser);

        // TODO: retrieve propname and value from config
        String propName = "Fullname";
        Value v = superuser.getValueFactory().createValue("Super User");
        try {
            auth.setProperty(propName, v);
            save(superuser);
        } catch (RepositoryException e) {
            throw new NotExecutableException("Cannot test 'Authorizable.setProperty'.");
        }

        try {
            boolean found = false;
            for (Iterator<String> it = auth.getPropertyNames(); it.hasNext() && !found;) {
                found = propName.equals(it.next());
            }
            assertTrue(found);

            found = false;
            for (Iterator<String> it = auth.getPropertyNames("."); it.hasNext() && !found;) {
                found = propName.equals(it.next());
            }
            assertTrue(found);

            assertTrue(auth.hasProperty(propName));
            assertTrue(auth.hasProperty("./" + propName));
            
            assertTrue(auth.getProperty(propName).length == 1);

            assertEquals(v, auth.getProperty(propName)[0]);
            assertEquals(v, auth.getProperty("./" + propName)[0]);

            assertTrue(auth.removeProperty(propName));
            assertFalse(auth.hasProperty(propName));
            
            save(superuser);
        } finally {
            // try to remove the property again even if previous calls failed.
            auth.removeProperty(propName);
            save(superuser);
        }
    }


    public void testSetMultiValueProperty() throws NotExecutableException, RepositoryException {
        Authorizable auth = getTestUser(superuser);

        // TODO: retrieve propname and values from config
        String propName = "Fullname";
        Value[] v = new Value[] {superuser.getValueFactory().createValue("Super User")};
        try {
            auth.setProperty(propName, v);
            save(superuser);
        } catch (RepositoryException e) {
            throw new NotExecutableException("Cannot test 'Authorizable.setProperty'.");
        }

        try {
            boolean found = false;
            for (Iterator<String> it = auth.getPropertyNames(); it.hasNext() && !found;) {
                found = propName.equals(it.next());
            }
            assertTrue(found);

            found = false;
            for (Iterator<String> it = auth.getPropertyNames("."); it.hasNext() && !found;) {
                found = propName.equals(it.next());
            }
            assertTrue(found);
            
            assertTrue(auth.hasProperty(propName));
            assertTrue(auth.hasProperty("./" + propName));
            
            assertEquals(Arrays.asList(v), Arrays.asList(auth.getProperty(propName)));
            assertEquals(Arrays.asList(v), Arrays.asList(auth.getProperty("./" + propName)));

            assertTrue(auth.removeProperty(propName));
            assertFalse(auth.hasProperty(propName));
            
            save(superuser);
        } finally {
            // try to remove the property again even if previous calls failed.
            auth.removeProperty(propName);
            save(superuser);
        }
    }


    public void testGetPropertyByInvalidRelativePath() throws NotExecutableException, RepositoryException {
        Authorizable auth = getTestUser(superuser);

        List<String> wrongPaths = new ArrayList<String>();
        wrongPaths.add("../jcr:primaryType");
        wrongPaths.add("../../jcr:primaryType");
        wrongPaths.add("../testing/jcr:primaryType");
        for (String path : wrongPaths) {
            assertNull(auth.getProperty(path));
        }

        List<String> invalidPaths = new ArrayList<String>();
        invalidPaths.add("/testing/jcr:primaryType");
        invalidPaths.add("..");
        invalidPaths.add(".");
        invalidPaths.add(null);
        for (String invalidPath : invalidPaths) {
            try {
                assertNull(auth.getProperty(invalidPath));
            } catch (Exception e) {
                // success
            }
        }
    }


    public void testHasPropertyByInvalidRelativePath() throws NotExecutableException, RepositoryException {
        Authorizable auth = getTestUser(superuser);

        List<String> wrongPaths = new ArrayList<String>();
        wrongPaths.add("../jcr:primaryType");
        wrongPaths.add("../../jcr:primaryType");
        wrongPaths.add("../testing/jcr:primaryType");
        for (String path : wrongPaths) {
            assertFalse(auth.hasProperty(path));
        }


        List<String> invalidPaths = new ArrayList<String>();
        invalidPaths.add("..");
        invalidPaths.add(".");
        invalidPaths.add(null);

        for (String invalidPath : invalidPaths) {
            try {
                assertFalse(auth.hasProperty(invalidPath));
            } catch (Exception e) {
                // success
            }
        }
    }


    public void testGetNotExistingProperty() throws RepositoryException, NotExecutableException {
        Authorizable auth = getTestUser(superuser);
        String hint = "Fullname";
        String propName = hint;
        int i = 0;
        while (auth.hasProperty(propName)) {
            propName = hint + i;
            i++;
        }
        assertNull(auth.getProperty(propName));
        assertFalse(auth.hasProperty(propName));
    }


    public void testRemoveNotExistingProperty() throws RepositoryException, NotExecutableException {
        Authorizable auth = getTestUser(superuser);
        String hint = "Fullname";
        String propName = hint;
        int i = 0;
        while (auth.hasProperty(propName)) {
            propName = hint + i;
            i++;
        }
        assertFalse(auth.removeProperty(propName));
        save(superuser);
    }


    public void testDirectScope() throws RepositoryException {
        Group[] groups = new Group[]{mammals, vertebrates, apes};
        for (final Group g : groups) {
            Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    try {
                        builder.setScope(g.getID(), true);
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                    }
                }
            });

            Iterator<Authorizable> members = g.getDeclaredMembers();
            assertSameElements(result, members);
        }
    }


    public void testFindGroupsInGroup() throws RepositoryException {
        Group[] groups = new Group[]{mammals, vertebrates, apes};
        for (final Group g : groups) {
            Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    try {
                        builder.setSelector(Group.class);
                        builder.setScope(g.getID(), true);
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                    }
                }
            });

            Iterator<Authorizable> members = g.getDeclaredMembers();
            Iterator<Authorizable> users = Iterators.filterIterator(members, new Predicate<Authorizable>() {
                public boolean evaluate(Authorizable authorizable) {
                    return authorizable.isGroup();
                }
            });
            assertSameElements(result, users);
        }
    }


    public void testIndirectScope() throws RepositoryException {
        Group[] groups = new Group[]{mammals, vertebrates, apes};
        for (final Group g : groups) {
            Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    try {
                        builder.setScope(g.getID(), false);
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                    }
                }
            });

            Iterator<Authorizable> members = g.getMembers();
            assertSameElements(result, members);
        }
    }


    public void testFindUsersInGroup() throws RepositoryException {
        Group[] groups = new Group[]{mammals, vertebrates, apes};
        for (final Group g : groups) {
            Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    try {
                        builder.setSelector(User.class);
                        builder.setScope(g.getID(), false);
                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                    }
                }
            });

            Iterator<Authorizable> members = g.getMembers();
            Iterator<Authorizable> users = Iterators.filterIterator(members, new Predicate<Authorizable>() {
                public boolean evaluate(Authorizable authorizable) {
                    return !authorizable.isGroup();
                }
            });
            assertSameElements(result, users);
        }
    }


    public void testNameMatch() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.nameMatches("a%"));
            }
        });

        Iterator<Authorizable> expected = Iterators.filterIterator(authorizables.iterator(), new Predicate<Authorizable>() {
            public boolean evaluate(Authorizable authorizable) {
                try {
                    String name = authorizable.getID();
                    Principal principal = authorizable.getPrincipal();
                    return name.startsWith("a") || principal != null && principal.getName().startsWith("a");
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testFindProperty1() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        eq("@canFly", vf.createValue(true)));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] canFly = user.getProperty("canFly");
                    return canFly != null && canFly.length == 1 && canFly[0].getBoolean();
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testPropertyLike() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        like("profile/@food", "m%"));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] food = user.getProperty("profile/food");
                    if (food == null || food.length != 1) {
                        return false;
                    }
                    else {
                        String value = food[0].getString();
                        return value.startsWith("m");
                    }
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testCondition1() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        and(builder.
                            eq("profile/@cute", vf.createValue(true)), builder.
                            not(builder.
                                eq("@color", vf.createValue("black")))));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] cute = user.getProperty("profile/cute");
                    Value[] black = user.getProperty("color");
                    return cute != null && cute.length == 1 && cute[0].getBoolean() &&
                           !(black != null && black.length == 1 && black[0].getString().equals("black"));
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testFindProperty3() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        eq("@numberOfLegs", vf.createValue(8)));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] numberOfLegs = user.getProperty("numberOfLegs");
                    return numberOfLegs != null && numberOfLegs.length == 1 && numberOfLegs[0].getLong() == 8;
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testPropertyExistence() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        exists("@poisonous"));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] poisonous = user.getProperty("poisonous");
                    return poisonous != null && poisonous.length == 1;
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testCondition2() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        or(builder.
                            eq("profile/@food", vf.createValue("mice")), builder.
                            eq("profile/@food", vf.createValue("nectar"))));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] food = user.getProperty("profile/food");
                    return food != null && food.length == 1 &&
                          (food[0].getString().equals("mice") || food[0].getString().equals("nectar"));
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testFindProperty2() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        gt("profile/@weight", vf.createValue(2000.0)));
            }
        });

        Iterator<User> expected = Iterators.filterIterator(users.iterator(), new Predicate<User>() {
            public boolean evaluate(User user) {
                try {
                    Value[] weight = user.getProperty("profile/weight");
                    return weight != null && weight.length == 1 && weight[0].getDouble() > 2000.0;
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }
        });

        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


            public boolean evaluate(Authorizable authorizable) {
                try {
                    String name = authorizable.getID();
                    Principal principal = authorizable.getPrincipal();
                    return name.startsWith("a") || principal != null && principal.getName().startsWith("a");
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }


                public boolean evaluate(User user) {
                    try {
                        Value[] cute = user.getProperty("profile/cute");
                        Value[] weight = user.getProperty("profile/weight");
                        return cute != null && cute.length == 1 && cute[0].getBoolean() &&
                                weight != null && weight.length == 1 && weight[0].getDouble() > 1000.0;

                    } catch (RepositoryException e) {
                        fail(e.getMessage());
                    }
                    return false;
                }


            public boolean evaluate(User user) {
                try {
                    Value[] cute = user.getProperty("profile/cute");
                    Value[] black = user.getProperty("color");
                    return cute != null && cute.length == 1 && cute[0].getBoolean() &&
                           !(black != null && black.length == 1 && black[0].getString().equals("black"));
                } catch (RepositoryException e) {
                    fail(e.getMessage());
                }
                return false;
            }


    public void testContains1() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        contains(".", "gold"));
            }
        });

        Iterator<User> expected = Iterators.singleton(goldenToad);
        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testContains2() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        contains("@color", "gold"));
            }
        });

        Iterator<User> expected = Iterators.singleton(goldenToad);
        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testImpersonation() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        impersonates("jackrabbit"));
            }
        });

        Iterator<User> expected = Iterators.singleton(elephant);
        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testContains4() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        contains("profile/@food", "grass"));
            }
        });

        Iterator<User> expected = Iterators.singleton(kangaroo);
        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testContains3() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        contains("profile/.", "grass"));
            }
        });

        Iterator<User> expected = Iterators.singleton(kangaroo);
        assertTrue(result.hasNext());
        assertSameElements(result, expected);
    }


    public void testSortOrder1() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        exists("@color"));
                builder.setSortOrder("@color", Direction.DESCENDING);
            }
        });

        assertTrue(result.hasNext());
        String prev = null;
        while (result.hasNext()) {
            Authorizable authorizable = result.next();
            Value[] color = authorizable.getProperty("color");
            assertNotNull(color);
            assertEquals(1, color.length);
            assertTrue(prev == null || prev.compareToIgnoreCase(color[0].getString()) >= 0);
            prev = color[0].getString();
        }
    }


    public void testSortOrder2() throws RepositoryException {
        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setCondition(builder.
                        exists("profile/@weight"));
                builder.setSortOrder("profile/@weight", Direction.ASCENDING, true);
            }
        });

        assertTrue(result.hasNext());
        double prev = Double.MIN_VALUE;
        while (result.hasNext()) {
            Authorizable authorizable = result.next();
            Value[] weight = authorizable.getProperty("profile/weight");
            assertNotNull(weight);
            assertEquals(1, weight.length);
            assertTrue(prev <= weight[0].getDouble());
            prev = weight[0].getDouble();
        }
    }


    public void testOffset() throws RepositoryException {
        long[] offsets = {2, 0, 3, 0,      100000};
        long[] counts =  {4, 4, 0, 100000, 100000};

        for (int k = 0; k < offsets.length; k++) {
            final long offset = offsets[k];
            final long count = counts[k];
            Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    builder.setSortOrder("profile/@weight", Direction.ASCENDING);
                    builder.setLimit(offset, count);
                }
            });

            Iterator<Authorizable> expected = userMgr.findAuthorizables(new Query() {
                public <T> void build(QueryBuilder<T> builder) {
                    builder.setSortOrder("profile/@weight", Direction.ASCENDING);
                }
            });

            skip(expected, offset);
            assertSame(expected, result, count);
            assertFalse(result.hasNext());
        }
    }


    public void testScopeWithOffset() throws RepositoryException {
        final int offset = 5;
        final int count = 10000;

        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setScope("vertebrates", false);
                builder.setSortOrder("profile/@weight", Direction.ASCENDING);
                builder.setLimit(offset, count);
            }
        });

        Iterator<Authorizable> expected = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setScope("vertebrates", false);
                builder.setSortOrder("profile/@weight", Direction.ASCENDING);
            }
        });

        skip(expected, offset);
        assertSame(expected, result, count);
        assertFalse(result.hasNext());
    }


    public void testScopeWithMax() throws RepositoryException {
        final int offset = 0;
        final int count = 22;

        Iterator<Authorizable> result = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setScope("vertebrates", false);
                builder.setSortOrder("profile/@weight", Direction.ASCENDING);
                builder.setLimit(offset, count);
            }
        });

        Iterator<Authorizable> expected = userMgr.findAuthorizables(new Query() {
            public <T> void build(QueryBuilder<T> builder) {
                builder.setScope("vertebrates", false);
                builder.setSortOrder("profile/@weight", Direction.ASCENDING);
            }
        });

        assertSameElements(expected, result);
        assertFalse(result.hasNext());
    }


    public void testFindUserWithSpecialCharIdByPrincipalName() throws RepositoryException {
        List<String> ids = Arrays.asList("'", Text.escapeIllegalJcrChars("']"), Text.escape("']"));
        for (String id : ids) {
            User user = null;
            try {
                user = userMgr.createUser(id, "pw");
                superuser.save();

                boolean found = false;
                Iterator<Authorizable> it = userMgr.findAuthorizables("rep:principalName", id, UserManager.SEARCH_TYPE_USER);
                while (it.hasNext() && !found) {
                    Authorizable a = it.next();
                    found = id.equals(a.getID());
                }
                assertTrue(found);
            } finally {
                if (user != null) {
                    user.remove();
                    superuser.save();
                }
            }
        }
    }


    public void testQueryUserWithSpecialCharId() throws Exception {
        List<String> ids = Arrays.asList("'", "]");
        for (String id : ids) {
            User user = null;
            try {
                user = userMgr.createUser(id, "pw");
                superuser.save();

                boolean found = false;
                String query = "{\"condition\":[{\"named\":\"" + id + "\"}]}";
                AuthorizableQueryManager queryManager = new AuthorizableQueryManager(userMgr, superuser.getValueFactory());
                Iterator<Authorizable> it = queryManager.execute(query);
                while (it.hasNext() && !found) {
                    Authorizable a = it.next();
                    found = id.equals(a.getID());
                }
                assertTrue(found);
            } finally {
                if (user != null) {
                    user.remove();
                    superuser.save();
                }
            }
        }
    }


    public void testFindUserWithSpecialCharIdByPrincipalName2() throws RepositoryException {
        List<String> ids = Arrays.asList("]");
        for (String id : ids) {
            User user = null;
            try {
                user = userMgr.createUser(id, "pw");
                superuser.save();

                boolean found = false;
                Iterator<Authorizable> it = userMgr.findAuthorizables("rep:principalName", id, UserManager.SEARCH_TYPE_USER);
                while (it.hasNext() && !found) {
                    Authorizable a = it.next();
                    found = id.equals(a.getID());
                }
                assertTrue(found);
            } finally {
                if (user != null) {
                    user.remove();
                    superuser.save();
                }
            }
        }
    }


    public void testChangePassword() throws RepositoryException, NotExecutableException {
        String oldPw = getHelper().getProperty("javax.jcr.tck.superuser.pwd");
        if (oldPw == null) {
            // missing property
            throw new NotExecutableException();
        }

        User user = getTestUser(superuser);
        try {
            user.changePassword("pw");
            save(superuser);
            
            // make sure the user can login with the new pw
            Session s = getHelper().getRepository().login(new SimpleCredentials(user.getID(), "pw".toCharArray()));
            s.logout();
        } finally {
            user.changePassword(oldPw);
            save(superuser);
        }
    }


    public void testChangePassword2() throws RepositoryException, NotExecutableException {
        String oldPw = getHelper().getProperty("javax.jcr.tck.superuser.pwd");
        if (oldPw == null) {
            // missing property
            throw new NotExecutableException();
        }

        User user = getTestUser(superuser);
        try {
            user.changePassword("pw");
            save(superuser);

            Session s = getHelper().getRepository().login(new SimpleCredentials(user.getID(), oldPw.toCharArray()));
            s.logout();
            fail("superuser pw has changed. login must fail.");
        } catch (LoginException e) {
            // success
        } finally {
            user.changePassword(oldPw);
            save(superuser);
        }
    }


    public void testChangePasswordWithOldPassword2() throws RepositoryException, NotExecutableException {
        String oldPw = getHelper().getProperty("javax.jcr.tck.superuser.pwd");
        if (oldPw == null) {
            // missing property
            throw new NotExecutableException();
        }

        User user = getTestUser(superuser);
        try {
            user.changePassword("pw", oldPw);
            save(superuser);

            Session s = getHelper().getRepository().login(new SimpleCredentials(user.getID(), oldPw.toCharArray()));
            s.logout();
            fail("superuser pw has changed. login must fail.");
        } catch (LoginException e) {
            // success
        } finally {
            user.changePassword(oldPw);
            save(superuser);
        }
    }


    public void testAddRemoveMember() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup1 = null;
        Group newGroup2 = null;
        try {
            newGroup1 = userMgr.createGroup(getTestPrincipal());
            newGroup2 = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalse(newGroup1.isMember(auth));
            assertFalse(newGroup1.removeMember(auth));
            save(superuser);
            assertFalse(newGroup2.isMember(auth));
            assertFalse(newGroup2.removeMember(auth));
            save(superuser);

            assertTrue(newGroup1.addMember(auth));
            save(superuser);
            assertTrue(newGroup1.isMember(auth));
            assertTrue(newGroup1.isMember(userMgr.getAuthorizable(auth.getID())));

            assertTrue(newGroup2.addMember(auth));
            save(superuser);
            assertTrue(newGroup2.isMember(auth));
            assertTrue(newGroup2.isMember(userMgr.getAuthorizable(auth.getID())));

            assertTrue(newGroup1.removeMember(auth));
            save(superuser);
            assertTrue(newGroup2.removeMember(auth));
            save(superuser);

            assertTrue(newGroup1.addMember(auth));
            save(superuser);
            assertTrue(newGroup1.isMember(auth));
            assertTrue(newGroup1.isMember(userMgr.getAuthorizable(auth.getID())));
            assertTrue(newGroup1.removeMember(auth));
            save(superuser);


        } finally {
            if (newGroup1 != null) {
                newGroup1.removeMember(auth);
                newGroup1.remove();
                save(superuser);
            }
            if (newGroup2 != null) {
                newGroup2.removeMember(auth);
                newGroup2.remove();
                save(superuser);
            }
        }
    }


    public void testIsDeclaredMember() throws RepositoryException, NotExecutableException {
        User auth = getTestUser(superuser);
        Group newGroup1 = null;
        Group newGroup2 = null;
        try {
            newGroup1 = userMgr.createGroup(getTestPrincipal());
            newGroup2 = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            assertFalse(newGroup1.isDeclaredMember(auth));
            assertFalse(newGroup2.isDeclaredMember(auth));

            assertTrue(newGroup2.addMember(auth));
            save(superuser);
            assertTrue(newGroup2.isDeclaredMember(auth));
            assertTrue(newGroup2.isDeclaredMember(userMgr.getAuthorizable(auth.getID())));

            assertTrue(newGroup1.addMember(newGroup2));
            save(superuser);
            assertTrue(newGroup1.isDeclaredMember(newGroup2));
            assertTrue(newGroup1.isDeclaredMember(userMgr.getAuthorizable(newGroup2.getID())));
            assertTrue(newGroup1.isMember(auth));
            assertTrue(newGroup1.isMember(userMgr.getAuthorizable(auth.getID())));
            assertFalse(newGroup1.isDeclaredMember(auth));
            assertFalse(newGroup1.isDeclaredMember(userMgr.getAuthorizable(auth.getID())));
        } finally {
            if (newGroup1 != null) {
                newGroup1.remove();
                save(superuser);
            }
            if (newGroup2 != null) {
                newGroup2.remove();
                save(superuser);
            }
        }
    }


    public void testIndirectMembers() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        Group newGroup2 = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            newGroup2 = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            newGroup.addMember(newGroup2);
            save(superuser);
            assertTrue(newGroup.isMember(newGroup2));

            newGroup2.addMember(auth);
            save(superuser);

            // testuser must not be declared member of 'newGroup'
            assertFalseIsMember(newGroup.getDeclaredMembers(), auth);
            assertFalseMemberOfContainsGroup(auth.declaredMemberOf(), newGroup);

            // testuser must however be member of 'newGroup' (indirect).
            assertTrueIsMember(newGroup.getMembers(), auth);
            assertTrueMemberOfContainsGroup(auth.memberOf(), newGroup);

            // testuser cannot be removed from 'newGroup'
            assertFalse(newGroup.removeMember(auth));
            save(superuser);
        } finally {
            if (newGroup != null) {
                newGroup.removeMember(newGroup2);
                newGroup.remove();
                save(superuser);
            }
            if (newGroup2 != null) {
                newGroup2.removeMember(auth);
                newGroup2.remove();
                save(superuser);
            }
        }
    }


    public void testMembersInPrincipal() throws NotExecutableException, RepositoryException {
        User auth = getTestUser(superuser);
        Group newGroup = null;
        Group newGroup2 = null;
        try {
            newGroup = userMgr.createGroup(getTestPrincipal());
            newGroup2 = userMgr.createGroup(getTestPrincipal());
            save(superuser);

            newGroup.addMember(newGroup2);
            save(superuser);
            newGroup2.addMember(auth);
            save(superuser);

            java.security.acl.Group ngPrincipal = (java.security.acl.Group) newGroup.getPrincipal();
            java.security.acl.Group ng2Principal = (java.security.acl.Group) newGroup2.getPrincipal();

            assertFalse(ng2Principal.isMember(ngPrincipal));

            // newGroup2 must be member of newGroup's principal
            assertTrue(ngPrincipal.isMember(newGroup2.getPrincipal()));

            // testuser must be member of newGroup2's and newGroup's principal (indirect)
            assertTrue(ng2Principal.isMember(auth.getPrincipal()));
            assertTrue(ngPrincipal.isMember(auth.getPrincipal()));

        } finally {
            if (newGroup != null) {
                newGroup.removeMember(newGroup2);
                newGroup.remove();
                save(superuser);
            }
            if (newGroup2 != null) {
                newGroup2.removeMember(auth);
                newGroup2.remove();
                save(superuser);
            }
        }
    }


    public void testHasPrivilegesWithInvalidPath() throws RepositoryException {
        JackrabbitAccessControlManager jacMgr = (JackrabbitAccessControlManager) acMgr;
        String invalidPath = testRoot;
        while (superuser.nodeExists(invalidPath)) {
            invalidPath += "_";
        }
        
        try {
            jacMgr.hasPrivileges(invalidPath, principals, new Privilege[] {jacMgr.privilegeFromName(Privilege.JCR_READ)});
            fail("Invalid path must be detected");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    public void testGetPrivilegesWithInvalidPath() throws RepositoryException {
        JackrabbitAccessControlManager jacMgr = (JackrabbitAccessControlManager) acMgr;
        String invalidPath = testRoot;
        while (superuser.nodeExists(invalidPath)) {
            invalidPath += "_";
        }

        try {
            jacMgr.getPrivileges(invalidPath, principals);
            fail("Invalid path must be detected");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    private void nodeAdded(Path path) {
        acquire();

        try {
            PathMap.Element<LockInfo> parent =
                lockMap.map(path.getAncestor(1), true);
            if (parent != null) {
                refresh(parent);
            }
        } catch (RepositoryException e) {
            log.warn("Unable to determine path of added node's parent.", e);
        } finally {
            release();
        }
    }


    private void nodeRemoved(Path path) {
        acquire();

        try {
            PathMap.Element<LockInfo> parent =
                lockMap.map(path.getAncestor(1), true);
            if (parent != null) {
                refresh(parent);
            }
        } catch (RepositoryException e) {
            log.warn("Unable to determine path of removed node's parent.", e);
        } finally {
            release();
        }
    }


    private void nodeMoved(Path oldPath, Path newPath) {
        acquire();

        try {
            PathMap.Element<LockInfo> parent =
                lockMap.map(oldPath.getAncestor(1), true);
            if (parent != null) {
                refresh(parent);
            }
        } catch (RepositoryException e) {
            log.warn("Unable to determine path of moved node's parent.", e);
        } finally {
            release();
        }
    }


    public String toString() {
        final StringBuilder builder = new StringBuilder();
        lockMap.traverse(new PathMap.ElementVisitor<LockInfo>() {
            public void elementVisited(PathMap.Element<LockInfo> element) {
                for (int i = 0; i < element.getDepth(); i++) {
                    builder.append("--");
                }
                builder.append(element.getName());
                int index = element.getIndex();
                if (index != 0 && index != 1) {
                    builder.append('[');
                    builder.append(index);
                    builder.append(']');
                }
                builder.append("  ");
                builder.append(element.get());
                builder.append("\n");
            }
        }, true);
        return builder.toString();
    }


    public String toString() {
        final StringBuilder builder = new StringBuilder();
        synchronized (cacheMonitor) {
            pathCache.traverse(new PathMap.ElementVisitor<LRUEntry>() {
                public void elementVisited(PathMap.Element<LRUEntry> element) {
                    for (int i = 0; i < element.getDepth(); i++) {
                        builder.append("--");
                    }
                    builder.append(element.getName());
                    int index = element.getIndex();
                    if (index != 0 && index != 1) {
                        builder.append('[');
                        builder.append(index);
                        builder.append(']');
                    }
                    builder.append("  ");
                    builder.append(element.get());
                    builder.append("\n");
                }
            }, true);
        }
        return builder.toString();
    }


    public void addLockToken(SessionImpl session, String lt) throws RepositoryException {
        try {
            NodeId id = LockInfo.parseLockToken(lt);
            NodeImpl node = (NodeImpl) session.getItemManager().getItem(id);
            LockInfo info = getLockInfo(node);
            if (info != null && !info.isLockHolder(session)) {
                if (info.getLockHolder() == null) {
                    info.setLockHolder(session);
                } else {
                    String msg = "Cannot add lock token: lock already held by other session.";
                    log.warn(msg);
                    throw new LockException(msg);
                }
            }
            // inform SessionLockManager
            getSessionLockManager(session).lockTokenAdded(lt);
        } catch (IllegalArgumentException e) {
            String msg = "Bad lock token: " + e.getMessage();
            log.warn(msg);
            throw new LockException(msg);
        }
    }


    public void removeLockToken(SessionImpl session, String lt) throws RepositoryException {
        try {
            NodeId id = LockInfo.parseLockToken(lt);

            NodeImpl node = (NodeImpl) session.getItemManager().getItem(id);
            LockInfo info = getLockInfo(node);
            if (info != null) {
                if (info.isLockHolder(session)) {
                    info.setLockHolder(null);
                } else if (info.getLockHolder() != null) {
                    String msg = "Cannot remove lock token: lock held by other session.";
                    log.warn(msg);
                    throw new LockException(msg);
                }
            }
            // inform SessionLockManager
            getSessionLockManager(session).lockTokenRemoved(lt);
        } catch (IllegalArgumentException e) {
            String msg = "Bad lock token: " + e.getMessage();
            log.warn(msg);
            throw new LockException(msg);
        }
    }


    public void associate(TransactionContext tx) {
        XAEnvironment xaEnv = null;
        if (tx != null) {
            xaEnv = (XAEnvironment) tx.getAttribute(XA_ENV_ATTRIBUTE_NAME);
            if (xaEnv == null) {
                xaEnv = new XAEnvironment(lockMgr);
                tx.setAttribute(XA_ENV_ATTRIBUTE_NAME, xaEnv);
            }
        }
        this.xaEnv = xaEnv;
    }


    public void associate(TransactionContext tx) {
        ChangeLog txLog = null;
        if (tx != null) {
            txLog = (ChangeLog) tx.getAttribute(attributeName);
            if (txLog == null) {
                txLog = new ChangeLog();
                tx.setAttribute(attributeName, txLog);
            }
        }
        this.txLog = txLog;
    }


    public List<? extends ProtectedItemImporter> getProtectedItemImporters() {
        List<ProtectedItemImporter> piis = new ArrayList<ProtectedItemImporter>();
        for (BeanConfig bc : protectedItemImporters) {
            try {
                piis.add(bc.newInstance(ProtectedItemImporter.class));
            } catch (ConfigurationException e) {
                log.warn(e.getMessage());
            }
        }
        return piis;
    }


    public AccessControlPolicy[] editAccessControlPolicies(String nodePath) throws AccessControlException, PathNotFoundException, RepositoryException {
        List<AccessControlPolicy> templates = new ArrayList<AccessControlPolicy>();
        for (AccessControlEditor editor : editors) {
            try {
                templates.addAll(Arrays.asList(editor.editAccessControlPolicies(nodePath)));
            } catch (AccessControlException e) {
                log.debug(e.getMessage());
                // ignore.
            }
        }
        return templates.toArray(new AccessControlPolicy[templates.size()]);
    }


    private Collection<NodeType> registerNodeTypes(List<QNodeTypeDefinition> defs)
            throws InvalidNodeTypeDefException, RepositoryException {
        context.getNodeTypeRegistry().registerNodeTypes(defs);

        Set<NodeType> types = new HashSet<NodeType>();
        for (QNodeTypeDefinition def : defs) {
            try {
                types.add(getNodeType(def.getName()));
            } catch (NoSuchNodeTypeException e) {
                // ignore
            }
        }
        return types;
    }


    public JackrabbitAccessControlPolicy[] editAccessControlPolicies(Principal principal) throws RepositoryException {
        List<JackrabbitAccessControlPolicy> templates = new ArrayList<JackrabbitAccessControlPolicy>();
        for (AccessControlEditor editor : editors) {
            try {
                templates.addAll(Arrays.asList(editor.editAccessControlPolicies(principal)));
            } catch (AccessControlException e) {
                log.debug(e.getMessage());
                // ignore.
            }
        }
        return templates.toArray(new JackrabbitAccessControlPolicy[templates.size()]);
    }


    private Map<String, Method> getSetters(Class<?> klass) {
        Map<String, Method> methods = new HashMap<String, Method>();
        for (Method method : klass.getMethods()) {
            String name = method.getName();
            if (name.startsWith("set") && name.length() > 3
                    && Modifier.isPublic(method.getModifiers())
                    && !Modifier.isStatic(method.getModifiers())
                    && Void.TYPE.equals(method.getReturnType())
                    && method.getParameterTypes().length == 1) {
                methods.put(
                        name.substring(3, 4).toLowerCase(Locale.ENGLISH) + name.substring(4),
                        method);
            }
        }
        return methods;
    }


    private Map<String, PropertyValue> getColumnMap(String selector,
            NodeType type) throws RepositoryException {
        Map<String, PropertyValue> map = new LinkedHashMap<String, PropertyValue>();
        for (PropertyDefinition definition : type.getPropertyDefinitions()) {
            String name = definition.getName();
            if (!definition.isMultiple() && !"*".equals(name)) {
                // TODO: Add proper quoting
                map.put(selector + "." + name,
                        qomFactory.propertyValue(selector, name));
            }
        }
        return map;
    }


    private static Map<String, Method> getSetters(Class<?> cl) {
        Map<String, Method> methods = new HashMap<String, Method>();
        for (Method method : cl.getMethods()) {
            String name = method.getName();
            if (name.startsWith("set") && name.length() > 3
                    && Modifier.isPublic(method.getModifiers())
                    && !Modifier.isStatic(method.getModifiers())
                    && Void.TYPE.equals(method.getReturnType())
                    && method.getParameterTypes().length == 1) {
                methods.put(name.substring(3, 4).toLowerCase() + name.substring(4), method);
            }
        }
        return methods;
    }


    public PropertyImpl getProperty(Path path)
            throws PathNotFoundException, AccessDeniedException, RepositoryException {
        PropertyId id = hierMgr.resolvePropertyPath(path);
        if (id == null) {
            throw new PathNotFoundException(safeGetJCRPath(path));
        }
        try {
            return (PropertyImpl) getItem(id, path, true);
        } catch (ItemNotFoundException infe) {
            throw new PathNotFoundException(safeGetJCRPath(path));
        }
    }


    protected NodeState getNodeState(ItemStateManager srcStateMgr,
                                     HierarchyManager srcHierMgr,
                                     Path nodePath)
            throws PathNotFoundException, RepositoryException {
        try {
            NodeId id = srcHierMgr.resolveNodePath(nodePath);
            if (id == null) {
                throw new PathNotFoundException(safeGetJCRPath(nodePath));
            }
            return (NodeState) getItemState(srcStateMgr, id);
        } catch (ItemNotFoundException infe) {
            throw new PathNotFoundException(safeGetJCRPath(nodePath));
        }
    }


    synchronized boolean hasChildNodes(NodeId parentId)
            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
        sanityCheck();

        ItemData data = getItemData(parentId);
        if (!data.isNode()) {
            String msg = "can't list child nodes of property " + parentId;
            log.debug(msg);
            throw new RepositoryException(msg);
        }

        NodeState state = (NodeState) data.getState();
        for (ChildNodeEntry entry : state.getChildNodeEntries()) {
            // make sure any of the properties can be read.
            if (canRead(data, entry.getId())) {
                return true;
            }
        }
        return false;
    }


    synchronized boolean hasChildProperties(NodeId parentId)
            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
        sanityCheck();

        ItemData data = getItemData(parentId);
        if (!data.isNode()) {
            String msg = "can't list child properties of property " + parentId;
            log.debug(msg);
            throw new RepositoryException(msg);
        }
        Iterator<Name> iter = ((NodeState) data.getState()).getPropertyNames().iterator();

        while (iter.hasNext()) {
            Name propName = iter.next();
            // make sure any of the properties can be read.
            if (canRead(data, new PropertyId(parentId, propName))) {
                return true;
            }
        }

        return false;
    }


    synchronized PropertyIterator getChildProperties(NodeId parentId)
            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
        sanityCheck();

        ItemData data = getItemData(parentId);
        if (!data.isNode()) {
            String msg = "can't list child properties of property " + parentId;
            log.debug(msg);
            throw new RepositoryException(msg);
        }
        ArrayList<PropertyId> childIds = new ArrayList<PropertyId>();
        Iterator<Name> iter = ((NodeState) data.getState()).getPropertyNames().iterator();

        while (iter.hasNext()) {
            Name propName = iter.next();
            PropertyId id = new PropertyId(parentId, propName);
            // delay check for read-access until item is being built
            // thus avoid duplicate check
            childIds.add(id);
        }

        return new LazyItemIterator(sessionContext, childIds);
    }


    synchronized NodeIterator getChildNodes(NodeId parentId)
            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
        sanityCheck();

        ItemData data = getItemData(parentId);
        if (!data.isNode()) {
            String msg = "can't list child nodes of property " + parentId;
            log.debug(msg);
            throw new RepositoryException(msg);
        }
        ArrayList<ItemId> childIds = new ArrayList<ItemId>();
        Iterator<ChildNodeEntry> iter = ((NodeState) data.getState()).getChildNodeEntries().iterator();

        while (iter.hasNext()) {
            ChildNodeEntry entry = iter.next();
            // delay check for read-access until item is being built
            // thus avoid duplicate check
            childIds.add(entry.getId());
        }

        return new LazyItemIterator(sessionContext, childIds, parentId);
    }


    public void commit(Xid xid, boolean onePhase) throws XAException {
        TransactionContext tx = txGlobal.get(xid);
        if (tx == null) {
            throw new XAException(XAException.XAER_NOTA);
        }
        try {
        	if (onePhase) {
        		tx.prepare();
        	}
        	tx.commit();
        } finally {
        	txGlobal.remove(xid);
        }
    }


    public void rollback(Xid xid) throws XAException {
        TransactionContext tx = txGlobal.get(xid);
        if (tx == null) {
            throw new XAException(XAException.XAER_NOTA);
        }
        try {
        	tx.rollback();
        } finally {
        	txGlobal.remove(xid);
        }
    }


    public Version checkin(final String absPath, final Calendar created)
            throws RepositoryException {
        return perform(new SessionWriteOperation<Version> () {
            public Version perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(
                        absPath,
                        CHECK_LOCK | CHECK_HOLD | CHECK_PENDING_CHANGES_ON_NODE,
                        Permission.VERSION_MNGMT);
                NodeId baseId = checkoutCheckin(state, true, false, created);
                return (Version) session.getNodeById(baseId);
            }
            public String toString() {
                return "versionManager.checkin(" + absPath + ", " + created + ")";
            }
        });
    }


    public Version checkpoint(final String absPath) throws RepositoryException {
        return perform(new SessionWriteOperation<Version> () {
            public Version perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(
                        absPath,
                        CHECK_LOCK | CHECK_HOLD | CHECK_PENDING_CHANGES_ON_NODE,
                        Permission.VERSION_MNGMT);
                NodeId baseId = checkoutCheckin(state, true, true, null);
                return (Version) session.getNodeById(baseId);
            }
            public String toString() {
                return "versionManager.checkpoint(" + absPath + ")";
            }
        });
    }


    public VersionHistory getVersionHistory(final String absPath)
            throws RepositoryException {
        return perform(new SessionOperation<VersionHistory> () {
            public VersionHistory perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(absPath);
                InternalVersionHistory vh = getVersionHistory(state);
                if (vh == null) {
                    throw new InconsistentVersioningState("Couldn't get version history for node " + state.getNodeId());
                }
                return (VersionHistory) session.getNodeById(vh.getId());
            }
            public String toString() {
                return "versionManager.getVersionHistory(" + absPath + ")";
            }
        });
    }


    public Version getBaseVersion(final String absPath)
            throws RepositoryException {
        return perform(new SessionOperation<Version> () {
            public Version perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(absPath);
                InternalVersion v = getBaseVersion(state);
                return (Version) session.getNodeById(v.getId());
            }
            public String toString() {
                return "versionManager.getBaseVersion(" + absPath + ")";
            }
        });
    }


    public void restore(
            final String absPath, final String versionName,
            final boolean removeExisting) throws RepositoryException {
        perform(new SessionWriteOperation<Object> () {
            public Object perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(
                        absPath,
                        CHECK_PENDING_CHANGES | CHECK_LOCK | CHECK_HOLD,
                        Permission.NONE);
                restore(state, context.getQName(versionName), removeExisting);
                return this;
            }
            public String toString() {
                return "versionManager.restore("
                    + absPath + ", " +  versionName + ", "
                    +  removeExisting + ")";
            }
        });
    }


    public void restoreByLabel(
            final String absPath, final String versionLabel,
            final boolean removeExisting) throws RepositoryException {
        perform(new SessionWriteOperation<Object> () {
            public Object perform(SessionContext context)
                    throws RepositoryException {
                NodeStateEx state = getNodeState(
                        absPath,
                        CHECK_PENDING_CHANGES | CHECK_LOCK | CHECK_HOLD,
                        Permission.NONE);
                restoreByLabel(
                        state, context.getQName(versionLabel), removeExisting);
                return this;
            }
            public String toString() {
                return "versionManager.restoreByLabel("
                    + absPath + ", " +  versionLabel + ", "
                    + removeExisting + ")";
            }
        });
    }


    protected synchronized ItemState getOrCreateTransientItemState()
            throws RepositoryException {

        synchronized (data) {
            if (!isTransient()) {
                // make transient (copy-on-write)
                try {
                    PropertyState transientState =
                            stateMgr.createTransientPropertyState(
                                    data.getPropertyState(), ItemState.STATUS_EXISTING_MODIFIED);
                    // swap persistent with transient state
                    data.setState(transientState);
                } catch (ItemStateException ise) {
                    String msg = "failed to create transient state";
                    log.debug(msg);
                    throw new RepositoryException(msg, ise);
                }
            }
            return getItemState();
        }
    }


    protected synchronized ItemState getOrCreateTransientItemState()
            throws RepositoryException {

        synchronized (data) {
            if (!isTransient()) {
                try {
                    // make transient (copy-on-write)
                    NodeState transientState =
                            stateMgr.createTransientNodeState(
                                    (NodeState) stateMgr.getItemState(getId()), ItemState.STATUS_EXISTING_MODIFIED);
                    // replace persistent with transient state
                    data.setState(transientState);
                } catch (ItemStateException ise) {
                    String msg = "failed to create transient state";
                    log.debug(msg);
                    throw new RepositoryException(msg, ise);
                }
            }
            return getItemState();
        }
    }


    protected void restoreTransient(PropertyState transientState)
            throws RepositoryException {
        PropertyState thisState = null;

        if (!isTransient()) {
            thisState = (PropertyState) getOrCreateTransientItemState();
            if (transientState.getStatus() == ItemState.STATUS_NEW
                    && thisState.getStatus() != ItemState.STATUS_NEW) {
                thisState.setStatus(ItemState.STATUS_NEW);
                stateMgr.disconnectTransientItemState(thisState);
            }
        } else {
            // JCR-2503: Re-create transient state in the state manager,
            // because it was removed
            synchronized (data) {
                try {
                    thisState = stateMgr.createTransientPropertyState(
                            transientState.getParentId(),
                            transientState.getName(),
                            PropertyState.STATUS_NEW);
                    data.setState(thisState);
                } catch (ItemStateException e) {
                    throw new RepositoryException(e);
                }
            }
        }

        // reapply transient changes
        thisState.setType(transientState.getType());
        thisState.setMultiValued(transientState.isMultiValued());
        thisState.setValues(transientState.getValues());
        thisState.setModCount(transientState.getModCount());
    }


    protected void restoreTransient(NodeState transientState)
            throws RepositoryException {
        NodeState thisState = null;

        if (!isTransient()) {
            thisState = (NodeState) getOrCreateTransientItemState();
            if (transientState.getStatus() == ItemState.STATUS_NEW
                    && thisState.getStatus() != ItemState.STATUS_NEW) {
                thisState.setStatus(ItemState.STATUS_NEW);
                stateMgr.disconnectTransientItemState(thisState);
            }
            thisState.setParentId(transientState.getParentId());
            thisState.setNodeTypeName(transientState.getNodeTypeName());
        } else {
            // JCR-2503: Re-create transient state in the state manager,
            // because it was removed
            synchronized (data) {
                thisState = stateMgr.createTransientNodeState(
                        (NodeId) transientState.getId(),
                        transientState.getNodeTypeName(),
                        transientState.getParentId(),
                        NodeState.STATUS_NEW);
                data.setState(thisState);
            }
        }

        // re-apply transient changes
        thisState.setMixinTypeNames(transientState.getMixinTypeNames());
        thisState.setChildNodeEntries(transientState.getChildNodeEntries());
        thisState.setPropertyNames(transientState.getPropertyNames());
        thisState.setSharedSet(transientState.getSharedSet());
        thisState.setModCount(transientState.getModCount());
    }


    public void setValue(Calendar value) throws RepositoryException {
        if (value != null) {
            try {
                setValue(getSession().getValueFactory().createValue(value));
            } catch (IllegalArgumentException e) {
                throw new ValueFormatException(
                        "Value is not an ISO8601 date: " + value, e);
            }
        } else {
            setValue((Value) null);
        }
    }


    public Property setProperty(String name, Calendar value)
            throws RepositoryException {
        if (value != null) {
            try {
                return setProperty(name, getValueFactory().createValue(value));
            } catch (IllegalArgumentException e) {
                throw new ValueFormatException(
                        "Value is not an ISO8601 date: " + value, e);
            }
        } else {
            return setProperty(name, (Value) null);
        }
    }


    public void setValue(Node value) throws RepositoryException {
        if (value != null) {
            try {
                setValue(getValueFactory().createValue(value));
            } catch (UnsupportedRepositoryOperationException e) {
                throw new ValueFormatException(
                        "Node is not referenceable: " + value, e);
            }
        } else {
            setValue((Value) null);
        }
    }


    public Property setProperty(String name, InputStream value)
            throws RepositoryException {
        if (value != null) {
            Binary binary = getValueFactory().createBinary(value);
            try {
                return setProperty(name, getValueFactory().createValue(binary));
            } finally {
                binary.dispose();
            }
        } else {
            return setProperty(name, (Value) null);
        }
    }


    public Property setProperty(String name, Node value)
            throws RepositoryException {
        if (value != null) {
            try {
                return setProperty(name, getValueFactory().createValue(value));
            } catch (UnsupportedRepositoryOperationException e) {
                throw new ValueFormatException(
                        "Node is not referenceable: " + value, e);
            }
        } else {
            return setProperty(name, (Value) null);
        }
    }


    public void setValue(InputStream value) throws RepositoryException {
        if (value != null) {
            Binary binary = getValueFactory().createBinary(value);
            try {
                setValue(getValueFactory().createValue(binary));
            } finally {
                binary.dispose();
            }
        } else {
            setValue((Value) null);
        }
    }


    public String getPath() throws RepositoryException {
        return perform(new SessionOperation<String>() {
            public String perform(SessionContext context)
                    throws RepositoryException {
                return context.getJCRPath(getPrimaryPath());
            }
            public String toString() {
                return "item.getPath()";
            }
        });
    }


    public boolean hasProperty(final Name name) throws RepositoryException {
        return perform(new SessionOperation<Boolean>() {
            public Boolean perform(SessionContext context)
                    throws RepositoryException {
                return data.getNodeState().hasPropertyName(name)
                    && context.getItemManager().itemExists(
                            new PropertyId(getNodeId(), name));
            }
            public String toString() {
                return "node.hasProperty(" + name + ")";
            }
        });
    }


    public QueryResult execute() throws RepositoryException {
        long time = System.nanoTime();
        final QueryResult result = sessionContext.getSessionState().perform(
                new SessionOperation<QueryResult>() {
                    public QueryResult perform(SessionContext context)
                            throws RepositoryException {
                        final QueryEngine engine = new QueryEngine(
                                sessionContext.getSessionImpl(), lqf, variables);
                        return engine.execute(getColumns(), getSource(),
                                getConstraint(), getOrderings(), offset, limit);
                    }

                    public String toString() {
                        return "query.execute(" + statement + ")";
                    }
                });
        time = System.nanoTime() - time;
        final long timeMs = time / 1000000;
        log.debug("executed in {} ms. ({})", timeMs, statement);
        RepositoryStatisticsImpl statistics = sessionContext
                .getRepositoryContext().getRepositoryStatistics();
        statistics.getCounter(Type.QUERY_COUNT).incrementAndGet();
        statistics.getCounter(Type.QUERY_DURATION).addAndGet(timeMs);
        sessionContext.getRepositoryContext().getStatManager().getQueryStat()
                .logQuery(language, statement, timeMs);
        return result;
    }


    public QueryResult execute() throws RepositoryException {
        checkInitialized();
        long time = System.nanoTime();
        QueryResult result = sessionContext.getSessionState().perform(
                new SessionOperation<QueryResult>() {
                    public QueryResult perform(SessionContext context)
                            throws RepositoryException {
                        return query.execute(offset, limit);
                    }

                    public String toString() {
                        return "query.execute(" + statement + ")";
                    }
                });
        time = System.nanoTime() - time;
        final long timeMs = time / 1000000;
        log.debug("executed in {} ms. ({})", timeMs, statement);
        RepositoryStatisticsImpl statistics = sessionContext
                .getRepositoryContext().getRepositoryStatistics();
        statistics.getCounter(Type.QUERY_COUNT).incrementAndGet();
        statistics.getCounter(Type.QUERY_DURATION).addAndGet(timeMs);
        sessionContext.getRepositoryContext().getStatManager().getQueryStat()
                .logQuery(language, statement, timeMs);
        return result;
    }


    public int nextDoc() throws IOException {
        if (nextDoc == NO_MORE_DOCS) {
            return nextDoc;
        }

        nextDoc = docFilter.nextSetBit(nextDoc + 1);
        if (nextDoc < 0) {
            nextDoc = NO_MORE_DOCS;
        }
        return nextDoc;
    }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateHits();
            nextDoc = hits.nextSetBit(nextDoc + 1);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateParent();
            nextDoc = hits.nextSetBit(nextDoc + 1);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateChildren();
            nextDoc = hits.nextSetBit(nextDoc + 1);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateHits();
            nextDoc = hits.nextSetBit(nextDoc + 1);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateChildren();
            nextDoc = hits.nextSetBit(nextDoc + 1);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int nextDoc() throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            calculateChildren();
            do {
                nextDoc = hits.next();
            } while (nextDoc > -1 && !indexIsValid(nextDoc));

            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


    private Properties getNamespaces(Node node) {
        Properties namespaces = new Properties();
        NamedNodeMap attributes = node.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            Attr attribute = (Attr) attributes.item(i);
            if (attribute.getName().startsWith("xmlns:")) {
                namespaces.setProperty(
                        attribute.getName().substring(6), attribute.getValue());
            }
        }
        return namespaces;
    }


    public Properties getNamespaces() {
        Properties namespaces = new Properties();
        NamedNodeMap attributes = current.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            Attr attribute = (Attr) attributes.item(i);
            if (attribute.getName().startsWith("xmlns:")) {
                namespaces.setProperty(
                        attribute.getName().substring(6), attribute.getValue());
            }
        }
        return namespaces;
    }


    private static String getTextContent(Node node) {
        StringBuffer content = new StringBuffer();
        NodeList nodes = node.getChildNodes();
        for (int i = 0; i < nodes.getLength(); i++) {
            Node n = nodes.item(i);
            if (n.getNodeType() == Node.TEXT_NODE) {
                content.append(((CharacterData) n).getData());
            }
        }
        return content.toString();
    }


    private static String getTextContent(Node node) {
        StringBuffer content = new StringBuffer();
        NodeList nodes = node.getChildNodes();
        for (int i = 0; i < nodes.getLength(); i++) {
            Node n = nodes.item(i);
            if (n.getNodeType() == Node.TEXT_NODE) {
                content.append(((CharacterData) n).getData());
            }
        }
        return content.toString();
    }


    public String getContent() {
        StringBuilder content = new StringBuilder();

        NodeList nodes = current.getChildNodes();
        for (int i = 0; i < nodes.getLength(); i++) {
            Node node = nodes.item(i);
            if (node.getNodeType() == Node.TEXT_NODE) {
                content.append(((CharacterData) node).getData());
            }
        }

        return content.toString();
    }


    public static Comparable getComparable(InternalValue value)
            throws RepositoryException {
        switch (value.getType()) {
        case PropertyType.BINARY:
            return null;
        case PropertyType.BOOLEAN:
            return value.getBoolean();
        case PropertyType.DATE:
            return value.getDate().getTimeInMillis();
        case PropertyType.DOUBLE:
            return value.getDouble();
        case PropertyType.LONG:
            return value.getLong();
        case PropertyType.DECIMAL:
            return value.getDecimal();
        case PropertyType.NAME:
            return value.getName().toString();
        case PropertyType.PATH:
            return value.getPath().toString();
        case PropertyType.URI:
        case PropertyType.WEAKREFERENCE:
        case PropertyType.REFERENCE:
        case PropertyType.STRING:
            return value.getString();
        default:
            return null;
        }
    }


    public static Comparable getComparable(Value value)
            throws ValueFormatException, RepositoryException {
        switch (value.getType()) {
        case PropertyType.BOOLEAN:
            return value.getBoolean();
        case PropertyType.DATE:
            return value.getDate().getTimeInMillis();
        case PropertyType.DOUBLE:
            return value.getDouble();
        case PropertyType.LONG:
            return value.getLong();
        case PropertyType.DECIMAL:
            return value.getDecimal();
        case PropertyType.NAME:
        case PropertyType.PATH:
        case PropertyType.URI:
        case PropertyType.WEAKREFERENCE:
        case PropertyType.REFERENCE:
        case PropertyType.STRING:
            return value.getString();
        default:
            throw new RepositoryException("Unsupported type: "
                    + PropertyType.nameFromValue(value.getType()));
        }
    }


    public static int compare(Comparable<?>[] c1, Comparable<?>[] c2) {
        if(c1 == null && c2 == null){
            return 0;
        }
        if (c1 == null) {
            return -1;
        }
        if (c2 == null) {
            return 1;
        }
        for (int i = 0; i < c1.length && i < c2.length; i++) {
            int d = compare(c1[i], c2[i]);
            if (d != 0) {
                return d;
            }
        }
        return c1.length - c2.length;
    }


    public static int compare(Value[] a, Value[] b) throws RepositoryException {
        if(a == null && b == null){
            return 0;
        }
        if (a == null) {
            return -1;
        }
        if (b == null) {
            return 1;
        }
        for (int i = 0; i < a.length && i < b.length; i++) {
            int d = compare(a[i], b[i]);
            if (d != 0) {
                return d;
            }
        }
        return a.length - b.length;
    }


    public String[] retrieveInterestingTerms(int docNum) throws IOException {
        List<String> al = new ArrayList<String>(maxQueryTerms);
        PriorityQueue pq = retrieveTerms(docNum);
        Object cur;
        int lim = maxQueryTerms; // have to be careful, retrieveTerms returns all words but that's probably not useful to our caller...
        // we just want to return the top words
        while (((cur = pq.pop()) != null) && lim-- > 0) {
            Object[] ar = (Object[]) cur;
            al.add((String) ar[0]); // the 1st entry is the interesting word
        }
        return al.toArray(new String[al.size()]);
    }


    public String[] retrieveInterestingTerms(Reader r) throws IOException {
        List<String> al = new ArrayList<String>(maxQueryTerms);
        PriorityQueue pq = retrieveTerms(r);
        Object cur;
        int lim = maxQueryTerms; // have to be careful, retrieveTerms returns all words but that's probably not useful to our caller...
        // we just want to return the top words
        while (((cur = pq.pop()) != null) && lim-- > 0) {
            Object[] ar = (Object[]) cur;
            al.add((String) ar[0]); // the 1st entry is the interesting word
        }
        return al.toArray(new String[al.size()]);
    }


    private boolean isExcluded(NodeId id) {
        try {
            final HierarchyManager hierarchyManager = handler.getContext().getHierarchyManager();
            final Path path = hierarchyManager.getPath(id);
            for (Path excludedPath : excludedPaths) {
                if (excludedPath.isEquivalentTo(path) || excludedPath.isAncestorOf(path)) {
                    return true;
                }
            }
        } catch (RepositoryException ignored) {
        }
        return false;
    }


    private boolean isIgnored(NodeId id) {
        try {
            final HierarchyManager hierarchyManager = handler.getContext().getHierarchyManager();
            final Path path = hierarchyManager.getPath(id);
            for (Path excludedPath : ignoredPaths) {
                if (excludedPath.isEquivalentTo(path) || excludedPath.isAncestorOf(path)) {
                    return true;
                }
            }
        } catch (RepositoryException ignored) {
        }
        return false;
    }


        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
                throws RepositoryException, IOException {
            final List<Document> documents = handler.getNodeDocuments(id);
            for (Document document : documents) {
                final String parent = document.get(FieldNames.PARENT);
                if (parent != null && !parent.isEmpty()) {
                    final NodeId parentId = new NodeId(parent);
                    if (handler.getNodeDocuments(parentId).isEmpty()) {
                        return true;
                    }
                }
            }
            return false;

        }


        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
                throws IOException, RepositoryException {
            final List<Document> documents = handler.getNodeDocuments(id);
            for (Document document : documents) {
                final String parent = document.get(FieldNames.PARENT);
                if (parent != null && !parent.isEmpty()) {
                    final NodeId parentId = new NodeId(parent);
                    if (parentId.equals(this.parentId) && !stateManager.hasItemState(parentId)) {
                        return true;
                    }
                }
            }
            return false;
        }


        boolean doubleCheck(final SearchIndex handler, final ItemStateManager stateManager)
                throws RepositoryException, IOException {
            final List<Document> documents = handler.getNodeDocuments(id);
            for (Document document : documents) {
                final String parent = document.get(FieldNames.PARENT);
                if (parent != null && !parent.isEmpty()) {
                    final NodeId parentId = new NodeId(parent);
                    if (parentId.equals(indexedParentId) && !stateManager.hasItemState(parentId)) {
                        return true;
                    }
                }
            }
            return false;
        }


        void repair() throws Exception {
            index.removeAllDocuments(id);
            try {
                NodeState node = (NodeState) stateMgr.getItemState(id);
                log.info("Re-indexing node with wrong parent in index: " + getPath(node));
                Document d = index.createDocument(node);
                index.addDocument(d);
                nodeIds.put(node.getNodeId(), Boolean.TRUE);
            } catch (NoSuchItemStateException e) {
                log.info("Not re-indexing node with wrong parent because node no longer exists");
            }
        }


        public void repair() throws Exception {
            // first remove all occurrences
            index.removeAllDocuments(id);
            // then re-index the node
            try {
                NodeState node = (NodeState) stateMgr.getItemState(id);
                log.info("Re-indexing duplicate node occurrences in index: " + getPath(node));
                Document d = index.createDocument(node);
                index.addDocument(d);
                nodeIds.put(node.getNodeId(), Boolean.TRUE);
            } catch (NoSuchItemStateException e) {
                log.info("Not re-indexing node with multiple occurrences because node no longer exists");
            }
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }
            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }
            calculateParent();
            nextDoc = hits.nextSetBit(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }
            
            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                hits.skipTo(target);
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }

            calculateChildren();
            nextDoc = hits.skipTo(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }

            while (nextDoc != NO_MORE_DOCS && !indexIsValid(nextDoc)) {
                nextDoc();
            }
            return nextDoc;
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }
            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }

            calculateHits();
            nextDoc = hits.nextSetBit(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }

            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }

            calculateChildren();
            nextDoc = hits.nextSetBit(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }
            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }

            calculateHits();
            nextDoc = hits.nextSetBit(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


        public int advance(int target) throws IOException {
            if (nextDoc == NO_MORE_DOCS) {
                return nextDoc;
            }
            // optimize in the case of an advance to finish.
            // see https://issues.apache.org/jira/browse/JCR-3091
            if (target == NO_MORE_DOCS) {
                nextDoc = NO_MORE_DOCS;
                return nextDoc;
            }

            calculateChildren();
            nextDoc = hits.nextSetBit(target);
            if (nextDoc < 0) {
                nextDoc = NO_MORE_DOCS;
            }
            return nextDoc;
        }


    public MultiColumnQueryHits executeQuery(SessionImpl session,
                                             AbstractQueryImpl queryImpl,
                                             Query query,
                                             Path[] orderProps,
                                             boolean[] orderSpecs,
                                             String[] orderFuncs, long resultFetchHint)
            throws IOException {
        checkOpen();

        Sort sort = new Sort(createSortFields(orderProps, orderSpecs, orderFuncs));

        final IndexReader reader = getIndexReader(queryImpl.needsSystemTree());
        JackrabbitIndexSearcher searcher = new JackrabbitIndexSearcher(
                session, reader, getContext().getItemStateManager());
        searcher.setSimilarity(getSimilarity());
        return new FilterMultiColumnQueryHits(
                searcher.execute(query, sort, resultFetchHint,
                        QueryImpl.DEFAULT_SELECTOR_NAME)) {
            public void close() throws IOException {
                try {
                    super.close();
                } finally {
                    Util.closeOrRelease(reader);
                }
            }
        };
    }


    public MultiColumnQueryHits executeQuery(SessionImpl session,
                                             MultiColumnQuery query,
                                             Ordering[] orderings,
                                             long resultFetchHint)
            throws IOException {
        checkOpen();

        final IndexReader reader = getIndexReader();
        JackrabbitIndexSearcher searcher = new JackrabbitIndexSearcher(
                session, reader, getContext().getItemStateManager());
        searcher.setSimilarity(getSimilarity());
        return new FilterMultiColumnQueryHits(
                query.execute(searcher, orderings, resultFetchHint)) {
            public void close() throws IOException {
                try {
                    super.close();
                } finally {
                    Util.closeOrRelease(reader);
                }
            }
        };
    }


    protected SynonymProvider createSynonymProvider() {
        SynonymProvider sp = null;
        if (synonymProviderClass != null) {
            try {
                sp = (SynonymProvider) synonymProviderClass.newInstance();
                sp.initialize(createSynonymProviderConfigResource());
            } catch (Exception e) {
                log.warn("Exception initializing synonym provider: "
                        + synonymProviderClass, e);
                sp = null;
            }
        }
        return sp;
    }


    protected SpellChecker createSpellChecker() {
        SpellChecker spCheck = null;
        if (spellCheckerClass != null) {
            try {
                spCheck = (SpellChecker) spellCheckerClass.newInstance();
                spCheck.init(this);
            } catch (Exception e) {
                log.warn("Exception initializing spell checker: "
                        + spellCheckerClass, e);
            }
        }
        return spCheck;
    }


    public void setExcerptProviderClass(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            if (ExcerptProvider.class.isAssignableFrom(clazz)) {
                excerptProviderClass = clazz;
            } else {
                log.warn("Invalid value for excerptProviderClass, {} does "
                        + "not implement ExcerptProvider interface.", className);
            }
        } catch (ClassNotFoundException e) {
            log.warn("Invalid value for excerptProviderClass, class {} not found.",
                    className);
        }
    }


    public void setSpellCheckerClass(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            if (SpellChecker.class.isAssignableFrom(clazz)) {
                spellCheckerClass = clazz;
            } else {
                log.warn("Invalid value for spellCheckerClass, {} "
                        + "does not implement SpellChecker interface.",
                        className);
            }
        } catch (ClassNotFoundException e) {
            log.warn("Invalid value for spellCheckerClass,"
                    + " class {} not found.", className);
        }
    }


    public void setIndexingConfigurationClass(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            if (IndexingConfiguration.class.isAssignableFrom(clazz)) {
                indexingConfigurationClass = clazz;
            } else {
                log.warn("Invalid value for indexingConfigurationClass, {} "
                        + "does not implement IndexingConfiguration interface.",
                        className);
            }
        } catch (ClassNotFoundException e) {
            log.warn("Invalid value for indexingConfigurationClass, class {} not found.",
                    className);
        }
    }


    public void setSynonymProviderClass(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            if (SynonymProvider.class.isAssignableFrom(clazz)) {
                synonymProviderClass = clazz;
            } else {
                log.warn("Invalid value for synonymProviderClass, {} "
                        + "does not implement SynonymProvider interface.",
                        className);
            }
        } catch (ClassNotFoundException e) {
            log.warn("Invalid value for synonymProviderClass, class {} not found.",
                    className);
        }
    }


    public Object visit(DerefQueryNode node, Object data) throws RepositoryException {
        Query context = (Query) data;
        if (context == null) {
            exceptions.add(new IllegalArgumentException("Unsupported query"));
        }

        try {
            String refProperty = resolver.getJCRName(node.getRefProperty());

            if (node.getIncludeDescendants()) {
                Query refPropQuery = Util.createMatchAllQuery(refProperty, indexFormatVersion, cache);
                context = new DescendantSelfAxisQuery(context, refPropQuery, false);
            }

            context = new DerefQuery(context, refProperty, node.getNameTest(),
                    indexFormatVersion, nsMappings);

            // attach predicates
            Object[] predicates = node.acceptOperands(this, data);
            if (predicates.length > 0) {
                BooleanQuery andQuery = new BooleanQuery();
                for (Object predicate : predicates) {
                    andQuery.add((Query) predicate, Occur.MUST);
                }
                andQuery.add(context, Occur.MUST);
                context = andQuery;
            }

        } catch (NamespaceException e) {
            // should never happen
            exceptions.add(e);
        }

        return context;
    }


    public Query createPredicateDeref(Query subQuery, DerefQueryNode node, Object data) throws RepositoryException {
        Query context = (Query) data;
        
        if (context == null) {
            exceptions.add(new IllegalArgumentException("Unsupported query"));
        }

        try {
            String refProperty = resolver.getJCRName(node.getRefProperty());

            context = new PredicateDerefQuery(subQuery, refProperty, node.getNameTest(),
                    indexFormatVersion, nsMappings);

            // attach predicates
            Object[] predicates = node.acceptOperands(this, data);
            if (predicates.length > 0) {
                BooleanQuery andQuery = new BooleanQuery();
                for (Object predicate : predicates) {
                    andQuery.add((Query) predicate, Occur.MUST);
                }
                andQuery.add(context, Occur.MUST);
                context = andQuery;
            }
            
        } catch (NamespaceException e) {
            // should never happen
            exceptions.add(e);
        }

        return context;
    }


    public static String longToString(long value) {
        StringBuffer sb = new StringBuffer(STRING_LONG_LEN);
        if (value < 0) {
            // shift value
            value += Long.MAX_VALUE;
            value++;
            // after shift
            // Long.MIN_VALUE -> 0
            // 1 -> Long.MAX_VALUE

            // convert into string
            String s = Long.toString(value, Character.MAX_RADIX);
            // pad with leading zeros
            while ((sb.length() + s.length()) < STRING_LONG_LEN) {
                sb.append('0');
            }
            sb.append(s);
        } else {
            // convert into string
            String s = Long.toString(value, Character.MAX_RADIX);
            // mark as positive
            sb.append('1');
            // fill in zeros if needed
            while ((sb.length() + s.length()) < STRING_LONG_LEN) {
                sb.append('0');
            }
            sb.append(s);
        }
        return sb.toString();
    }


    public static String doubleToString(double value) {
        long longValue = Double.doubleToLongBits(value);
        StringBuffer sb = new StringBuffer(STRING_DOUBLE_LEN);

        if ((longValue & SIGN_MASK) == 0) {
            // positive
            String s = Long.toString(longValue, Character.MAX_RADIX);
            // add sign character
            sb.append('1');
            while ((sb.length() + s.length()) < STRING_DOUBLE_LEN) {
                sb.append('0');
            }
            sb.append(s);
        } else {
            // negative
            // fold value by reversing sign
            longValue = -longValue;
            String s = Long.toString(longValue, Character.MAX_RADIX);
            // pad with leading zeros
            while ((sb.length() + s.length()) < STRING_DOUBLE_LEN) {
                sb.append('0');
            }
            sb.append(s);
        }
        return sb.toString();
    }


    public String toString(String field) {
        StringBuffer sb = new StringBuffer();
        sb.append("DescendantSelfAxisQuery(");
        sb.append(contextQuery);
        sb.append(", ");
        sb.append(subQuery);
        sb.append(", ");
        sb.append(minLevels);
        sb.append(")");
        return sb.toString();
    }


    public String toString(String field) {
        StringBuffer sb = new StringBuffer();
        sb.append("ChildAxisQuery(");
        sb.append(contextQuery);
        sb.append(", ");
        sb.append(nameTest);
        if (position != LocationStepQueryNode.NONE) {
            sb.append(", ");
            sb.append(position);
        }
        sb.append(")");
        return sb.toString();
    }


    public String toString(String field) {
        StringBuffer sb = new StringBuffer();
        sb.append("PredicateDerefQuery(");
        sb.append(subQuery);
        sb.append(", ");
        sb.append(nameTest);
        sb.append(", ");
        sb.append(refProperty);
        sb.append(")");
        return sb.toString();
    }


    public String toString(String field) {
        StringBuffer sb = new StringBuffer();
        sb.append("DerefQuery(");
        sb.append(refProperty);
        sb.append(", ");
        sb.append(contextQuery);
        sb.append(", ");
        sb.append(nameTest);
        sb.append(")");
        return sb.toString();
    }


                public ScoreNode nextScoreNode() throws IOException {
                    while (currentTraversal != null) {
                        ScoreNode sn = currentTraversal.nextScoreNode();
                        if (sn != null) {
                            return sn;
                        } else {
                            fetchNextTraversal();
                        }
                    }
                    // if we get here there are no more score nodes
                    return null;
                }


    public ScoreNode nextScoreNode() throws IOException {
        while (childHits != null) {
            ScoreNode sn = childHits.nextScoreNode();
            if (sn != null) {
                return sn;
            } else {
                fetchNextChildHits();
            }
        }
        // if we get here there are no more score nodes
        return null;
    }


    private Map<String, NodeType> getSelectorNames(Source source)
            throws RepositoryException {
        if (source instanceof Selector) {
            Selector selector = (Selector) source;
            return Collections.singletonMap(selector.getSelectorName(),
                    getNodeType(selector));
        } else if (source instanceof Join) {
            Join join = (Join) source;
            Map<String, NodeType> map = new LinkedHashMap<String, NodeType>();
            map.putAll(getSelectorNames(join.getLeft()));
            map.putAll(getSelectorNames(join.getRight()));
            return map;
        } else {
            throw new UnsupportedRepositoryOperationException(
                    "Unknown source type: " + source);
        }
    }


    private Set<String> getSelectorNames(Source source)
            throws RepositoryException {
        if (source instanceof Selector) {
            Selector selector = (Selector) source;
            return Collections.singleton(selector.getSelectorName());
        } else if (source instanceof Join) {
            Join join = (Join) source;
            Set<String> set = new LinkedHashSet<String>();
            set.addAll(getSelectorNames(join.getLeft()));
            set.addAll(getSelectorNames(join.getRight()));
            return set;
        } else {
            throw new UnsupportedRepositoryOperationException(
                    "Unknown source type: " + source);
        }
    }


    public List<Constraint> getRightJoinConstraints(Collection<Row> leftRows)
            throws RepositoryException {
        Set<String> paths = new HashSet<String>();
        for (Row row : leftRows) {
            paths.addAll(getLeftValues(row));
        }

        List<Constraint> constraints = new ArrayList<Constraint>();
        for (String path : paths) {
            if (rightSelectors.contains(descendantSelector)) {
                constraints.add(
                        factory.descendantNode(descendantSelector, path));
            } else {
                constraints.add(factory.sameNode(ancestorSelector, path));
            }
        }
        return constraints;
    }


    public List<Constraint> getRightJoinConstraints(Collection<Row> leftRows)
            throws RepositoryException {
        Set<String> paths = new HashSet<String>();
        for (Row row : leftRows) {
            paths.addAll(getLeftValues(row));
        }

        List<Constraint> constraints = new ArrayList<Constraint>();
        for (String path : paths) {
            if (rightSelectors.contains(selector1)) {
                constraints.add(factory.sameNode(selector1, path));
            } else {
                constraints.add(factory.sameNode(selector2, path));
            }
        }
        return constraints;
    }


    public List<Constraint> getRightJoinConstraints(Collection<Row> leftRows)
            throws RepositoryException {
        Set<String> paths = new HashSet<String>();
        for (Row row : leftRows) {
            paths.addAll(getLeftValues(row));
        }

        List<Constraint> constraints = new ArrayList<Constraint>();
        for (String path: paths) {
            if (rightSelectors.contains(childSelector)) {
                constraints.add(factory.childNode(childSelector, path));
            } else {
                constraints.add(factory.sameNode(parentSelector, path));
            }
        }
        return constraints;
    }


    public static Constraint and(
            QueryObjectModelFactory factory, List<Constraint> constraints)
            throws RepositoryException {
        int n = constraints.size();
        if (n == 0) {
            return null;
        } else if (n == 1) {
            return constraints.get(0);
        } else {
            int m = n / 2;
            return factory.and(
                    and(factory, constraints.subList(0, m)),
                    and(factory, constraints.subList(m, n)));
        }
    }


    public static Constraint or(
            QueryObjectModelFactory factory, List<Constraint> constraints)
            throws RepositoryException {
        int n = constraints.size();
        if (n == 0) {
            return null;
        } else if (n == 1) {
            return constraints.get(0);
        } else {
            int m = n / 2;
            return factory.or(
                    or(factory, constraints.subList(0, m)),
                    or(factory, constraints.subList(m, n)));
        }
    }


                public Object visit(DescendantNodeJoinConditionImpl node, Object data)
                        throws Exception {
                    MultiColumnQueryHits ancestor = getSourceWithName(node.getAncestorSelectorQName(), left, right);
                    MultiColumnQueryHits descendant = getSourceWithName(node.getDescendantSelectorQName(), left, right);
                    Condition c;
                    if (isInner
                            || descendant == left && JoinType.LEFT == joinType
                            || descendant == right && JoinType.RIGHT == joinType) {
                        // also applies to inner join
                        // assumption: DescendantNodeJoin is more
                        // efficient than AncestorNodeJoin, TODO: verify
                        outer = descendant;
                        outerIdx = getIndex(outer, node.getDescendantSelectorQName());
                        c = new DescendantNodeJoin(ancestor, node.getAncestorSelectorQName(), reader, resolver);
                    } else {
                        // left == ancestor
                        outer = ancestor;
                        outerIdx = getIndex(outer, node.getAncestorSelectorQName());
                        c = new AncestorNodeJoin(descendant, node.getDescendantSelectorQName(), reader, resolver);
                    }
                    return new Join(outer, outerIdx, isInner, c);
                }


                public Object visit(ChildNodeJoinConditionImpl node, Object data)
                        throws Exception {
                    MultiColumnQueryHits child = getSourceWithName(node.getChildSelectorQName(), left, right);
                    MultiColumnQueryHits parent = getSourceWithName(node.getParentSelectorQName(), left, right);
                    Condition c;
                    if (child == left && JoinType.LEFT == joinType
                            || child == right && JoinType.RIGHT == joinType) {
                        outer = child;
                        outerIdx = getIndex(outer, node.getChildSelectorQName());
                        c = new ChildNodeJoin(parent, reader, resolver, node);
                    } else {
                        // also applies to inner joins
                        // assumption: ParentNodeJoin is more efficient than
                        // ChildNodeJoin, TODO: verify
                        outer = parent;
                        outerIdx = getIndex(outer, node.getParentSelectorQName());
                        c = new ParentNodeJoin(child, reader, resolver, node);
                    }
                    return new Join(outer, outerIdx, isInner, c);
                }


    public AncestorNodeJoin(MultiColumnQueryHits context,
                            Name contextSelectorName,
                            IndexReader reader,
                            HierarchyResolver resolver) throws IOException {
        super(context);
        this.reader = reader;
        this.resolver = resolver;
        int idx = getIndex(context, contextSelectorName);
        ScoreNode[] nodes;
        while ((nodes = context.nextScoreNodes()) != null) {
            Integer docNum = nodes[idx].getDoc(reader);
            ancestors.clear();
            collectAncestors(docNum);
            for (Integer doc : ancestors) {
                contextIndex.addScoreNodes(doc, nodes);
            }
        }
    }


    public AncestorPathNodeJoin(MultiColumnQueryHits context,
                                Name contextSelectorName,
                                Path relPath,
                                HierarchyManager hmgr) throws IOException {
        super(context);
        this.hmgr = hmgr;
        this.relPath = relPath;
        int idx = getIndex(context, contextSelectorName);
        ScoreNode[] nodes;
        while ((nodes = context.nextScoreNodes()) != null) {
            try {
                Path p = hmgr.getPath(nodes[idx].getNodeId());
                contextIndex.addScoreNodes(p, nodes);
            } catch (RepositoryException e) {
                // ignore
            }
        }
    }


    public DescendantNodeJoin(MultiColumnQueryHits context,
                              Name contextSelectorName,
                              IndexReader reader,
                              HierarchyResolver resolver) throws IOException {
        super(context);
        this.reader = reader;
        this.resolver = resolver;
        int idx = getIndex(context, contextSelectorName);
        ScoreNode[] nodes;
        while ((nodes = context.nextScoreNodes()) != null) {
            Integer docNum = nodes[idx].getDoc(reader);
            contextIndex.addScoreNodes(docNum, nodes);
        }
    }


    public DescendantPathNodeJoin(MultiColumnQueryHits context,
                                  Name contextSelectorName,
                                  Path relPath,
                                  HierarchyManager hmgr) throws IOException {
        super(context);
        this.hmgr = hmgr;
        int idx = getIndex(context, contextSelectorName);
        ScoreNode[] nodes;
        while ((nodes = context.nextScoreNodes()) != null) {
            try {
                Path p = hmgr.getPath(nodes[idx].getNodeId());
                PathBuilder builder = new PathBuilder(p);
                builder.addAll(relPath.getElements());
                p = builder.getPath().getNormalizedPath();
                contextIndex.addScoreNodes(p, nodes);
            } catch (RepositoryException e) {
                // ignore
            }
        }
    }


    public ChildNodeJoin(MultiColumnQueryHits parent,
                         IndexReader reader,
                         HierarchyResolver resolver,
                         ChildNodeJoinConditionImpl condition)
            throws IOException {
        super(parent);
        this.reader = reader;
        this.resolver = resolver;
        int idx = getIndex(parent, condition.getParentSelectorQName());
        ScoreNode[] nodes;
        while ((nodes = parent.nextScoreNodes()) != null) {
            Integer docNum = nodes[idx].getDoc(reader);
            parentIndex.addScoreNodes(docNum, nodes);
        }
    }


    private void collectAncestors(int doc) throws IOException {
        docNums = resolver.getParents(doc, docNums);
        if (docNums.length == 1) {
            ancestors.add(docNums[0]);
            collectAncestors(docNums[0]);
        } else if (docNums.length > 1) {
            // clone because recursion uses docNums again
            for (int docNum : docNums.clone()) {
                ancestors.add(docNum);
                collectAncestors(docNum);
            }
        }
    }


    private void collectAncestors(int doc) throws IOException {
        docNums = resolver.getParents(doc, docNums);
        if (docNums.length == 1) {
            ancestors.add(docNums[0]);
            collectAncestors(docNums[0]);
        } else if (docNums.length > 1) {
            // clone because recursion uses docNums again
            for (int docNum : docNums.clone()) {
                ancestors.add(docNum);
                collectAncestors(docNum);
            }
        }
    }


    public ScoreNode[][] getMatchingScoreNodes(ScoreNode descendant)
            throws IOException {
        ancestors.clear();
        collectAncestors(descendant.getDoc(reader));
        scoreNodes.clear();
        for (Integer ancestor : ancestors) {
            ScoreNode[][] sn = contextIndex.getScoreNodes(ancestor);
            if (sn != null) {
                for (ScoreNode[] aSn : sn) {
                    scoreNodes.add(aSn);
                }
            }
        }
        if (scoreNodes.isEmpty()) {
            return null;
        } else {
            return scoreNodes.toArray(new ScoreNode[scoreNodes.size()][]);
        }
    }


    public ScoreNode[][] getMatchingScoreNodes(ScoreNode child) throws IOException {
        docNums = resolver.getParents(child.getDoc(reader), docNums);
        tmpScoreNodes.clear();
        for (int docNum : docNums) {
            ScoreNode[][] sn = parentIndex.getScoreNodes(docNum);
            if (sn != null) {
                for (ScoreNode[] aSn : sn) {
                    tmpScoreNodes.add(aSn);
                }
            }
        }
        if (tmpScoreNodes.isEmpty()) {
            return null;
        } else {
            return tmpScoreNodes.toArray(new ScoreNode[tmpScoreNodes.size()][]);
        }
    }


    private Term getLowerTerm() throws IOException {
        try {
            String text;
            if (lowerName == null) {
                text = nsMappings.getPrefix(upperName.getNamespaceURI()) + ":";
            } else {
                text = nsMappings.translateName(lowerName);
            }
            return new Term(FieldNames.LABEL, text);
        } catch (RepositoryException e) {
            throw Util.createIOException(e);
        }
    }


    private Term getUpperTerm() throws IOException {
        try {
            String text;
            if (upperName == null) {
                text = nsMappings.getPrefix(lowerName.getNamespaceURI()) + ":\uFFFF";
            } else {
                text = nsMappings.translateName(upperName);
            }
            return new Term(FieldNames.LABEL, text);
        } catch (RepositoryException e) {
            throw Util.createIOException(e);
        }
    }


    private int scorerIndex(int n) {
        int lo = 0;                                      // search starts array
        int hi = scorers.length - 1;                  // for first element less

        while (hi >= lo) {
            int mid = (lo + hi) >> 1;
            int midValue = starts[mid];
            if (n < midValue) {
                hi = mid - 1;
            } else if (n > midValue) {
                lo = mid + 1;
            } else {                                      // found a match
                while (mid + 1 < scorers.length && starts[mid + 1] == midValue) {
                    mid++;                                  // scan to last match
                }
                return mid;
            }
        }
        return hi;
    }


    protected final int readerIndex(int n) {
        int lo = 0;
        int hi = readers.size() - 1;

        while (hi >= lo) {
            int mid = (lo + hi) >> 1;
            int midValue = starts[mid];
            if (n < midValue) {
                hi = mid - 1;
            }
            else if (n > midValue) {
                lo = mid + 1;
            }
            else {
                while (mid + 1 < readers.size() && starts[mid + 1] == midValue) {
                    mid++;
                }
                return mid;
            }
        }
        return hi;
    }


    public final PropertyState getPropertyState(ScoreNode sn,
                                                EvaluationContext context)
            throws RepositoryException {
        ItemStateManager ism = context.getItemStateManager();
        PropertyId propId = new PropertyId(sn.getNodeId(), operand.getPropertyQName());
        try {
            return (PropertyState) ism.getItemState(propId);
        } catch (NoSuchItemStateException e) {
            return null;
        } catch (ItemStateException e) {
            throw new RepositoryException(e);
        }
    }


    public final Property getProperty(ScoreNode sn,
                                      EvaluationContext context)
            throws RepositoryException {
        SessionImpl session = context.getSession();
        try {
            Node n = session.getNodeById(sn.getNodeId());
            return n.getProperty(operand.getPropertyName());
        } catch (ItemNotFoundException e) {
            // access denied to score node
            return null;
        } catch (PathNotFoundException e) {
            // property not found
            return null;
        }
    }


    public FieldComparator newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {
        FieldComparator comparator = base.newComparator(fieldname, numHits, sortPos, reversed);
        assert comparator instanceof FieldComparatorBase;

        return new FieldComparatorDecorator((FieldComparatorBase) comparator) {
            @Override
            protected Comparable sortValue(int doc) {
                Comparable c = super.sortValue(doc);
                return c == null ? null : c.toString().toUpperCase();
            }
        };
    }


    public FieldComparator newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {
        FieldComparator comparator = base.newComparator(fieldname, numHits, sortPos, reversed);
        assert comparator instanceof FieldComparatorBase;

        return new FieldComparatorDecorator((FieldComparatorBase) comparator) {
            @Override
            protected Comparable sortValue(int doc) {
                Comparable c = super.sortValue(doc);
                return c == null ? null : c.toString().toLowerCase();
            }
        };
    }


    public void stateCreated(ItemState created) {
        ItemStateListener[] la;
        synchronized (listeners) {
            la = listeners.toArray(new ItemStateListener[listeners.size()]);
        }
        for (int i = 0; i < la.length; i++) {
            if (la[i] != null) {
                la[i].stateCreated(created);
            }
        }
    }


    public void stateModified(ItemState modified) {
        ItemStateListener[] la;
        synchronized (listeners) {
            la = listeners.toArray(new ItemStateListener[listeners.size()]);
        }
        for (int i = 0; i < la.length; i++) {
            if (la[i] != null) {
                la[i].stateModified(modified);
            }
        }
    }


    public void stateDestroyed(ItemState destroyed) {
        if (destroyed.isNode() && destroyed.getId().equals(rootNodeId)) {
            try {
                root = createRootNodeState();
            } catch (RepositoryException e) {
                // ignore
            }
        }
        evict((NodeId) destroyed.getId());

        ItemStateListener[] la;
        synchronized (listeners) {
            la = listeners.toArray(new ItemStateListener[listeners.size()]);
        }
        for (int i = 0; i < la.length; i++) {
            if (la[i] != null) {
                la[i].stateDestroyed(destroyed);
            }
        }
    }


    public void stateDiscarded(ItemState discarded) {
        if (discarded.isNode() && discarded.getId().equals(rootNodeId)) {
            try {
                root = createRootNodeState();
            } catch (RepositoryException e) {
                // ignore
            }
        }
        evict((NodeId) discarded.getId());

        ItemStateListener[] la;
        synchronized (listeners) {
            la = listeners.toArray(new ItemStateListener[listeners.size()]);
        }
        for (int i = 0; i < la.length; i++) {
            if (la[i] != null) {
                la[i].stateDiscarded(discarded);
            }
        }
    }


    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
        UserManagerConfig umc = getConfig().getUserManagerConfig();
        UserManagerImpl umgr;
        // in contrast to the DefaultSecurityManager users are not retrieved
        // from a dedicated workspace: the system session of each workspace must
        // get a system user manager that asserts the existence of the admin user.
        if (umc != null) {
            Class<?>[] paramTypes = new Class[] {
                    SessionImpl.class,
                    String.class,
                    Properties.class,
                    MembershipCache.class};
            umgr = (UserPerWorkspaceUserManager) umc.getUserManager(UserPerWorkspaceUserManager.class,
                    paramTypes, session, adminId, umc.getParameters(), getMembershipCache(session));
        } else {
            umgr = new UserPerWorkspaceUserManager(session, adminId, null, getMembershipCache(session));
        }

        if (umc != null && !(session instanceof SystemSession)) {
            AuthorizableAction[] actions = umc.getAuthorizableActions();
            umgr.setAuthorizableActions(actions);
        }
        return umgr;
    }


    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
        UserManagerConfig umc = getConfig().getUserManagerConfig();
        UserManagerImpl um;
        if (umc != null) {
            Class<?>[] paramTypes = new Class[] {
                    SessionImpl.class,
                    String.class,
                    Properties.class,
                    MembershipCache.class};
            um = (UserManagerImpl) umc.getUserManager(UserManagerImpl.class,
                    paramTypes, session, adminId, umc.getParameters(), getMembershipCache(session));
        } else {
            um = new UserManagerImpl(session, adminId, null, getMembershipCache(session));
        }

        if (umc != null && !(session instanceof SystemSession)) {
            AuthorizableAction[] actions = umc.getAuthorizableActions();
            um.setAuthorizableActions(actions);
        }
        return um;
    }


    public void nodeAdded(NodeState state, Name name, int index, NodeId id) {
        synchronized (cacheMonitor) {
            if (idCache.containsKey(state.getNodeId())) {
                // Optimization: ignore notifications for nodes that are not in the cache
                try {
                    Path path = PathFactoryImpl.getInstance().create(getPath(state.getNodeId()), name, index, true);
                    nodeAdded(state, path, id);
                    checkConsistency();
                } catch (PathNotFoundException e) {
                    log.warn("Unable to get path of node " + state.getNodeId()
                            + ", event ignored.");
                } catch (MalformedPathException e) {
                    log.warn("Unable to create path of " + id, e);
                } catch (ItemNotFoundException e) {
                    log.warn("Unable to find item " + state.getNodeId(), e);
                } catch (ItemStateException e) {
                    log.warn("Unable to find item " + id, e);
                } catch (RepositoryException e) {
                    log.warn("Unable to get path of " + state.getNodeId(), e);
                }
            } else if (state.getParentId() == null && idCache.containsKey(id)) {
                // A top level node was added
                evictAll(id, true);
            }
        }
    }


    public void nodeRemoved(NodeState state, Name name, int index, NodeId id) {
        synchronized (cacheMonitor) {
            if (idCache.containsKey(state.getNodeId())) {
                // Optimization: ignore notifications for nodes that are not in the cache
                try {
                    Path path = PathFactoryImpl.getInstance().create(getPath(state.getNodeId()), name, index, true);
                    nodeRemoved(state, path, id);
                    checkConsistency();
                } catch (PathNotFoundException e) {
                    log.warn("Unable to get path of node " + state.getNodeId()
                            + ", event ignored.");
                } catch (MalformedPathException e) {
                    log.warn("Unable to create path of " + id, e);
                } catch (ItemStateException e) {
                    log.warn("Unable to find item " + id, e);
                } catch (ItemNotFoundException e) {
                    log.warn("Unable to get path of " + state.getNodeId(), e);
                } catch (RepositoryException e) {
                    log.warn("Unable to get path of " + state.getNodeId(), e);
                }
            } else if (state.getParentId() == null && idCache.containsKey(id)) {
                // A top level node was removed
                evictAll(id, true);
            }
        }
    }


    public String getURI(String prefix) throws NamespaceException {
        NamespaceContext current = this;
        while (current != null) {
            String uri = (String) current.prefixToURI.get(prefix);
            if (uri != null) {
                return uri;
            }
            current = current.parent;
        }
        throw new NamespaceException("Unknown prefix: " + prefix);
    }


    public String getPrefix(String uri) throws NamespaceException {
        NamespaceContext current = this;
        while (current != null) {
            String prefix = (String) current.uriToPrefix.get(uri);
            if (prefix != null) {
                return prefix;
            }
            current = current.parent;
        }
        throw new NamespaceException("Unknown URI: " + uri);
    }


    private static byte[] read(InputStream stream) throws RepositoryException {
        if (stream != null) {
            try {
                final int bufferSize = Math.min(stream.available(), 4096);
                ByteArrayOutputStream s = new ByteArrayOutputStream(bufferSize);

                byte[] buffer = new byte[bufferSize];
                while (true) {
                    int numRead = stream.read(buffer);
                    if (numRead > 0) {
                        s.write(buffer, 0, numRead);
                    }
                    if (numRead != bufferSize) {
                        break;
                    }
                }

                return s.toByteArray();
            } catch (IOException e) {
                throw new RepositoryException(e);
            } finally {
                try {
                    stream.close();
                } catch (IOException ignore) {

                }
            }
        } else {
            return null;
        }
    }


    private static char[] read(Reader reader) throws RepositoryException {
        if (reader != null) {
            try {
                final int bufferSize = 4096;
                CharArrayWriter w = new CharArrayWriter(bufferSize);

                char[] buffer = new char[bufferSize];
                while (true) {
                    int numRead = reader.read(buffer);
                    if (numRead > 0) {
                        w.write(buffer, 0, numRead);
                    }
                    if (numRead != bufferSize) {
                        break;
                    }
                }
                return w.toCharArray();
            } catch (IOException e) {
                throw new RepositoryException(e);
            } finally {
                try {
                    reader.close();
                } catch (IOException ignore) {

                }
            }
        } else {
            return null;
        }

    }


    private void save() throws RepositoryException {
        try {
            OutputStream out = new FileOutputStream(fileName);
            try {
                properties.store(out, MAGIC);
            } finally {
                out.close();
            }
            lastWrite = new File(fileName).lastModified();
            if (LOG.isDebugEnabled()) {
                LOG.debug("Save " + properties);
            }
        } catch (IOException e) {
            throw getException(e);
        }
    }


    private Properties load() throws RepositoryException {
        try {
            Properties p2 = new Properties();
            InputStream in = new FileInputStream(fileName);
            try {
                p2.load(in);
            } finally {
                in.close();
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug("Load " + p2);
            }
            return p2;
        } catch (IOException e) {
            throw getException(e);
        }
    }


    private void closeRandomAccessFile() {
        if (randomAccessFile != null) {
            try {
                randomAccessFile.close();
            } catch (IOException e) {
                LOG.warn("Unable to close the random access file " + file, e);
            }
            randomAccessFile = null;
        }
    }


    private static void close(ReadRecord record) {
        if (record != null) {
            try {
                record.close();
            } catch (IOException e) {
                String msg = "Error while closing record.";
                log.warn(msg, e);
            }
        }
    }


    protected void resetStatement(PreparedStatement stmt) {
        if (stmt != null) {
            try {
                stmt.clearParameters();
                stmt.clearWarnings();
            } catch (SQLException se) {
                logException("failed resetting PreparedStatement", se);
            }
        }
    }


    public V get(K key) {
        recordCacheAccess();

        Map<K, E<V>> segment = getSegment(key);
        synchronized (segment) {
            E<V> entry = segment.get(key);
            if (entry != null) {
                return entry.value;
            }
        }
        recordCacheMiss();
        return null;
    }


    public V remove(K key) {
        Map<K, E<V>> segment = getSegment(key);
        synchronized (segment) {
            E<V> entry = segment.remove(key);
            if (entry != null) {
                recordSizeChange(-entry.size);
                return entry.value;
            } else {
                return null;
            }
        }
    }


    public int getDepth(ItemId id)
            throws ItemNotFoundException, RepositoryException {
        // shortcut
        if (id.equals(rootNodeId)) {
            return 0;
        }
        try {
            ItemState state = getItemState(id);
            NodeId parentId = getParentId(state);
            int depth = 0;
            while (parentId != null) {
                depth++;
                state = getItemState(parentId);
                parentId = getParentId(state);
            }
            return depth;
        } catch (NoSuchItemStateException nsise) {
            String msg = "failed to determine depth of " + id;
            log.debug(msg);
            throw new ItemNotFoundException(msg, nsise);
        } catch (ItemStateException ise) {
            String msg = "failed to determine depth of " + id;
            log.debug(msg);
            throw new RepositoryException(msg, ise);
        }
    }


    public int getRelativeDepth(NodeId ancestorId, ItemId descendantId)
            throws ItemNotFoundException, RepositoryException {
        if (ancestorId.equals(descendantId)) {
            return 0;
        }
        int depth = 1;
        try {
            ItemState state = getItemState(descendantId);
            NodeId parentId = getParentId(state);
            while (parentId != null) {
                if (parentId.equals(ancestorId)) {
                    return depth;
                }
                depth++;
                state = getItemState(parentId);
                parentId = getParentId(state);
            }
            // not an ancestor
            return -1;
        } catch (NoSuchItemStateException nsise) {
            String msg = "failed to determine depth of " + descendantId
                    + " relative to " + ancestorId;
            log.debug(msg);
            throw new ItemNotFoundException(msg, nsise);
        } catch (ItemStateException ise) {
            String msg = "failed to determine depth of " + descendantId
                    + " relative to " + ancestorId;
            log.debug(msg);
            throw new RepositoryException(msg, ise);
        }
    }


    public boolean isAncestor(NodeId nodeId, ItemId itemId)
            throws ItemNotFoundException, RepositoryException {
        if (nodeId.equals(itemId)) {
            // can't be ancestor of self
            return false;
        }
        try {
            ItemState state = getItemState(itemId);
            NodeId parentId = getParentId(state);
            while (parentId != null) {
                if (parentId.equals(nodeId)) {
                    return true;
                }
                state = getItemState(parentId);
                parentId = getParentId(state);
            }
            // not an ancestor
            return false;
        } catch (NoSuchItemStateException nsise) {
            String msg = "failed to determine degree of relationship of "
                    + nodeId + " and " + itemId;
            log.debug(msg);
            throw new ItemNotFoundException(msg, nsise);
        } catch (ItemStateException ise) {
            String msg = "failed to determine degree of relationship of "
                    + nodeId + " and " + itemId;
            log.debug(msg);
            throw new RepositoryException(msg, ise);
        }
    }


    public int getShareRelativeDepth(NodeId ancestor, ItemId descendant)
            throws ItemNotFoundException, RepositoryException {

        if (ancestor.equals(descendant)) {
            return 0;
        }
        int depth = 1;
        try {
            ItemState state = getItemState(descendant);
            Set<NodeId> parentIds = getParentIds(state, true);
            while (parentIds.size() > 0) {
                if (parentIds.contains(ancestor)) {
                    return depth;
                }
                depth++;
                Set<NodeId> grandparentIds = new LinkedHashSet<NodeId>();
                for (NodeId parentId : parentIds) {
                    state = getItemState(parentId);
                    grandparentIds.addAll(getParentIds(state, true));
                }
                parentIds = grandparentIds;
            }
            // not an ancestor
            return -1;
        } catch (NoSuchItemStateException nsise) {
            String msg = "failed to determine degree of relationship of "
                    + ancestor + " and " + descendant;
            log.debug(msg);
            throw new ItemNotFoundException(msg, nsise);
        } catch (ItemStateException ise) {
            String msg = "failed to determine degree of relationship of "
                    + ancestor + " and " + descendant;
            log.debug(msg);
            throw new RepositoryException(msg, ise);
        }
    }


    public boolean isShareAncestor(NodeId ancestor, NodeId descendant)
            throws ItemNotFoundException, RepositoryException {
        if (ancestor.equals(descendant)) {
            // can't be ancestor of self
            return false;
        }
        try {
            ItemState state = getItemState(descendant);
            Set<NodeId> parentIds = getParentIds(state, false);
            while (parentIds.size() > 0) {
                if (parentIds.contains(ancestor)) {
                    return true;
                }
                Set<NodeId> grandparentIds = new LinkedHashSet<NodeId>();
                for (NodeId parentId : parentIds) {
                    grandparentIds.addAll(getParentIds(getItemState(parentId), false));
                }
                parentIds = grandparentIds;
            }
            // not an ancestor
            return false;
        } catch (NoSuchItemStateException nsise) {
            String msg = "failed to determine degree of relationship of "
                    + ancestor + " and " + descendant;
            log.debug(msg);
            throw new ItemNotFoundException(msg, nsise);
        } catch (ItemStateException ise) {
            String msg = "failed to determine degree of relationship of "
                    + ancestor + " and " + descendant;
            log.debug(msg);
            throw new RepositoryException(msg, ise);
        }
    }


        protected SearchManager getSearchManager() throws RepositoryException {
            if (!isInitialized()) {
                throw new IllegalStateException("workspace '" + getName()
                        + "' not initialized");
            }

            synchronized (this) {
                if (searchMgr == null && config.isSearchEnabled()) {
                    // search manager is lazily instantiated in order to avoid
                    // 'chicken & egg' bootstrap problems
                    searchMgr = new SearchManager(
                            getName(),
                            context,
                            config,
                            itemStateMgr, persistMgr,
                            context.getRootNodeId(),
                            getSystemSearchManager(getName()),
                            SYSTEM_ROOT_NODE_ID);
                }
                return searchMgr;
            }
        }


        protected SystemSession getSystemSession() throws RepositoryException {
            if (!isInitialized()) {
                throw new IllegalStateException("workspace '" + getName()
                        + "' not initialized");
            }

            synchronized (this) {
                // system session is lazily instantiated in order to avoid
                // 'chicken & egg' bootstrap problems
                if (systemSession == null) {
                    systemSession = SystemSession.create(context, config);
                }
                return systemSession;
            }
        }


        protected RetentionRegistry getRetentionRegistry() throws RepositoryException {
            if (!isInitialized()) {
                throw new IllegalStateException("workspace '" + getName() + "' not initialized");
            }
            synchronized (this) {
                if (retentionReg == null) {
                    retentionReg = new RetentionRegistryImpl(getSystemSession(), fs);
                }
                return retentionReg;
            }
        }


    protected Property setProperty(NodeImpl parentImpl, Name name, Value[] values) throws RepositoryException {
        checkPermission(parentImpl, name, getPermission(false, false));
        // validation: make sure Node is not locked or checked-in.
        parentImpl.checkSetProperty();
        InternalValue[] intVs = new InternalValue[values.length];
        for (int i = 0; i < values.length; i++) {
            intVs[i] = InternalValue.create(values[i], parentImpl.sessionContext);
        }
        return parentImpl.internalSetProperty(name, intVs);
    }


    protected Property setProperty(NodeImpl parentImpl, Name name, Value[] values, int type) throws RepositoryException {
        checkPermission(parentImpl, name, getPermission(false, false));
        // validation: make sure Node is not locked or checked-in.
        parentImpl.checkSetProperty();
        InternalValue[] intVs = new InternalValue[values.length];
        for (int i = 0; i < values.length; i++) {
            intVs[i] = InternalValue.create(values[i], parentImpl.sessionContext);
        }
        return parentImpl.internalSetProperty(name, intVs, type);
    }


    public AccessManager getAccessManager(Session session, AMContext amContext) throws RepositoryException {
        checkInitialized();
        AccessManagerConfig amConfig = repository.getConfig().getSecurityConfig().getAccessManagerConfig();
        try {
            String wspName = session.getWorkspace().getName();
            AccessControlProvider pp = getAccessControlProvider(wspName);
            AccessManager accessMgr;
            if (amConfig == null) {
                log.debug("No configuration entry for AccessManager. Using org.apache.jackrabbit.core.security.DefaultAccessManager");
                accessMgr = new DefaultAccessManager();
            } else {
                accessMgr = amConfig.newInstance(AccessManager.class);
            }

            accessMgr.init(amContext, pp, workspaceAccessManager);
            return accessMgr;
        } catch (AccessDeniedException e) {
            // re-throw
            throw e;
        } catch (Exception e) {
            // wrap in RepositoryException
            String clsName = (amConfig == null) ? "-- missing access manager configuration --" : amConfig.getClassName();
            String msg = "Failed to instantiate AccessManager (" + clsName + ")";
            log.error(msg, e);
            throw new RepositoryException(msg, e);
        }
    }


    public AccessManager getAccessManager(Session session, AMContext amContext) throws RepositoryException {
        checkInitialized();
        try {
            String wspName = session.getWorkspace().getName();
            AccessControlProvider acP = getAccessControlProvider(systemSession, wspName);

            AccessManagerConfig amc = config.getAccessManagerConfig();
            AccessManager accessMgr;
            if (amc == null) {
                accessMgr = new SimpleAccessManager();
            } else {
                accessMgr = amc.newInstance(AccessManager.class);
            }
            accessMgr.init(amContext, acP, workspaceAccessManager);
            return accessMgr;
        } catch (AccessDeniedException ade) {
            // re-throw
            throw ade;
        } catch (Exception e) {
            // wrap in RepositoryException
            String msg = "failed to instantiate AccessManager implementation: " + SimpleAccessManager.class.getName();
            log.error(msg, e);
            throw new RepositoryException(msg, e);
        }
    }


    public static SessionItemOperation<Boolean> itemExists(String path) {
        return new SessionItemOperation<Boolean>("itemExists", path) {
            @Override @SuppressWarnings("deprecation")
            protected Boolean perform(ItemManager manager, Path path) {
                return manager.itemExists(path);
            }
        };
    }


    public static SessionItemOperation<ItemImpl> getItem(String path) {
        return new SessionItemOperation<ItemImpl>("getItem", path) {
            @Override @SuppressWarnings("deprecation")
            protected ItemImpl perform(ItemManager manager, Path path)
                    throws RepositoryException {
                return manager.getItem(path);
            }
        };
    }


    public static SessionItemOperation<Object> remove(String path) {
        return new SessionItemOperation<Object>("remove", path) {
            @Override  @SuppressWarnings("deprecation")
            protected Object perform(ItemManager manager, Path path)
                    throws RepositoryException {
                manager.getItem(path).remove();
                return this;
            }
        };
    }


    public LockableFileRevision(File file) {
        this.file = file;

        try {
            if (!file.exists()) {
                file.createNewFile();
            }
        } catch (IOException e) {
            String msg = "I/O error while attempting to create new file '" + file + "': " + e.getMessage();
            log.warn(msg);
        }
    }


        private CustomPrivilegeStore(FileSystemResource customPrivilegesResource) throws RepositoryException {
            this.customPrivilegesResource = customPrivilegesResource;
            try {
                // make sure path to resource exists
                if (!customPrivilegesResource.exists()) {
                    customPrivilegesResource.makeParentDirs();
                }
            } catch (FileSystemException e) {
                String error = "Internal error: Failed to access/create file system resource for custom privileges at " + customPrivilegesResource.getPath();
                log.debug(error);
                throw new RepositoryException(error, e);
            }
        }


    public void setJanitorFirstRunHourOfDay(int hourOfDay) {
        janitorNextRun = Calendar.getInstance();
        if (janitorNextRun.get(Calendar.HOUR_OF_DAY) >= hourOfDay) {
            janitorNextRun.add(Calendar.DAY_OF_MONTH, 1);
        }
        janitorNextRun.set(Calendar.HOUR_OF_DAY, hourOfDay);
        janitorNextRun.set(Calendar.MINUTE, 0);
        janitorNextRun.set(Calendar.SECOND, 0);
        janitorNextRun.set(Calendar.MILLISECOND, 0);
    }


    public void setMoveDataTaskFirstRunHourOfDay(int hourOfDay) {
        moveDataTaskNextRun = Calendar.getInstance();
        if (moveDataTaskNextRun.get(Calendar.HOUR_OF_DAY) >= hourOfDay) {
            moveDataTaskNextRun.add(Calendar.DAY_OF_MONTH, 1);
        }
        moveDataTaskNextRun.set(Calendar.HOUR_OF_DAY, hourOfDay);
        moveDataTaskNextRun.set(Calendar.MINUTE, 0);
        moveDataTaskNextRun.set(Calendar.SECOND, 0);
        moveDataTaskNextRun.set(Calendar.MILLISECOND, 0);
    }


    private void skip(long n) throws IOException {
        long skiplen = n;
        while (skiplen > 0) {
            long skipped = in.skip(skiplen);
            if (skipped <= 0) {
                break;
            }
            skiplen -= skipped;
        }
        if (skiplen != 0) {
            String msg = "Unable to skip remaining bytes.";
            throw new IOException(msg);
        }
    }


    private void skip(long n) throws IOException {
        long skiplen = n;
        while (skiplen > 0) {
            long skipped = dataIn.skip(skiplen);
            if (skipped <= 0) {
                break;
            }
            skiplen -= skipped;
        }
        if (skiplen != 0) {
            String msg = "Should have skipped " + n
                + " bytes, only " + (n - skiplen) + " skipped.";
            throw new IOException(msg);
        }
    }


    public NamingEnumeration list(Name name) throws NamingException {
        if (name.isEmpty()) {
            return new NamingEnum(this);
        }
        String n = getComponentName(name);
        Object obj = getBoundObject(n);
        if (obj instanceof Context) {
            return ((Context) obj).list("");
        } else {
            throw new NotContextException(name + " is not bound to a context");
        }
    }


    public NamingEnumeration listBindings(Name name) throws NamingException {
        if (name.isEmpty()) {
            return new BindingEnum(this);
        }
        String n = getComponentName(name);
        Object obj = getBoundObject(n);
        if (obj instanceof Context) {
            return ((Context) obj).listBindings("");
        } else {
            throw new NotContextException(name + " is not bound to a context");
        }
    }


    public TokenInfo getTokenInfo(String token) throws RepositoryException {
        if (token == null) {
            return null;
        }
        NodeImpl tokenNode = (NodeImpl) getTokenNode(token, session);
        String userId = getUserId(tokenNode, userManager);
        if (userId == null || !isValidTokenTree(tokenNode)) {
            return null;
        } else {
            return new CompatModeInfo(token);
        }
    }


    public TokenInfo getTokenInfo(String token) throws RepositoryException {
        if (token == null) {
            return null;
        }
        NodeImpl tokenNode = (NodeImpl) getTokenNode(token, session);
        String userId = getUserId(tokenNode, userManager);
        if (userId == null || !isValidTokenTree(tokenNode)) {
            return null;
        } else {
            return new TokenInfoImpl(tokenNode, token, userId);
        }
    }


    private static String getUserId(NodeImpl tokenNode, UserManager userManager) throws RepositoryException {
        if (tokenNode != null) {
            final NodeImpl userNode = (NodeImpl) tokenNode.getParent().getParent();
            final String principalName = userNode.getProperty(UserImpl.P_PRINCIPAL_NAME).getString();
            if (userNode.isNodeType(UserImpl.NT_REP_USER)) {
                Authorizable a = userManager.getAuthorizable(new ItemBasedPrincipal() {
                    public String getPath() throws RepositoryException {
                        return userNode.getPath();
                    }

                    public String getName() {
                        return principalName;
                    }
                });
                if (a != null && !a.isGroup() && !((User)a).isDisabled()) {
                    return a.getID();
                }
            } else {
                throw new RepositoryException("Failed to calculate userId from token credentials");
            }
        }
        return null;
    }


    static String getUserId(NodeImpl tokenNode, UserManager userManager) throws RepositoryException {
        if (tokenNode != null) {
            final NodeImpl userNode = (NodeImpl) tokenNode.getParent().getParent();
            final String principalName = userNode.getProperty(UserImpl.P_PRINCIPAL_NAME).getString();
            if (userNode.isNodeType(UserImpl.NT_REP_USER)) {
                Authorizable a = userManager.getAuthorizable(new ItemBasedPrincipal() {
                    public String getPath() throws RepositoryException {
                        return userNode.getPath();
                    }

                    public String getName() {
                        return principalName;
                    }
                });
                if (a != null && !a.isGroup() && !((User)a).isDisabled()) {
                    return a.getID();
                }
            } else {
                throw new RepositoryException("Failed to calculate userId from token credentials");
            }
        }
        return null;
    }


    private static String generateKey(int size) {
        SecureRandom random = new SecureRandom();
        byte key[] = new byte[size];
        random.nextBytes(key);

        StringBuffer res = new StringBuffer(key.length * 2);
        for (byte b : key) {
            res.append(Text.hexTable[(b >> 4) & 15]);
            res.append(Text.hexTable[b & 15]);
        }
        return res.toString();
    }


    private static String generateKey(int size) {
        SecureRandom random = new SecureRandom();
        byte key[] = new byte[size];
        random.nextBytes(key);

        StringBuilder res = new StringBuilder(key.length * 2);
        for (byte b : key) {
            res.append(Text.hexTable[(b >> 4) & 15]);
            res.append(Text.hexTable[b & 15]);
        }
        return res.toString();
    }


    private static String generateSalt(int saltSize) {
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[saltSize];
        random.nextBytes(salt);

        StringBuilder res = new StringBuilder(salt.length * 2);
        for (byte b : salt) {
            res.append(Text.hexTable[(b >> 4) & 15]);
            res.append(Text.hexTable[b & 15]);
        }
        return res.toString();
    }


        public boolean remove() {
            Session s = null;
            try {
                s = ((SessionImpl) session).createSession(session.getWorkspace().getName());
                Node tokenNode = getTokenNode(token, s);

                tokenNode.remove();
                s.save();
                return true;
            } catch (RepositoryException e) {
                log.warn("Internal error while removing token node.", e);
            } finally {
                if (s != null) {
                    s.logout();
                }
            }
            return false;
        }


        public boolean remove() {
            Session s = null;
            try {
                s = session.createSession(session.getWorkspace().getName());
                Node node = s.getNode(tokenPath);
                node.remove();
                s.save();
                return true;
            } catch (RepositoryException e) {
                log.warn("Internal error while removing token node.", e);
            } finally {
                if (s != null) {
                    s.logout();
                }
            }
            return false;
        }


        public TokenCredentials getCredentials() {
            TokenCredentials tc = new TokenCredentials(token);
            for (String name : attributes.keySet()) {
                tc.setAttribute(name, attributes.get(name));
            }
            for (String name : info.keySet()) {
                tc.setAttribute(name, info.get(name));
            }
            return tc;
        }


        public TokenCredentials getCredentials() {
            TokenCredentials tc = new TokenCredentials(token);
            for (String name : mandatoryAttributes.keySet()) {
                tc.setAttribute(name, mandatoryAttributes.get(name));
            }
            for (String name : publicAttributes.keySet()) {
                tc.setAttribute(name, publicAttributes.get(name));
            }
            return tc;
        }


    public synchronized void setProperty(String relPath, Value value) throws RepositoryException {
        String name = Text.getName(relPath);
        String intermediate = (relPath.equals(name)) ? null : Text.getRelativeParent(relPath, 1);
        checkProtectedProperty(name);
        try {
            Node n = getOrCreateTargetNode(intermediate);
            // check if the property has already been created as multi valued
            // property before -> in this case remove in order to avoid
            // ValueFormatException.
            if (n.hasProperty(name)) {
                Property p = n.getProperty(name);
                if (p.isMultiple()) {
                    p.remove();
                }
            }
            n.setProperty(name, value);
            if (userManager.isAutoSave()) {
                node.save();
            }
        } catch (RepositoryException e) {
            log.debug("Failed to set Property " + name + " for " + this, e);
            node.refresh(false);
            throw e;
        }
    }


    public synchronized void setProperty(String relPath, Value[] values) throws RepositoryException {
        String name = Text.getName(relPath);
        String intermediate = (relPath.equals(name)) ? null : Text.getRelativeParent(relPath, 1);
        checkProtectedProperty(name);
        try {
            Node n = getOrCreateTargetNode(intermediate);
            // check if the property has already been created as single valued
            // property before -> in this case remove in order to avoid
            // ValueFormatException.
            if (n.hasProperty(name)) {
                Property p = n.getProperty(name);
                if (!p.isMultiple()) {
                    p.remove();
                }
            }
            n.setProperty(name, values);
            if (userManager.isAutoSave()) {
                node.save();
            }
        } catch (RepositoryException e) {
            log.debug("Failed to set Property " + name + " for " + this, e);
            node.refresh(false);
            throw e;
        }
    }


    public User createUser(String userID, String password,
                           Principal principal, String intermediatePath)
            throws AuthorizableExistsException, RepositoryException {
        checkValidID(userID);

        // NOTE: password validation during setPassword and onCreate.
        // NOTE: principal validation during setPrincipal call.

        try {
            NodeImpl userNode = (NodeImpl) nodeCreator.createUserNode(userID, intermediatePath);
            setPrincipal(userNode, principal);
            setPassword(userNode, password, true);

            User user = createUser(userNode);
            onCreate(user, password);
            if (isAutoSave()) {
                session.save();
            }

            log.debug("User created: " + userID + "; " + userNode.getPath());
            return user;
        } catch (RepositoryException e) {
            // something went wrong -> revert changes and re-throw
            session.refresh(false);
            log.debug("Failed to create new User, reverting changes.");
            throw e;
        }
    }


    public Group createGroup(String groupID, Principal principal, String intermediatePath) throws AuthorizableExistsException, RepositoryException {
        checkValidID(groupID);
        // NOTE: principal validation during setPrincipal call.
        try {
            NodeImpl groupNode = (NodeImpl) nodeCreator.createGroupNode(groupID, intermediatePath);
            
            if (principal != null) {
            	setPrincipal(groupNode, principal);
            }

            Group group = createGroup(groupNode);
            onCreate(group);
            if (isAutoSave()) {
                session.save();
            }

            log.debug("Group created: " + groupID + "; " + groupNode.getPath());
            return group;
        } catch (RepositoryException e) {
            session.refresh(false);
            log.debug("newInstance new Group failed, revert changes on parent");
            throw e;
        }
    }


    public static String escapeForQuery(String value) {
        StringBuilder ret = new StringBuilder();
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (c == '\\') {
                ret.append("\\\\");
            } else if (c == '\'') {
                ret.append("''");
            } else {
                ret.append(c);
            }
        }
        return ret.toString();
    }


    private static String escapeForQuery(String value) {
        StringBuilder ret = new StringBuilder();
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (c == '\\') {
                ret.append("\\\\");
            } else if (c == '\'') {
                ret.append("''");
            } else {
                ret.append(c);
            }
        }
        return ret.toString();
    }


    public Principal getPrincipal() throws RepositoryException {
        if (principal == null) {
            if (isAdmin()) {
                principal = new NodeBasedAdminPrincipal(getPrincipalName());
            } else {
                principal = new NodeBasedPrincipal(getPrincipalName());
            }
        }
        return principal;
    }


    public ItemDefinition getDefinition() throws RepositoryException {
        if (definition == null && itemMgr != null) {
            if (isNode()) {
                definition = itemMgr.getDefinition((NodeState) state);
            } else {
                definition = itemMgr.getDefinition((PropertyState) state);
            }
        }
        return definition;
    }


    private Set<String> getImpersonatorNames() throws RepositoryException {
        Set<String> princNames = new HashSet<String>();
        if (user.getNode().hasProperty(P_IMPERSONATORS)) {
            Value[] vs = user.getNode().getProperty(P_IMPERSONATORS).getValues();
            for (Value v : vs) {
                princNames.add(v.getString());
            }
        }
        return princNames;
    }


    private Set<NodeId> getMergeFailed(NodeStateEx state)
            throws RepositoryException {
        Set<NodeId> set = new HashSet<NodeId>();
        if (state.hasProperty(NameConstants.JCR_MERGEFAILED)) {
            InternalValue[] vals = state.getPropertyValues(NameConstants.JCR_MERGEFAILED);
            for (InternalValue val : vals) {
                set.add(val.getNodeId());
            }
        }
        return set;
    }


        public Iterator<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException {
            if (node.hasProperty(P_MEMBERS)) {
                Value[] members = node.getProperty(P_MEMBERS).getValues();

                if (includeIndirect) {
                    return includeIndirect(toAuthorizables(members, type), type);
                } else {
                    return new RangeIteratorAdapter(toAuthorizables(members, type), members.length);
                }
            } else {
                return Iterators.empty();
            }
        }


        public Iterator<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException {
            if (node.hasNode(N_MEMBERS)) {
                PropertySequence members = getPropertySequence(node.getNode(N_MEMBERS), userManager);
                if (includeIndirect) {
                    return includeIndirect(toAuthorizables(members.iterator(), type), type);
                } else {
                    return toAuthorizables(members.iterator(), type);
                }
            } else {
                return Iterators.empty();
            }
        }


        private void siftNodeAdded(String identifier) throws RepositoryException {
            try {
                NodeImpl n = (NodeImpl) session.getNodeByIdentifier(identifier);
                if (n.isNodeType(EntryCollector.NT_REP_ACL)) {
                    // a new ACL was added -> use the added node to update
                    // the cache.
                    addModification(
                            accessControlledIdFromAclNode(n),
                            AccessControlObserver.POLICY_ADDED);
                } else if (n.isNodeType(EntryCollector.NT_REP_ACE)) {
                    // a new ACE was added -> use the parent node (acl)
                    // to update the cache.
                    addModification(
                            accessControlledIdFromAceNode(n),
                            AccessControlObserver.POLICY_MODIFIED);
                } /* else: some other node added below an access controlled
                     parent node -> not interested. */
            } catch (ItemNotFoundException e) {
                log.debug("Cannot process NODE_ADDED event. Node {} doesn't exist (anymore).", identifier);
            }
        }


        private void siftPropertyChanged(String identifier) throws RepositoryException {
            try {
                // test if the changed prop belongs to an ACE
                NodeImpl parent = (NodeImpl) session.getNodeByIdentifier(identifier);
                if (parent.isNodeType(EntryCollector.NT_REP_ACE)) {
                    addModification(
                            accessControlledIdFromAceNode(parent),
                            AccessControlObserver.POLICY_MODIFIED);
                } /* some other property below an access controlled node
                 changed -> not interested. (NOTE: rep:ACL doesn't
                 define any properties. */
            } catch (ItemNotFoundException e) {
                log.debug("Cannot process PROPERTY_CHANGED event. Node {} doesn't exist (anymore).", identifier);
            }
        }


    public CompiledPermissions compilePermissions(Set<Principal> principals) throws RepositoryException {
        checkInitialized();
        if (isAdminOrSystem(principals)) {
            return getAdminPermissions();
        } else if (isReadOnly(principals)) {
            return getReadOnlyPermissions();
        } else {
            return new CompiledPermissionsImpl(principals, session, entryCollector, this, true);
        }
    }


    public CompiledPermissions compilePermissions(Set<Principal> principals) throws RepositoryException {
        checkInitialized();
        if (isAdminOrSystem(principals)) {
            return getAdminPermissions();
        } else if (isReadOnly(principals)) {
            return getReadOnlyPermissions();
        } else {
            return new CompiledPermissionImpl(principals);
        }
    }


    public boolean canAccessRoot(Set<Principal> principals) throws RepositoryException {
        checkInitialized();
        if (isAdminOrSystem(principals)) {
            return true;
        } else {
            CompiledPermissions cp = new CompiledPermissionsImpl(principals, session, entryCollector, this, false);
            try {
                return cp.canRead(null, rootNodeId);
            } finally {
                cp.close();
            }
        }
    }


    public boolean canAccessRoot(Set<Principal> principals) throws RepositoryException {
        checkInitialized();
        if (isAdminOrSystem(principals)) {
            return true;
        } else {
            CompiledPermissions cp = new CompiledPermissionImpl(principals);
            try {
                Path rootPath = PathFactoryImpl.getInstance().getRootPath();
                return cp.grants(rootPath, Permission.READ);
            } finally {
                cp.close();
            }
        }
    }


    protected static Name getUniqueNodeName(Node node, String name) throws RepositoryException {
        if (name == null) {
            name = DEFAULT_ACE_NAME;
        } else {
            try {
                NameParser.checkFormat(name);
            } catch (NameException e) {
                name = DEFAULT_ACE_NAME;
                log.debug("Invalid path name for Permission: " + name + ".");
            }
        }
        int i = 0;
        String check = name;
        while (node.hasNode(check)) {
            check = name + i;
            i++;
        }
        return ((SessionImpl) node.getSession()).getQName(check);
    }


    protected static Name getUniqueNodeName(Node node, String name) throws RepositoryException {
        if (name == null) {
            name = DEFAULT_ACE_NAME;
        } else {
            try {
                NameParser.checkFormat(name);
            } catch (NameException e) {
                name = DEFAULT_ACE_NAME;
                log.debug("Invalid path name for Permission: " + name + ".");
            }
        }
        int i = 0;
        String check = name;
        while (node.hasNode(check)) {
            check = name + i;
            i++;
        }
        return ((SessionImpl) node.getSession()).getQName(check);
    }


    public AccessControlPolicy[] getPolicies(String nodePath) throws AccessControlException, PathNotFoundException, RepositoryException {
        List<AccessControlPolicy> templates = new ArrayList<AccessControlPolicy>();
        for (AccessControlEditor editor : editors) {
            AccessControlPolicy[] ts = editor.getPolicies(nodePath);
            if (ts != null && ts.length > 0) {
                templates.addAll(Arrays.asList(ts));
            }
        }
        return templates.toArray(new AccessControlPolicy[templates.size()]);
    }


    public JackrabbitAccessControlPolicy[] getPolicies(Principal principal) throws AccessControlException, RepositoryException {
        List<JackrabbitAccessControlPolicy> templates = new ArrayList<JackrabbitAccessControlPolicy>();
        for (AccessControlEditor editor : editors) {
            JackrabbitAccessControlPolicy[] ts = editor.getPolicies(principal);
            if (ts != null && ts.length > 0) {
                templates.addAll(Arrays.asList(ts));
            }
        }
        return templates.toArray(new JackrabbitAccessControlPolicy[templates.size()]);
    }


    public void setPolicy(String nodePath, AccessControlPolicy template) throws AccessControlException, PathNotFoundException, RepositoryException {
        for (AccessControlEditor editor : editors) {
            try {
                // return as soon as the first editor successfully handled the
                // specified template
                editor.setPolicy(nodePath, template);
                log.debug("Set template " + template + " using " + editor);
                return;
            } catch (AccessControlException e) {
                log.debug(e.getMessage());
                // ignore and try next
            }
        }

        // none accepted -> throw
        throw new AccessControlException("None of the editors accepted policy " + template + " at " + nodePath);
    }


    public void removePolicy(String nodePath,
                             AccessControlPolicy policy) throws AccessControlException, PathNotFoundException, RepositoryException {
        for (AccessControlEditor editor : editors) {
            try {
                // return as soon as the first editor successfully handled the
                // specified template
                editor.removePolicy(nodePath, policy);
                log.debug("Removed template " + policy + " using " + editor);
                return;
            } catch (AccessControlException e) {
                log.debug(e.getMessage());
                // ignore and try next
            }
        }
        // neither of the editors was able to remove a policy at nodePath
        throw new AccessControlException("Unable to remove template " + policy);
    }


        private Entry(Principal principal, Privilege[] privileges, boolean allow,
                      Map<String, Value> restrictions)
                throws AccessControlException, RepositoryException {
            super(principal, privileges, allow, restrictions);

            Map<Name, Value> rstr = getRestrictions();
            nodePath = rstr.get(P_NODE_PATH).getString();
            Value glob = rstr.get(P_GLOB);
            if (glob != null) {
                pattern = GlobPattern.create(nodePath, glob.getString());
            } else {
                pattern = GlobPattern.create(nodePath);
            }
        }


        private Entry(Principal principal, PrivilegeBits privilegeBits, boolean allow,
                      Map<String, Value> restrictions)
                throws AccessControlException, RepositoryException {
            super(principal, privilegeBits, allow, restrictions);

            Map<Name, Value> rstr = getRestrictions();
            nodePath = rstr.get(P_NODE_PATH).getString();
            Value glob = rstr.get(P_GLOB);
            if (glob != null) {
                pattern = GlobPattern.create(nodePath, glob.getString());
            } else {
                pattern = GlobPattern.create(nodePath);
            }
        }


    public PrincipalIterator findPrincipals(String simpleFilter) {
        checkIsValid();
        List<CheckedIteratorEntry> entries = new ArrayList<CheckedIteratorEntry>(providers.length);
        for (PrincipalProvider pp : providers) {
            PrincipalIterator it = pp.findPrincipals(simpleFilter);
            if (it.hasNext()) {
                entries.add(new CheckedIteratorEntry(it, pp));
            }
        }
        return new CheckedPrincipalIterator(entries);
    }


    public PrincipalIterator getPrincipals(int searchType) {
        checkIsValid();
        List<CheckedIteratorEntry> entries = new ArrayList<CheckedIteratorEntry>(providers.length);
        for (PrincipalProvider pp : providers) {
            PrincipalIterator it = pp.getPrincipals(searchType);
            if (it.hasNext()) {
                entries.add(new CheckedIteratorEntry(it, pp));
            }
        }
        return new CheckedPrincipalIterator(entries);
    }


    public PrincipalIterator findPrincipals(String simpleFilter, int searchType) {
        checkIsValid();
        List<CheckedIteratorEntry> entries = new ArrayList<CheckedIteratorEntry>(providers.length);
        for (PrincipalProvider pp : providers) {
            PrincipalIterator it = pp.findPrincipals(simpleFilter, searchType);
            if (it.hasNext()) {
                entries.add(new CheckedIteratorEntry(it, pp));
            }
        }
        return new CheckedPrincipalIterator(entries);
    }


    public boolean hasPrivileges(String absPath, Set<Principal> principals, Privilege[] privileges) throws PathNotFoundException, RepositoryException {
        if (anonymous) {
            // anonymous doesn't have READ_AC privilege
            throw new AccessDeniedException();
        }
        
        if (principals.size() == 1) {
            Principal princ = principals.iterator().next();
            if (princ instanceof AnonymousPrincipal) {
                return privileges.length == 1 && privileges[0].equals(privilegeManager.getPrivilege(Privilege.JCR_READ));
            }
        }

        // @todo check permission based on principals
        return true;
    }


    public Privilege[] getPrivileges(String absPath, Set<Principal> principals) throws PathNotFoundException, RepositoryException {
        if (anonymous) {
            // anonymous doesn't have READ_AC privilege
            throw new AccessDeniedException();
        }

        if (principals.size() == 1) {
            Principal princ = principals.iterator().next();
            if (princ instanceof AnonymousPrincipal) {
                return new Privilege[] {privilegeManager.getPrivilege(Privilege.JCR_READ)};
            }
        }

        // @todo check permission based on principals
        return new Privilege[] {privilegeManager.getPrivilege(Privilege.JCR_ALL)};
    }


    private boolean hasHold(ItemImpl item, boolean isRemoval) throws RepositoryException {
        if (item.isNew()) {
            return false;
        }
        Path path = item.getPrimaryPath();
        if (!item.isNode()) {
            path = path.getAncestor(1);
        }
        boolean checkParent = (item.isNode() && isRemoval);
        return context.getSessionImpl().getRetentionRegistry().hasEffectiveHold(path, checkParent);
    }


    private boolean hasRetention(ItemImpl item, boolean isRemoval) throws RepositoryException {
        if (item.isNew()) {
            return false;
        }
        Path path = item.getPrimaryPath();
        if (!item.isNode()) {
            path = path.getAncestor(1);
        }
        boolean checkParent = (item.isNode() && isRemoval);
        return context.getSessionImpl().getRetentionRegistry().hasEffectiveRetention(path, checkParent);
    }


    protected void restore(NodeStateEx state, InternalVersion v, boolean removeExisting)
            throws RepositoryException {
        checkVersionable(state);

        // check if 'own' version
        if (!v.getVersionHistory().equals(getVersionHistory(state))) {
            String msg = "Unable to restore version. Not same version history.";
            log.error(msg);
            throw new VersionException(msg);
        }
        WriteOperation ops = startWriteOperation();
        try {
            internalRestore(state, v, new DateVersionSelector(v.getCreated()), removeExisting);
            ops.save();
        } catch (ItemStateException e) {
            throw new RepositoryException(e);
        } finally {
            ops.close();
        }
    }


    protected void restoreByLabel(NodeStateEx state, Name versionLabel, boolean removeExisting)
            throws RepositoryException {
        checkVersionable(state);
        InternalVersion v = getVersionHistory(state).getVersionByLabel(versionLabel);
        if (v == null) {
            String msg = "No version for label " + versionLabel + " found.";
            log.error(msg);
            throw new VersionException(msg);
        }
        WriteOperation ops = startWriteOperation();
        try {
            internalRestore(state, v, new LabelVersionSelector(versionLabel), removeExisting);
            ops.save();
        } catch (ItemStateException e) {
            throw new RepositoryException(e);
        } finally {
            ops.close();
        }
    }


    private WriteOperation startWriteOperation() throws RepositoryException {
        boolean success = false;
        VersioningLock.WriteLock lock = acquireWriteLock();
        try {
            stateMgr.edit();
            success = true;
            return new WriteOperation(lock);
        } catch (IllegalStateException e) {
            throw new RepositoryException("Unable to start edit operation.", e);
        } finally {
            if (!success) {
                lock.release();
            }
        }
    }


    public WriteOperation startWriteOperation() throws RepositoryException {
        boolean success = false;
        VersioningLock.WriteLock lock = acquireWriteLock();
        try {
            stateMgr.edit();
            success = true;
            return new WriteOperation(lock);
        } catch (IllegalStateException e) {
            String msg = "Unable to start edit operation.";
            throw new RepositoryException(msg, e);
        } finally {
            if (!success) {
                lock.release();
            }
        }
    }


    public synchronized InternalVersion getVersion(Name versionName)
            throws VersionException {
        NodeId versionId = nameCache.get(versionName);
        if (versionId == null) {
            throw new VersionException("Version " + versionName + " does not exist.");
        }

        InternalVersion v = versionCache.get(versionId);
        if (v == null) {
            v = createVersionInstance(versionName);
        }
        return v;
    }


    public synchronized InternalVersion getVersionByLabel(Name label) {
        Name versionName = labelCache.get(label);
        if (versionName == null) {
            return null;
        }

        NodeId id = nameCache.get(versionName);
        InternalVersion v = versionCache.get(id);
        if (v == null) {
            v = createVersionInstance(versionName);
        }
        return v;
    }


    public boolean isSame(Item otherItem) {
        if (otherItem instanceof VersionImpl) {
            // since all versions live in the same workspace, we can compare the uuids
            try {
                InternalVersion other = ((VersionImpl) otherItem).getInternalVersion();
                return other.getId().equals(getInternalVersion().getId());
            } catch (RepositoryException e) {
                log.warn("Unable to retrieve internal version objects: " + e.getMessage());
                log.debug("Stack dump:", e);
            }
        }
        return false;
    }


    public boolean isSame(Item otherItem) {
        if (otherItem instanceof VersionHistoryImpl) {
            // since all version histories live in the same workspace, we can compare the uuids
            try {
                InternalVersionHistory other = ((VersionHistoryImpl) otherItem).getInternalVersionHistory();
                return other.getId().equals(getInternalVersionHistory().getId());
            } catch (RepositoryException e) {
                log.warn("Unable to retrieve internal version history objects: " + e.getMessage());
                log.debug("Stack dump:", e);
            }
        }
        return false;
    }


    public InternalXAResource getXAResourceBegin() {
        return new InternalXAResource() {
            public void associate(TransactionContext tx) {
            }

            public void beforeOperation(TransactionContext tx) {
            }

            public void prepare(TransactionContext tx) {
                vmgrLock = vMgr.acquireWriteLock();
                vmgrLocked = true;
            }

            public void commit(TransactionContext tx) {
                // JCR-2712: Ensure that the transaction is prepared
                if (!vmgrLocked) {
                    prepare(tx);
                }
            }

            public void rollback(TransactionContext tx) {
                // JCR-2712: Ensure that the transaction is prepared
                if (!vmgrLocked) {
                    prepare(tx);
                }
            }

            public void afterOperation(TransactionContext tx) {
            }
        };
    }


    public InternalXAResource getXAResourceEnd() {
        return new InternalXAResource() {
            public void associate(TransactionContext tx) {
            }

            public void beforeOperation(TransactionContext tx) {
            }

            public void prepare(TransactionContext tx) {
            }

            public void commit(TransactionContext tx) {
                internalReleaseWriteLock();
            }

            public void rollback(TransactionContext tx) {
                internalReleaseWriteLock();
            }

            public void afterOperation(TransactionContext tx) {
            }

            private void internalReleaseWriteLock() {
                if (vmgrLocked) {
                    vmgrLock.release();
                    vmgrLocked = false;
                }
            }
        };
    }


    private InternalVersionHistoryImpl makeLocalCopy(InternalVersionHistoryImpl history)
            throws RepositoryException {
        VersioningLock.ReadLock lock = acquireReadLock();
        try {
            NodeState state = (NodeState) stateMgr.getItemState(history.getId());
            NodeStateEx stateEx = new NodeStateEx(stateMgr, ntReg, state, null);
            return new InternalVersionHistoryImpl(this, stateEx);
        } catch (ItemStateException e) {
            throw new RepositoryException("Unable to make local copy", e);
        } finally {
            lock.release();
        }
    }


    private InternalActivityImpl makeLocalCopy(InternalActivityImpl act)
            throws RepositoryException {
        VersioningLock.ReadLock lock = acquireReadLock();
        try {
            NodeState state = (NodeState) stateMgr.getItemState(act.getId());
            NodeStateEx stateEx = new NodeStateEx(stateMgr, ntReg, state, null);
            return new InternalActivityImpl(this, stateEx);
        } catch (ItemStateException e) {
            throw new RepositoryException("Unable to make local copy", e);
        } finally {
            lock.release();
        }
    }


    public javax.jcr.version.Version getVersion(String versionName)
            throws VersionException, RepositoryException {
        try {
            Name name = sessionContext.getQName(versionName);
            InternalVersion v = getInternalVersionHistory().getVersion(name);
            if (v == null) {
                throw new VersionException("No version with name '" + versionName + "' exists in this version history.");
            }
            return (Version) sessionContext.getSessionImpl().getNodeById(v.getId());
        } catch (NameException e) {
            throw new VersionException(e);
        }
    }


    public javax.jcr.version.Version getVersionByLabel(String label) throws RepositoryException {
        try {
            Name qLabel = sessionContext.getQName(label);
            InternalVersion v =
                getInternalVersionHistory().getVersionByLabel(qLabel);
            if (v == null) {
                throw new VersionException("No version with label '" + label + "' exists in this version history.");
            }
            return (Version) sessionContext.getSessionImpl().getNodeById(v.getId());
        } catch (NameException e) {
            throw new VersionException(e);
        }
    }


    protected ChildNodeEntry getChildNodeEntry(NodeState parent,
                                                         Name name,
                                                         int index) {
        // first look for the entry in the current child node entry list
        ChildNodeEntry entry = super.getChildNodeEntry(parent, name, index);
        if (entry == null) {
            // if not found, we need to look for a removed child node entry
            for (ChildNodeEntry candidate : parent.getRemovedChildNodeEntries()) {
                if (candidate.getName().equals(name)
                        && candidate.getIndex() == index) {
                    entry = candidate;
                    break;
                }
            }
        }
        return entry;
    }


    protected ChildNodeEntry getChildNodeEntry(NodeState parent,
                                                         NodeId id) {
        // first look for the entry in the current child node entry list
        ChildNodeEntry entry = super.getChildNodeEntry(parent, id);
        if (entry == null) {
            // if not found, we need to look for a removed child node entry
            for (ChildNodeEntry candidate : parent.getRemovedChildNodeEntries()) {
                if (candidate.getId().equals(id)) {
                    entry = candidate;
                    break;
                }
            }
        }
        return entry;
    }


    protected final DataSource getDataSource() throws Exception {
        if (getDataSourceName() == null || "".equals(getDataSourceName())) {
            return connectionFactory.getDataSource(getDriver(), getUrl(), getUser(), getPassword());
        } else {
            String dbType = connectionFactory.getDataBaseType(dataSourceName);
            if (DatabaseFileSystem.class.getResourceAsStream(dbType + ".ddl") != null) {
                setSchema(dbType);
            }
            return connectionFactory.getDataSource(dataSourceName);
        }
    }


    private DataSource getDataSource() throws Exception {
        if (getDataSourceName() == null || "".equals(getDataSourceName())) {
            return connectionFactory.getDataSource(getDriver(), getUrl(), getUser(), getPassword());
        } else {
            String dbType = connectionFactory.getDataBaseType(dataSourceName);
            if (BundleDbPersistenceManager.class.getResourceAsStream(dbType + ".ddl") != null) {
                setDatabaseType(dbType);
            }
            return connectionFactory.getDataSource(dataSourceName);
        }
    }


    public void deleteFile(String filePath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(filePath);

        String parentDir = FileSystemPathUtil.getParentDir(filePath);
        String name = FileSystemPathUtil.getName(filePath);

        int count = 0;
        synchronized (deleteFileSQL) {
            try {
                count = conHelper.update(
                        deleteFileSQL, new Object[]{parentDir, name});
            } catch (SQLException e) {
                String msg = "failed to delete file: " + filePath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            }
        }

        if (count == 0) {
            throw new FileSystemException("no such file: " + filePath);
        }
    }


    public void deleteFolder(String folderPath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(folderPath);

        if (folderPath.equals(FileSystem.SEPARATOR)) {
            throw new FileSystemException("cannot delete root");
        }

        String parentDir = FileSystemPathUtil.getParentDir(folderPath);
        String name = FileSystemPathUtil.getName(folderPath);

        int count = 0;
        synchronized (deleteFolderSQL) {
            try {
                count = conHelper.update(deleteFolderSQL, new Object[]{
                        parentDir,
                        name,
                        folderPath,
                        folderPath + FileSystem.SEPARATOR + "%"});
            } catch (SQLException e) {
                String msg = "failed to delete folder: " + folderPath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            }
        }

        if (count == 0) {
            throw new FileSystemException("no such folder: " + folderPath);
        }
    }


    public boolean exists(String path) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(path);

        String parentDir = FileSystemPathUtil.getParentDir(path);
        String name = FileSystemPathUtil.getName(path);

        synchronized (selectExistSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectExistSQL, new Object[]{parentDir, name}, false, 0);

                // a file system entry exists if the result set
                // has at least one entry
                return rs.next();
            } catch (SQLException e) {
                String msg = "failed to check existence of file system entry: " + path;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public long length(String filePath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(filePath);

        String parentDir = FileSystemPathUtil.getParentDir(filePath);
        String name = FileSystemPathUtil.getName(filePath);

        synchronized (selectLengthSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectLengthSQL, new Object[]{parentDir, name}, false, 0);
                if (!rs.next()) {
                    throw new FileSystemException("no such file: " + filePath);
                }
                return rs.getLong(1);
            } catch (SQLException e) {
                String msg = "failed to determine length of file: " + filePath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public long lastModified(String path) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(path);

        String parentDir = FileSystemPathUtil.getParentDir(path);
        String name = FileSystemPathUtil.getName(path);

        synchronized (selectLastModifiedSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectLastModifiedSQL, new Object[]{parentDir, name}, false, 0);
                if (!rs.next()) {
                    throw new FileSystemException("no such file system entry: " + path);
                }
                return rs.getLong(1);
            } catch (SQLException e) {
                String msg = "failed to determine lastModified of file system entry: " + path;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public boolean isFile(String path) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(path);

        String parentDir = FileSystemPathUtil.getParentDir(path);
        String name = FileSystemPathUtil.getName(path);

        synchronized (selectFileExistSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectFileExistSQL, new Object[]{parentDir, name}, false, 0);

                // a file exists if the result set has at least one entry
                return rs.next();
            } catch (SQLException e) {
                String msg = "failed to check existence of file: " + path;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public boolean isFolder(String path) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(path);

        String parentDir = FileSystemPathUtil.getParentDir(path);
        String name = FileSystemPathUtil.getName(path);

        synchronized (selectFolderExistSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectFolderExistSQL, new Object[]{parentDir, name}, false, 0);

                // a folder exists if the result set has at least one entry
                return rs.next();
            } catch (SQLException e) {
                String msg = "failed to check existence of folder: " + path;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public boolean exists(NodeId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (nodeStateSelectExistSQL) {
            ResultSet rs = null;
            try {
                Statement stmt = executeStmt(nodeStateSelectExistSQL, new Object[]{id.toString()});
                rs = stmt.getResultSet();

                // a node state exists if the result has at least one entry
                return rs.next();
            } catch (Exception e) {
                String msg = "failed to check existence of node state: " + id;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                closeResultSet(rs);
            }
        }
    }


    public boolean existsReferencesTo(NodeId targetId) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (nodeReferenceSelectExistSQL) {
            ResultSet rs = null;
            try {
                Statement stmt = executeStmt(
                        nodeReferenceSelectExistSQL, new Object[]{targetId.toString()});
                rs = stmt.getResultSet();

                // a reference exists if the result has at least one entry
                return rs.next();
            } catch (Exception e) {
                String msg = "failed to check existence of node references: "
                        + targetId;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                closeResultSet(rs);
            }
        }
    }


    public boolean exists(PropertyId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (propertyStateSelectExistSQL) {
            ResultSet rs = null;
            try {
                Statement stmt = executeStmt(
                        propertyStateSelectExistSQL, new Object[]{id.toString()});
                rs = stmt.getResultSet();

                // a property state exists if the result has at least one entry
                return rs.next();
            } catch (Exception e) {
                String msg = "failed to check existence of property state: " + id;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                closeResultSet(rs);
            }
        }
    }


    public String[] list(String folderPath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(folderPath);

        if (!isFolder(folderPath)) {
            throw new FileSystemException("no such folder: " + folderPath);
        }

        synchronized (selectFileAndFolderNamesSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectFileAndFolderNamesSQL, new Object[]{folderPath}, false, 0);
                ArrayList<String> names = new ArrayList<String>();
                while (rs.next()) {
                    String name = rs.getString(1);
                    if (name.length() == 0
                            && FileSystemPathUtil.denotesRoot(folderPath)) {
                        // this is the file system root entry, skip...
                        continue;
                    }
                    names.add(name);
                }
                return names.toArray(new String[names.size()]);
            } catch (SQLException e) {
                String msg = "failed to list child entries of folder: " + folderPath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public String[] listFolders(String folderPath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(folderPath);

        if (!isFolder(folderPath)) {
            throw new FileSystemException("no such folder: " + folderPath);
        }

        synchronized (selectFolderNamesSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectFolderNamesSQL, new Object[]{folderPath}, false, 0);
                ArrayList<String> names = new ArrayList<String>();
                while (rs.next()) {
                    String name = rs.getString(1);
                    if (name.length() == 0
                            && FileSystemPathUtil.denotesRoot(folderPath)) {
                        // this is the file system root entry, skip...
                        continue;
                    }
                    names.add(name);
                }
                return (String[]) names.toArray(new String[names.size()]);
            } catch (SQLException e) {
                String msg = "failed to list folder entries of folder: " + folderPath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    public String[] listFiles(String folderPath) throws FileSystemException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        FileSystemPathUtil.checkFormat(folderPath);

        if (!isFolder(folderPath)) {
            throw new FileSystemException("no such folder: " + folderPath);
        }

        synchronized (selectFileNamesSQL) {
            ResultSet rs = null;
            try {
                rs = conHelper.exec(
                        selectFileNamesSQL, new Object[]{folderPath}, false, 0);
                ArrayList<String> names = new ArrayList<String>();
                while (rs.next()) {
                    names.add(rs.getString(1));
                }
                return names.toArray(new String[names.size()]);
            } catch (SQLException e) {
                String msg = "failed to list file entries of folder: " + folderPath;
                log.error(msg, e);
                throw new FileSystemException(msg, e);
            } finally {
                DbUtility.close(rs);
            }
        }
    }


    private NodeId getNodeId(Path p) throws RepositoryException {
        if (p.getLength() == 1 && p.denotesName()) {
            // check if node entry exists
            ChildNodeEntry cne = data.getNodeState().getChildNodeEntry(
                    p.getName(), p.getNormalizedIndex());
            if (cne != null) {
                return cne.getId();
            } else {
                return null; // there's no child node with that name
            }
        } else {
            // build and resolve absolute path
            try {
                p = PathFactoryImpl.getInstance().create(
                        getPrimaryPath(), p, true);
            } catch (RepositoryException re) {
                // failed to build canonical path
                return null;
            }
            return sessionContext.getHierarchyManager().resolveNodePath(p);
        }
    }


    private PropertyId getPropertyId(Path p) throws RepositoryException {
        if (p.getLength() == 1 && p.denotesName()) {
            // check if property entry exists
            NodeState thisState = data.getNodeState();
            if (p.getIndex() == Path.INDEX_UNDEFINED
                    && thisState.hasPropertyName(p.getName())) {
                return new PropertyId(thisState.getNodeId(), p.getName());
            } else {
                return null; // there's no property with that name
            }
        } else {
            // build and resolve absolute path
            try {
                p = PathFactoryImpl.getInstance().create(
                        getPrimaryPath(), p, true);
            } catch (RepositoryException re) {
                // failed to build canonical path
                return null;
            }
            return sessionContext.getHierarchyManager().resolvePropertyPath(p);
        }
    }


    protected Property internalSetProperty(Name name, InternalValue[] values,
                                           int type)
            throws ValueFormatException, RepositoryException {
        BitSet status = new BitSet();
        PropertyImpl prop = getOrCreateProperty(name, type, true, true, status);
        try {
            prop.internalSetValue(values, type);
        } catch (RepositoryException re) {
            if (status.get(CREATED)) {
                // setting value failed, get rid of newly created property
                removeChildProperty(name);
            }
            // rethrow
            throw re;
        }
        return prop;
    }


            public PropertyImpl perform(SessionContext context)
                    throws RepositoryException {
                // check pre-conditions for setting property
                checkSetProperty();

                BitSet status = new BitSet();
                PropertyImpl prop = getOrCreateProperty(
                        name, type, true, enforceType, status);
                try {
                    prop.setValue(values, type);
                } catch (RepositoryException re) {
                    if (status.get(CREATED)) {
                        // setting value failed, get rid of newly created property
                        removeChildProperty(name);
                    }
                    // rethrow
                    throw re;
                }
                return prop;
            }


    public NodeIterator getNodes() throws RepositoryException {
        // IMPORTANT: an implementation of Node.getNodes() must not use
        // a class derived from TraversingElementVisitor to traverse the
        // hierarchy because this would lead to an infinite recursion!
        return perform(new SessionOperation<NodeIterator>() {
            public NodeIterator perform(SessionContext context)
                    throws RepositoryException {
                try {
                    return itemMgr.getChildNodes((NodeId) id);
                } catch (ItemNotFoundException e) {
                    throw new RepositoryException(
                            "Failed to list child nodes of " + NodeImpl.this, e);
                } catch (AccessDeniedException e) {
                    throw new RepositoryException(
                            "Failed to list child nodes of " + NodeImpl.this, e);
                }
            }
            public String toString() {
                return "node.getNodes()";
            }
        });
    }


    public PropertyIterator getProperties() throws RepositoryException {
        // IMPORTANT: an implementation of Node.getProperties() must not use
        // a class derived from TraversingElementVisitor to traverse the
        // hierarchy because this would lead to an infinite recursion!
        return perform(new SessionOperation<PropertyIterator>() {
            public PropertyIterator perform(SessionContext context)
                    throws RepositoryException {
                try {
                    return itemMgr.getChildProperties((NodeId) id);
                } catch (ItemNotFoundException e) {
                    throw new RepositoryException(
                            "Failed to list properties of " + NodeImpl.this, e);
                } catch (AccessDeniedException e) {
                    throw new RepositoryException(
                            "Failed to list properties of " + NodeImpl.this, e);
                }
            }
            public String toString() {
                return "node.getProperties()";
            }
        });
    }


    private String internalCopy(String srcAbsPath,
                              WorkspaceImpl srcWsp,
                              String destAbsPath,
                              int flag)
            throws ConstraintViolationException, AccessDeniedException,
            VersionException, PathNotFoundException, ItemExistsException,
            LockException, RepositoryException {

        Path srcPath;
        try {
            srcPath = context.getQPath(srcAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + srcAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!srcPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + srcAbsPath);
        }

        Path destPath;
        try {
            destPath = context.getQPath(destAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + destAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!destPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + destAbsPath);
        }

        BatchedItemOperations ops =
            new BatchedItemOperations(stateMgr, context);

        try {
            ops.edit();
        } catch (IllegalStateException e) {
            String msg = "unable to start edit operation";
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }

        boolean succeeded = false;

        try {
            NodeId id = ops.copy(srcPath, srcWsp.getItemStateManager(),
                    srcWsp.getHierarchyManager(),
                    srcWsp.context.getAccessManager(),
                    destPath, flag);
            ops.update();
            succeeded = true;
            return context.getJCRPath(hierMgr.getPath(id));
        } finally {
            if (!succeeded) {
                // update operation failed, cancel all modifications
                ops.cancel();
            }
        }
    }


    public void move(String srcAbsPath, String destAbsPath)
            throws ConstraintViolationException, VersionException,
            AccessDeniedException, PathNotFoundException, ItemExistsException,
            LockException, RepositoryException {
        // check state of this instance
        sanityCheck();

        // intra-workspace move...

        Path srcPath;
        try {
            srcPath = context.getQPath(srcAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + srcAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!srcPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + srcAbsPath);
        }

        Path destPath;
        try {
            destPath = context.getQPath(destAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + destAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!destPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + destAbsPath);
        }

        BatchedItemOperations ops =
            new BatchedItemOperations(stateMgr, context);

        try {
            ops.edit();
        } catch (IllegalStateException e) {
            String msg = "unable to start edit operation";
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }

        boolean succeeded = false;

        try {
            ops.move(srcPath, destPath);
            ops.update();
            succeeded = true;
        } finally {
            if (!succeeded) {
                // update operation failed, cancel all modifications
                ops.cancel();
            }
        }
    }


    private String internalClone(String srcAbsPath, String destAbsPath)
            throws ConstraintViolationException, AccessDeniedException,
                   VersionException, PathNotFoundException, ItemExistsException,
                   LockException, RepositoryException {

        Path srcPath;
        try {
            srcPath = context.getQPath(srcAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + srcAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!srcPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + srcAbsPath);
        }

        Path destPath;
        try {
            destPath = context.getQPath(destAbsPath).getNormalizedPath();
        } catch (NameException e) {
            String msg = "invalid path: " + destAbsPath;
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }
        if (!destPath.isAbsolute()) {
            throw new RepositoryException("not an absolute path: " + destAbsPath);
        }

        BatchedItemOperations ops =
            new BatchedItemOperations(stateMgr, context);

        try {
            ops.edit();
        } catch (IllegalStateException e) {
            String msg = "unable to start edit operation";
            log.debug(msg);
            throw new RepositoryException(msg, e);
        }

        boolean succeeded = false;

        try {
            ItemId id = ops.clone(srcPath, destPath);
            ops.update();
            succeeded = true;
            return context.getJCRPath(hierMgr.getPath(id));
        } finally {
            if (!succeeded) {
                // update operation failed, cancel all modifications
                ops.cancel();
            }
        }
    }


    public void init(PMContext context) throws Exception {
        if (initialized) {
            throw new IllegalStateException("already initialized");
        }

        stateStore = new HashMap<ItemId, byte[]>(initialCapacity, loadFactor);
        refsStore = new HashMap<NodeId, byte[]>(initialCapacity, loadFactor);

        wspFS = context.getFileSystem();

        // Choose a FileSystem for the BlobStore based on whether data is persistent or not 
        if (persistent) {
            blobFS = new LocalFileSystem();
            ((LocalFileSystem) blobFS).setRoot(new File(context.getHomeDir(), "blobs"));
        } else {
            blobFS = new MemoryFileSystem();
        }
        blobFS.init();
        blobStore = new FileSystemBLOBStore(blobFS);

        if (persistent) {
            // deserialize contents of state and refs stores
            loadContents();
        }

        initialized = true;
    }


    public void init(PMContext context) throws Exception {
        if (initialized) {
            throw new IllegalStateException("already initialized");
        }
        super.init(context);
        // initialize mem stores
        bundleStore = new LinkedHashMap<NodeId, byte[]>(initialCapacity, loadFactor);
        refsStore = new HashMap<NodeId, byte[]>(initialCapacity, loadFactor);

        // Choose a FileSystem for the BlobStore based on whether data is persistent or not 
        if (useFileBlobStore) {
            blobFS = new LocalFileSystem();
            ((LocalFileSystem) blobFS).setRoot(new File(context.getHomeDir(), "blobs"));
            blobFS.init();
            blobStore = new FileSystemBLOBStore(blobFS);
        } else {
            blobStore = new InMemBLOBStore();
        }

        wspFS = context.getFileSystem();

        // load namespaces
        binding = new BundleBinding(errorHandling, blobStore, getNsIndex(), getNameIndex(), context.getDataStore());
        binding.setMinBlobSize(minBlobSize);

        if (persistent) {
            // deserialize contents of the stores
            loadContents();
        }
        initialized = true;
    }


    public synchronized NodeState load(NodeId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        byte[] data = stateStore.get(id);
        if (data == null) {
            throw new NoSuchItemStateException(id.toString());
        }

        ByteArrayInputStream in = new ByteArrayInputStream(data);
        try {
            NodeState state = createNew(id);
            Serializer.deserialize(state, in);
            return state;
        } catch (Exception e) {
            String msg = "failed to read node state: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized PropertyState load(PropertyId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        byte[] data = stateStore.get(id);
        if (data == null) {
            throw new NoSuchItemStateException(id.toString());
        }

        ByteArrayInputStream in = new ByteArrayInputStream(data);
        try {
            PropertyState state = createNew(id);
            Serializer.deserialize(state, in, blobStore);
            return state;
        } catch (Exception e) {
            String msg = "failed to read property state: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized NodeReferences loadReferencesTo(NodeId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        byte[] data = refsStore.get(id);
        if (data == null) {
            throw new NoSuchItemStateException(id.toString());
        }

        ByteArrayInputStream in = new ByteArrayInputStream(data);
        try {
            NodeReferences refs = new NodeReferences(id);
            Serializer.deserialize(refs, in);
            return refs;
        } catch (Exception e) {
            String msg = "failed to load references: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize node state
            Serializer.serialize(state, out);

            // store in serialized format in map for better memory efficiency
            stateStore.put(state.getNodeId(), out.toByteArray());
            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write node state: " + state.getNodeId();
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(NodeReferences refs) throws ItemStateException {
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize references
            Serializer.serialize(refs, out);
            // store in serialized format in map for better memory efficiency
            refsStore.put(refs.getTargetId(), out.toByteArray());
        } catch (Exception e) {
            String msg = "failed to store " + refs;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(PropertyState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize property state
            Serializer.serialize(state, out, blobStore);

            // store in serialized format in map for better memory efficiency
            stateStore.put(state.getPropertyId(), out.toByteArray());
            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to store property state: " + state.getPropertyId();
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize references
            Serializer.serialize(refs, out);

            // store in serialized format in map for better memory efficiency
            refsStore.put(refs.getTargetId(), out.toByteArray());
            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to store " + refs;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void storeBundle(NodePropBundle bundle) throws ItemStateException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
        try {
            binding.writeBundle(out, bundle);
            bundleStore.put(bundle.getId(), out.toByteArray());
        } catch (IOException e) {
            String msg = "failed to write bundle: " + bundle.getId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


        public String createId(PropertyId id, int index) {
            StringBuilder buf = new StringBuilder();
            buf.append(id.getParentId().toString());
            buf.append('.');
            buf.append(getNsIndex().stringToIndex(id.getName().getNamespaceURI()));
            buf.append('.');
            buf.append(getNameIndex().stringToIndex(id.getName().getLocalName()));
            buf.append('.');
            buf.append(index);
            return buf.toString();
        }


        public String createId(PropertyId id, int index) {
            StringBuilder buf = new StringBuilder();
            buf.append(id.getParentId().toString());
            buf.append('.');
            buf.append(getNsIndex().stringToIndex(id.getName().getNamespaceURI()));
            buf.append('.');
            buf.append(getNameIndex().stringToIndex(id.getName().getLocalName()));
            buf.append('.');
            buf.append(index);
            return buf.toString();
        }


    private String buildPropFilePath(PropertyId id) {
        String fileName;
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(id.getName().getNamespaceURI().getBytes());
            md5.update(id.getName().getLocalName().getBytes());
            byte[] bytes = md5.digest();
            char[] chars = new char[32];
            for (int i = 0, j = 0; i < 16; i++) {
                chars[j++] = HEXDIGITS[(bytes[i] >> 4) & 0x0f];
                chars[j++] = HEXDIGITS[bytes[i] & 0x0f];
            }
            fileName = new String(chars) + ".xml";
        } catch (NoSuchAlgorithmException nsae) {
            // should never get here as MD5 should always be available in the JRE
            String msg = "MD5 not available";
            log.error(msg, nsae);
            throw new InternalError(msg + nsae);
        }
        return buildNodeFolderPath(id.getParentId()) + "/" + fileName;
    }


    private static String buildPropFilePath(PropertyId id) {
        String fileName;
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(id.getName().getNamespaceURI().getBytes());
            md5.update(id.getName().getLocalName().getBytes());
            byte[] bytes = md5.digest();
            char[] chars = new char[32];
            for (int i = 0, j = 0; i < 16; i++) {
                chars[j++] = HEXDIGITS[(bytes[i] >> 4) & 0x0f];
                chars[j++] = HEXDIGITS[bytes[i] & 0x0f];
            }
            fileName = new String(chars);
        } catch (NoSuchAlgorithmException nsae) {
            // should never get here as MD5 should always be available in the JRE
            String msg = "MD5 not available: ";
            log.error(msg, nsae);
            throw new InternalError(msg + nsae);
        }
        return buildNodeFolderPath(id.getParentId()) + FileSystem.SEPARATOR + fileName;
    }


    public void init(PMContext context) throws Exception {
        if (initialized) {
            throw new IllegalStateException("already initialized");
        }

        itemStateFS = new BasedFileSystem(context.getFileSystem(), "/data");

        /**
         * store BLOB data in local file system in a sub directory
         * of the workspace home directory
         */
        LocalFileSystem blobFS = new LocalFileSystem();
        blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
        blobFS.init();
        this.blobFS = blobFS;
        blobStore = new FileSystemBLOBStore(blobFS);

        initialized = true;
    }


    public void init(PMContext context) throws Exception {
        if (initialized) {
            throw new IllegalStateException("already initialized");
        }

        FileSystem wspFS = context.getFileSystem();
        itemStateFS = new BasedFileSystem(wspFS, "/data");

        /**
         * store BLOB data in local file system in a sub directory
         * of the workspace home directory
         */
        LocalFileSystem blobFS = new LocalFileSystem();
        blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
        blobFS.init();
        this.blobFS = blobFS;
        blobStore = new FileSystemBLOBStore(blobFS);

        initialized = true;
    }


    public synchronized void close() throws Exception {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            // close BLOB file system
            blobFS.close();
            blobFS = null;
            blobStore = null;
            /**
             * there's no need close the item state store because it
             * is based in the workspace's file system which is
             * closed by the repository
             */
        } finally {
            initialized = false;
        }
    }


    public synchronized void close() throws Exception {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            // close blob store
            blobStore.close();
            blobStore = null;
            itemFs.close();
            itemFs = null;
            super.close();
        } finally {
            initialized = false;
        }
    }


    public synchronized void close() throws Exception {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            if (nameIndex instanceof DbNameIndex) {
                ((DbNameIndex) nameIndex).close();
            }            
            // close blob store
            blobStore.close();
            blobStore = null;
            super.close();
        } finally {
            initialized = false;
        }
    }


    public synchronized void close() throws Exception {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            // close BLOB file system
            blobFS.close();
            blobFS = null;
            blobStore = null;
            /**
             * there's no need close the item state store because it
             * is based in the workspace's file system which is
             * closed by the repository
             */
        } finally {
            initialized = false;
        }
    }


    public synchronized NodeState load(NodeId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        Exception e = null;
        String nodeFilePath = buildNodeFilePath(id);

        try {
            if (!itemStateFS.isFile(nodeFilePath)) {
                throw new NoSuchItemStateException(id.toString());
            }
            InputStream in = itemStateFS.getInputStream(nodeFilePath);

            try {
                DOMWalker walker = new DOMWalker(in);
                String ntName = walker.getAttribute(NODETYPE_ATTRIBUTE);

                NodeState state = createNew(id);
                state.setNodeTypeName(factory.create(ntName));
                readState(walker, state);
                return state;
            } finally {
                in.close();
            }
        } catch (IOException ioe) {
            e = ioe;
            // fall through
        } catch (FileSystemException fse) {
            e = fse;
            // fall through
        }
        String msg = "failed to read node state: " + id;
        log.debug(msg);
        throw new ItemStateException(msg, e);
    }


    public synchronized NodeReferences loadReferencesTo(NodeId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        Exception e = null;
        String refsFilePath = buildNodeReferencesFilePath(id);
        try {
            if (!itemStateFS.isFile(refsFilePath)) {
                throw new NoSuchItemStateException(id.toString());
            }

            InputStream in = itemStateFS.getInputStream(refsFilePath);

            try {
                DOMWalker walker = new DOMWalker(in);
                NodeReferences refs = new NodeReferences(id);
                readState(walker, refs);
                return refs;
            } finally {
                in.close();
            }
        } catch (IOException ioe) {
            e = ioe;
            // fall through
        } catch (FileSystemException fse) {
            e = fse;
            // fall through
        }
        String msg = "failed to load references: " + id;
        log.debug(msg);
        throw new ItemStateException(msg, e);
    }


    public synchronized PropertyState load(PropertyId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        Exception e = null;
        String propFilePath = buildPropFilePath(id);

        try {
            if (!itemStateFS.isFile(propFilePath)) {
                throw new NoSuchItemStateException(id.toString());
            }
            InputStream in = itemStateFS.getInputStream(propFilePath);
            try {
                DOMWalker walker = new DOMWalker(in);
                PropertyState state = createNew(id);
                readState(walker, state);
                return state;
            } finally {
                in.close();
            }
        } catch (IOException ioe) {
            e = ioe;
            // fall through
        } catch (FileSystemException fse) {
            e = fse;
            // fall through
        }
        String msg = "failed to read property state: " + id.toString();
        log.debug(msg);
        throw new ItemStateException(msg, e);
    }


    protected void destroy(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        NodeId id = state.getNodeId();
        String nodeFilePath = buildNodeFilePath(id);
        FileSystemResource nodeFile = new FileSystemResource(itemStateFS, nodeFilePath);
        try {
            if (nodeFile.exists()) {
                // delete resource and prune empty parent folders
                nodeFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete node state: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    protected void destroy(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String refsFilePath = buildNodeReferencesFilePath(refs.getTargetId());
        FileSystemResource refsFile = new FileSystemResource(itemStateFS, refsFilePath);
        try {
            if (refsFile.exists()) {
                // delete resource and prune empty parent folders
                refsFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete " + refs;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    protected void destroy(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String refsFilePath = buildNodeReferencesFilePath(refs.getTargetId());
        FileSystemResource refsFile = new FileSystemResource(itemStateFS, refsFilePath);
        try {
            if (refsFile.exists()) {
                // delete resource and prune empty parent folders
                refsFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete " + refs;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    protected void destroy(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String nodeFilePath = buildNodeFilePath(state.getNodeId());
        FileSystemResource nodeFile = new FileSystemResource(itemStateFS, nodeFilePath);
        try {
            if (nodeFile.exists()) {
                // delete resource and prune empty parent folders
                nodeFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete node state: " + state.getNodeId();
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    protected void destroy(PropertyState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // delete binary values (stored as files)
        InternalValue[] values = state.getValues();
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                InternalValue val = values[i];
                if (val != null) {
                    val.deleteBinaryResource();
                }
            }
        }
        // delete property file
        String propFilePath = buildPropFilePath(state.getPropertyId());
        FileSystemResource propFile = new FileSystemResource(itemStateFS, propFilePath);
        try {
            if (propFile.exists()) {
                // delete resource and prune empty parent folders
                propFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete property state: " + state.getParentId() + "/" + state.getName();
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    protected void destroy(PropertyState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // delete binary values (stored as files)
        InternalValue[] values = state.getValues();
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                InternalValue val = values[i];
                if (val != null) {
                    val.deleteBinaryResource();
                }
            }
        }
        // delete property file
        String propFilePath = buildPropFilePath(state.getPropertyId());
        FileSystemResource propFile = new FileSystemResource(itemStateFS, propFilePath);
        try {
            if (propFile.exists()) {
                // delete resource and prune empty parent folders
                propFile.delete(true);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to delete property state: " + state.getParentId() + "/" + state.getName();
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean exists(NodeId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String nodeFilePath = buildNodeFilePath(id);
            FileSystemResource nodeFile = new FileSystemResource(itemStateFS, nodeFilePath);
            return nodeFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of item state: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean exists(PropertyId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String propFilePath = buildPropFilePath(id);
            FileSystemResource propFile = new FileSystemResource(itemStateFS, propFilePath);
            return propFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of item state: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean existsReferencesTo(NodeId id)
            throws ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String refsFilePath = buildNodeReferencesFilePath(id);
            FileSystemResource refsFile = new FileSystemResource(itemStateFS, refsFilePath);
            return refsFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of references: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean existsReferencesTo(NodeId id)
            throws ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String refsFilePath = buildNodeReferencesFilePath(id);
            FileSystemResource refsFile = new FileSystemResource(itemStateFS, refsFilePath);
            return refsFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of references: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean exists(PropertyId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String propFilePath = buildPropFilePath(id);
            FileSystemResource propFile = new FileSystemResource(itemStateFS, propFilePath);
            return propFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of item state: " + id;
            log.error(msg, fse);
            throw new ItemStateException(msg, fse);
        }
    }


    public synchronized boolean exists(NodeId id) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            String nodeFilePath = buildNodeFilePath(id);
            FileSystemResource nodeFile = new FileSystemResource(itemStateFS, nodeFilePath);
            return nodeFile.exists();
        } catch (FileSystemException fse) {
            String msg = "failed to check existence of item state: " + id;
            log.error(msg, fse);
            throw new ItemStateException(msg, fse);
        }
    }


    private String readName() throws IOException {
        int b = in.readUnsignedByte();
        if ((b & 0x80) == 0) {
            return "indexToName #" + b;
        } else {
            String uri;
            int ns = (b >> 4) & 0x07;
            if (ns < namespaces.length && namespaces[ns] != null) {
                uri = namespaces[ns];
            } else {
                uri = readString();
                if (ns < namespaces.length) {
                    namespaces[ns] = uri;
                }
            }
            String local = new String(readBytes((b & 0x0f) + 1, 0x10), "UTF-8");
            return uri + ":" + local;
        }
    }


    private Name readName() throws IOException {
        int b = in.readUnsignedByte();
        if ((b & 0x80) == 0) {
            return BundleNames.indexToName(b);
        } else {
            String uri;
            int ns = (b >> 4) & 0x07;
            if (ns < namespaces.length && namespaces[ns] != null) {
                uri = namespaces[ns];
            } else {
                uri = readString();
                if (ns < namespaces.length) {
                    namespaces[ns] = uri;
                }
            }

            String local = new String(readBytes((b & 0x0f) + 1, 0x10), "UTF-8");

            return NameFactoryImpl.getInstance().create(uri, local);
        }
    }


    private long readVarLong() throws IOException {
        long value = 0;
        int bits = 0;
        long b;
        do {
            b = in.readUnsignedByte();
            if (bits < 57) {
                value = (b & 0x7f) << 57 | value >>> 7;
                bits += 7;
            } else {
                value = (b & 0x01) << 63 | value >>> 1;
                bits = 64;
            }
        } while ((b & 0x80) != 0);
        value = value >>> (64 - bits);
        if ((value & 1) != 0) {
            return ~(value >>> 1);
        } else {
            return value >>> 1;
        }
    }


    private long readVarLong() throws IOException {
        long value = 0;
        int bits = 0;
        long b;
        do {
            b = in.readUnsignedByte();
            if (bits < 57) {
                value = (b & 0x7f) << 57 | value >>> 7;
                bits += 7;
            } else {
                value = (b & 0x01) << 63 | value >>> 1;
                bits = 64;
            }
        } while ((b & 0x80) != 0);
        value = value >>> (64 - bits);
        if ((value & 1) != 0) {
            return ~(value >>> 1);
        } else {
            return value >>> 1;
        }
    }


    private Calendar readDate() throws IOException {
        long ts = readVarLong();

        TimeZone tz;
        if ((ts & 1) == 0) {
            tz = COMMON_TIMEZONES[0];
            ts >>= 1;
        } else if ((ts & 2) == 0) {
            tz = COMMON_TIMEZONES[((int) ts >> 2) & 0x1f]; // 5 bits;
            ts >>= 7;
        } else {
            int m = ((int) ts << 19) >> 21; // 11 bits, sign-extended
            int h = m / 60;
            String s;
            if (m < 0) {
                s = String.format("GMT-%02d:%02d", -h, h * 60 - m);
            } else {
                s = String.format("GMT+%02d:%02d", h, m - h * 60);
            }
            tz = TimeZone.getTimeZone(s);
            ts >>= 13;
        }

        int u = 0;
        int s = 0;
        int m = 0;
        int h = 0;
        int type = (int) ts & 3;
        ts >>= 2;
        switch (type) {
        case 3:
            u = (int) ts & 0x3fffffff; // 30 bits
            s = u / 1000;
            m = s / 60;
            h = m / 60;
            m -= h * 60;
            s -= (h * 60 + m) * 60;
            u -= ((h * 60 + m) * 60 + s) * 1000;
            ts >>= 30;
            break;
        case 2:
            m = (int) ts & 0x07ff; // 11 bits
            h = m / 60;
            m -= h * 60;
            ts >>= 11;
            break;
        case 1:
            h = (int) ts & 0x1f; // 5 bits
            ts >>= 5;
            break;
        }

        int d = (int) ts & 0x01ff; // 9 bits;
        ts >>= 9;
        int y = (int) (ts + 2010);

        Calendar value = Calendar.getInstance(tz);
        if (y <= 0) {
            value.set(Calendar.YEAR, 1 - y);
            value.set(Calendar.ERA, GregorianCalendar.BC);
        } else {
            value.set(Calendar.YEAR, y);
            value.set(Calendar.ERA, GregorianCalendar.AD);
        }
        value.set(Calendar.DAY_OF_YEAR, d);
        value.set(Calendar.HOUR_OF_DAY, h);
        value.set(Calendar.MINUTE, m);
        value.set(Calendar.SECOND, s);
        value.set(Calendar.MILLISECOND, u);

        return value;
    }


    private Calendar readDate() throws IOException {
        long ts = readVarLong();

        TimeZone tz;
        if ((ts & 1) == 0) {
            tz = COMMON_TIMEZONES[0];
            ts >>= 1;
        } else if ((ts & 2) == 0) {
            tz = COMMON_TIMEZONES[((int) ts >> 2) & 0x1f]; // 5 bits;
            ts >>= 7;
        } else {
            int m = ((int) ts << 19) >> 21; // 11 bits, sign-extended
            int h = m / 60;
            String s;
            if (m < 0) {
                s = String.format("GMT-%02d:%02d", -h, h * 60 - m);
            } else {
                s = String.format("GMT+%02d:%02d", h, m - h * 60);
            }
            tz = TimeZone.getTimeZone(s);
            ts >>= 13;
        }

        int u = 0;
        int s = 0;
        int m = 0;
        int h = 0;
        int type = (int) ts & 3;
        ts >>= 2;
        switch (type) {
        case 3:
            u = (int) ts & 0x3fffffff; // 30 bits
            s = u / 1000;
            m = s / 60;
            h = m / 60;
            m -= h * 60;
            s -= (h * 60 + m) * 60;
            u -= ((h * 60 + m) * 60 + s) * 1000;
            ts >>= 30;
            break;
        case 2:
            m = (int) ts & 0x07ff; // 11 bits
            h = m / 60;
            m -= h * 60;
            ts >>= 11;
            break;
        case 1:
            h = (int) ts & 0x1f; // 5 bits
            ts >>= 5;
            break;
        }

        int d = (int) ts & 0x01ff; // 9 bits;
        ts >>= 9;
        int y = (int) (ts + 2010);

        Calendar value = Calendar.getInstance(tz);
        if (y <= 0) {
            value.set(Calendar.YEAR, 1 - y);
            value.set(Calendar.ERA, GregorianCalendar.BC);
        } else {
            value.set(Calendar.YEAR, y);
            value.set(Calendar.ERA, GregorianCalendar.AD);
        }
        value.set(Calendar.DAY_OF_YEAR, d);
        value.set(Calendar.HOUR_OF_DAY, h);
        value.set(Calendar.MINUTE, m);
        value.set(Calendar.SECOND, s);
        value.set(Calendar.MILLISECOND, u);

        return value;
    }


    protected int insertString(String string) {
        // assert index does not exist
        try {
            conHelper.exec(nameInsertSQL, new Object[]{string});
            return getGeneratedKey();
        } catch (Exception e) {
            IllegalStateException ise = new IllegalStateException("Unable to insert index for string: " + string);
            ise.initCause(e);
            throw ise;
        }
    }


    protected int insertString(String string) {
        // assert index does not exist
        try {
            conHelper.exec(nameInsertSQL, new Object[] { string });
        } catch (Exception e) {
            IllegalStateException ise = new IllegalStateException(
                    "Unable to insert index for string: " + string);
            ise.initCause(e);
            throw ise;
        }
        return getIndex(string);
    }


    public StringIndex getNameIndex() {
        try {
            if (nameIndex == null) {
                FileSystemResource res = new FileSystemResource(context.getFileSystem(), RES_NAME_INDEX);
                if (res.exists()) {
                    nameIndex = super.getNameIndex();
                } else {
                    // create db nameindex
                    nameIndex = createDbNameIndex();
                }
            }
            return nameIndex;
        } catch (Exception e) {
            IllegalStateException exception =
                new IllegalStateException("Unable to create nsIndex");
            exception.initCause(e);
            throw exception;
        }
    }


    public StringIndex getNsIndex() {
        try {
            if (nsIndex == null) {
                // load name and ns index
                FileSystemResource nsFile = new FileSystemResource(context.getFileSystem(), RES_NS_INDEX);
                if (nsFile.exists()) {
                    nsIndex = new FileBasedIndex(nsFile);
                } else {
                    nsIndex = (StringIndex) context.getNamespaceRegistry();
                }
            }
            return nsIndex;
        } catch (Exception e) {
            IllegalStateException e2 = new IllegalStateException("Unable to create nsIndex.");
            e2.initCause(e);
            throw e2;
        }
    }


    public synchronized List<NodeId> getAllNodeIds(NodeId bigger, int maxCount)
            throws ItemStateException, RepositoryException {
        ResultSet rs = null;
        try {
            String sql = bundleSelectAllIdsSQL;
            NodeId lowId = null;
            Object[] keys = new Object[0];
            if (bigger != null) {
                sql = bundleSelectAllIdsFromSQL;
                lowId = bigger;
                keys = getKey(bigger);
            }
            if (getStorageModel() == SM_LONGLONG_KEYS  && maxCount > 0) {
                // get some more rows, in case the first row is smaller
                // only required for SM_LONGLONG_KEYS
                // probability is very low to get get the wrong first key, < 1 : 2^64
                // see also bundleSelectAllIdsFrom SQL statement
                maxCount += 10;
            }
            rs = conHelper.exec(sql, keys, false, maxCount);
            ArrayList<NodeId> result = new ArrayList<NodeId>();
            while ((maxCount == 0 || result.size() < maxCount) && rs.next()) {
                NodeId current;
                if (getStorageModel() == SM_BINARY_KEYS) {
                    current = new NodeId(rs.getBytes(1));
                } else {
                    long high = rs.getLong(1);
                    long low = rs.getLong(2);
                    current = new NodeId(high, low);
                    if (lowId != null) {
                        // skip the keys that are smaller or equal (see above, maxCount += 10)
                        // only required for SM_LONGLONG_KEYS
                        if (current.compareTo(lowId) <= 0) {
                            continue;
                        }
                    }
                }
                result.add(current);
            }
            return result;
        } catch (SQLException e) {
            String msg = "getAllNodeIds failed.";
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            DbUtility.close(rs);
        }
    }


    public synchronized Map<NodeId, NodeInfo> getAllNodeInfos(NodeId bigger, int maxCount) throws ItemStateException {
        ResultSet rs = null;
        try {
            String sql = bundleSelectAllBundlesSQL;
            NodeId lowId = null;
            Object[] keys = new Object[0];
            if (bigger != null) {
                sql = bundleSelectAllBundlesFromSQL;
                lowId = bigger;
                keys = getKey(bigger);
            }
            if (getStorageModel() == SM_LONGLONG_KEYS && maxCount > 0) {
                // get some more rows, in case the first row is smaller
                // only required for SM_LONGLONG_KEYS
                // probability is very low to get get the wrong first key, < 1 : 2^64
                // see also bundleSelectAllIdsFrom SQL statement
                maxCount += 10;
            }
            rs = conHelper.exec(sql, keys, false, maxCount);
            Map<NodeId, NodeInfo> result = new LinkedHashMap<NodeId, NodeInfo>(maxCount);
            while ((maxCount == 0 || result.size() < maxCount) && rs.next()) {
                NodeId current;
                if (getStorageModel() == SM_BINARY_KEYS) {
                    current = new NodeId(rs.getBytes(1));
                } else {
                    long high = rs.getLong(1);
                    long low = rs.getLong(2);
                    current = new NodeId(high, low);
                }
                if (getStorageModel() == SM_LONGLONG_KEYS && lowId != null) {
                    // skip the keys that are smaller or equal (see above, maxCount += 10)
                    if (current.compareTo(lowId) <= 0) {
                        continue;
                    }
                }
                NodePropBundle bundle = readBundle(current, rs, getStorageModel() == SM_LONGLONG_KEYS ? 3 : 2);
                NodeInfo nodeInfo = new NodeInfo(bundle);
                result.put(nodeInfo.getId(), nodeInfo);
            }
            return result;
        } catch (SQLException e) {
            String msg = "getAllNodeIds failed.";
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            DbUtility.close(rs);
        }
    }


    protected synchronized void destroyBundle(NodePropBundle bundle) throws ItemStateException {
        try {
            conHelper.update(bundleDeleteSQL, getKey(bundle.getId()));
        } catch (Exception e) {
            if (e instanceof NoSuchItemStateException) {
                throw (NoSuchItemStateException) e;
            }
            String msg = "failed to delete bundle: " + bundle.getId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    protected synchronized void destroyBundle(NodePropBundle bundle) throws ItemStateException {
        try {
            StringBuffer buf = buildNodeFilePath(null, bundle.getId());
            itemFs.deleteFile(buf.toString());
        } catch (Exception e) {
            if (e instanceof NoSuchItemStateException) {
                throw (NoSuchItemStateException) e;
            }
            String msg = "failed to delete bundle: " + bundle.getId();
            BundleFsPersistenceManager.log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized NodeReferences loadReferencesTo(NodeId targetId)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        ResultSet rs = null;
        InputStream in = null;
        try {
            rs = conHelper.exec(nodeReferenceSelectSQL, getKey(targetId), false, 0);
            if (!rs.next()) {
                throw new NoSuchItemStateException(targetId.toString());
            }

            in = rs.getBinaryStream(1);
            NodeReferences refs = new NodeReferences(targetId);
            Serializer.deserialize(refs, in);

            return refs;
        } catch (Exception e) {
            if (e instanceof NoSuchItemStateException) {
                throw (NoSuchItemStateException) e;
            }
            String msg = "failed to read references: " + targetId;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            IOUtils.closeQuietly(in);
            DbUtility.close(rs);
        }
    }


    public NodeState load(NodeId id)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (nodeStateSelectSQL) {
            ResultSet rs = null;
            InputStream in = null;
            try {
                Statement stmt = executeStmt(nodeStateSelectSQL, new Object[]{id.toString()});
                rs = stmt.getResultSet();
                if (!rs.next()) {
                    throw new NoSuchItemStateException(id.toString());
                }

                in = rs.getBinaryStream(1);
                NodeState state = createNew(id);
                Serializer.deserialize(state, in);

                return state;
            } catch (Exception e) {
                if (e instanceof NoSuchItemStateException) {
                    throw (NoSuchItemStateException) e;
                }
                String msg = "failed to read node state: " + id;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                IOUtils.closeQuietly(in);
                closeResultSet(rs);
            }
        }
    }


    public NodeReferences loadReferencesTo(NodeId targetId)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (nodeReferenceSelectSQL) {
            ResultSet rs = null;
            InputStream in = null;
            try {
                Statement stmt = executeStmt(
                        nodeReferenceSelectSQL, new Object[]{targetId.toString()});
                rs = stmt.getResultSet();
                if (!rs.next()) {
                    throw new NoSuchItemStateException(targetId.toString());
                }

                in = rs.getBinaryStream(1);
                NodeReferences refs = new NodeReferences(targetId);
                Serializer.deserialize(refs, in);

                return refs;
            } catch (Exception e) {
                if (e instanceof NoSuchItemStateException) {
                    throw (NoSuchItemStateException) e;
                }
                String msg = "failed to read node references: " + targetId;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                IOUtils.closeQuietly(in);
                closeResultSet(rs);
            }
        }
    }


    public PropertyState load(PropertyId id)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        synchronized (propertyStateSelectSQL) {
            ResultSet rs = null;
            InputStream in = null;
            try {
                Statement stmt = executeStmt(propertyStateSelectSQL, new Object[]{id.toString()});
                rs = stmt.getResultSet();
                if (!rs.next()) {
                    throw new NoSuchItemStateException(id.toString());
                }

                in = rs.getBinaryStream(1);

                if (!externalBLOBs) {
                    // JCR-1532: pre-fetch/buffer stream data
                    ByteArrayInputStream bain = new ByteArrayInputStream(
                            IOUtils.toByteArray(in));
                    IOUtils.closeQuietly(in);
                    in = bain;
                }

                PropertyState state = createNew(id);
                Serializer.deserialize(state, in, blobStore);

                return state;
            } catch (Exception e) {
                if (e instanceof NoSuchItemStateException) {
                    throw (NoSuchItemStateException) e;
                }
                String msg = "failed to read property state: " + id;
                log.error(msg, e);
                throw new ItemStateException(msg, e);
            } finally {
                IOUtils.closeQuietly(in);
                closeResultSet(rs);
            }
        }
    }


    public synchronized void store(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = existsReferencesTo(refs.getTargetId());
        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize references
            Serializer.serialize(refs, out);

            Object[] params = createParams(refs.getTargetId(), out.toByteArray(), true);
            conHelper.exec(sql, params);
            
            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write " + refs;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void store(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = state.getStatus() != ItemState.STATUS_NEW;
        //boolean update = exists(state.getId());
        String sql = (update) ? nodeStateUpdateSQL : nodeStateInsertSQL;

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize node state
            Serializer.serialize(state, out);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            executeStmt(sql, new Object[]{out.toByteArray(), state.getNodeId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write node state: " + state.getNodeId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void store(PropertyState state)
            throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = state.getStatus() != ItemState.STATUS_NEW;
        //boolean update = exists(state.getId());
        String sql = (update) ? propertyStateUpdateSQL : propertyStateInsertSQL;

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize property state
            Serializer.serialize(state, out, blobStore);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            executeStmt(sql, new Object[]{out.toByteArray(), state.getPropertyId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write property state: " + state.getPropertyId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void store(NodeReferences refs)
            throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = existsReferencesTo(refs.getTargetId());
        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;

        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize references
            Serializer.serialize(refs, out);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            executeStmt(sql, new Object[]{out.toByteArray(), refs.getTargetId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write " + refs;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void destroy(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            conHelper.exec(nodeReferenceDeleteSQL, getKey(refs.getTargetId()));
        } catch (Exception e) {
            if (e instanceof NoSuchItemStateException) {
                throw (NoSuchItemStateException) e;
            }
            String msg = "failed to delete " + refs;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void destroy(NodeReferences refs)
            throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            executeStmt(nodeReferenceDeleteSQL, new Object[]{refs.getTargetId().toString()});
        } catch (Exception e) {
            String msg = "failed to delete " + refs;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void destroy(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }
        try {
            StringBuffer buf = buildNodeReferencesFilePath(null, refs.getTargetId());
            itemFs.deleteFile(buf.toString());
        } catch (Exception e) {
            if (e instanceof NoSuchItemStateException) {
                throw (NoSuchItemStateException) e;
            }
            String msg = "failed to delete " + refs;
            BundleFsPersistenceManager.log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void destroy(NodeState state)
            throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        try {
            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            executeStmt(nodeStateDeleteSQL, new Object[]{state.getNodeId().toString()});
        } catch (Exception e) {
            String msg = "failed to delete node state: " + state.getNodeId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    private static String buildNodeFolderPath(NodeId id) {
        StringBuilder sb = new StringBuilder();
        char[] chars = id.toString().toCharArray();
        int cnt = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '-') {
                continue;
            }
            //if (cnt > 0 && cnt % 4 == 0) {
            if (cnt == 2 || cnt == 4) {
                sb.append(FileSystem.SEPARATOR_CHAR);
            }
            sb.append(chars[i]);
            cnt++;
        }
        return sb.toString();
    }


    protected StringBuffer buildNodeFolderPath(StringBuffer buf, NodeId id) {
        if (buf == null) {
            buf = new StringBuffer();
        }
        char[] chars = id.toString().toCharArray();
        int cnt = 0;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '-') {
                continue;
            }
            //if (cnt > 0 && cnt % 4 == 0) {
            if (cnt == 2 || cnt == 4) {
                buf.append(FileSystem.SEPARATOR_CHAR);
            }
            buf.append(chars[i]);
            cnt++;
        }
        return buf;
    }


    public synchronized NodeState load(NodeId id)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String nodeFilePath = buildNodeFilePath(id);

        try {
            if (!itemStateFS.isFile(nodeFilePath)) {
                throw new NoSuchItemStateException(nodeFilePath);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to read node state: " + nodeFilePath;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }

        try {
            BufferedInputStream in =
                    new BufferedInputStream(itemStateFS.getInputStream(nodeFilePath));
            try {
                NodeState state = createNew(id);
                Serializer.deserialize(state, in);
                return state;
            } catch (Exception e) {
                String msg = "failed to read node state: " + id;
                log.debug(msg);
                throw new ItemStateException(msg, e);
            } finally {
                in.close();
            }
        } catch (Exception e) {
            String msg = "failed to read node state: " + nodeFilePath;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized PropertyState load(PropertyId id)
            throws NoSuchItemStateException, ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String propFilePath = buildPropFilePath(id);

        try {
            if (!itemStateFS.isFile(propFilePath)) {
                throw new NoSuchItemStateException(propFilePath);
            }
        } catch (FileSystemException fse) {
            String msg = "failed to read property state: " + propFilePath;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }

        try {
            BufferedInputStream in =
                    new BufferedInputStream(itemStateFS.getInputStream(propFilePath));
            try {
                PropertyState state = createNew(id);
                Serializer.deserialize(state, in, blobStore);
                return state;
            } finally {
                in.close();
            }
        } catch (Exception e) {
            String msg = "failed to read property state: " + propFilePath;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized NodeReferences loadReferencesTo(NodeId id)
            throws NoSuchItemStateException, ItemStateException {

        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String refsFilePath = buildNodeReferencesFilePath(id);

        try {
            if (!itemStateFS.isFile(refsFilePath)) {
                throw new NoSuchItemStateException(id.toString());
            }
        } catch (FileSystemException fse) {
            String msg = "failed to load references: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, fse);
        }

        try {
            BufferedInputStream in =
                    new BufferedInputStream(itemStateFS.getInputStream(refsFilePath));
            try {
                NodeReferences refs = new NodeReferences(id);
                Serializer.deserialize(refs, in);
                return refs;
            } finally {
                in.close();
            }
        } catch (Exception e) {
            String msg = "failed to load references: " + id;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String nodeFilePath = buildNodeFilePath(state.getNodeId());
        FileSystemResource nodeFile = new FileSystemResource(itemStateFS, nodeFilePath);
        try {
            nodeFile.makeParentDirs();
            BufferedOutputStream out = new BufferedOutputStream(nodeFile.getOutputStream());
            try {
                // serialize node state
                Serializer.serialize(state, out);
            } finally {
                out.close();
            }
        } catch (Exception e) {
            String msg = "failed to write node state: " + state.getNodeId();
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String refsFilePath = buildNodeReferencesFilePath(refs.getTargetId());
        FileSystemResource refsFile = new FileSystemResource(itemStateFS, refsFilePath);
        try {
            refsFile.makeParentDirs();
            OutputStream out = new BufferedOutputStream(refsFile.getOutputStream());
            try {
                Serializer.serialize(refs, out);
            } finally {
                out.close();
            }
        } catch (Exception e) {
            String msg = "failed to store " + refs;
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    protected void store(PropertyState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        String propFilePath = buildPropFilePath(state.getPropertyId());
        FileSystemResource propFile = new FileSystemResource(itemStateFS, propFilePath);
        try {
            propFile.makeParentDirs();
            BufferedOutputStream out = new BufferedOutputStream(propFile.getOutputStream());
            try {
                // serialize property state
                Serializer.serialize(state, out, blobStore);
            } finally {
                out.close();
            }
        } catch (Exception e) {
            String msg = "failed to store property state: " + state.getParentId() + "/" + state.getName();
            log.debug(msg);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void store(NodeState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = state.getStatus() != ItemState.STATUS_NEW;
        //boolean update = exists((NodeId) state.getId());
        String sql = (update) ? nodeStateUpdateSQL : nodeStateInsertSQL;

        Blob blob = null;
        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize node state
            Serializer.serialize(state, out);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            blob = createTemporaryBlob(new ByteArrayInputStream(out.toByteArray()));
            executeStmt(sql, new Object[]{blob, state.getNodeId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write node state: " + state.getId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            if (blob != null) {
                try {
                    freeTemporaryBlob(blob);
                } catch (Exception ignore) {
                }
            }
        }
    }


    public synchronized void store(PropertyState state) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = state.getStatus() != ItemState.STATUS_NEW;
        //boolean update = exists((PropertyId) state.getId());
        String sql = (update) ? propertyStateUpdateSQL : propertyStateInsertSQL;

        Blob blob = null;
        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize property state
            Serializer.serialize(state, out, blobStore);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            blob = createTemporaryBlob(new ByteArrayInputStream(out.toByteArray()));
            executeStmt(sql, new Object[]{blob, state.getPropertyId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write property state: " + state.getId();
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            if (blob != null) {
                try {
                    freeTemporaryBlob(blob);
                } catch (Exception ignore) {
                }
            }
        }
    }


    public synchronized void store(NodeReferences refs) throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }

        // check if insert or update
        boolean update = existsReferencesTo(refs.getTargetId());
        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;

        Blob blob = null;
        try {
            ByteArrayOutputStream out =
                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
            // serialize references
            Serializer.serialize(refs, out);

            // we are synchronized on this instance, therefore we do not
            // not have to additionally synchronize on the sql statement
            blob = createTemporaryBlob(new ByteArrayInputStream(out.toByteArray()));
            executeStmt(sql, new Object[]{blob, refs.getTargetId().toString()});

            // there's no need to close a ByteArrayOutputStream
            //out.close();
        } catch (Exception e) {
            String msg = "failed to write " + refs;
            log.error(msg, e);
            throw new ItemStateException(msg, e);
        } finally {
            if (blob != null) {
                try {
                    freeTemporaryBlob(blob);
                } catch (Exception ignore) {
                }
            }
        }
    }


    protected void checkSchema() throws Exception {
        DatabaseMetaData metaData = con.getMetaData();
        String tableName = schemaObjectPrefix + "NODE";
        if (metaData.storesLowerCaseIdentifiers()) {
            tableName = tableName.toLowerCase();
        } else if (metaData.storesUpperCaseIdentifiers()) {
            tableName = tableName.toUpperCase();
        }
        String userName = metaData.getUserName();

        ResultSet rs = metaData.getTables(null, userName, tableName, null);
        boolean schemaExists;
        try {
            schemaExists = rs.next();
        } finally {
            rs.close();
        }

        if (!schemaExists) {
            // read ddl from resources
            InputStream in = getSchemaDDL();
            if (in == null) {
                String msg = "Configuration error: unknown schema '" + schema + "'";
                log.debug(msg);
                throw new RepositoryException(msg);
            }
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            Statement stmt = con.createStatement();
            try {
                String sql = reader.readLine();
                while (sql != null) {
                    // Skip comments and empty lines
                    if (!sql.startsWith("#") && sql.length() > 0) {
                        // replace prefix variable
                        sql = Text.replace(sql, SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);

                        // set the tablespace if it is defined
                        String tspace;
                        if (tableSpace == null || "".equals(tableSpace)) {
                            tspace = "";
                        } else {
                            tspace = "tablespace " + tableSpace;
                        }
                        sql = Text.replace(sql, TABLE_SPACE_VARIABLE, tspace).trim();

                        // execute sql stmt
                        stmt.executeUpdate(sql);
                    }
                    // read next sql stmt
                    sql = reader.readLine();
                }
                // commit the changes
                con.commit();
            } finally {
                IOUtils.closeQuietly(in);
                closeStatement(stmt);
            }
        }
    }


    protected void checkSchema() throws Exception {
        DatabaseMetaData metaData = con.getMetaData();
        String tableName = schemaObjectPrefix + "NODE";
        if (metaData.storesLowerCaseIdentifiers()) {
            tableName = tableName.toLowerCase();
        } else if (metaData.storesUpperCaseIdentifiers()) {
            tableName = tableName.toUpperCase();
        }

        ResultSet rs = metaData.getTables(null, null, tableName, null);
        boolean schemaExists;
        try {
            schemaExists = rs.next();
        } finally {
            rs.close();
        }

        if (!schemaExists) {
            // read ddl from resources
            InputStream in = getSchemaDDL();
            if (in == null) {
                String msg = "Configuration error: unknown schema '" + schema + "'";
                log.debug(msg);
                throw new RepositoryException(msg);
            }
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            Statement stmt = con.createStatement();
            try {
                String sql = reader.readLine();
                while (sql != null) {
                    // Skip comments and empty lines
                    if (!sql.startsWith("#") && sql.length() > 0) {
                        // replace prefix variable
                        sql = createSchemaSql(sql);
                        // execute sql stmt
                        stmt.executeUpdate(sql);
                    }
                    // read next sql stmt
                    sql = reader.readLine();
                }
                // commit the changes
                con.commit();
            } finally {
                IOUtils.closeQuietly(in);
                closeStatement(stmt);
            }
        }
    }


    protected Blob createTemporaryBlob(InputStream in) throws Exception {
        /*
        BLOB blob = BLOB.createTemporary(con, false, BLOB.DURATION_SESSION);
        blob.open(BLOB.MODE_READWRITE);
        OutputStream out = blob.getBinaryOutputStream();
        ...
        out.flush();
        out.close();
        blob.close();
        return blob;
        */
        Method createTemporary = blobClass.getMethod("createTemporary",
                new Class[]{Connection.class, Boolean.TYPE, Integer.TYPE});
        Object blob = createTemporary.invoke(null, new Object[]{
                ConnectionFactory.unwrap(con),
                Boolean.FALSE, durationSessionConstant });
        Method open = blobClass.getMethod("open", new Class[]{Integer.TYPE});
        open.invoke(blob, new Object[]{modeReadWriteConstant});
        Method getBinaryOutputStream =
                blobClass.getMethod("getBinaryOutputStream", new Class[0]);
        OutputStream out = (OutputStream) getBinaryOutputStream.invoke(blob);
        try {
            IOUtils.copy(in, out);
        } finally {
            try {
                out.flush();
            } catch (IOException ioe) {
            }
            out.close();
        }
        Method close = blobClass.getMethod("close", new Class[0]);
        close.invoke(blob);
        return (Blob) blob;
    }


    private Blob createTemporaryBlob(Connection con, InputStream in) throws Exception {
        /*
         * BLOB blob = BLOB.createTemporary(con, false, BLOB.DURATION_SESSION);
         * blob.open(BLOB.MODE_READWRITE); OutputStream out = blob.getBinaryOutputStream(); ... out.flush();
         * out.close(); blob.close(); return blob;
         */
        Method createTemporary =
            blobClass.getMethod("createTemporary", new Class[]{Connection.class, Boolean.TYPE, Integer.TYPE});
        Object blob =
            createTemporary.invoke(null, new Object[]{ConnectionFactory.unwrap(con), Boolean.FALSE,
                    durationSessionConstant});
        Method open = blobClass.getMethod("open", new Class[]{Integer.TYPE});
        open.invoke(blob, new Object[]{modeReadWriteConstant});
        Method getBinaryOutputStream = blobClass.getMethod("getBinaryOutputStream", new Class[0]);
        OutputStream out = (OutputStream) getBinaryOutputStream.invoke(blob);
        try {
            IOUtils.copy(in, out);
        } finally {
            try {
                out.flush();
            } catch (IOException ioe) {
            }
            out.close();
        }
        Method close = blobClass.getMethod("close", new Class[0]);
        close.invoke(blob);
        return (Blob) blob;
    }


    protected synchronized void storeBundle(NodePropBundle bundle) throws ItemStateException {
        try {
            StringBuffer buf = buildNodeFolderPath(null, bundle.getId());
            buf.append('.');
            buf.append(NODEFILENAME);
            String fileName = buf.toString();
            String dir = fileName.substring(0, fileName.lastIndexOf(FileSystem.SEPARATOR_CHAR));
            if (!itemFs.exists(dir)) {
                itemFs.createFolder(dir);
            }
            OutputStream out = itemFs.getOutputStream(fileName);
            try {
                binding.writeBundle(out, bundle);
            } finally {
                out.close();
            }
        } catch (Exception e) {
            String msg = "failed to write bundle: " + bundle.getId();
            BundleFsPersistenceManager.log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


    public synchronized void store(NodeReferences refs)
            throws ItemStateException {
        if (!initialized) {
            throw new IllegalStateException("not initialized");
        }
        try {
            StringBuffer buf = buildNodeFolderPath(null, refs.getTargetId());
            buf.append('.');
            buf.append(NODEREFSFILENAME);
            String fileName = buf.toString();
            String dir = fileName.substring(0, fileName.lastIndexOf(FileSystem.SEPARATOR_CHAR));
            if (!itemFs.exists(dir)) {
                itemFs.createFolder(dir);
            }
            OutputStream out = itemFs.getOutputStream(fileName);
            Serializer.serialize(refs, out);
            out.close();
        } catch (Exception e) {
            String msg = "failed to write " + refs;
            BundleFsPersistenceManager.log.error(msg, e);
            throw new ItemStateException(msg, e);
        }
    }


        void doRepair(final ChangeLog changes) throws ItemStateException {
            final NodePropBundle bundle = getBundle(nodeId);
            final Iterator<NodePropBundle.ChildNodeEntry> entryIterator = bundle.getChildNodeEntries().iterator();
            while (entryIterator.hasNext()) {
                final NodePropBundle.ChildNodeEntry childNodeEntry = entryIterator.next();
                if (childNodeEntry.getId().equals(childNodeId)) {
                    entryIterator.remove();
                    saveBundle(bundle);
                    changes.modified(new NodeState(nodeId, null, null, ItemState.STATUS_EXISTING, false));
                }
            }
        }


        void doRepair(final ChangeLog changes) throws ItemStateException {
            NodePropBundle bundle = getBundle(nodeId);
            final Iterator<NodePropBundle.ChildNodeEntry> entryIterator = bundle.getChildNodeEntries().iterator();
            while (entryIterator.hasNext()) {
                final NodePropBundle.ChildNodeEntry childNodeEntry = entryIterator.next();
                if (childNodeEntry.getId().equals(childNodeId)) {
                    entryIterator.remove();
                    saveBundle(bundle);
                    changes.modified(new NodeState(nodeId, null, null, ItemState.STATUS_EXISTING, false));
                    break;
                }
            }
        }


        boolean doubleCheck() throws ItemStateException {
            final NodePropBundle childBundle = pm.loadBundle(childNodeId);
            if (childBundle == null) {
                final NodePropBundle bundle = pm.loadBundle(nodeId);
                if (bundle != null) {
                    for (NodePropBundle.ChildNodeEntry entry : bundle.getChildNodeEntries()) {
                        if (entry.getId().equals(childNodeId)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        boolean doubleCheck() throws ItemStateException {
            final NodePropBundle childBundle = pm.loadBundle(childNodeId);
            if (childBundle != null && !childBundle.getParentId().equals(nodeId)) {
                final NodePropBundle bundle = pm.loadBundle(nodeId);
                if (bundle != null) {
                    // double check if the child node entry is still there
                    for (NodePropBundle.ChildNodeEntry entry : bundle.getChildNodeEntries()) {
                        if (entry.getId().equals(childNodeId)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        boolean doubleCheck() throws ItemStateException {
            final NodePropBundle parentBundle = pm.loadBundle(parentNodeId);
            if (parentBundle == null) {
                final NodePropBundle bundle = pm.loadBundle(nodeId);
                if (bundle != null) {
                    if (parentNodeId.equals(bundle.getParentId())) {
                        return true;
                    }
                }
            }
            return false;
        }


    public void invalidate(Name name) {
        /**
         * remove all affected effective node types from aggregates cache
         * (copy keys first to prevent ConcurrentModificationException)
         */
        ArrayList<Key> keys = new ArrayList<Key>(aggregates.keySet());
        for (Iterator<Key> keysIter = keys.iterator(); keysIter.hasNext();) {
            Key k = keysIter.next();
            EffectiveNodeType ent = get(k);
            if (ent.includesNodeType(name)) {
                remove(k);
            }
        }
    }


    public void invalidate(Name name) {
        // remove all affected effective node types from aggregates cache
        // (copy keys first to prevent ConcurrentModificationException)
        ArrayList<Key> keys = new ArrayList<Key>(sortedKeys);
        for (Iterator<Key> keysIter = keys.iterator(); keysIter.hasNext();) {
            Key k = keysIter.next();
            EffectiveNodeType ent = get(k);
            if (ent.includesNodeType(name)) {
                remove(k);
            }
        }
    }


    public QPropertyDefinition getApplicablePropertyDef(Name name, int type,
                                            boolean multiValued)
            throws ConstraintViolationException {
        // try named property definitions first
        QPropertyDefinition match =
                getMatchingPropDef(getNamedPropDefs(name), type, multiValued);
        if (match != null) {
            return match;
        }

        // no item with that name defined;
        // try residual property definitions
        match = getMatchingPropDef(getUnnamedPropDefs(), type, multiValued);
        if (match != null) {
            return match;
        }

        // no applicable definition found
        throw new ConstraintViolationException("no matching property definition found for " + name);
    }


    public QPropertyDefinition getApplicablePropertyDef(Name name, int type)
            throws ConstraintViolationException {
        // try named property definitions first
        QPropertyDefinition match = getMatchingPropDef(getNamedPropDefs(name), type);
        if (match != null) {
            return match;
        }

        // no item with that name defined;
        // try residual property definitions
        match = getMatchingPropDef(getUnnamedPropDefs(), type);
        if (match != null) {
            return match;
        }

        // no applicable definition found
        throw new ConstraintViolationException("no matching property definition found for " + name);
    }


    public void checkRemoveItemConstraints(Name name) throws ConstraintViolationException {
        /**
         * as there might be multiple definitions with the same name and we
         * don't know which one is applicable, we check all of them
         */
        QItemDefinition[] defs = getNamedItemDefs(name);
        if (defs != null) {
            for (QItemDefinition def : defs) {
                if (def.isMandatory()) {
                    throw new ConstraintViolationException("can't remove mandatory item");
                }
                if (def.isProtected()) {
                    throw new ConstraintViolationException("can't remove protected item");
                }
            }
        }
    }


    public void checkRemoveNodeConstraints(Name name) throws ConstraintViolationException {
        /**
         * as there might be multiple definitions with the same name and we
         * don't know which one is applicable, we check all of them
         */
        QNodeDefinition[] defs = getNamedNodeDefs(name);
        if (defs != null) {
            for (QNodeDefinition def : defs) {
                if (def.isMandatory()) {
                    throw new ConstraintViolationException("can't remove mandatory node");
                }
                if (def.isProtected()) {
                    throw new ConstraintViolationException("can't remove protected node");
                }
            }
        }
    }


    public void checkRemovePropertyConstraints(Name name) throws ConstraintViolationException {
        /**
         * as there might be multiple definitions with the same name and we
         * don't know which one is applicable, we check all of them
         */
        QItemDefinition[] defs = getNamedPropDefs(name);
        if (defs != null) {
            for (QItemDefinition def : defs) {
                if (def.isMandatory()) {
                    throw new ConstraintViolationException("can't remove mandatory property");
                }
                if (def.isProtected()) {
                    throw new ConstraintViolationException("can't remove protected property");
                }
            }
        }
    }


    public void nodeTypeReRegistered(Name ntName) {
        // flush all affected cache entries
        ntCache.remove(ntName);
        synchronized (pdCache) {
            Iterator<PropertyDefinitionImpl> iter = pdCache.values().iterator();
            while (iter.hasNext()) {
                PropertyDefinitionImpl pd = iter.next();
                if (ntName.equals(pd.unwrap().getDeclaringNodeType())) {
                    iter.remove();
                }
            }
        }
        synchronized (ndCache) {
            Iterator<NodeDefinitionImpl> iter = ndCache.values().iterator();
            while (iter.hasNext()) {
                NodeDefinitionImpl nd = iter.next();
                if (ntName.equals(nd.unwrap().getDeclaringNodeType())) {
                    iter.remove();
                }
            }
        }
    }


    public void nodeTypesUnregistered(Collection<Name> names) {
        // flush all affected cache entries
        for (Name name : names) {
            ntCache.remove(name);
        }
        synchronized (pdCache) {
            Iterator<PropertyDefinitionImpl> iter = pdCache.values().iterator();
            while (iter.hasNext()) {
                PropertyDefinitionImpl pd = iter.next();
                if (names.contains(pd.unwrap().getDeclaringNodeType())) {
                    iter.remove();
                }
            }
        }
        synchronized (ndCache) {
            Iterator<NodeDefinitionImpl> iter = ndCache.values().iterator();
            while (iter.hasNext()) {
                NodeDefinitionImpl nd = iter.next();
                if (names.contains(nd.unwrap().getDeclaringNodeType())) {
                    iter.remove();
                }
            }
        }
    }


    public boolean itemExists(String absPath) throws RepositoryException {
        if (absPath != null && absPath.startsWith("[") && absPath.endsWith("]")) {
            // an identifier segment has been specified (JCR-3014)
            try {
                NodeId id = NodeId.valueOf(absPath.substring(1, absPath.length() - 1));
                return getItemManager().itemExists(id);
            } catch (IllegalArgumentException e) {
                throw new MalformedPathException(absPath);
            }
        }
        return perform(SessionItemOperation.itemExists(absPath));
    }


    public boolean nodeExists(String absPath) throws RepositoryException {
        if (absPath != null && absPath.startsWith("[") && absPath.endsWith("]")) {
            // an identifier segment has been specified (JCR-3014)
            try {
                NodeId id = NodeId.valueOf(absPath.substring(1, absPath.length() - 1));
                return getItemManager().itemExists(id);
            } catch (IllegalArgumentException e) {
                throw new MalformedPathException(absPath);
            }
        }
        return perform(SessionItemOperation.nodeExists(absPath));
    }


    void prepareEvents(EventStateCollection events) {
        Iterator<EventState> it = events.iterator();
        Set<ItemId> denied = null;
        while (it.hasNext()) {
            EventState state = it.next();
            if (state.getType() == Event.NODE_REMOVED
                    || state.getType() == Event.PROPERTY_REMOVED) {

                if (session.equals(state.getSession())) {
                    // if we created the event, we can be sure that
                    // we have enough access rights to see the event
                    continue;
                }

                // check read permission
                ItemId targetId = state.getTargetId();
                boolean granted = false;
                try {
                    granted = canRead(state);
                } catch (RepositoryException e) {
                    log.warn("Unable to check access rights for item: " + targetId);
                }
                if (!granted) {
                    if (denied == null) {
                        denied = new HashSet<ItemId>();
                    }
                    denied.add(targetId);
                }
            }
        }
        if (denied != null) {
            accessDenied.put(events, denied);
        }
    }


    void prepareDeleted(EventStateCollection events, Iterable<ItemState> deletedItems) {
        Set<ItemId> denied = null;
        Set<ItemId> deletedIds = new HashSet<ItemId>();
        for (ItemState state : deletedItems) {
            deletedIds.add(state.getId());
        }

        for (Iterator<EventState> it = events.iterator(); it.hasNext();) {
            EventState evState = it.next();
            ItemId targetId = evState.getTargetId();
            if (deletedIds.contains(targetId)) {
                // check read permission
                boolean granted = false;
                try {
                    granted = canRead(evState);
                } catch (RepositoryException e) {
                    log.warn("Unable to check access rights for item: " + targetId);
                }
                if (!granted) {
                    if (denied == null) {
                        denied = new HashSet<ItemId>();
                    }
                    denied.add(targetId);
                }
            }
        }
        if (denied != null) {
            accessDenied.put(events, denied);
        }
    }


    void addConsumer(EventConsumer consumer) {
        synchronized (consumerChange) {
            if (consumer.getEventListener() instanceof SynchronousEventListener) {
                // remove existing if any
                synchronousConsumers.remove(consumer);
                // re-add it
                synchronousConsumers.add(consumer);
                // reset read only consumer set
                synchronousReadOnlyConsumers = null;
            } else {
                // remove existing if any
                activeConsumers.remove(consumer);
                // re-add it
                activeConsumers.add(consumer);
                // reset read only consumer set
                readOnlyConsumers = null;
            }
        }
    }


    void removeConsumer(EventConsumer consumer) {
        synchronized (consumerChange) {
            if (consumer.getEventListener() instanceof SynchronousEventListener) {
                synchronousConsumers.remove(consumer);
                // reset read only listener set
                synchronousReadOnlyConsumers = null;
            } else {
                activeConsumers.remove(consumer);
                // reset read only listener set
                readOnlyConsumers = null;
            }
        }
    }


    public ObservationManagerImpl(
            ObservationDispatcher dispatcher, SessionImpl session,
            ClusterNode clusterNode) {
        if (dispatcher == null) {
            throw new NullPointerException("dispatcher");
        }
        if (session == null) {
            throw new NullPointerException("session");
        }

        this.dispatcher = dispatcher;
        this.session = session;
        this.clusterNode = clusterNode;
    }


    public ClientEventPoll(RemoteObservationManager remote, Session session)
            throws NullPointerException {
        super(THREAD_NAME);

        // check remote and session
        if (remote == null) {
            throw new NullPointerException("remote");
        }
        if (session == null) {
            throw new NullPointerException("session");
        }

        this.remote = remote;
        this.session = session;
    }


    public ItemState[] retrieveAll() {
        List<ItemState> states = new ArrayList<ItemState>();
        for (int i = 0; i < segments.length; i++) {
            synchronized (segments[i]) {
                states.addAll(segments[i].values());
            }
        }
        return states.toArray(new ItemState[states.size()]);
    }


    private static HashSet<String> getPathSet(Node[] nodes) throws RepositoryException {
    		HashSet<String> paths = new HashSet<String>();
    		if (nodes != null) {
    	        for (int i = 0; i < nodes.length; i++) {
    	        		paths.add(nodes[i].getPath());
        		}
    		}
    		return paths;
    }


    public NodeState createTransientNodeState(NodeState overlayedState, int initialStatus)
            throws ItemStateException {

        ItemId id = overlayedState.getNodeId();

        // check map; synchronized to ensure an entry is not created twice.
        synchronized (transientStore) {
            if (transientStore.containsKey(id)) {
                String msg = "there's already a node state instance with id " + id;
                log.debug(msg);
                throw new ItemStateException(msg);
            }

            NodeState state = new NodeState(overlayedState, initialStatus, true);
            // put transient state in the map
            transientStore.put(id, state);
            state.setContainer(this);
            return state;
        }
    }


    public PropertyState createTransientPropertyState(NodeId parentId, Name propName, int initialStatus)
            throws ItemStateException {

        PropertyId id = new PropertyId(parentId, propName);

        // check map; synchronized to ensure an entry is not created twice.
        synchronized (transientStore) {
            if (transientStore.containsKey(id)) {
                String msg = "there's already a property state instance with id " + id;
                log.debug(msg);
                throw new ItemStateException(msg);
            }

            PropertyState state = new PropertyState(id, initialStatus, true);
            // put transient state in the map
            transientStore.put(id, state);
            state.setContainer(this);
            return state;
        }
    }


    public PropertyState createTransientPropertyState(PropertyState overlayedState, int initialStatus)
            throws ItemStateException {

        PropertyId id = overlayedState.getPropertyId();

        // check map; synchronized to ensure an entry is not created twice.
        synchronized (transientStore) {
            if (transientStore.containsKey(id)) {
                String msg = "there's already a property state instance with id " + id;
                log.debug(msg);
                throw new ItemStateException(msg);
            }

            PropertyState state = new PropertyState(overlayedState, initialStatus, true);
            // put transient state in the map
            transientStore.put(id, state);
            state.setContainer(this);
            return state;
        }
    }


    public void stateModified(ItemState modified) {
        ItemState local;
        if (modified.getContainer() != this) {
            // shared state was modified
            local = cache.retrieve(modified.getId());
            if (local != null && local.isConnected()) {
                // this instance represents existing state, update it
                local.pull();
            }
        } else {
            // local state was modified
            local = modified;
        }
        if (local != null) {
            dispatcher.notifyStateModified(local);
        } else if (modified.isNode()) {
            // if the state is not ours (and is not cached) it could have
            // vanished from the weak-ref cache due to a gc. but there could
            // still be some listeners (e.g. CachingHierarchyManager) that want
            // to get notified.
            dispatcher.notifyNodeModified((NodeState) modified);
        }
    }


    public void stateDiscarded(ItemState discarded) {
        ItemState local = null;
        if (discarded.getContainer() != this) {
            // shared state was discarded
            local = cache.retrieve(discarded.getId());
            if (local != null && local.isConnected()) {
                local.setStatus(ItemState.STATUS_UNDEFINED);
            }
        } else {
            // local state was discarded
            local = discarded;
        }
        cache.evict(discarded.getId());
        if (local != null) {
            dispatcher.notifyStateDiscarded(local);
        }
    }


    public void stateDestroyed(ItemState destroyed) {
        ItemState local = null;
        if (destroyed.getContainer() != this) {
            // shared state was destroyed
            local = cache.retrieve(destroyed.getId());
            if (local != null && local.isConnected()) {
                local.setStatus(ItemState.STATUS_EXISTING_REMOVED);
            }
        } else {
            // local state was destroyed
            local = destroyed;
        }
        cache.evict(destroyed.getId());
        if (local != null) {
            dispatcher.notifyStateDestroyed(local);
        }
    }


    public void push() {
        for (ItemState state : modifiedStates()) {
            state.push();
        }
        for (ItemState state : deletedStates()) {
            state.push();
        }
        for (ItemState state : addedStates()) {
            state.push();
        }
    }


    public void persisted() {
        for (ItemState state : modifiedStates()) {
            state.setStatus(ItemState.STATUS_EXISTING);
            state.notifyStateUpdated();
        }
        for (ItemState state : deletedStates()) {
            state.setStatus(ItemState.STATUS_EXISTING_REMOVED);
            state.notifyStateDestroyed();
            state.discard();
        }
        for (ItemState state : addedStates()) {
            state.setStatus(ItemState.STATUS_EXISTING);
            state.notifyStateCreated();
        }
    }


    public void disconnect() {
        for (ItemState state : modifiedStates()) {
            state.disconnect();
        }
        for (ItemState state : deletedStates()) {
            state.disconnect();
        }
        for (ItemState state : addedStates()) {
            state.disconnect();
        }
    }


    private void addVirtualReference(
            ChangeLog references, PropertyId sourceId, NodeId targetId)
            throws NoSuchItemStateException, ItemStateException {

        NodeReferences refs = references.getReferencesTo(targetId);
        if (refs == null) {
            refs = virtualProvider.getNodeReferences(targetId);
        }
        if (refs == null && virtualProvider.hasItemState(targetId)) {
            refs = new NodeReferences(targetId);
        }
        if (refs != null) {
            refs.addReference(sourceId);
            references.modified(refs);
        }
    }


    private void removeVirtualReference(
            ChangeLog references, PropertyId sourceId, NodeId targetId)
            throws NoSuchItemStateException, ItemStateException {

        NodeReferences refs = references.getReferencesTo(targetId);
        if (refs == null) {
            refs = virtualProvider.getNodeReferences(targetId);
        }
        if (refs == null && virtualProvider.hasItemState(targetId)) {
            refs = new NodeReferences(targetId);
        }
        if (refs != null) {
            refs.removeReference(sourceId);
            references.modified(refs);
        }
    }


        public void release() {
            Sync exclusive = writerStateRWLock.writeLock();
            for (;;) {
                try {
                    exclusive.acquire();
                    break;
                } catch (InterruptedException e) {
                    // try again
                    Thread.interrupted();
                }
            }
            try {
                activeWriter = null;
                activeWriterId = null;
                notifyWaitingReaders();
                notifyWaitingWriters();
            } finally {
                exclusive.release();
            }
        }


        public void release() {
            Sync shared = writerStateRWLock.readLock();
            for (;;) {
                try {
                    shared.acquire();
                    break;
                } catch (InterruptedException e) {
                    // try again
                    Thread.interrupted();
                }
            }
            try {
                readLockMap.removeLock(id);
                if (readerCount.decrementAndGet() == 0 && activeWriter == null) {
                    activeWriterId = null;
                }
                if (!isSameThreadId(activeWriterId, getCurrentThreadId())) {
                    // only notify waiting writers if we do *not* hold a write
                    // lock at the same time. that would be a waste of cpu time.
                    notifyWaitingWriters();
                }
            } finally {
                shared.release();
            }
        }


        public ReadLock downgrade() {
            readerCount.incrementAndGet();
            readLockMap.addLock(null);
            Sync exclusive = writerStateRWLock.writeLock();
            for (;;) {
                try {
                    exclusive.acquire();
                    break;
                } catch (InterruptedException e) {
                    // try again
                    Thread.interrupted();
                }
            }
            try {
                activeWriter = null;
                // only notify waiting readers since we still hold a down
                // graded lock, which is kind of exclusiv with respect to
                // other writers
                notifyWaitingReaders();
            } finally {
                exclusive.release();
            }
            return anonymousReadLock;
        }


    public boolean hasItemState(ItemId id) {
        // check the virtual root ids (needed for overlay)
        for (VirtualItemStateProvider virtualProvider : virtualProviders) {
            if (virtualProvider.isVirtualRoot(id)) {
                return true;
            }
        }

        ISMLocking.ReadLock readLock;
        try {
            readLock = acquireReadLock(id);
        } catch (ItemStateException e) {
            return false;
        }

        try {
            if (cache.isCached(id)) {
                return true;
            }

            // check if this manager has the item state
            if (hasNonVirtualItemState(id)) {
                return true;
            }
        } finally {
            readLock.release();
        }

        // otherwise check virtual ones
        for (VirtualItemStateProvider virtualProvider : virtualProviders) {
            if (virtualProvider.hasItemState(id)) {
                return true;
            }
        }

        return false;
    }


    public boolean hasNodeReferences(NodeId id) {
        ISMLocking.ReadLock readLock;
        try {
            readLock = acquireReadLock(id);
        } catch (ItemStateException e) {
            return false;
        }
        try {
            // check persistence manager
            try {
                if (persistMgr.existsReferencesTo(id)) {
                    return true;
                }
            } catch (ItemStateException e) {
                // ignore
            }
        } finally {
            readLock.release();
        }

        // check virtual providers
        for (VirtualItemStateProvider virtualProvider : virtualProviders) {
            if (virtualProvider.hasNodeReferences(id)) {
                return true;
            }
        }

        return false;
    }


        private boolean isReferenceable(NodeState state) throws ItemStateException {
            // shortcut: check some well known built-in types first
            Name primary = state.getNodeTypeName();
            Set<Name> mixins = state.getMixinTypeNames();
            if (mixins.contains(NameConstants.MIX_REFERENCEABLE)
                    || mixins.contains(NameConstants.MIX_VERSIONABLE)
                    || primary.equals(NameConstants.NT_RESOURCE)) {
                return true;
            }

            // build effective node type
            try {
                EffectiveNodeType type = ntReg.getEffectiveNodeType(primary, mixins);
                return type.includesNodeType(NameConstants.MIX_REFERENCEABLE);
            } catch (NodeTypeConflictException ntce) {
                String msg = "internal error: failed to build effective node type for node "
                        + state.getNodeId();
                log.debug(msg);
                throw new ItemStateException(msg, ntce);
            } catch (NoSuchNodeTypeException nsnte) {
                String msg = "internal error: failed to build effective node type for node "
                        + state.getNodeId();
                log.debug(msg);
                throw new ItemStateException(msg, nsnte);
            }
        }


    private boolean isShareable(NodeState state) throws RepositoryException {
        // shortcut: check some well-known built-in types first
        Name primary = state.getNodeTypeName();
        Set<Name> mixins = state.getMixinTypeNames();
        if (mixins.contains(NameConstants.MIX_SHAREABLE)) {
            return true;
        }

        try {
            EffectiveNodeType type = ntReg.getEffectiveNodeType(primary, mixins);
            return type.includesNodeType(NameConstants.MIX_SHAREABLE);
        } catch (NodeTypeConflictException ntce) {
            String msg = "internal error: failed to build effective node type for node " + state.getNodeId();
            log.debug(msg);
            throw new RepositoryException(msg, ntce);
        }
    }


    private boolean isShareable(NodeState state) throws RepositoryException {
        // shortcut: check some wellknown built-in types first
        Name primary = state.getNodeTypeName();
        Set<Name> mixins = state.getMixinTypeNames();
        if (mixins.contains(NameConstants.MIX_SHAREABLE)) {
            return true;
        }

        try {
            NodeTypeRegistry registry = context.getNodeTypeRegistry();
            EffectiveNodeType type =
                registry.getEffectiveNodeType(primary, mixins);
            return type.includesNodeType(NameConstants.MIX_REFERENCEABLE);
        } catch (NodeTypeConflictException ntce) {
            String msg = "internal error: failed to build effective node type for node "
                    + state.getNodeId();
            log.debug(msg);
            throw new RepositoryException(msg, ntce);
        }
    }


    public boolean removeChildNodeEntry(Name nodeName, int index) {
        ChildNodeEntry entry = null;
        synchronized (this) {
            entry = childNodeEntries.remove(nodeName, index);
        }
        if (entry != null) {
            notifyNodeRemoved(entry);
        }
        return entry != null;
    }


    public boolean removeChildNodeEntry(NodeId id) {
        ChildNodeEntry entry = null;
        synchronized (this) {
            entry = childNodeEntries.remove(id);    
        }
        if (entry != null) {
            notifyNodeRemoved(entry);
        }
        return entry != null;
    }


    public void remapped(String oldPrefix, String newPrefix, String uri) {
        if (status != STARTED) {
            log.info("not started: namespace operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new NamespaceRecord(oldPrefix, newPrefix, uri, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


    public void registeredPrivileges(Collection<PrivilegeDefinition> definitions) {
        if (status != STARTED) {
            log.info("not started: nodetype operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new PrivilegeRecord(definitions, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


    public void workspaceCreated(String workspaceName,
            ClonedInputSource inputSource) {
        if (status != STARTED) {
            log.info("not started: namespace operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new WorkspaceRecord(workspaceName, inputSource, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


    public void registered(Collection ntDefs) {
        if (status != STARTED) {
            log.info("not started: nodetype operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new NodeTypeRecord(ntDefs, true, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


    public void unregistered(Collection qnames) {
        if (status != STARTED) {
            log.info("not started: nodetype operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new NodeTypeRecord(qnames, false, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


    public void reregistered(QNodeTypeDefinition ntDef) {
        if (status != STARTED) {
            log.info("not started: nodetype operation ignored.");
            return;
        }
        ClusterRecord record = null;
        boolean succeeded = false;

        try {
            record = new NodeTypeRecord(ntDef, producer.append());
            record.write();
            record.update();
            setRevision(record.getRevision());
            succeeded = true;
        } catch (JournalException e) {
            String msg = "Unable to create log entry: " + e.getMessage();
            log.error(msg);
        } catch (Throwable e) {
            String msg = "Unexpected error while creating log entry.";
            log.error(msg, e);
        } finally {
            if (!succeeded && record != null) {
                record.cancelUpdate();
            }
        }
    }


        public ClusterOperation create(NodeId nodeId, boolean deep, String owner) {
            if (status != STARTED) {
                log.info("not started: lock operation ignored.");
                return null;
            }
            try {
                ClusterRecord record = new LockRecord(nodeId, deep, owner,
                        producer.append(), workspace);
                return new DefaultClusterOperation(ClusterNode.this, record);
            } catch (JournalException e) {
                String msg = "Unable to create log entry: " + e.getMessage();
                log.error(msg);
                return null;
            } catch (Throwable e) {
                String msg = "Unexpected error while creating log entry.";
                log.error(msg, e);
                return null;
            }
        }


        public ClusterOperation create(NodeId nodeId) {
            if (status != STARTED) {
                log.info("not started: unlock operation ignored.");
                return null;
            }
            try {
                ClusterRecord record = new LockRecord(nodeId, producer.append(),
                        workspace);
                return new DefaultClusterOperation(ClusterNode.this, record);
            } catch (JournalException e) {
                String msg = "Unable to create log entry: " + e.getMessage();
                log.error(msg);
                return null;
            } catch (Throwable e) {
                String msg = "Unexpected error while creating log entry.";
                log.error(msg, e);
                return null;
            }
        }


    public void process(NamespaceRecord record) {
        if (namespaceListener == null) {
            String msg = "Namespace listener unavailable.";
            log.error(msg);
            return;
        }
        try {
            namespaceListener.externalRemap(record.getOldPrefix(),
                    record.getNewPrefix(), record.getUri());
        } catch (RepositoryException e) {
            String msg = "Unable to deliver namespace operation: " + e.getMessage();
            log.error(msg);
        }
    }


    public void process(PrivilegeRecord record) {
        if (privilegeListener == null) {
            String msg = "Privilege listener unavailable.";
            log.error(msg);
            return;
        }
        try {
            privilegeListener.externalRegisteredPrivileges(record.getDefinitions());
        } catch (RepositoryException e) {
            String msg = "Unable to deliver privilege registration operation: " + e.getMessage();
            log.error(msg);
        }
    }


    public void testGetSpi2davRepository() throws RepositoryException {
        Map<String, String> parameters = new HashMap<String, String>();

        parameters.put("org.apache.jackrabbit.spi.RepositoryServiceFactory",
                       "org.apache.jackrabbit.spi2dav.Spi2davRepositoryServiceFactory");
        parameters.put("org.apache.jackrabbit.spi2dav.uri",
                       "http://localhost/");

        try {
            Repository repo = factory.getRepository(parameters);
            assertNotNull(repo);
        } catch (RepositoryException e) {
            // If there is no jcr server on localhost, one of the below
            // exceptions will be thrown. Since this indicates that the
            // factory is working correctly, it is safe to ignore them.
            if (!(ConnectException.class.isInstance(e.getCause()) ||
                  DavException.class.isInstance(e.getCause()))) {
                throw e;
            }
        }
    }


    public void testGetSpi2davexRepository() throws RepositoryException {
        Map<String, String> parameters = Collections.singletonMap(
                "org.apache.jackrabbit.spi.RepositoryServiceFactory",
                "org.apache.jackrabbit.spi2davex.Spi2davexRepositoryServiceFactory");

        try {
            Repository repo = factory.getRepository(parameters);
            assertNotNull(repo);
        } catch (RepositoryException e) {
            // If there is no jcr server on localhost, one of the below
            // exceptions will be thrown. Since this indicates that the
            // factory is working correctly, it is safe to ignore them.
            if (!(ConnectException.class.isInstance(e.getCause()) ||
                    DavException.class.isInstance(e.getCause()))) {
                  throw e;
              }
        }
    }


    public static TestSuite suite() {
        TestSuite suite = new TestSuite();
        if (Boolean.getBoolean("jackrabbit.test.integration")) {
            suite.addTest(new JCRTestSuite());
            suite.addTest(new Jcr2SpiTestSuite());
            suite.addTest(new Jcr2SpiSecurityTestSuite());
            suite.addTest(new StopRepository());
        }
        return suite;
    }


    public static PropertyManager getDefaultManager() {
        if (DEFAULT_MANAGER == null) {
            PropertyManager manager = new PropertyManagerImpl();
            manager.addPropertyHandler(new ZipHandler());
            manager.addPropertyHandler(new XmlHandler());
            manager.addPropertyHandler(new DefaultHandler());
            DEFAULT_MANAGER = manager;
        }
        return DEFAULT_MANAGER;
    }


    public void testSetPropertyWithUnicodeChars() throws IOException,
            DiffException {
        final String value = "\"String value containing \u2355\u8723 unicode chars.\"";
        String diff = "^/a/prop : " + value;

        DiffHandler handler = new DummyDiffHandler() {
            @Override
            public void setProperty(String targetPath, String diffValue) {
                assertEquals(targetPath, "/a/prop");
                assertEquals(value, diffValue);
            }
        };

        DiffParser parser = new DiffParser(handler);
        parser.parse(diff);
    }


    public void testSetPropertyUnterminatedString() throws IOException,
            DiffException {
        final String value = "\"String value ending with \r\r\n\n\r\n.";
        String diff = "^/a/prop : " + value;

        DiffHandler handler = new DummyDiffHandler() {
            @Override
            public void setProperty(String targetPath, String diffValue) {
                assertEquals(targetPath, "/a/prop");
                assertEquals(value, diffValue);
            }
        };
        DiffParser parser = new DiffParser(handler);
        parser.parse(diff);
    }


    public void testSetPropertyWithTrailingLineSep() throws IOException,
            DiffException {
        final String value = "\"String value ending with \r\r\n\n\r\n.\"";
        String diff = "^/a/prop : " + value;

        DiffHandler handler = new DummyDiffHandler() {
            @Override
            public void setProperty(String targetPath, String diffValue) {
                assertEquals(targetPath, "/a/prop");
                assertEquals(value, diffValue);
            }
        };

        DiffParser parser = new DiffParser(handler);
        parser.parse(diff);
    }


    public void testSetPropertyWithSpecialChar() throws IOException, DiffException {
        final String value = "+abc \\r+ \\n-ab >c \r\\r\\n+";
        String diff = "^/a/prop : " + value;

        DiffHandler handler = new DummyDiffHandler() {
            @Override
            public void setProperty(String targetPath, String diffValue) {
                assertEquals(targetPath, "/a/prop");
                assertEquals(value, diffValue);
            }
        };

        DiffParser parser = new DiffParser(handler);
        parser.parse(diff);
    }


    public void testAllPolicyNode() throws Exception {
        try {
            testRootNode.addMixin("rep:AccessControllable");

            JsonDiffHandler handler = new JsonDiffHandler(superuser, testRoot, null);
            new DiffParser(handler).parse(JSOP_POLICY_TREE);

            assertTrue(testRootNode.hasNode("rep:policy"));
            assertTrue(testRootNode.getNode("rep:policy").getDefinition().isProtected());

            assertTrue(testRootNode.getNode("rep:policy").getPrimaryNodeType()
                    .getName().equals("rep:ACL"));

            assertPolicy(acMgr, testRootNode, 1);

            AccessControlEntry entry = ((AccessControlList) acMgr.getPolicies(testRoot)[0]).getAccessControlEntries()[0];
            assertEquals(EveryonePrincipal.NAME, entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if (entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }

        } finally {
            superuser.refresh(false);
        }
    }


    public void testUpdatePolicyNode() throws Exception {
        try {
            AccessControlUtils.addAccessControlEntry(superuser, testRoot, EveryonePrincipal.getInstance(), new String[] {Privilege.JCR_READ}, false);

            JsonDiffHandler handler = new JsonDiffHandler(superuser, testRoot, null);
            new DiffParser(handler).parse(JSOP_POLICY_TREE);

            assertTrue(testRootNode.hasNode("rep:policy"));
            assertTrue(testRootNode.getNode("rep:policy").getDefinition().isProtected());

            assertTrue(testRootNode.getNode("rep:policy").getPrimaryNodeType()
                    .getName().equals("rep:ACL"));

            assertPolicy(acMgr, testRootNode, 1);

            AccessControlEntry entry = ((AccessControlList) acMgr.getPolicies(testRoot)[0]).getAccessControlEntries()[0];
            assertEquals(EveryonePrincipal.NAME, entry.getPrincipal().getName());
            assertEquals(1, entry.getPrivileges().length);
            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);

            if (entry instanceof JackrabbitAccessControlEntry) {
                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());
            }

        } finally {
            superuser.refresh(false);
        }
    }


    public void testIOManagerConfig() throws Exception {
        InputStream in = new ByteArrayInputStream(CONFIG_1.getBytes("UTF-8"));

        ResourceConfig config = new ResourceConfig(null);
        config.parse(in);

        IOManager ioMgr = config.getIOManager();
        assertNotNull(ioMgr);
        assertEquals("org.apache.jackrabbit.server.io.IOManagerImpl", ioMgr.getClass().getName());

        IOHandler[] handlers = ioMgr.getIOHandlers();
        assertNotNull(handlers);
        assertEquals(1, handlers.length);
        assertEquals("org.apache.jackrabbit.server.io.DefaultHandler", handlers[0].getName());
    }


    public void testIOManagerConfigWithParam() throws Exception {
        InputStream in = new ByteArrayInputStream(CONFIG_2.getBytes("UTF-8"));

        ResourceConfig config = new ResourceConfig(null);
        config.parse(in);

        IOManager ioMgr = config.getIOManager();
        assertNotNull(ioMgr);
        assertEquals("org.apache.jackrabbit.server.io.IOManagerImpl", ioMgr.getClass().getName());

        IOHandler[] handlers = ioMgr.getIOHandlers();
        assertNotNull(handlers);
        assertEquals(1, handlers.length);
        assertEquals("org.apache.jackrabbit.server.io.DefaultHandler", handlers[0].getName());
        DefaultHandler dh = (DefaultHandler) handlers[0];
        assertEquals("nt:unstructured", dh.getCollectionNodeType());
        assertEquals("nt:unstructured", dh.getNodeType());
        assertEquals("nt:resource", dh.getContentNodeType());
    }


    public boolean importContent(ImportContext context, boolean isCollection) throws IOException {
        boolean success = false;
        if (context != null) {
            IOListener ioListener = context.getIOListener();
            if (ioListener == null) {
                ioListener = new DefaultIOListener(log);
            }
            IOHandler[] ioHandlers = getIOHandlers();
            for (int i = 0; i < ioHandlers.length && !success; i++) {
                IOHandler ioh = ioHandlers[i];
                if (ioh.canImport(context, isCollection)) {
                    ioListener.onBegin(ioh, context);
                    success = ioh.importContent(context, isCollection);
                    ioListener.onEnd(ioh, context, success);
                }
            }
            context.informCompleted(success);
        }
        return success;
    }


    public boolean importContent(ImportContext context, DavResource resource) throws IOException {
        boolean success = false;
        if (context != null && resource != null) {
            IOListener ioListener = context.getIOListener();
            if (ioListener == null) {
                ioListener = new DefaultIOListener(log);
            }
            IOHandler[] ioHandlers = getIOHandlers();
            for (int i = 0; i < ioHandlers.length && !success; i++) {
                IOHandler ioh = ioHandlers[i];
                if (ioh.canImport(context, resource)) {
                    ioListener.onBegin(ioh, context);
                    success = ioh.importContent(context, resource);
                    ioListener.onEnd(ioh, context, success);
                }
            }
            context.informCompleted(success);
        }
        return success;
    }


    public boolean exportContent(ExportContext context, boolean isCollection) throws IOException {
        boolean success = false;
        if (context != null) {
            IOListener ioListener = context.getIOListener();
            if (ioListener == null) {
                ioListener = new DefaultIOListener(log);
            }
            IOHandler[] ioHandlers = getIOHandlers();
            for (int i = 0; i < ioHandlers.length && !success; i++) {
                IOHandler ioh = ioHandlers[i];
                if (ioh.canExport(context, isCollection)) {
                    ioListener.onBegin(ioh, context);
                    success = ioh.exportContent(context, isCollection);
                    ioListener.onEnd(ioh, context, success);
                }
            }
            context.informCompleted(success);
        }
        return success;
    }


    public boolean exportContent(ExportContext context, DavResource resource) throws IOException {
        boolean success = false;
        if (context != null && resource != null) {
            IOListener ioListener = context.getIOListener();
            if (ioListener == null) {
                ioListener = new DefaultIOListener(log);
            }
            IOHandler[] ioHandlers = getIOHandlers();
            for (int i = 0; i < ioHandlers.length && !success; i++) {
                IOHandler ioh = ioHandlers[i];
                if (ioh.canExport(context, resource)) {
                    ioListener.onBegin(ioh, context);
                    success = ioh.exportContent(context, resource);
                    ioListener.onEnd(ioh, context, success);
                }
            }
            context.informCompleted(success);
        }
        return success;
    }


    public boolean canExport(ExportContext context, boolean isCollection) {
        if (super.canExport(context, isCollection)) {
            // mimetype must be application/zip
            String mimeType = null;
            // if zip-content has not been extracted -> delegate to some other handler
            boolean hasDataProperty = false;
            try {
                Node contentNode = getContentNode(context, isCollection);
                // jcr:data property indicates that the zip-file has been imported as binary (not extracted)
                hasDataProperty = contentNode.hasProperty(JcrConstants.JCR_DATA);
                if (contentNode.hasProperty(JcrConstants.JCR_MIMETYPE)) {
                    mimeType  = contentNode.getProperty(JcrConstants.JCR_MIMETYPE).getString();
                } else {
                    mimeType = detect(context.getExportRoot().getName());
                }
            } catch (RepositoryException e) {
                // ignore and return false
            }
            return ZIP_MIMETYPE.equals(mimeType) && !hasDataProperty;
        }
        return false;
    }


    public boolean canExport(ExportContext context, boolean isCollection) {
        if (super.canExport(context, isCollection)) {
            String mimeType = null;
            try {
                Node contentNode = getContentNode(context, isCollection);
                if (contentNode.hasProperty(JcrConstants.JCR_MIMETYPE)) {
                    mimeType = contentNode.getProperty(JcrConstants.JCR_MIMETYPE).getString();
                } else {
                    mimeType = detect(context.getExportRoot().getName());
                }
            } catch (RepositoryException e) {
                // ignore and return false
            }
            return XML_MIMETYPE.equals(mimeType);
        }
        return false;
    }


    public boolean exportContent(ExportContext context, boolean isCollection) throws IOException {
        if (!canExport(context, isCollection)) {
            throw new IOException(getName() + ": Cannot export " + context.getExportRoot());
        }

        // properties (content length undefined)
        context.setModificationTime(new Date().getTime());
        context.setContentType("text/html", "UTF-8");
        context.setETag("");

        // data
        if (context.hasStream()) {
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(context.getOutputStream(), "utf8"));
            try {
                Item item = context.getExportRoot();
                Repository rep = item.getSession().getRepository();
                String repName = rep.getDescriptor(Repository.REP_NAME_DESC);
                String repURL = rep.getDescriptor(Repository.REP_VENDOR_URL_DESC);
                String repVersion = rep.getDescriptor(Repository.REP_VERSION_DESC);
                writer.print("<html><head><title>");
                writer.print(Text.encodeIllegalHTMLCharacters(repName));
                writer.print(" ");
                writer.print(Text.encodeIllegalHTMLCharacters(repVersion));
                writer.print(" ");
                writer.print(Text.encodeIllegalHTMLCharacters(item.getPath()));
                writer.print("</title></head>");
                writer.print("<body><h2>");
                writer.print(Text.encodeIllegalHTMLCharacters(item.getPath()));
                writer.print("</h2><ul>");
                writer.print("<li><a href=\"..\">..</a></li>");
                if (item.isNode()) {
                    NodeIterator iter = ((Node)item).getNodes();
                    while (iter.hasNext()) {
                        Node child = iter.nextNode();
                        String label = Text.getName(child.getPath());
                        writer.print("<li><a href=\"");
                        writer.print(Text.encodeIllegalHTMLCharacters(Text.escape(label)));
                        if (child.isNode()) {
                            writer.print("/");
                        }
                        writer.print("\">");
                        writer.print(Text.encodeIllegalHTMLCharacters(label));
                        writer.print("</a></li>");
                    }
                }
                writer.print("</ul><hr size=\"1\"><em>Powered by <a href=\"");
                writer.print(Text.encodeIllegalHTMLCharacters(repURL));
                writer.print("\">");
                writer.print(Text.encodeIllegalHTMLCharacters(repName));
                writer.print("</a> version ");
                writer.print(Text.encodeIllegalHTMLCharacters(repVersion));
                writer.print("</em></body></html>");
            } catch (RepositoryException e) {
                // should not occur
                log.debug(e.getMessage());
            }
            writer.close();
        }
        return true;
    }


    public boolean exportContent(ExportContext context, DavResource resource) throws IOException {
        if (!canExport(context, resource)) {
            throw new IOException(getName() + ": Cannot export " + context.getExportRoot());
        }

        // properties (content length undefined)
        context.setModificationTime(new Date().getTime());
        context.setContentType("text/html", "UTF-8");
        context.setETag("");

        // data
        if (context.hasStream()) {
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(context.getOutputStream(), "utf8"));
            try {
                Item item = context.getExportRoot();
                Repository rep = item.getSession().getRepository();
                String repName = rep.getDescriptor(Repository.REP_NAME_DESC);
                String repURL = rep.getDescriptor(Repository.REP_VENDOR_URL_DESC);
                String repVersion = rep.getDescriptor(Repository.REP_VERSION_DESC);
                writer.print("<html><head><title>");
                writer.print(Text.encodeIllegalHTMLCharacters(repName));
                writer.print(" ");
                writer.print(Text.encodeIllegalHTMLCharacters(repVersion));
                writer.print(" ");
                writer.print(Text.encodeIllegalHTMLCharacters(resource.getResourcePath()));
                writer.print("</title></head>");
                writer.print("<body><h2>");
                writer.print(Text.encodeIllegalHTMLCharacters(resource.getResourcePath()));
                writer.print("</h2><ul>");
                writer.print("<li><a href=\"..\">..</a></li>");
                DavResourceIterator iter = resource.getMembers();
                while (iter.hasNext()) {
                    DavResource child = iter.nextResource();
                    String label = Text.getName(child.getResourcePath());
                    writer.print("<li><a href=\"");
                    writer.print(Text.encodeIllegalHTMLCharacters(child.getHref()));
                    writer.print("\">");
                    writer.print(Text.encodeIllegalHTMLCharacters(label));
                    writer.print("</a></li>");
                }
                writer.print("</ul><hr size=\"1\"><em>Powered by <a href=\"");
                writer.print(Text.encodeIllegalHTMLCharacters(repURL));
                writer.print("\">");
                writer.print(Text.encodeIllegalHTMLCharacters(repName));
                writer.print("</a> version ");
                writer.print(Text.encodeIllegalHTMLCharacters(repVersion));
                writer.print("</em></body></html>");
            } catch (RepositoryException e) {
                // should not occur
                log.debug(e.getMessage());
            }
            writer.close();
        }
        return true;
    }


    public boolean exportProperties(PropertyExportContext context, boolean isCollection) throws RepositoryException {
        boolean success = false;
        PropertyHandler[] propertyHandlers = getPropertyHandlers();
        for (int i = 0; i < propertyHandlers.length && !success; i++) {
            PropertyHandler ph = propertyHandlers[i];
            if (ph.canExport(context, isCollection)) {
                success = ph.exportProperties(context, isCollection);
            }
        }
        context.informCompleted(success);
        return success;
    }


    public boolean delete(DeleteContext deleteContext, DavResource member) throws DavException {
        boolean success = false;
        DeleteHandler[] deleteHandlers = getDeleteHandlers();
        for (int i = 0; i < deleteHandlers.length && !success; i++) {
            DeleteHandler dh = deleteHandlers[i];
            if (dh.canDelete(deleteContext, member)) {
                success = dh.delete(deleteContext, member);
            }
        }
        return success;
    }


    public boolean move(CopyMoveContext context, DavResource source, DavResource destination) throws DavException {
        boolean success = false;
        CopyMoveHandler[] copyMoveHandlers = getCopyMoveHandlers();
        for (int i = 0; i < copyMoveHandlers.length && !success; i++) {
            CopyMoveHandler cmh = copyMoveHandlers[i];
            if (cmh.canMove(context, source, destination)) {
                success = cmh.move(context, source, destination);
            }
        }
        return success;
    }


    public boolean copy(CopyMoveContext context, DavResource source, DavResource destination) throws DavException {
        boolean success = false;
        CopyMoveHandler[] copyMoveHandlers = getCopyMoveHandlers();
        for (int i = 0; i < copyMoveHandlers.length && !success; i++) {
            CopyMoveHandler cmh = copyMoveHandlers[i];
            if (cmh.canCopy(context, source, destination)) {
                success = cmh.copy(context, source, destination);
            }
        }
        return success;
    }


        private String getUUID() {
            if (uuid != null && uuid.value != null) {
                try {
                    return uuid.value.getString();
                } catch (RepositoryException e) {
                    log.error(e.getMessage());
                }
            }
            return null;
        }


        private String getPrimaryType() {
            if (ntName != null && ntName.value != null) {
                try {
                    return ntName.value.getString();
                } catch (RepositoryException e) {
                    log.error(e.getMessage());
                }
            }
            return null;
        }


        void startValueElement(ContentHandler contentHandler) throws IOException {
            try {            	
                String str = value.getString();
                contentHandler.startElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE, new AttributesImpl());
                contentHandler.characters(str.toCharArray(), 0, str.length());
                contentHandler.endElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE);
            } catch(SAXException e) {
                throw new DiffException(e.getMessage());
            } catch (ValueFormatException e) {
                throw new DiffException(e.getMessage());
            } catch (RepositoryException e) {
                throw new DiffException(e.getMessage());
            }
        }


        void startValueElement(ContentHandler contentHandler) throws IOException {
            try {
            	// Multi-valued property with values present in the request multi-part             	
            	if (values.size() == 0) {            	
            		values = Arrays.asList(extractValuesFromRequest(getPath()));            	   
            	}
            	
                for (Value v : values) {
                    String str = v.getString();
                    contentHandler.startElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE, new AttributesImpl());
                    contentHandler.characters(str.toCharArray(), 0, str.length());
                    contentHandler.endElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE);
                }
            } catch(SAXException e) {
                throw new DiffException(e.getMessage());
            } catch (ValueFormatException e) {
                throw new DiffException(e.getMessage());
            } catch (RepositoryException e) {
                throw new DiffException(e.getMessage());
            }
        }


    private void writeKeyArray(String key, Value[] values) throws RepositoryException, IOException {
        writeKey(key);
        writer.write('[');
        for (int i = 0; i < values.length; i++) {
            if (i > 0) {
                writer.write(',');
            }
            writeJsonValue(values[i]);
        }
        writer.write(']');
    }


    private void writeKeyArray(String key, long[] binLengths) throws RepositoryException, IOException {
        writeKey(key);
        writer.write('[');
        for (int i = 0; i < binLengths.length; i++) {
            if (i > 0) {
                writer.write(',');
            }
            writer.write(String.valueOf(binLengths[i]));
        }
        writer.write(']');
    }


        private int getDepth() {
            if (isJsonRequest) {
                if (repositoryPath == null) {
                    extract();
                }
                return depth;
            } else {
                return Integer.MIN_VALUE;
            }
        }


        public String getRepositoryPath() {
            if (isJsonRequest) {
                if (repositoryPath == null) {
                    extract();
                }
                return repositoryPath;
            } else {
                return loc.getRepositoryPath();
            }
        }


        public void start(TransactionResource resource) throws DavException {
            try {
                // make sure, the given resource represents an existing repository item
                if (!getRepositorySession(resource).itemExists(resource.getLocator().getRepositoryPath())) {
                    throw new DavException(DavServletResponse.SC_CONFLICT, "Unable to start local transaction: no repository item present at " + getResourcePath());
                }
            } catch (RepositoryException e) {
                log.error("Unexpected error: " + e.getMessage());
                throw new JcrDavException(e);
            }
        }


    public void setValue(Value value) throws RepositoryException {
        try {
            if (value != null) {
                value = SerialValueFactory.makeSerialValue(value);
            }
            remote.setValue(value);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public void deleteFromCache(DataIdentifier identifier)
                    throws DataStoreException {
        try {
            // order is important here
            recLenCache.remove(identifier);
            String fileName = getFileName(identifier);
            asyncWriteCache.delete(fileName);
            cache.delete(fileName);
        } catch (IOException ioe) {
            throw new DataStoreException(ioe);
        }
    }


    public void setValue(Value[] values) throws RepositoryException {
        try {
            if (values != null) {
                values = SerialValueFactory.makeSerialValueArray(values);
            }
            remote.setValue(values);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public void setValue(String[] strings) throws RepositoryException {
        try {
            Value[] values = null;
            if (strings != null) {
                values = SerialValueFactory.makeSerialValueArray(strings);
            }
            remote.setValue(values);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public DavResource getCollection() {
        DavResource collection = null;

        String parentPath = Text.getRelativeParent(getResourcePath(), 1);
        DavResourceLocator parentLoc = getLocator().getFactory().createResourceLocator(getLocator().getPrefix(), getLocator().getWorkspacePath(), parentPath);
        try {
            collection = createResourceFromLocator(parentLoc);
        } catch (DavException e) {
            log.error("Unexpected error while retrieving collection: " + e.getMessage());
        }

        return collection;
    }


    public DavResource getCollection() {
        DavResource collection = null;
        // create location with 'null' values for workspace-path and resource-path
        DavResourceLocator parentLoc = getLocator().getFactory().createResourceLocator(getLocator().getPrefix(), null, null, false);
        try {
            collection = createResourceFromLocator(parentLoc);
        } catch (DavException e) {
            log.error("Unexpected error while retrieving collection: " + e.getMessage());
        }
        return collection;
    }


    public void spool(OutputContext outputContext) throws IOException {

        outputContext.setProperty("Link", "<?" + EventJournalResourceImpl.RELURIFROMWORKSPACE
                + ">; title=\"Event Journal\"; rel=alternate; type=\"" + AtomFeedConstants.MEDIATYPE + "\"");

        if (outputContext.hasStream()) {
            Session session = getRepositorySession();
            Repository rep = session.getRepository();
            String repName = rep.getDescriptor(Repository.REP_NAME_DESC);
            String repURL = rep.getDescriptor(Repository.REP_VENDOR_URL_DESC);
            String repVersion = rep.getDescriptor(Repository.REP_VERSION_DESC);
            String repostr = repName + " " + repVersion;

            StringBuilder sb = new StringBuilder();
            sb.append("<html><head><title>");
            sb.append(repostr);
            sb.append("</title>");
            sb.append("<link rel=alternate type=\"" + AtomFeedConstants.MEDIATYPE
                    + "\" title=\"Event Journal\" href=\"?" + EventJournalResourceImpl.RELURIFROMWORKSPACE + "\">");
            sb.append("</head>");
            sb.append("<body><h2>").append(repostr).append("</h2><ul>");
            sb.append("<li><a href=\"..\">..</a></li>");
            DavResourceIterator it = getMembers();
            while (it.hasNext()) {
                DavResource res = it.nextResource();
                sb.append("<li><a href=\"");
                sb.append(res.getHref());
                sb.append("\">");
                sb.append(res.getDisplayName());
                sb.append("</a></li>");
            }
            sb.append("</ul><hr size=\"1\"><em>Powered by <a href=\"");
            sb.append(repURL).append("\">").append(repName);
            sb.append("</a> ").append(repVersion);
            sb.append("</em></body></html>");

            outputContext.setContentLength(sb.length());
            outputContext.setModificationTime(getModificationTime());
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputContext.getOutputStream(), "utf8"));
            writer.print(sb.toString());
            writer.close();
        } else {
            outputContext.setContentLength(0);
            outputContext.setModificationTime(getModificationTime());
        }
    }


    public void spool(OutputContext outputContext) throws IOException {
        if (outputContext.hasStream()) {
            Session session = getRepositorySession();
            Repository rep = session.getRepository();
            String repName = rep.getDescriptor(Repository.REP_NAME_DESC);
            String repURL = rep.getDescriptor(Repository.REP_VENDOR_URL_DESC);
            String repVersion = rep.getDescriptor(Repository.REP_VERSION_DESC);
            String repostr = repName + " " + repVersion;

            StringBuilder sb = new StringBuilder();
            sb.append("<html><head><title>");
            sb.append(repostr);
            sb.append("</title></head>");
            sb.append("<body><h2>").append(repostr).append("</h2>");
            sb.append("<h3>Available Workspace Resources:</h3><ul>");

            DavResourceIterator it = getMembers();
            while (it.hasNext()) {
                DavResource res = it.nextResource();
                sb.append("<li><a href=\"");
                sb.append(res.getHref());
                sb.append("\">");
                sb.append(res.getDisplayName());
                sb.append("</a></li>");
            }
            sb.append("</ul><hr size=\"1\"><em>Powered by <a href=\"");
            sb.append(repURL).append("\">").append(repName);
            sb.append("</a> ").append(repVersion);
            sb.append("</em></body></html>");

            outputContext.setContentLength(sb.length());
            outputContext.setModificationTime(getModificationTime());
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputContext.getOutputStream(), "utf8"));
            writer.print(sb.toString());
            writer.close();
        } else {
            outputContext.setContentLength(0);
            outputContext.setModificationTime(getModificationTime());
        }
    }


    public MultiStatusResponse alterProperties(List<? extends PropEntry> changeList) throws DavException {
        for (PropEntry propEntry : changeList) {
            if (propEntry instanceof DavPropertyName) {
                // altering any properties fails if an attempt is made to remove
                // a property
                throw new DavException(DavServletResponse.SC_FORBIDDEN);
            } else if (propEntry instanceof DavProperty<?>) {
                DavProperty<?> prop = (DavProperty<?>) propEntry;
                internalSetProperty(prop);
            } else {
                throw new IllegalArgumentException("unknown object in change list: " + propEntry.getClass().getName());
            }
        }
        complete();
        return new MultiStatusResponse(getHref(), DavServletResponse.SC_OK);
    }


    public MultiStatusResponse alterProperties(List<? extends PropEntry> changeList) throws DavException {
        for (PropEntry propEntry : changeList) {
            if (propEntry instanceof DavPropertyName) {
                // use the internal remove method in order to prevent premature 'save'
                DavPropertyName propName = (DavPropertyName) propEntry;
                internalRemoveProperty(propName);
            } else if (propEntry instanceof DavProperty) {
                // use the internal set method in order to prevent premature 'save'
                DavProperty<?> prop = (DavProperty<?>) propEntry;
                internalSetProperty(prop);
            } else {
                throw new IllegalArgumentException("unknown object in change list: " + propEntry.getClass().getName());
            }
        }
        // TODO: missing undo of successful set/remove if subsequent operation fails
        // NOTE, that this is relevant with transactions only.

        // success: save all changes together if no error occurred
        complete();
        return new MultiStatusResponse(getHref(), DavServletResponse.SC_OK);
    }


    public void addLockToken(String token) {
        if (!LockTokenMapper.isForSessionScopedLock(token)) {
            try {
                session.getWorkspace().getLockManager().addLockToken(LockTokenMapper.getJcrLockToken(token));
            }
            catch (RepositoryException ex) {
                log.debug("trying to add lock token " + token + " to session", ex);
            }
        }
        lockTokens.add(token);
    }


    public void removeLockToken(String token) {
        if (!LockTokenMapper.isForSessionScopedLock(token)) {
            try {
                session.getWorkspace().getLockManager().removeLockToken(LockTokenMapper.getJcrLockToken(token));
            }
            catch (RepositoryException ex) {
                log.debug("trying to remove lock token " + token + " to session", ex);
            }
        }
        lockTokens.remove(token);
    }


    public String getSupportedMethods() {
        StringBuffer sb = new StringBuffer(super.getSupportedMethods());
        // Versioning support
        sb.append(", ").append(VersionableResource.METHODS);
        if (isVersionControlled()) {
            try {
                if (((Node)item).isCheckedOut()) {
                    sb.append(", ").append(VersionControlledResource.methods_checkedOut);
                } else {
                    sb.append(", ").append(VersionControlledResource.methods_checkedIn);
                }
            } catch (RepositoryException e) {
                // should not occur.
                log.error(e.getMessage());
            }
        }
        return sb.toString();
    }


    public String getSupportedMethods() {
        StringBuffer sb = new StringBuffer(super.getSupportedMethods());
        // Versioning support
        sb.append(", ").append(VersionableResource.METHODS);
        if (isVersionControlled()) {
            try {
                if (getNode().isCheckedOut()) {
                    sb.append(", ").append(DavMethods.METHOD_CHECKIN);
                } else {
                    sb.append(", ").append(DavMethods.METHOD_CHECKOUT);
                    sb.append(", ").append(DavMethods.METHOD_LABEL);
                }
            } catch (RepositoryException e) {
                // should not occur.
                log.error(e.getMessage());
            }
        }
        return sb.toString();
    }


    public void addVersionControl() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            try {
                ((Node)item).addMixin(JcrConstants.MIX_VERSIONABLE);
                item.save();
            } catch (RepositoryException e) {
                throw new JcrDavException(e);
            }
        } // else: is already version controlled -> ignore
    }


    public void addVersionControl() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (isCollection()) {
            // since the version-controlled-collection feature is not supported
            // collections may not be put under dav version control even if
            // the underlying node was / could be made jcr versionable.
            throw new DavException(DavServletResponse.SC_METHOD_NOT_ALLOWED);
        }
        if (!isVersionControlled()) {
            Node item = getNode();
            try {
                item.addMixin(JcrConstants.MIX_VERSIONABLE);
                item.save();
            } catch (RepositoryException e) {
                throw new JcrDavException(e);
            }
        } // else: is already version controlled -> ignore
    }


    public void checkout() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            throw new DavException(DavServletResponse.SC_METHOD_NOT_ALLOWED);
        }
        try {
            getVersionManager().checkout(item.getPath());
        } catch (RepositoryException e) {
            // UnsupportedRepositoryException should not occur
            throw new JcrDavException(e);
        }
    }


    public void checkout() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            throw new DavException(DavServletResponse.SC_METHOD_NOT_ALLOWED);
        }
        try {
            getNode().checkout();
        } catch (RepositoryException e) {
            // UnsupportedRepositoryException should not occur
            throw new JcrDavException(e);
        }
    }


    public String checkin() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            throw new DavException(DavServletResponse.SC_METHOD_NOT_ALLOWED);
        }
        try {
            Version v = getVersionManager().checkin(item.getPath());
            String versionHref = getLocatorFromItem(v).getHref(true);
            return versionHref;
        } catch (RepositoryException e) {
            // UnsupportedRepositoryException should not occur
            throw new JcrDavException(e);
        }
    }


    public String checkin() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            throw new DavException(DavServletResponse.SC_METHOD_NOT_ALLOWED);
        }
        try {
            Version v = getNode().checkin();
            String versionHref = getLocatorFromNode(v).getHref(false);
            return versionHref;
        } catch (RepositoryException e) {
            // UnsupportedRepositoryException should not occur
            throw new JcrDavException(e);
        }
    }


    public void label(LabelInfo labelInfo) throws DavException {
        if (labelInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Valid label request body required.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        try {
            if (!isVersionControlled() || ((Node)item).isCheckedOut()) {
                throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "A LABEL request may only be applied to a version-controlled, checked-in resource.");
            }
            DavResource[] resArr = this.getReferenceResources(CHECKED_IN);
            if (resArr.length == 1 && resArr[0] instanceof VersionResource) {
                ((VersionResource)resArr[0]).label(labelInfo);
            } else {
                throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR, "DAV:checked-in property on '" + getHref() + "' did not point to a single VersionResource.");
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public void label(LabelInfo labelInfo) throws DavException {
        if (labelInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Valid label request body required.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        try {
            if (!isVersionControlled() || getNode().isCheckedOut()) {
                throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "A LABEL request may only be applied to a version-controlled, checked-in resource.");
            }
            DavResource[] resArr = this.getReferenceResources(CHECKED_IN);
            if (resArr.length == 1 && resArr[0] instanceof VersionResource) {
                ((VersionResource)resArr[0]).label(labelInfo);
            } else {
                throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR, "DAV:checked-in property on '" + getHref() + "' did not point to a single VersionResource.");
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public VersionHistoryResource getVersionHistory() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        try {
            VersionHistory vh = ((Node)item).getVersionHistory();
            DavResourceLocator loc = getLocatorFromItem(vh);
            return (VersionHistoryResource) createResourceFromLocator(loc);
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public VersionHistoryResource getVersionHistory() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        try {
            VersionHistory vh = getVersionHistoryItem();
            DavResourceLocator loc = getLocatorFromItem(vh);
            return (VersionHistoryResource) createResourceFromLocator(loc);
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    private boolean isVersionControlled() {
        boolean vc = false;
        if (exists()) {
            try {
                vc = ((Node) item).isNodeType(JcrConstants.MIX_VERSIONABLE);
            } catch (RepositoryException e) {
                log.warn(e.getMessage());
            }
        }
        return vc;
    }


    private boolean isVersionControlled() {
        boolean vc = false;
        // since the version-controlled-collection feature is not supported
        // all collection are excluded from version-control even if the
        // underlying node was JCR versionable.
        if (exists() && !isCollection()) {
            Node item = getNode();
            try {
                vc = item.isNodeType(JcrConstants.MIX_VERSIONABLE);
            } catch (RepositoryException e) {
                log.warn(e.getMessage());
            }
        }
        return vc;
    }


    public boolean isOrderable() {
        boolean orderable = false;
        if (exists()) {
            try {
                orderable = ((Node) item).getPrimaryNodeType().hasOrderableChildNodes();
            } catch (RepositoryException e) {
                log.warn(e.getMessage());
            }
        }
        return orderable;
    }


    public void label(LabelInfo labelInfo) throws DavException {
        if (labelInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Valid label request body required.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        try {
            VersionHistory vh = getVersionHistoryItem();
            if (labelInfo.getType() == LabelInfo.TYPE_REMOVE) {
                vh.removeVersionLabel(labelInfo.getLabelName());
            } else if (labelInfo.getType() == LabelInfo.TYPE_ADD) {
                // ADD: only add if not yet existing
                vh.addVersionLabel(item.getName(), labelInfo.getLabelName(), false);
            } else {
                // SET: move label if already existing
                vh.addVersionLabel(item.getName(), labelInfo.getLabelName(), true);
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public void label(LabelInfo labelInfo) throws DavException {
        if (labelInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Valid label request body required.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        try {
            VersionHistory vh = getVersionHistoryItem();
            if (labelInfo.getType() == LabelInfo.TYPE_REMOVE) {
                vh.removeVersionLabel(labelInfo.getLabelName());
            } else if (labelInfo.getType() == LabelInfo.TYPE_ADD) {
                // ADD: only add if not yet existing
                vh.addVersionLabel(getNode().getName(), labelInfo.getLabelName(), false);
            } else {
                // SET: move label if already existing
                vh.addVersionLabel(getNode().getName(), labelInfo.getLabelName(), true);
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    protected String getCreatorDisplayName() {
        // overwrite the default creation date and creator-displayname if possible
        try {
            // DAV:creator-displayname -> use jcr:createBy if present.
            if (exists() && ((Node) item).hasProperty(Property.JCR_CREATED_BY)) {
                return ((Node) item).getProperty(Property.JCR_CREATED_BY).getString();
            }
        } catch (RepositoryException e) {
            log.warn("Error while accessing jcr:createdBy property");
        }

        // fallback
        return super.getCreatorDisplayName();
    }


    protected String getCreationDate() {
        // overwrite the default creation date and creator-displayname if possible
        try {
            if (exists() && ((Node) item).hasProperty(JcrConstants.JCR_CREATED)) {
                long creationTime = ((Node) item).getProperty(JcrConstants.JCR_CREATED).getValue().getLong();
                return HttpDateFormat.creationDateFormat().format(new Date(creationTime));
            }
        } catch (RepositoryException e) {
            log.warn("Error while accessing jcr:created property");
        }

        // fallback
        return super.getCreationDate();
    }


    public OptionsResponse getOptionResponse(OptionsInfo optionsInfo) {
        OptionsResponse oR = null;
        if (optionsInfo != null) {
            oR = new OptionsResponse();
            // currently only DAV:version-history-collection-set and
            // DAV:workspace-collection-set is supported.
            if (optionsInfo.containsElement(DeltaVConstants.XML_VH_COLLECTION_SET, DeltaVConstants.NAMESPACE)) {
                String[] hrefs = new String[] {
                        getLocatorFromItemPath(ItemResourceConstants.VERSIONSTORAGE_PATH).getHref(true)
                };
                oR.addEntry(DeltaVConstants.XML_VH_COLLECTION_SET, DeltaVConstants.NAMESPACE, hrefs);
            }
            if (optionsInfo.containsElement(DeltaVConstants.XML_WSP_COLLECTION_SET, DeltaVConstants.NAMESPACE)) {
                // workspaces cannot be created anywhere.
                oR.addEntry(DeltaVConstants.XML_WSP_COLLECTION_SET, DeltaVConstants.NAMESPACE, new String[0]);
            }
        }
        return oR;
    }


    public OptionsResponse getOptionResponse(OptionsInfo optionsInfo) {
        OptionsResponse oR = null;
        if (optionsInfo != null) {
            oR = new OptionsResponse();
            // currently only DAV:version-history-collection-set is supported
            if (optionsInfo.containsElement(DeltaVConstants.XML_VH_COLLECTION_SET, DeltaVConstants.NAMESPACE)) {
                String[] hrefs = new String[] {
                    getLocatorFromNodePath("/"+JcrConstants.JCR_SYSTEM+"/"+JcrConstants.JCR_VERSIONSTORAGE).getHref(true)
                };
                oR.addEntry(DeltaVConstants.XML_VH_COLLECTION_SET, DeltaVConstants.NAMESPACE, hrefs);
            }
        }
        return oR;
    }


    public Report getReport(ReportInfo reportInfo) throws DavException {
        if (reportInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "A REPORT request must provide a valid XML request body.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        if (!supportedReports.isSupportedReport(reportInfo)) {
            Element condition = null;
            try {
                condition = DomUtil.createDocument().createElementNS("DAV:", "supported-report");
            } catch (ParserConfigurationException ex) {
                // we don't care THAT much
            }
            throw new DavException(DavServletResponse.SC_CONFLICT,
                    "Unknown report '" + reportInfo.getReportName() + "' requested.", null, condition);
        }

        return ReportType.getType(reportInfo).createReport(this, reportInfo);
    }


    public Report getReport(ReportInfo reportInfo) throws DavException {
        if (reportInfo == null) {
            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "A REPORT request must provide a valid XML request body.");
        }
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        if (!supportedReports.isSupportedReport(reportInfo)) {
            Element condition = null;
            try {
                condition = DomUtil.createDocument().createElementNS("DAV:", "supported-report");
            } catch (ParserConfigurationException ex) {
                // we don't care THAT much
            }
            throw new DavException(DavServletResponse.SC_CONFLICT,
                    "Unknown report '" + reportInfo.getReportName() + "' requested.", null, condition);
        }
        return ReportType.getType(reportInfo).createReport(this, reportInfo);
    }


    protected DavResourceLocator getLocatorFromItem(Item repositoryItem) {
        String itemPath = null;
        try {
            if (repositoryItem != null) {
                itemPath = repositoryItem.getPath();
            }
        } catch (RepositoryException e) {
            // ignore: should not occur
            log.warn(e.getMessage());
        }
        return getLocatorFromItemPath(itemPath);
    }


    protected DavResourceLocator getLocatorFromNode(Node repositoryNode) {
        String nodePath = null;
        try {
            if (repositoryNode != null) {
                nodePath = repositoryNode.getPath();
            }
        } catch (RepositoryException e) {
            // ignore: should not occur
            log.warn(e.getMessage());
        }
        return getLocatorFromNodePath(nodePath);
    }


    public VersionHistoryResource getVersionHistory() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }

        try {
            VersionHistory vh = getVersionHistoryItem();
            DavResourceLocator loc = getLocatorFromNode(vh);
            DavResource vhr = createResourceFromLocator(loc);
            if (vhr instanceof VersionHistoryResource) {
                return (VersionHistoryResource)vhr;
            } else {
                // severe error since resource factory doesn't behave correctly.
                throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public VersionHistoryResource getVersionHistory() throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (!isVersionControlled()) {
            throw new DavException(DavServletResponse.SC_FORBIDDEN);
        }
        try {
            VersionHistory vh = getNode().getVersionHistory();
            DavResourceLocator loc = getLocatorFromNode(vh);
            DavResource vhr =  createResourceFromLocator(loc);
            if (vhr instanceof VersionHistoryResource) {
                return (VersionHistoryResource)vhr;
            } else {
                // severe error since resource factory doesn't behave correctly.
                throw new DavException(DavServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public DavResourceIterator getMembers() {
        ArrayList<DavResource> list = new ArrayList<DavResource>();
        if (exists() && isCollection()) {
            try {
                // only display versions as members of the vh. the jcr:versionLabels
                // node is an internal structure.
                VersionIterator it = ((VersionHistory) getNode()).getAllVersions();
                while (it.hasNext()) {
                    // omit item filter here. if the version history is visible
                    // its versions should be visible as well.
                    Version v = it.nextVersion();
                    DavResourceLocator vhLocator = getLocator();
                    DavResourceLocator resourceLocator = vhLocator.getFactory().createResourceLocator(vhLocator.getPrefix(), vhLocator.getWorkspacePath(), v.getPath(), false);
                    DavResource childRes = getFactory().createResource(resourceLocator, getSession());
                    list.add(childRes);
                }
            } catch (RepositoryException e) {
                // should not occur
                log.error("Unexpected error",e);
            } catch (DavException e) {
                // should not occur
                log.error("Unexpected error",e);
            }
        }
        return new DavResourceIteratorImpl(list);
    }


    public DavResourceIterator getMembers() {
        ArrayList<DavResource> list = new ArrayList<DavResource>();
        if (exists() && isCollection()) {
            try {
                NodeIterator it = node.getNodes();
                while (it.hasNext()) {
                    Node n = it.nextNode();
                    if (!isFilteredItem(n)) {
                        DavResourceLocator resourceLocator = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), n.getPath(), false);
                        DavResource childRes = factory.createResource(resourceLocator, session);
                        list.add(childRes);
                    } else {
                        log.debug("Filtered resource '" + n.getName() + "'.");
                    }
                }
            } catch (RepositoryException e) {
                // should not occur
            } catch (DavException e) {
                // should not occur
            }
        }
        return new DavResourceIteratorImpl(list);
    }


    public void move(DavResource destination) throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (isLocked(this)) {
            throw new DavException(DavServletResponse.SC_LOCKED);
        }
        if (isFilteredResource(destination)) {
            throw new DavException(DavServletResponse.SC_FORBIDDEN);
        }
        // make sure, that src and destination belong to the same workspace
        checkSameWorkspace(destination.getLocator());
        if (!config.getCopyMoveManager().move(new CopyMoveContextImpl(getJcrSession()), this, destination)) {
            throw new DavException(DavServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);
        }
    }


    public void copy(DavResource destination, boolean shallow) throws DavException {
        if (!exists()) {
            throw new DavException(DavServletResponse.SC_NOT_FOUND);
        }
        if (isLocked(destination)) {
            throw new DavException(DavServletResponse.SC_LOCKED);
        }
        if (isFilteredResource(destination)) {
            throw new DavException(DavServletResponse.SC_FORBIDDEN);
        }
        // make sure, that src and destination belong to the same workspace
        checkSameWorkspace(destination.getLocator());
        if (!config.getCopyMoveManager().copy(new CopyMoveContextImpl(getJcrSession(), shallow), this, destination)) {
            throw new DavException(DavServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);
        }
    }


    public void bind(DavResource collection, DavResource newBinding) throws DavException {
        if (!exists()) {
            //DAV:bind-source-exists
            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
        }
        if (isLocked(collection)) {
            //DAV:locked-update-allowed?
            throw new DavException(DavServletResponse.SC_LOCKED);
        }
        if (isFilteredResource(newBinding)) {
            throw new DavException(DavServletResponse.SC_FORBIDDEN);
        }
        checkSameWorkspace(collection.getLocator());
        try {
            if (!node.isNodeType(MIX_SHAREABLE)) {
                if (!node.canAddMixin(MIX_SHAREABLE)) {
                    //DAV:binding-allowed
                    throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
                }
                node.addMixin(MIX_SHAREABLE);
                node.save();
            }
            Workspace workspace = session.getRepositorySession().getWorkspace();
            workspace.clone(workspace.getName(), node.getPath(), newBinding.getLocator().getRepositoryPath(), false);

        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }

    }


    public void rebind(DavResource collection, DavResource newBinding) throws DavException {
        if (!exists()) {
            //DAV:rebind-source-exists
            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
        }
        if (isLocked(this)) {
            //DAV:protected-source-url-deletion.allowed
            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
        }
        if (isLocked(collection)) {
            //DAV:locked-update-allowed?
            throw new DavException(DavServletResponse.SC_LOCKED);
        }
        if (isFilteredResource(newBinding)) {
            throw new DavException(DavServletResponse.SC_FORBIDDEN);
        }
        checkSameWorkspace(collection.getLocator());
        try {
            if (!node.isNodeType(MIX_REFERENCEABLE)) {
                throw new DavException(node.canAddMixin(MIX_REFERENCEABLE)?
                                       DavServletResponse.SC_CONFLICT : DavServletResponse.SC_METHOD_NOT_ALLOWED);
            }
            getJcrSession().getWorkspace().move(locator.getRepositoryPath(), newBinding.getLocator().getRepositoryPath());
        } catch (RepositoryException e) {
            throw new JcrDavException(e);
        }
    }


    public void testSetFileSystemOptionsPropertiesInString() throws Exception {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#setFileSystemOptionsPropertiesInString, testDir=" + dataStoreDir);
            doSetFileSystemOptionsPropertiesInString();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#setFileSystemOptionsPropertiesInString finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testReference() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testReference, testDir=" + dataStoreDir);
            doReferenceTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testReference finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testAddRecord() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#addRecord, testDir=" + dataStoreDir);
            doAddRecordTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#addRecord finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testDeleteAllOlderThan() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testDeleteAllOlderThan, testDir=" + dataStoreDir);
            doDeleteAllOlderThan();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testDeleteAllOlderThan finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testGetAllIdentifiers() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testGetAllIdentifiers, testDir=" + dataStoreDir);
            doGetAllIdentifiersTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testGetAllIdentifiers finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testMultiThreaded() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testMultiThreaded, testDir=" + dataStoreDir);
            doTestMultiThreaded();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testMultiThreaded finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }

    }


    public void testDeleteRecord() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testDeleteRecord, testDir=" + dataStoreDir);
            doDeleteRecordTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testDeleteRecord finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testSingleThread() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testSingleThread, testDir=" + dataStoreDir);
            doTestSingleThread();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testSingleThread finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
            fail(e.getMessage());
        }
    }


    public void testGetRecord() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testGetRecord, testDir=" + dataStoreDir);
            doGetRecordTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testGetRecord finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
        }
    }


    public void testUpdateLastModifiedOnAccess() {
        try {
            long start = System.currentTimeMillis();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testUpdateLastModifiedOnAccess, testDir=" + dataStoreDir);
            doUpdateLastModifiedOnAccessTest();
            LOG.info("Testcase: " + this.getClass().getName()
                + "#testUpdateLastModifiedOnAccess finished, time taken = ["
                + (System.currentTimeMillis() - start) + "]ms");
        } catch (Exception e) {
            LOG.error("error:", e);
        }
    }


    static FileObject createChildFolder(FileObject baseFolder, String name) throws DataStoreException {
        FileObject childFolder = null;

        try {
            childFolder = baseFolder.resolveFile(name);

            if (!childFolder.exists()) {
                childFolder.createFolder();
                childFolder = baseFolder.getChild(childFolder.getName().getBaseName());
            }
        } catch (FileSystemException e) {
            throw new DataStoreException(
                    "Could not create a child folder, '" + name + "' under " + baseFolder.getName().getFriendlyURI(),
                    e);
        }

        return childFolder;
    }


    static FileObject createChildFile(FileObject baseFolder, String name) throws DataStoreException {
        FileObject childFile = null;

        try {
            childFile = baseFolder.resolveFile(name);

            if (!childFile.exists()) {
                childFile.createFile();
                childFile = baseFolder.getChild(childFile.getName().getBaseName());
            }
        } catch (FileSystemException e) {
            throw new DataStoreException(
                    "Could not create a child file, '" + name + "' under " + baseFolder.getName().getFriendlyURI(),
                    e);
        }

        return childFile;
    }


    public InputStream read(DataIdentifier identifier) throws DataStoreException {
        FileObject fileObject = getExistingFileObject(identifier);

        if (fileObject == null) {
            throw new DataStoreException("Could not find file object for: " + identifier);
        }

        try {
            return new LazyFileContentInputStream(fileObject);
        } catch (FileSystemException e) {
            throw new DataStoreException("Could not get input stream from object: " + identifier, e);
        }
    }


    public long getLength(DataIdentifier identifier) throws DataStoreException {
        FileObject fileObject = getExistingFileObject(identifier);

        if (fileObject == null) {
            throw new DataStoreException("Could not find file object for: " + identifier);
        }

        try {
            return fileObject.getContent().getSize();
        } catch (FileSystemException e) {
            throw new DataStoreException("Could not get length from object: " + identifier, e);
        }
    }


    protected Value[] getSerialValues(Value[] values)
            throws RepositoryException {
        List<Value> serials = new ArrayList<Value>();
        if (values != null) {
            for (Value value : values) {
                if (value != null) {
                    serials.add(getSerialValue(value));
                }
            }
        }
        return serials.toArray(new Value[serials.size()]);
    }


    public static Value[] makeSerialValueArray(String[] values) {
        List<Value> serials = new ArrayList<Value>();
        if (values != null) {
            for (String value : values) {
                if (value != null) {
                    serials.add(INSTANCE.createValue(value));
                }
            }
        }
        return serials.toArray(new Value[serials.size()]);
    }


    public static Value[] makeSerialValueArray(Value[] values)
            throws RepositoryException {
        List<Value> serials = new ArrayList<Value>();
        if (values != null) {
            for (Value value : values) {
                if (value != null) {
                    serials.add(makeSerialValue(value));
                }
            }
        }
        return serials.toArray(new Value[serials.size()]);
    }


    public RemoteVersion getLinearSuccessor() throws RepositoryException,
    		RemoteException {
        try {
            Version linearSuccessor = version.getLinearSuccessor();
            if (linearSuccessor == null) {
                return null;
            } else {
                return getFactory().getRemoteVersion(linearSuccessor);
            }
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public Version getLinearSuccessor() throws RepositoryException {
        try {
            RemoteVersion linearSuccessor = remote.getLinearSuccessor();
            if (linearSuccessor == null) {
                return null;
            } else {
                return getFactory().getVersion(getSession(), linearSuccessor);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public NodeType getDefaultPrimaryType() {
        try {
            RemoteNodeType nt = remote.getDefaultPrimaryType();
            if (nt == null) {
                return null;
            } else {
                return getFactory().getNodeType(nt);
            }
        } catch (RemoteException ex) {
            throw new RemoteRuntimeException(ex);
        }
    }


    public Node getActivity() throws RepositoryException {
        try {
            RemoteNode activity = remote.getActivity();
            if (activity == null) {
                return null;
            } else {
                return getFactory().getNode(session, activity);
            }
        } catch (RemoteException e) {
            throw new RemoteRepositoryException(e);
        }
    }


    public Version getLinearPredecessor() throws RepositoryException {
        try {
            RemoteVersion linearPredecessor = remote.getLinearPredecessor();
            if (linearPredecessor == null) {
                return null;
            } else {
                return getFactory().getVersion(getSession(), linearPredecessor);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public NodeType getDeclaringNodeType() {
        try {
            RemoteNodeType nt = remote.getDeclaringNodeType();
            if (nt == null) {
                return null;
            } else {
                return getFactory().getNodeType(nt);
            }
        } catch (RemoteException ex) {
            throw new RemoteRuntimeException(ex);
        }
    }


    public RemoteNode getActivity()
            throws RepositoryException, RemoteException {
        try {
            Node activity = manager.getActivity();
            if (activity == null) {
                return null;
            } else {
                return getFactory().getRemoteNode(activity);
            }
        } catch (RepositoryException e) {
            throw getRepositoryException(e);
        }
    }


    public RemoteVersion getLinearPredecessor() throws RepositoryException,
    		RemoteException {
        try {
            Version linearPredecessor = version.getLinearPredecessor();
            if (linearPredecessor == null) {
                return null;
            } else {
                return getFactory().getRemoteVersion(linearPredecessor);
            }
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public RemoteProperty setProperty(String name, Value[] values)
            throws RepositoryException, RemoteException {
        try {
            Property property = node.setProperty(name, values);
            if (property == null) {
                return null;
            } else {
                return getFactory().getRemoteProperty(property);
            }
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public RemoteProperty setProperty(String name, Value value, int type)
            throws RepositoryException, RemoteException {
        try {
            Property property = node.setProperty(name, value, type);
            if (property == null) {
                return null;
            } else {
                return getFactory().getRemoteProperty(property);
            }
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public Property setProperty(String name, Value value)
            throws RepositoryException {
        try {
            if (value == null) {
                remote.setProperty(name, value);
                return null;
            } else {
                RemoteProperty property = remote.setProperty(
                        name, SerialValueFactory.makeSerialValue(value));
                return getFactory().getProperty(getSession(), property);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public Property setProperty(String name, Value[] values)
            throws RepositoryException {
        try {
            if (values == null) {
                remote.setProperty(name, values);
                return null;
            } else {
                Value[] serials = SerialValueFactory.makeSerialValueArray(values);
                RemoteProperty property = remote.setProperty(name, serials);
                return getFactory().getProperty(getSession(), property);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public Property setProperty(String name, String[] strings)
            throws RepositoryException {
        try {
            if (strings == null) {
                remote.setProperty(name, (Value[]) null);
                return null;
            } else {
                Value[] serials = SerialValueFactory.makeSerialValueArray(strings);
                RemoteProperty property = remote.setProperty(name, serials);
                return getFactory().getProperty(getSession(), property);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public Property setProperty(String name, String[] strings, int type)
            throws RepositoryException {
        try {
            if (strings == null) {
                remote.setProperty(name, (Value[]) null);
                return null;
            } else {
                Value[] serials = SerialValueFactory.makeSerialValueArray(strings);
                RemoteProperty property = remote.setProperty(name, serials, type);
                return getFactory().getProperty(getSession(), property);
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public RemoteObservationManager getObservationManager()
            throws RepositoryException, RemoteException {
        try {
            if (remoteObservationManager == null) {
                ObservationManager observationManager =
                    workspace.getObservationManager();
                remoteObservationManager =
                    getFactory().getRemoteObservationManager(observationManager);
            }
            return remoteObservationManager;
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public RemoteVersionManager getVersionManager()
            throws RepositoryException, RemoteException {
        try {
            if (remoteVersionManager == null) {
                VersionManager versionManager = workspace.getVersionManager();
                remoteVersionManager =
                    getFactory().getRemoteVersionManager(workspace.getSession(), versionManager);
            }
            return remoteVersionManager;
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public RemoteLockManager getLockManager()
            throws RepositoryException, RemoteException {
        try {
            if (remoteLockManager == null) {
                LockManager lockManager = workspace.getLockManager();
                remoteLockManager =
                    getFactory().getRemoteLockManager(lockManager);
            }
            return remoteLockManager;
        } catch (RepositoryException ex) {
            throw getRepositoryException(ex);
        }
    }


    public Property setProperty(String name, Value[] values, int type)
            throws RepositoryException {
        try {
            if (values != null) {
                values = SerialValueFactory.makeSerialValueArray(values);
            }
            RemoteProperty property = remote.setProperty(name, values, type);
            if (property != null) {
                return getFactory().getProperty(getSession(), property);
            } else {
                return null;
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public Property setProperty(String name, Value value, int type)
            throws RepositoryException {
        try {
            if (value != null) {
                value = SerialValueFactory.makeSerialValue(value);
            }
            RemoteProperty property = remote.setProperty(name, value, type);
            if (property != null) {
                return getFactory().getProperty(getSession(), property);
            } else {
                return null;
            }
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }
    }


    public boolean hasPrivileges(String absPath, Privilege[] privileges)
            throws PathNotFoundException, RepositoryException {
        String[] privNames = new String[privileges.length];
        for (int i = 0; i < privNames.length; i++) {
            privNames[i] = privileges[i].getName();
        }

        try {
            return racm.hasPrivileges(absPath, privNames);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        }

    }


    public void restore(Version[] versions, boolean removeExisting)
            throws RepositoryException {
        try {
            String[] versionIdentifiers = new String[versions.length];
            for (int i = 0; i < versions.length; i++) {
                versionIdentifiers[i] = versions[i].getIdentifier();
            }
            remote.restore(versionIdentifiers, removeExisting);
        } catch (RemoteException e) {
            throw new RemoteRepositoryException(e);
        }
    }


    public void importXML(String path, InputStream xml, int mode)
            throws IOException, RepositoryException {
        try {
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            byte[] bytes = new byte[4096];
            for (int n = xml.read(bytes); n != -1; n = xml.read(bytes)) {
                buffer.write(bytes, 0, n);
            }
            remote.importXML(path, buffer.toByteArray(), mode);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        } finally {
            // JCR-2903
            try { xml.close(); } catch (IOException ignore) {}
        }
    }


    public void importXML(String path, InputStream xml, int uuidBehaviour)
            throws IOException, RepositoryException {
        try {
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            byte[] bytes = new byte[4096];
            for (int n = xml.read(bytes); n != -1; n = xml.read(bytes)) {
                buffer.write(bytes, 0, n);
            }
            remote.importXML(path, buffer.toByteArray(), uuidBehaviour);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        } finally {
            // JCR-2903
            try { xml.close(); } catch (IOException ignore) {}
        }
    }


    public ContentHandler getImportContentHandler(
            final String path, final int mode) throws RepositoryException {
        getItem(path); // Check that the path exists
        try {
            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            ContentHandler handler =
                SerializingContentHandler.getSerializer(buffer);
            return new DefaultContentHandler(handler) {
                public void endDocument() throws SAXException {
                    super.endDocument();
                    try {
                        remote.importXML(path, buffer.toByteArray(), mode);
                    } catch (Exception e) {
                        throw new SAXException("XML import failed", e);
                    }
                }
            };
        } catch (SAXException e) {
            throw new RepositoryException("XML serialization failed", e);
        }
    }


    public ContentHandler getImportContentHandler(
            final String path, final int mode) throws RepositoryException {
        getSession().getItem(path); // Check that the path exists
        try {
            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            return new DefaultContentHandler(
                    SerializingContentHandler.getSerializer(buffer)) {
                public void endDocument() throws SAXException {
                    super.endDocument();
                    try {
                        remote.importXML(path, buffer.toByteArray(), mode);
                    } catch (Exception e) {
                        throw new SAXException("XML import failed", e);
                    }
                }
            };
        } catch (SAXException e) {
            throw new RepositoryException("XML serialization failed", e);
        }
    }


    public void exportSystemView(
            String path, ContentHandler handler,
            boolean binaryAsLink, boolean noRecurse)
            throws SAXException, RepositoryException {
        try {
            byte[] xml = remote.exportSystemView(path, binaryAsLink, noRecurse);

            Source source = new StreamSource(new ByteArrayInputStream(xml));
            Result result = new SAXResult(handler);

            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            transformer.transform(source, result);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        } catch (IOException ex) {
            throw new SAXException(ex);
        } catch (TransformerConfigurationException ex) {
            throw new SAXException(ex);
        } catch (TransformerException ex) {
            throw new SAXException(ex);
        }
    }


    public void exportDocumentView(
            String path, ContentHandler handler,
            boolean binaryAsLink, boolean noRecurse)
            throws SAXException, RepositoryException {
        try {
            byte[] xml = remote.exportDocumentView(path, binaryAsLink, noRecurse);

            Source source = new StreamSource(new ByteArrayInputStream(xml));
            Result result = new SAXResult(handler);

            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            transformer.transform(source, result);
        } catch (RemoteException ex) {
            throw new RemoteRepositoryException(ex);
        } catch (IOException ex) {
            throw new SAXException(ex);
        } catch (TransformerConfigurationException ex) {
            throw new SAXException(ex);
        } catch (TransformerException ex) {
            throw new SAXException(ex);
        }
    }


    public synchronized String getDescriptor(String name) {
        try {
            return remote.getDescriptor(name);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.getDescriptor(name);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    public synchronized boolean isStandardDescriptor(String key) {
        try {
            return remote.isStandardDescriptor(key);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.isStandardDescriptor(key);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    public synchronized Value[] getDescriptorValues(String key) {
        try {
            return remote.getDescriptorValues(key);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.getDescriptorValues(key);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    public synchronized Value getDescriptorValue(String key) {
        try {
            return remote.getDescriptorValue(key);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.getDescriptorValue(key);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    public synchronized boolean isSingleValueDescriptor(String key) {
        try {
            return remote.isSingleValueDescriptor(key);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.isSingleValueDescriptor(key);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    public synchronized String[] getDescriptorKeys() {
        try {
            return remote.getDescriptorKeys();
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.getDescriptorKeys();
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRuntimeException(e2);
            }
        }
    }


    private synchronized RemoteSession remoteLogin(
            Credentials credentials, String workspace)
            throws RepositoryException {
        try {
            return remote.login(credentials, workspace);
        } catch (RemoteException e1) {
            try {
                remote = getRemoteRepository(false);
                return remote.login(credentials, workspace);
            } catch (RemoteException e2) {
                remote = new BrokenRemoteRepository(e2);
                throw new RemoteRepositoryException(e2);
            }
        }
    }


    protected void doGetRecordTest() throws Exception {
        ds = createDataStore();
        byte[] data = new byte[dataLength];
        randomGen.nextBytes(data);
        DataRecord rec = ds.addRecord(new ByteArrayInputStream(data));
        rec = ds.getRecord(rec.getIdentifier());
        assertEquals(data.length, rec.getLength());
        assertRecord(data, rec);
        ds.close();
    }


    protected void doReferenceTest() throws Exception {
        ds = createDataStore();
        byte[] data = new byte[dataLength];
        randomGen.nextBytes(data);
        String reference;
        DataRecord record = ds.addRecord(new ByteArrayInputStream(data));
        reference = record.getReference();
        assertReference(data, reference, ds);
        ds.close();
    }


    protected DataStore createDataStore() throws RepositoryException {
        CachingFDS cacheFDS = new CachingFDS();
        Properties props = loadProperties("/fs.properties");
        String pathValue = props.getProperty(FSBackend.FS_BACKEND_PATH);
        if (pathValue != null && !"".equals(pathValue.trim())) {
            fsPath = pathValue + "/cachingFds" + "-"
                + String.valueOf(randomGen.nextInt(100000)) + "-"
                + String.valueOf(randomGen.nextInt(100000));
        } else {
            fsPath = dataStoreDir + "/cachingFds";
        }
        props.setProperty(FSBackend.FS_BACKEND_PATH, fsPath);
        LOG.info("fsBackendPath [{}] set.", fsPath);
        cacheFDS.setProperties(props);
        cacheFDS.setSecret("12345");
        // disable asynchronous writing in testing.
        cacheFDS.setAsyncUploadLimit(0);
        cacheFDS.init(dataStoreDir);
        return cacheFDS;
    }


    protected DataStore createDataStore() throws RepositoryException {
        CachingFDS cacheFDS = new CachingFDS();
        Properties props = loadProperties("/fs.properties");
        String pathValue = props.getProperty(FSBackend.FS_BACKEND_PATH);
        if (pathValue != null && !"".equals(pathValue.trim())) {
            fsPath = pathValue + "/cachingFds" + "-"
                + String.valueOf(randomGen.nextInt(100000)) + "-"
                + String.valueOf(randomGen.nextInt(100000));
        } else {
            fsPath = dataStoreDir + "/cachingFDS";
        }
        props.setProperty(FSBackend.FS_BACKEND_PATH, fsPath);
        cacheFDS.setProperties(props);
        cacheFDS.setSecret("12345");
        // disable asynchronous writing in testing.
        cacheFDS.setAsyncUploadLimit(0);
        cacheFDS.setCacheSize(0);
        cacheFDS.init(dataStoreDir);
        return cacheFDS;
    }


    public void deleteRecord(DataIdentifier identifier)
			throws DataStoreException {
        File file = getFile(identifier);
        synchronized (this) {
            if (file.exists()) {
                if (file.delete()) {
                    deleteEmptyParentDirs(file);
                } else {
                    log.warn("Failed to delete file " + file.getAbsolutePath());
                }
            }
        }
    }


    public void deleteRecord(DataIdentifier identifier)
                    throws DataStoreException {
        File file = getFile(identifier);
        synchronized (this) {
            if (file.exists()) {
                if (file.delete()) {
                    deleteEmptyParentDirs(file);
                } else {
                    LOG.warn("Failed to delete file " + file.getAbsolutePath());
                }
            }
        }
    }


    private void deleteEmptyParentDirs(File file) {
        File parent = file.getParentFile();
        try {
            // Only iterate & delete if parent directory of the blob file is child
            // of the base directory and if it is empty
            while (FileUtils.directoryContains(directory, parent)) {
                String[] entries = parent.list();
                if (entries == null) {
                    log.warn("Failed to list directory {}", parent.getAbsolutePath());
                    break;
                }
                if (entries.length > 0) {
                    break;
                }
                boolean deleted = parent.delete();
                log.debug("Deleted parent [{}] of file [{}]: {}",
                        new Object[]{parent, file.getAbsolutePath(), deleted});
                parent = parent.getParentFile();
            }
        } catch (IOException e) {
            log.warn("Error in parents deletion for " + file.getAbsoluteFile(), e);
        }
    }


    private void deleteEmptyParentDirs(File file) {
        File parent = file.getParentFile();
        try {
            // Only iterate & delete if parent directory of the blob file is
            // child
            // of the base directory and if it is empty
            while (FileUtils.directoryContains(fsPathDir, parent)) {
                String[] entries = parent.list();
                if (entries == null) {
                    LOG.warn("Failed to list directory {}",
                        parent.getAbsolutePath());
                    break;
                }
                if (entries.length > 0) {
                    break;
                }
                boolean deleted = parent.delete();
                LOG.debug("Deleted parent [{}] of file [{}]: {}", new Object[] {
                    parent, file.getAbsolutePath(), deleted });
                parent = parent.getParentFile();
            }
        } catch (IOException e) {
            LOG.warn("Error in parents deletion for " + file.getAbsoluteFile(),
                e);
        }
    }


    private int deleteOlderRecursive(File file, long min) {
        int count = 0;
        if (file.isFile() && file.exists() && file.canWrite()) {
            synchronized (this) {
                long lastModified;
                try {
                    lastModified = getLastModified(file);
                } catch (DataStoreException e) {
                    log.warn("Failed to read modification date; file not deleted", e);
                    // don't delete the file, since the lastModified date is uncertain
                    lastModified = min;
                }
                if (lastModified < min) {
                    DataIdentifier id = new DataIdentifier(file.getName());
                    if (!inUse.containsKey(id)) {
                        if (log.isInfoEnabled()) {
                            log.info("Deleting old file " + file.getAbsolutePath() +
                                    " modified: " + new Timestamp(lastModified).toString() +
                                    " length: " + file.length());
                        }
                        if (!file.delete()) {
                            log.warn("Failed to delete old file " + file.getAbsolutePath());
                        }
                        count++;
                    }
                }
            }
        } else if (file.isDirectory()) {
            File[] list = file.listFiles();
            if (list != null) {
                for (File f: list) {
                    count += deleteOlderRecursive(f, min);
                }
            }

            // JCR-1396: FileDataStore Garbage Collector and empty directories
            // Automatic removal of empty directories (but not the root!)
            synchronized (this) {
                list = file.listFiles();
                if (list != null && list.length == 0) {
                    file.delete();
                }
            }
        }
        return count;
    }


    private void deleteOlderRecursive(File file, long min,
                    Set<DataIdentifier> deleteIdSet) throws DataStoreException {
        if (file.isFile() && file.exists() && file.canWrite()) {
            synchronized (this) {
                long lastModified;
                try {
                    lastModified = getLastModified(file);
                } catch (DataStoreException e) {
                    LOG.warn(
                        "Failed to read modification date; file not deleted", e);
                    // don't delete the file, since the lastModified date is
                    // uncertain
                    lastModified = min;
                }
                if (lastModified < min) {
                    DataIdentifier id = new DataIdentifier(file.getName());
                    if (getDataStore().confirmDelete(id)) {
                        getDataStore().deleteFromCache(id);
                        if (LOG.isInfoEnabled()) {
                            LOG.info("Deleting old file "
                                + file.getAbsolutePath() + " modified: "
                                + new Timestamp(lastModified).toString()
                                + " length: " + file.length());
                        }
                        if (file.delete()) {
                            deleteIdSet.add(id);
                        } else {
                            LOG.warn("Failed to delete old file "
                                + file.getAbsolutePath());
                        }
                    }
                }
            }
        } else if (file.isDirectory()) {
            File[] list = file.listFiles();
            if (list != null) {
                for (File f : list) {
                    deleteOlderRecursive(f, min, deleteIdSet);
                }
            }

            // JCR-1396: FileDataStore Garbage Collector and empty directories
            // Automatic removal of empty directories (but not the root!)
            synchronized (this) {
                list = file.listFiles();
                if (list != null && list.length == 0) {
                    file.delete();
                }
            }
        }
    }


    private void listRecursive(List<File> list, File file) {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isDirectory()) {
                    listRecursive(list, f);
                } else {
                    list.add(f);
                }
            }
        }
    }


    private void listRecursive(List<File> list, File file) {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isDirectory()) {
                    listRecursive(list, f);
                } else {
                    list.add(f);
                }
            }
        }
    }


    private static void listRecursive(List<File> list, File file) {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isDirectory()) {
                    listRecursive(list, f);
                } else {
                    list.add(f);
                }
            }
        }
    }


    public Iterator<DataIdentifier> getAllIdentifiers() {
        ArrayList<File> files = new ArrayList<File>();
        for (File file : directory.listFiles()) {
            if (file.isDirectory()) { // skip top-level files
                listRecursive(files, file);
            }
        }

        ArrayList<DataIdentifier> identifiers = new ArrayList<DataIdentifier>();
        for (File f: files) {
            String name = f.getName();
            identifiers.add(new DataIdentifier(name));
        }
        log.debug("Found " + identifiers.size() + " identifiers.");
        return identifiers.iterator();
    }


    public Iterator<DataIdentifier> getAllIdentifiers()
                    throws DataStoreException {
        ArrayList<File> files = new ArrayList<File>();
        for (File file : fsPathDir.listFiles()) {
            if (file.isDirectory()) { // skip top-level files
                listRecursive(files, file);
            }
        }

        ArrayList<DataIdentifier> identifiers = new ArrayList<DataIdentifier>();
        for (File f : files) {
            String name = f.getName();
            identifiers.add(new DataIdentifier(name));
        }
        LOG.debug("Found " + identifiers.size() + " identifiers.");
        return identifiers.iterator();
    }


    private static void setLastModified(File file, long time) throws DataStoreException {
        if (!file.setLastModified(time)) {
            if (!file.canWrite()) {
                // if we can't write to the file, so garbage collection will also not delete it
                // (read only files or file systems)
                return;
            }
            try {
                // workaround for Windows: if the file is already open for reading
                // (in this or another process), then setting the last modified date
                // doesn't work - see also JCR-2872
                RandomAccessFile r = new RandomAccessFile(file, "rw");
                try {
                    r.setLength(r.length());
                } finally {
                    r.close();
                }
            } catch (IOException e) {
                throw new DataStoreException("An IO Exception occurred while trying to set the last modified date: " + file.getAbsolutePath(), e);
            }
        }
    }


    private static void setLastModified(File file, long time)
                    throws DataStoreException {
        if (!file.setLastModified(time)) {
            if (!file.canWrite()) {
                // if we can't write to the file, so garbage collection will
                // also not delete it
                // (read only files or file systems)
                return;
            }
            try {
                // workaround for Windows: if the file is already open for
                // reading
                // (in this or another process), then setting the last modified
                // date
                // doesn't work - see also JCR-2872
                RandomAccessFile r = new RandomAccessFile(file, "rw");
                try {
                    r.setLength(r.length());
                } finally {
                    r.close();
                }
            } catch (IOException e) {
                throw new DataStoreException(
                    "An IO Exception occurred while trying to set the last modified date: "
                        + file.getAbsolutePath(), e);
            }
        }
    }


    private synchronized void serializeAsyncUploadMap() throws IOException {

        // use buffering
        OutputStream fos = new FileOutputStream(pendingUploads);
        OutputStream buffer = new BufferedOutputStream(fos);
        ObjectOutput output = new ObjectOutputStream(buffer);
        try {
            output.writeObject(asyncUploadMap);
            output.flush();
        } finally {
            output.close();
            IOUtils.closeQuietly(buffer);
            
        }
    }


    private synchronized void deserializeAsyncUploadMap() throws IOException,
            ClassNotFoundException {
        // use buffering
        InputStream fis = new FileInputStream(pendingUploads);
        InputStream buffer = new BufferedInputStream(fis);
        ObjectInput input = new ObjectInputStream(buffer);
        try {
            asyncUploadMap = (Map<String, Long>) input.readObject();
        } finally {
            input.close();
            IOUtils.closeQuietly(buffer);
        }
    }


    private synchronized void serializeToBeDeleted() throws IOException {

        // use buffering
        OutputStream fos = new FileOutputStream(toBeDeletedUploads);
        OutputStream buffer = new BufferedOutputStream(fos);
        ObjectOutput output = new ObjectOutputStream(buffer);
        try {
            output.writeObject(toBeDeleted);
            output.flush();
        } finally {
            output.close();
            IOUtils.closeQuietly(buffer);
        }
    }


    private synchronized void deserializeToBeDeleted() throws IOException,
            ClassNotFoundException {
        // use buffering
        InputStream fis = new FileInputStream(toBeDeletedUploads);
        InputStream buffer = new BufferedInputStream(fis);
        ObjectInput input = new ObjectInputStream(buffer);
        try {
            toBeDeleted = (Set<String>) input.readObject();
        } finally {
            input.close();
            IOUtils.closeQuietly(buffer);
        }
    }


            public void run() {
                try {
                    write(identifier, src);
                    callback.onSuccess(new AsyncUploadResult(identifier, src));
                } catch (DataStoreException dse) {
                    AsyncUploadResult res = new AsyncUploadResult(identifier,
                        src);
                    res.setException(dse);
                    callback.onFailure(res);
                }

            }


                public void run() {
                    try {
                        touch(identifier, minModifiedDate);
                        callback.onSuccess(new AsyncTouchResult(identifier));
                    } catch (DataStoreException e) {
                        AsyncTouchResult result = new AsyncTouchResult(
                            identifier);
                        result.setException(e);
                        callback.onFailure(result);
                    }
                }


                public void run() {
                    try {
                        touch(identifier, minModifiedDate);
                        callback.onSuccess(new AsyncTouchResult(identifier));
                    } catch (DataStoreException e) {
                        AsyncTouchResult result = new AsyncTouchResult(
                            identifier);
                        result.setException(e);
                        callback.onFailure(result);
                    }
                }


    public void touchAsync(final DataIdentifier identifier,
                    final long minModifiedDate,
                    final AsyncTouchCallback callback)
                    throws DataStoreException {
        try {
            if (callback == null) {
                throw new IllegalArgumentException(
                    "callback parameter cannot be null in touchAsync");
            }
            Thread.currentThread().setContextClassLoader(
                getClass().getClassLoader());

            getAsyncWriteExecutor().execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        touch(identifier, minModifiedDate);
                        callback.onSuccess(new AsyncTouchResult(identifier));
                    } catch (DataStoreException e) {
                        AsyncTouchResult result = new AsyncTouchResult(
                            identifier);
                        result.setException(e);
                        callback.onFailure(result);
                    }
                }
            });
        } catch (Exception e) {
            callback.onAbort(new AsyncTouchResult(identifier));
            throw new DataStoreException("Cannot touch the record "
                + identifier.toString(), e);
        }

    }


    public void touchAsync(final DataIdentifier identifier,
            final long minModifiedDate, final AsyncTouchCallback callback)
            throws DataStoreException {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            if (callback == null) {
                throw new IllegalArgumentException(
                    "callback parameter cannot be null in touchAsync");
            }
            Thread.currentThread().setContextClassLoader(
                getClass().getClassLoader());

            getAsyncWriteExecutor().execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        touch(identifier, minModifiedDate);
                        callback.onSuccess(new AsyncTouchResult(identifier));
                    } catch (DataStoreException e) {
                        AsyncTouchResult result = new AsyncTouchResult(
                            identifier);
                        result.setException(e);
                        callback.onFailure(result);
                    }
                }
            });
        } catch (Exception e) {
            callback.onAbort(new AsyncTouchResult(identifier));
            throw new DataStoreException("Cannot touch the record "
                + identifier.toString(), e);
        } finally {
            if (contextClassLoader != null) {
                Thread.currentThread().setContextClassLoader(contextClassLoader);
            }
        }

    }


    public int read() throws IOException {
        if (endOfStream) {
            return -1;
        }
        openStream();
        int c = in.read();
        if (c == -1) {
            endOfStream = true;
            close();
        }
        return c;
    }


    public int read(byte[] b, int off, int len) throws IOException {
        if (endOfStream) {
            return -1;
        }
        openStream();
        int c = in.read(b, off, len);
        if (c == -1) {
            endOfStream = true;
            close();
        }
        return c;
    }


    public void deleteFile(String filePath) throws FileSystemException {
        File f = new File(root, osPath(filePath));
        if (!f.isFile()) {
            String msg = f.getPath() + " does not denote an existing file";
            throw new FileSystemException(msg);
        }
        try {
            FileUtil.delete(f);
        } catch (IOException ioe) {
            String msg = "failed to delete " + f.getPath();
            if (monitor != null && monitor.isOpen(f)) {
                log.error("Unable to delete. There are still open streams.");
                monitor.dump(f);
            }

            throw new FileSystemException(msg, ioe);
        }
    }


    public void deleteFolder(String folderPath) throws FileSystemException {
        File f = new File(root, osPath(folderPath));
        if (!f.isDirectory()) {
            String msg = f.getPath() + " does not denote an existing folder";
            log.debug(msg);
            throw new FileSystemException(msg);
        }
        try {
            FileUtil.delete(f);
        } catch (IOException ioe) {
            String msg = "failed to delete " + f.getPath();
            log.debug(msg);
            throw new FileSystemException(msg, ioe);
        }
    }


    public String[] listFiles(String folderPath) throws FileSystemException {
        File folder = new File(root, osPath(folderPath));
        File[] files = folder.listFiles(new FileFilter() {
            public boolean accept(File f) {
                return f.isFile();
            }
        });
        if (files == null) {
            String msg = folderPath + " does not denote a folder";
            log.debug(msg);
            throw new FileSystemException(msg);
        }
        String[] entries = new String[files.length];
        for (int i = 0; i < files.length; i++) {
            entries[i] = files[i].getName();
        }
        return entries;
    }


    public String[] listFolders(String folderPath) throws FileSystemException {
        File file = new File(root, osPath(folderPath));
        File[] folders = file.listFiles(new FileFilter() {
            public boolean accept(File f) {
                return f.isDirectory();
            }
        });
        if (folders == null) {
            String msg = folderPath + " does not denote a folder";
            log.debug(msg);
            throw new FileSystemException(msg);
        }
        String[] entries = new String[folders.length];
        for (int i = 0; i < folders.length; i++) {
            entries[i] = folders[i].getName();
        }
        return entries;
    }


    protected CachingDataStore createDataStore() throws RepositoryException {
        S3DataStore s3ds = new S3DataStore();
        s3ds.setProperties(props);
        s3ds.setCacheSize(dataLength * 10);
        s3ds.setCachePurgeTrigFactor(0.5d);
        s3ds.setCachePurgeResizeFactor(0.4d);
        s3ds.setSecret("123456");
        s3ds.init(dataStoreDir);
        sleep(1000);
        return s3ds;
    }


    protected CachingDataStore createDataStore() throws RepositoryException {
        S3DataStore s3ds = new S3DataStore();
        s3ds.setProperties(props);
        s3ds.setTouchAsync(true);
        s3ds.setSecret("123456");
        s3ds.init(dataStoreDir);
        s3ds.updateModifiedDateOnAccess(System.currentTimeMillis() + 50 * 1000);
        sleep(1000);
        return s3ds;
    }


    public InputStream read(DataIdentifier identifier)
            throws DataStoreException {
        long start = System.currentTimeMillis();
        String key = getKeyName(identifier);
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(
                getClass().getClassLoader());
            S3Object object = s3service.getObject(bucket, key);
            InputStream in = object.getObjectContent();
            LOG.debug("[{}] read took [{}]ms", identifier,
                (System.currentTimeMillis() - start));
            return in;
        } catch (AmazonServiceException e) {
            throw new DataStoreException("Object not found: " + key, e);
        } finally {
            if (contextClassLoader != null) {
                Thread.currentThread().setContextClassLoader(contextClassLoader);
            }
        }
    }


    public long getLength(DataIdentifier identifier) throws DataStoreException {
        long start = System.currentTimeMillis();
        String key = getKeyName(identifier);
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(
                getClass().getClassLoader());
            ObjectMetadata object = s3service.getObjectMetadata(bucket, key);
            long length = object.getContentLength();
            LOG.debug("Identifier [{}]'s length = [{}] took [{}]ms.",
                new Object[] { identifier, length,
                    (System.currentTimeMillis() - start) });
            return length;
        } catch (AmazonServiceException e) {
            throw new DataStoreException("Could not length of dataIdentifier "
                + identifier, e);
        } finally {
            if (contextClassLoader != null) {
                Thread.currentThread().setContextClassLoader(contextClassLoader);
            }
        }
    }


    public long getLastModified(DataIdentifier identifier)
            throws DataStoreException {
        long start = System.currentTimeMillis();
        String key = getKeyName(identifier);
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(
                getClass().getClassLoader());
            ObjectMetadata object = s3service.getObjectMetadata(bucket, key);
            long lastModified = object.getLastModified().getTime();
            LOG.debug(
                "Identifier [{}]'s lastModified = [{}] took [{}]ms.",
                new Object[] { identifier, lastModified,
                    (System.currentTimeMillis() - start) });
            return lastModified;
        } catch (AmazonServiceException e) {
            if (e.getStatusCode() == 404 || e.getStatusCode() == 403) {
                LOG.info(
                    "getLastModified:Identifier [{}] not found. Took [{}] ms.",
                    identifier, (System.currentTimeMillis() - start));
            }
            throw new DataStoreException(e);
        } finally {
            if (contextClassLoader != null) {
                Thread.currentThread().setContextClassLoader(contextClassLoader);
            }
        }
    }


    public PutObjectRequest decorate(PutObjectRequest request) {
        switch (getDataEncryption()) {
            case SSE_S3:
                ObjectMetadata metadata = request.getMetadata() == null
                                ? new ObjectMetadata()
                                : request.getMetadata();
                metadata.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);
                request.setMetadata(metadata);
                break;
            case NONE:
                break;
        }
        return request;
    }


    public CopyObjectRequest decorate(CopyObjectRequest request) {
        switch (getDataEncryption()) {
            case SSE_S3:
                ObjectMetadata metadata = request.getNewObjectMetadata() == null
                                ? new ObjectMetadata()
                                : request.getNewObjectMetadata();
                metadata.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);
                request.setNewObjectMetadata(metadata);
                break;
            case NONE:
                break;
        }
        return request;
    }


    protected long getSize(RangeIterator it) {
        long size = it.getSize();
        if (size != -1) {
            return size;
        }
        size = 0;
        while (it.hasNext()) {
            it.next();
            size++;
        }
        return size;
    }


    private long getSize(RangeIterator it) {
        long size = it.getSize();
        if (size != -1) {
            return size;
        }
        size = 0;
        while (it.hasNext()) {
            it.next();
            size++;
        }
        return size;
    }


    protected void setUp() throws Exception {
        isReadOnly = true;
        super.setUp();

        session = getHelper().getReadOnlySession();
        testRootNode = session.getRootNode().getNode(testPath);

        PropertyIterator properties = testRootNode.getProperties();
        try {
            property = properties.nextProperty();
        } catch (NoSuchElementException e) {
            fail("Any node must have at least one property set: jcr:primaryType");
        }

    }


    protected void setUp() throws Exception {
        isReadOnly = true;
        super.setUp();

        session = getHelper().getReadOnlySession();

        testRootNode = session.getRootNode().getNode(testPath);
        NodeIterator nodes = testRootNode.getNodes();
        try {
            childNode = nodes.nextNode();
        } catch (NoSuchElementException e) {
        }
    }


    protected void setUp() throws Exception {
        isReadOnly = true;
        super.setUp();

        session = getHelper().getReadOnlySession();
        testRootNode = session.getRootNode().getNode(testPath);
        NodeIterator nodes = testRootNode.getNodes();
        try {
            childNode = nodes.nextNode();
        } catch (NoSuchElementException e) {
        }
    }


    public void testAccept() throws RepositoryException {
        final Property p = property;

        ItemVisitor itemVisitor = new ItemVisitor() {
            public void visit(Property property)
                    throws RepositoryException {
                assertTrue("Visited Property is not the same as the one returned by visit(Property).",
                        p.isSame(property));
            }

            public void visit(Node node) {
                fail("Wrong accept method executed.");
            }
        };

        p.accept(itemVisitor);
    }


    public void testAccept() throws RepositoryException {
        final Node n = testRootNode;

        ItemVisitor itemVisitor = new ItemVisitor() {
            public void visit(Property property) {
                fail("Wrong accept method executed.");
            }

            public void visit(Node node) throws RepositoryException {
                assertTrue("Visited node is not the same as the one passed in method visit(Node)",
                        n.isSame(node));
            }
        };

        n.accept(itemVisitor);
    }


    public void testCopyNodesVersionableAndCheckedIn() throws RepositoryException,
            NotExecutableException {
        // prepare the test data
        // create a non-versionable node below a versionable node
        // required for having a nearest versionable ancestor to a nonversionable sub node
        String dstAbsPath = node1W2.getPath() + "/" + node2.getName();
        workspaceW2.copy(workspace.getName(), node1.getPath(), dstAbsPath);

        // make parent node versionable and check-in
        addMixinVersionableToNode(testRootNodeW2, node1W2);
        node1W2.checkin();

        // 1. parent node of destAbsPath is non-versionable but its nearest versionable ancestor is checked-in
        try {
            workspaceW2.copy(workspace.getName(), node2.getPath(), dstAbsPath + "/" + node2.getName());
            fail("Copying a node to a node's versionable and checked-in nearest ancestor node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }

        // 2. parent node of destAbsPath is versionable and checked-in
        try {
            workspaceW2.copy(workspace.getName(), node2.getPath(), node1W2.getPath() + "/" + node2.getName());
            fail("Copying a node to a versionable and checked-in parent node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }
    }


    public void testCloneNodesVersionableAndCheckedIn() throws RepositoryException,
            NotExecutableException {
        // prepare the test data
        // create a non-versionable node below a versionable node
        // required for having a nearest versionable ancestor to a nonversionable sub node
        String dstAbsPath = node1W2.getPath() + "/" + node2.getName();
        workspaceW2.copy(workspace.getName(), node1.getPath(), dstAbsPath);

        // make parent node versionable and check-in
        addMixinVersionableToNode(testRootNodeW2, node1W2);
        node1W2.checkin();

        // 1. parent node of destAbsPath is non-versionable but its nearest versionable ancestor is checked-in
        try {
            workspaceW2.clone(workspace.getName(), node2.getPath(), dstAbsPath + "/" + node2.getName(), true);
            fail("Cloning a node to a node's versionable and checked-in nearest ancestor node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }

        // 2. parent node of destAbsPath is versionable and checked-in
        try {
            workspaceW2.clone(workspace.getName(), node2.getPath(), node1W2.getPath() + "/" + node2.getName(), true);
            fail("Cloning a node to a versionable and checked-in parent node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }
    }


    public void testAddMixinTwice() throws RepositoryException, NotExecutableException {
        Session session = testRootNode.getSession();
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);

        if (mixinName == null) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        node.addMixin(mixinName);
        // adding again must succeed
        node.addMixin(mixinName);

        session.save();

        node.addMixin(mixinName);
        assertFalse(node.isModified());
    }


    public void testAddMixinTwice() throws RepositoryException, NotExecutableException {
        Session session = testRootNode.getSession();
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);

        if (mixinName == null) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        assertTrue(node.canAddMixin(mixinName));
        node.addMixin(mixinName);
        // adding again must be possible (though it has no effect)
        assertTrue(node.canAddMixin(mixinName));

        session.save();

        // adding again must be possible (though it has no effect)
        assertTrue(node.canAddMixin(mixinName));
    }


    public void testLocked()
            throws NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        testRootNode.getSession().save();

        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);
        if (mixinName == null) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            try {
                // implementation specific: either throw LockException upon
                // addMixin or upon save.
                node.addMixin(mixinName);
                node.save();
                fail("Node.addMixin(String mixinName) must throw a LockException " +
                        "if the node is locked.");
            } catch (LockException e) {
                // success
            }

            // unlock to remove node at tearDown()
            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void testLocked()
            throws ConstraintViolationException, NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        testRootNode.getSession().save();

        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);
        if (mixinName == null) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        node.addMixin(mixinName);
        testRootNode.getSession().save();

        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            try {
                // remove mixin on locked node must throw either directly upon
                // removeMixin or upon save.
                node.removeMixin(mixinName);
                node.save();
                fail("Node.removeMixin(String mixinName) must throw a " +
                        "LockException if the node is locked.");
            } catch (LockException e) {
                // success
            }

            // unlock to remove node at tearDown()
            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void testLocked() throws NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        testRootNode.getSession().save();

        String primaryTypeName = getPrimaryTypeName(session, node);
        if (primaryTypeName == null) {
            throw new NotExecutableException("No testable node type found");
        }

        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            try {
                // implementation specific: either throw LockException upon
                // addMixin or upon save.
                node.setPrimaryType(primaryTypeName);
                node.save();
                fail("Node.setPrimaryType(String) must throw a LockException if the node is locked.");
            } catch (LockException e) {
                // success
            }

            // unlock to remove node at tearDown()
            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void testRemoveNodeParentLocked()
            throws LockException, NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        // create a child node
        Node subNode = node.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();

        // lock the node
        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);
        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            try {
                subNode.remove();
                session.save();
                fail("Removal of a Node must throw a LockException upon remove() " +
                     "or upon save() if the parent of the node is locked");
            } catch (LockException e) {
                // success
            }

            // unlock to remove node at tearDown()
            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void testLocked()
            throws ConstraintViolationException, NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        testRootNode.getSession().save();

        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);
        if (mixinName == null) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            node.refresh(false);
            assertFalse("Node.canAddMixin(String mixinName) must return false " +
                    "if the node is locked.",
                    node.canAddMixin(mixinName));

            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void testMoveLockException()
        throws NotExecutableException, RepositoryException {

        Session session = superuser;

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node lockableNode = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(lockableNode, mixLockable);

        // add a sub node (the one that is tried to move later on)
        Node srcNode = lockableNode.addNode(nodeName1, testNodeType);

        testRootNode.getSession().save();

        // remove first slash of path to get rel path to root
        String pathRelToRoot = lockableNode.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            try {
                String destPath = testRoot + "/" + nodeName2;
                session.move(srcNode.getPath(), destPath);
                testRootNode.getSession().save();
                fail("A LockException is thrown either immediately or on save  if a lock prevents the move.");
            } catch (LockException e){
                // success
            }

        } finally {
            session2.logout();
        }
    }


    public void testRemoveNodeLockedItself()
            throws LockException, NotExecutableException, RepositoryException {

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // create a node that is lockable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it lockable if it is not
        ensureMixinType(node, mixLockable);
        testRootNode.getSession().save();

        // remove first slash of path to get rel path to root
        String pathRelToRoot = node.getPath().substring(1);

        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(true, true);

            // test fails if a LockException is thrown when removing the node
            // (remove must be possible since the parent is not locked)
            node.remove();
        } finally {
            session2.logout();
        }
    }


    public void testCheckedIn()
            throws NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_VERSIONING_SUPPORTED)) {
            throw new NotExecutableException("Versioning is not supported.");
        }

        // create a node that is versionable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it versionable if it is not
        ensureMixinType(node, mixVersionable);
        testRootNode.getSession().save();

        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);
        if (mixinName == null || node.isNodeType(mixinName)) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        node.checkin();

        try {
            node.addMixin(mixinName);
            fail("Node.addMixin(String mixinName) must throw a VersionException " +
                    "if the node is checked-in.");
        } catch (VersionException e) {
            // success
        }
    }


    public void testCheckedIn()
            throws ConstraintViolationException, NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_VERSIONING_SUPPORTED)) {
            throw new NotExecutableException("Versioning is not supported.");
        }

        // create a node that is versionable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it versionable if it is not
        ensureMixinType(node, mixVersionable);
        testRootNode.getSession().save();

        String mixinName = NodeMixinUtil.getAddableMixinName(session, node);
        if (mixinName == null || node.isNodeType(mixinName)) {
            throw new NotExecutableException("No testable mixin node type found");
        }

        node.addMixin(mixinName);
        testRootNode.getSession().save();
        node.checkin();

        try {
            node.removeMixin(mixinName);
            fail("Node.removeMixin(String mixinName) must throw a " +
                    "VersionException if the node is checked-in.");
        } catch (VersionException e) {
            // success
        }
    }


    public void testCheckedIn() throws NotExecutableException, RepositoryException {

        Session session = testRootNode.getSession();

        if (!isSupported(Repository.OPTION_VERSIONING_SUPPORTED)) {
            throw new NotExecutableException("Versioning is not supported.");
        }

        // create a node that is versionable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        // or try to make it versionable if it is not
        ensureMixinType(node, mixVersionable);
        superuser.save();

        String primaryTypeName = getPrimaryTypeName(session, node);
        if (primaryTypeName == null) {
            throw new NotExecutableException("No testable node type found");
        }

        node.checkin();

        try {
            node.setPrimaryType(primaryTypeName);
            fail("Node.setPrimaryType(String) must throw a VersionException if the node is checked-in.");
        } catch (VersionException e) {
            // success
        }
    }


    public void testLockTransfer() throws Exception {        
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        Session other = getHelper().getReadWriteSession();
        LockManager otherLockMgr = getLockManager(other);
        try {
            lockMgr.removeLockToken(ltoken);
            otherLockMgr.addLockToken(ltoken);

            assertTrue("The new holding manager must contain the token.", containsLockToken(otherLockMgr, ltoken));

            Lock otherL = otherLockMgr.getLock(testPath);
            assertNotNull("Token must be exposed to new lock holder.", otherL.getLockToken());
            assertEquals("Token must be the same again.", ltoken, otherL.getLockToken());

        } finally {
            otherLockMgr.removeLockToken(ltoken);
            lockMgr.addLockToken(ltoken);
            other.logout();
        }
    }


    public void testLockTransfer3() throws Exception {
        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        Session other = getHelper().getReadWriteSession();
        LockManager otherLockMgr = getLockManager(other);
        try {
            lockMgr.removeLockToken(ltoken);
            otherLockMgr.addLockToken(ltoken);

            lockMgr.removeLockToken(ltoken);
            fail("Removing a token that has been transfered to another manager must fail.");
        } catch (LockException e) {
            // success
        } finally {
            otherLockMgr.removeLockToken(ltoken);
            lockMgr.addLockToken(ltoken);
            other.logout();
        }
    }


    public void testLockTransfer2() throws Exception {
        // TODO: for 283 add config option for simultaneous tokens....

        assertLockable(testNode);

        boolean sessionScoped = false;
        Lock l = lockMgr.lock(testPath, true, sessionScoped, Long.MAX_VALUE, null);
        String ltoken = l.getLockToken();

        Session other = getHelper().getReadWriteSession();
        LockManager otherLockMgr = getLockManager(other);
        try {
            lockMgr.removeLockToken(ltoken);
            otherLockMgr.addLockToken(ltoken);

            lockMgr.addLockToken(ltoken);
            fail("Adding the token to another session must fail.");
        } catch (LockException e) {
            // success
        } finally {
            otherLockMgr.removeLockToken(ltoken);
            lockMgr.addLockToken(ltoken);
            other.logout();
        }
    }


    public void testGetNode() throws Exception {
        // create new node with a sub node and lock it
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixLockable);
        Node n1Sub = n1.addNode(nodeName1, testNodeType);
        ensureMixinType(n1Sub, mixLockable);
        testRootNode.getSession().save();

        // lock node
        n1.lock(true, true);

        assertEquals("getNode() must return the lock holder",
                n1.getPath(),
                n1.getLock().getNode().getPath());

        assertEquals("getNode() must return the lock holder",
                n1.getPath(),
                n1Sub.getLock().getNode().getPath());

        n1.unlock();
    }


    public void testParentChildLock() throws Exception {
        // create new nodes
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixLockable);
        Node n2 = n1.addNode(nodeName2, testNodeType);
        ensureMixinType(n2, mixLockable);
        testRootNode.getSession().save();

        // lock parent node
        n1.lock(false, true);

        // lock child node
        n2.lock(false, true);

        // unlock parent node
        n1.unlock();

        // child node must still hold lock
        assertTrue("child node must still hold lock", n2.holdsLock());
    }


    public void testGetLock() throws Exception {
        // create new nodes
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixLockable);
        Node n2 = n1.addNode(nodeName2, testNodeType);
        ensureMixinType(n2, mixLockable);
        testRootNode.getSession().save();

        // deep lock parent node
        n1.lock(true, true);

        // get lock on child node
        Lock lock = n2.getLock();

        // lock holding node must be parent
        assertTrue("lock holding node must be parent", lock.getNode().isSame(n1));
    }


    public void testCheckedIn()
            throws NotExecutableException, RepositoryException {

        if (!isSupported(Repository.OPTION_VERSIONING_SUPPORTED)) {
            throw new NotExecutableException("Versioning is not supported.");
        }

        // create a node that is lockable and versionable
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(node, mixLockable);
        // try to make it versionable if it is not
        ensureMixinType(node, mixVersionable);
        testRootNode.getSession().save();

        node.checkin();

        try {
            node.lock(false, false);
        }
        catch (RepositoryException ex) {
            // repository may not allow shallow locks on this resource
            // retry with a deep lock
            node.lock(true, false);
        }

        assertTrue("Locking of a checked-in node failed.",
                node.isLocked());

        node.unlock();
        assertFalse("Unlocking of a checked-in node failed.",
                node.isLocked());
    }


    public void testCheckedInUnlock() throws Exception {
        if (!isSupported(Repository.OPTION_VERSIONING_SUPPORTED)) {
            throw new NotExecutableException("Repository does not support versioning.");
        }

        // set up versionable and lockable node
        Node testNode = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(testNode, mixLockable);
        ensureMixinType(testNode, mixVersionable);
        testRootNode.getSession().save();

        // lock and check-in
        try {
            testNode.lock(false, false);
        }
        catch (RepositoryException ex) {
            // repository may not allow shallow locks on this resource
            // retry with a deep lock
            testNode.lock(true, false);
        }
        testNode.save();
        testNode.checkin();

        // do the unlock
        testNode.unlock();
        assertFalse("Could not unlock a locked, checked-in node", testNode.holdsLock());
    }


    public void testLockTransfer() throws Exception {
        // add node
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixLockable);
        testRootNode.getSession().save();

        // create new session
        Session otherSuperuser = getHelper().getSuperuserSession();

        try {
            // get node created above
            Node n2 = (Node) otherSuperuser.getItem(n1.getPath());

            // lock node
            Lock lock = n2.lock(false, false);

            // assert: user must get non-null token
            assertNotNull("user must get non-null token", lock.getLockToken());

            // transfer to standard session
            String lockToken = lock.getLockToken();
            otherSuperuser.removeLockToken(lockToken);
            superuser.addLockToken(lockToken);

            String nlt = lock.getLockToken();
            assertTrue("freshly obtained lock token must either be null or the same as the one returned earlier",
                    nlt == null || nlt.equals(lockToken));

            // assert: user must get non-null token
            assertNotNull("user must get non-null token",
                    n1.getLock().getLockToken());
        } finally {
            // log out
            otherSuperuser.logout();
            // unlock again
            n1.unlock();
        }
    }


    public void testOpenScopedLocks() throws Exception {
        // add node
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixLockable);
        testRootNode.getSession().save();

        // create new session
        Session otherSuperuser = getHelper().getSuperuserSession();

        try {
            // get node created above
            Node n2 = (Node) otherSuperuser.getItem(n1.getPath());

            // lock node
            Lock lock = n2.lock(false, false);

            // transfer to standard session
            String lockToken = lock.getLockToken();
            otherSuperuser.removeLockToken(lockToken);
            superuser.addLockToken(lockToken);
        } finally {
            // log out
            otherSuperuser.logout();
        }

        // assert: node still locked
        assertTrue(n1.isLocked());
    }


    public void testGetLockOnChild() throws RepositoryException {
        if (isDeep()) {
            // get lock must succeed even if child is not lockable.
            Lock lock = childNode.getLock();
            assertNotNull(lock);
            assertTrue("Lock.getNode() must return the lock holding node", lockedNode.isSame(lock.getNode()));

            Lock lock2 = lockMgr.getLock(childNode.getPath());
            assertNotNull(lock2);
            assertTrue("Lock.getNode() must return the lock holding node", lockedNode.isSame(lock2.getNode()));
        } else {
            try {
                childNode.getLock();
                fail("Node.getLock() must throw if node is not locked.");
            } catch (LockException e) {
                // success
            }
            try {
                lockMgr.getLock(childNode.getPath());
                fail("LockManager.getLock(String) must throw if node is not locked.");
            } catch (LockException e) {
                // success
            }
        }
    }


    public void testGetLockOnNewChild() throws RepositoryException {
        Node newChild = lockedNode.addNode(nodeName3, testNodeType);
        if (isDeep()) {
            // get lock must succeed even if child is not lockable.
            Lock lock = newChild.getLock();
            assertNotNull(lock);
            assertTrue("Lock.getNode() must return the lock holding node", lockedNode.isSame(lock.getNode()));

            Lock lock2 = lockMgr.getLock(newChild.getPath());
            assertNotNull(lock2);
            assertTrue("Lock.getNode() must return the lock holding node", lockedNode.isSame(lock2.getNode()));
        } else {
            try {
                newChild.getLock();
                fail("Node.getLock() must throw if node is not locked.");
            } catch (LockException e) {
                // success
            }
            try {
                lockMgr.getLock(newChild.getPath());
                fail("LockManager.getLock(String) must throw if node is not locked.");
            } catch (LockException e) {
                // success
            }
        }
    }


    public Node createReferenceableNode(String name) throws RepositoryException {
        // remove a yet existing node at the target
        try {
            Node node = testRootNode.getNode(name);
            node.remove();
            superuser.save();
        } catch (PathNotFoundException pnfe) {
            // ok
        }
        // a referenceable node
        Node n1 = testRootNode.addNode(name, testNodeType);
        if (n1.canAddMixin(mixReferenceable)) {
            n1.addMixin(mixReferenceable);
            // make sure jcr:uuid is available
            superuser.save();
            return n1;
        }
        else {
            return null;
        }
    }


    public Node createReferenceableNode(String name) throws RepositoryException {
        // remove a yet existing node at the target
        try {
            Node node = testRootNode.getNode(name);
            node.remove();
            session.save();
        } catch (PathNotFoundException pnfe) {
            // ok
        }
        // a referenceable node
        Node n1 = testRootNode.addNode(name, testNodeType);
        if (n1.canAddMixin(mixReferenceable)) {
            n1.addMixin(mixReferenceable);
            // make sure jcr:uuid is available
            testRootNode.getSession().save();
            return n1;
        }
        else {
            return null;
        }
    }


    public void testSetMixinAsPrimaryType() throws RepositoryException {
        Session session = testRootNode.getSession();

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator nts = manager.getMixinNodeTypes();
        while (nts.hasNext()) {
            try {
                Node node = testRootNode.addNode(nodeName1, testNodeType);
                node.setPrimaryType(nts.nextNodeType().getName());
                fail("Node.setPrimaryType(String) must throw ConstraintViolationException if the specified node type name refers to a mixin.");
            } catch (ConstraintViolationException e) {
                // success
            } finally {
                // reset the changes.
                session.refresh(false);
            }
        }
    }


    public void testSetAbstractAsPrimaryType() throws RepositoryException {
        Session session = testRootNode.getSession();

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator nts = manager.getPrimaryNodeTypes();
        while (nts.hasNext()) {
            NodeType nt = nts.nextNodeType();
            if (nt.isAbstract()) {
                try {
                    Node node = testRootNode.addNode(nodeName1, testNodeType);
                    node.setPrimaryType(nt.getName());
                    fail("Node.setPrimaryType(String) must throw ConstraintViolationException if the specified node type name refers to an abstract node type.");
                } catch (ConstraintViolationException e) {
                    // success
                } finally {
                    // reset the changes.
                    session.refresh(false);
                }
            }
        }
    }


    public void testAbstractNodeType() throws RepositoryException {
        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator nts = ntMgr.getPrimaryNodeTypes();
        while (nts.hasNext()) {
            NodeType nt = nts.nextNodeType();
            if (nt.isAbstract()) {
                try {
                    testRootNode.addNode(nodeName1, nt.getName());
                    superuser.save();
                    fail("Expected ConstraintViolationException.");
                } catch (ConstraintViolationException e) {
                    // correct.
                } finally {
                    superuser.refresh(false);
                }
            }
        }
    }


    private static String getPrimaryTypeName(Session session, Node node)
            throws RepositoryException {

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator nts = manager.getPrimaryNodeTypes();

        while (nts.hasNext()) {
            String name = nts.nextNodeType().getName();
            if (!name.equals(node.getPrimaryNodeType().getName())) {
                return name;
            }
        }
        return null;
    }


    public static String getAddableMixinName(Session session, Node node)
            throws RepositoryException {

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator mixins = manager.getMixinNodeTypes();

        // Skip mix:shareable since not supported by removeMixin
        String mixShareable = session.getNamespacePrefix(AbstractJCRTest.NS_MIX_URI) + ":shareable";

        while (mixins.hasNext()) {
            String name = mixins.nextNodeType().getName();
            if (node.canAddMixin(name)
                    && !node.isNodeType(name)
                    && !mixShareable.equals(name)) {
                return name;
            }
        }
        return null;
    }


    public void testGetNamespacePrefixes() throws RepositoryException {
        Set<String> prefixes = new HashSet<String>();
        prefixes.addAll(Arrays.asList(nsr.getPrefixes()));
        for (int i = 0; i < BUILTIN_PREFIXES.length; i++) {
            String prefix = BUILTIN_PREFIXES[i];
            assertTrue("NamespaceRegistry does not contain built in prefix: " + prefix, prefixes.contains(prefix));
            String uri = nsr.getURI(prefix);
            assertEquals("Wrong namespace mapping for prefix: " + prefix, BUILTIN_URIS[i], uri);
        }
    }


    public void testGetNamespaceURIs() throws RepositoryException {
        Set<String> uris = new HashSet<String>();
        uris.addAll(Arrays.asList(nsr.getURIs()));
        for (int i = 0; i < BUILTIN_URIS.length; i++) {
            String uri = BUILTIN_URIS[i];
            assertTrue("NamespaceRegistry does not contain built in uri: " + uri, uris.contains(uri));
            String prefix = nsr.getPrefix(uri);
            assertEquals("Wrong namespace mapping for uri: " + uri, BUILTIN_PREFIXES[i], prefix);
        }
    }


    public void testGetURINamespaceException() throws RepositoryException, NotExecutableException {
        Set<String> prefixes = new HashSet<String>();
        prefixes.addAll(Arrays.asList(nsr.getPrefixes()));
        String prefix = "myapp";
        int count = 0;
        while (prefixes.contains(prefix + count)) {
            count++;
        }
        String testPrefix = prefix + count;
        try {
            nsr.getURI(testPrefix);
            fail("NamespaceRegistry.getURI should throw a NamespaceException " +
                    "in case of an unmapped prefix.");
        } catch (NamespaceException nse) {
            //ok
        }
    }


    public void testGetPrefixNamespaceException() throws RepositoryException, NotExecutableException {
        Set<String> uris = new HashSet<String>();
        uris.addAll(Arrays.asList(nsr.getURIs()));
        String uri = "http://www.unknown-company.com/namespace";
        int count = 0;
        while (uris.contains(uri + count)) {
            count++;
        }
        String testURI = uri + count;
        try {
            nsr.getPrefix(testURI);
            fail("NamespaceRegistry.getPrefix should throw a NamespaceException " +
                    "in case of an unregistered URI.");
        } catch (NamespaceException nse) {
            //ok
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        // initialize some binary value
        data = createRandomString(10).getBytes();
        value = superuser.getValueFactory().createValue(new ByteArrayInputStream(data));

        // create a new node under the testRootNode
        node = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();

        // special case for repositories that do allow binary property
        // values, but only on jcr:content/jcr:data
        if (propertyName1.equals("jcr:data") && node.hasNode("jcr:content")
            && node.getNode("jcr:content").isNodeType("nt:resource") && ! node.hasProperty("jcr:data")) {
            node = node.getNode("jcr:content");
        }

        // create a new single-value property and save it
        property1 = node.setProperty(propertyName1, superuser.getValueFactory().createValue(new ByteArrayInputStream(new byte[0])));
        superuser.save();
    }


    protected void setUp() throws Exception {
        super.setUp();

        // initialize some binary value
        data = createRandomString(10).getBytes();

        // create a new node under the testRootNode
        node = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();

        // special case for repositories that do allow binary property
        // values, but only on jcr:content/jcr:data
        if (propertyName1.equals("jcr:data") && node.hasNode("jcr:content")
            && node.getNode("jcr:content").isNodeType("nt:resource") && ! node.hasProperty("jcr:data")) {
            node = node.getNode("jcr:content");
        }

        // create a new single-value property and save it
        property1 = node.setProperty(propertyName1, superuser.getValueFactory().createValue(new ByteArrayInputStream(new byte[0])));
        superuser.save();
    }


    public void testBinarySession() throws RepositoryException, IOException {
        property1.setValue(value);
        superuser.save();
        InputStream in = property1.getValue().getStream();
        try {
            compareStream(data, in);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testBinarySessionJcr2() throws RepositoryException, IOException {
        property1.setValue(value);
        superuser.save();
        Binary bin = property1.getValue().getBinary();
        try {
            InputStream in = bin.getStream();
            try {
                compareStream(data, in);
            } finally {
                try { in.close(); } catch (IOException ignore) {}
            }
        } finally {
            bin.dispose();
        }
    }


    public void testBinaryParentJcr2() throws RepositoryException, IOException {
        Binary bin = value.getBinary();
        try {
            property1.setValue(bin);
            node.save();
            bin = property1.getValue().getBinary();
            InputStream in = bin.getStream();
            try {
                compareStream(data, in);
            } finally {
                try { in.close(); } catch (IOException ignore) {}
            }
        } finally {
            bin.dispose();
        }
    }


    public void testBinaryParent() throws RepositoryException, IOException {
        InputStream in = value.getStream();
        try {
            property1.setValue(in);
            node.save();
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
        in = property1.getValue().getStream();
        try {
            compareStream(data, in);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testRemoveBinarySession() throws RepositoryException, NotExecutableException {
        if (property1.getDefinition().isMandatory() || property1.getDefinition().isProtected()) {
            throw new NotExecutableException("property " + property1.getName() + " can not be removed");
        }

        property1.setValue((InputStream) null);
        superuser.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null Value has been assigned");
        } catch (Exception e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    public void testRemoveBinaryParent() throws RepositoryException, NotExecutableException {
        if (property1.getDefinition().isMandatory() || property1.getDefinition().isProtected()) {
            throw new NotExecutableException("property " + property1.getName() + " can not be removed");
        }

        property1.setValue((Value) null);
        node.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null Value has been assigned");
        } catch (Exception e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    protected void setUp() throws Exception {
        super.setUp();
        try {
            checkSupportedOption(Repository.OPTION_SHAREABLE_NODES_SUPPORTED);
            ensureKnowsNodeType(superuser, mixShareable);
        } catch (NotExecutableException e) {
            cleanUp();
            throw e;
        }
    }


    protected void setUp() throws Exception {
        checkSupportedOption(Repository.OPTION_RETENTION_SUPPORTED);

        super.setUp();

        try {
            retentionMgr = getRetentionManager(superuser);
        } catch (NotExecutableException e) {
            cleanUp();
            throw e;
        }
        testNodePath = testRootNode.getPath();
    }


    protected void setUp() throws Exception {
        super.setUp();

        try {
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkout(path);
        } catch (RepositoryException e) {
            cleanUp();
            throw e;
        }
    }


    protected void setUp() throws Exception {
        checkSupportedOption(Repository.OPTION_ACCESS_CONTROL_SUPPORTED);
        
        super.setUp();
        try {
            acMgr = getAccessControlManager(superuser);
        } catch (NotExecutableException e) {
            cleanUp();
            throw e;
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        try {
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkout(path);
        } catch (RepositoryException e) {
            cleanUp();
            throw e;
        }
    }


    public void testGetIndex() throws Exception {
        
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        a2.addNode("b");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // verify indices of nodes b1/b2 in shared set
        assertEquals(1, b1.getIndex());
        assertEquals(2, b2.getIndex());
    }


    public void testSameUUID() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // verify nodes in a shared set have the same jcr:uuid
        assertTrue(b1.getUUID().equals(b2.getUUID()));
    }


    public void testIsSame() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // verify b1 is same as b2 (and vice-versa)
        assertTrue(b1.isSame(b2));
        assertTrue(b2.isSame(b1));
    }


    public void testGetPath() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // verify paths of nodes b1/b2 in shared set
        String testRootNodePath = testRootNode.getPath();
        assertEquals(testRootNodePath + "/a1/b1", b1.getPath());
        assertEquals(testRootNodePath + "/a2/b2", b2.getPath());
    }


    public void testGetName() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // verify names of nodes b1/b2 in shared set
        assertEquals("b1", b1.getName());
        assertEquals("b2", b2.getName());
    }


    public void testAddChild() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // add node to b1, verify b2 is modified as well and contains that child
        b1.addNode("c");
        assertTrue(b2.isModified());
        assertTrue(b2.hasNode("c"));
        b1.save();
    }


    public void testRemoveShare() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
        b1 = shared[0];
        Node b2 = shared[1];

        // remove b1 from shared set
        b1.removeShare();
        a1.save();

        // verify shared set of b2 contains only 1 item, namely b2 itself
        shared = getSharedSet(b2);
        assertEquals(1, shared.length);
        assertTrue(shared[0].isSame(b2));
    }


    public void testGetSharedSet() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // verify shared set contains 2 items
        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);
    }


    public void testGetNode() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // a1.getNode("b1") should return b1
        b1 = a1.getNode("b1");
        assertEquals("b1", b1.getName());

        // a2.getNode("b2") should return b2
        Node b2 = a2.getNode("b2");
        assertEquals("b2", b2.getName());
    }


    public void testRemoveSharedSet() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // remove shared set
        b1.removeSharedSet();
        testRootNode.getSession().save();

        // verify neither a1 nor a2 contain any more children
        assertFalse(a1.hasNodes());
        assertFalse(a2.hasNodes());
    }


    public void testModifyDescendantAndSave() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node c to b1
        Node c = b1.addNode("c");
        b1.save();

        // add child d to c, this modifies c
        c.addNode("d");

        // save a2 (having path /testroot/a2): this should save c as well
        // since one of the paths to c is /testroot/a2/b2/c
        a2.save();
        assertFalse("Saving share-ancestor should save share-descendants",
                c.isModified());
    }


    public void testRemoveSharedSetSaveOneParentOnly() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // remove shared set
        b1.removeSharedSet();

        try {
            // save only one of the parents, should fail
            a1.save();
            fail("Removing a shared set requires saving all parents.");
        } catch (ConstraintViolationException e) {
            // expected
        }
    }


    public void testRemoveDescendantAndSave() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node c to b1
        Node c = b1.addNode("c");
        b1.save();

        // remove child node c
        c.remove();

        // save a2 (having path /testroot/a2): this should save c as well
        // since one of the paths to c is /testroot/a2/b2/c
        a2.save();
        assertFalse("Saving share-ancestor should save share-descendants",
                session.hasPendingChanges());
    }


    public void testRemoveDescendantAndRemoveShareAndSave() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node c to b1
        Node c = b1.addNode("c");
        b1.save();

        // remove child node c
        c.remove();

        // remove share b2 from a2
        a2.getNode("b2").removeShare();

        // save a2 (having path /testroot/a2): this should save c as well
        // since one of the paths to c was /testroot/a2/b2/c
        a2.save();
        assertFalse("Saving share-ancestor should save share-descendants",
                session.hasPendingChanges());
    }


    public void testModifyDescendantAndRemoveShareAndSave() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node c to b1
        Node c = b1.addNode("c");
        b1.save();

        // add child d to c, this modifies c
        c.addNode("d");

        // remove share b2 from a2
        a2.getNode("b2").removeShare();

        // save a2 (having path /testroot/a2): this should save c as well
        // since one of the paths to c was /testroot/a2/b2/c
        a2.save();
        assertFalse("Saving share-ancestor should save share-descendants",
                c.isModified());
    }


    public void testDetectShareCycleOnMove() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node
        Node c = b1.addNode("c");
        b1.save();

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);

        // move node
        try {
            workspace.move(testRootNode.getPath() + "/a2", c.getPath() + "/d");
            fail("Share cycle not detected on move.");
        } catch (RepositoryException e) {
            // expected
        }
    }


    public void testDetectShareCycleOnTransientMove() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child node
        Node c = b1.addNode("c");
        b1.save();

        Node[] shared = getSharedSet(b1);
        assertEquals(2, shared.length);

        // move node
        try {
            session.move(testRootNode.getPath() + "/a2", c.getPath());
            fail("Share cycle not detected on transient move.");
        } catch (RepositoryException e) {
            // expected
        }
    }


    public void testGetNodes() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // a1.getNodes() should return b1
        Node[] children = toArray(a1.getNodes());
        assertEquals(1, children.length);
        assertEquals("b1", children[0].getName());

        // a2.getNodes() should return b2
        children = toArray(a2.getNodes());
        assertEquals(1, children.length);
        assertEquals("b2", children[0].getName());
    }


    public void testGetNodesByPattern() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // a1.getNodes(*) should return b1
        Node[] children = toArray(a1.getNodes("*"));
        assertEquals(1, children.length);
        assertEquals("b1", children[0].getName());

        // a2.getNodes(*) should return b2
        children = toArray(a2.getNodes("*"));
        assertEquals(1, children.length);
        assertEquals("b2", children[0].getName());
    }


    public void testRestore() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // make b1 shareable
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // make a2 versionable
        ensureMixinType(a2, mixVersionable);
        a2.save();

        // check in version and check out again
        Version v = a2.checkin();
        a2.checkout();

        // delete b2 and save
        a2.getNode("b2").remove();
        a2.save();

        // verify shared set contains one element only
        Node[] shared = getSharedSet(b1);
        assertEquals(1, shared.length);

        // restore version
        a2.restore(v, false);

        // verify shared set contains again two elements
        shared = getSharedSet(b1);
        assertEquals(2, shared.length);
    }


    public void testRestoreRemoveExisting() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // make b1 shareable
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Workspace workspace = b1.getSession().getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child c
        b1.addNode("c");
        b1.save();

        // make a2 versionable
        ensureMixinType(a2, mixVersionable);
        a2.save();

        // check in version and check out again
        Version v = a2.checkin();
        a2.checkout();

        // delete b2 and save
        a2.getNode("b2").remove();
        a2.save();

        // verify shareable set contains one elements only
        Node[] shared = getSharedSet(b1);
        assertEquals(1, shared.length);

        // restore version and remove existing (i.e. b1)
        a2.restore(v, true);

        // verify shareable set contains still one element
        shared = getSharedSet(a2.getNode("b2"));
        assertEquals(1, shared.length);

        // verify child c still exists
        Node[] children = toArray(a2.getNode("b2").getNodes());
        assertEquals(1, children.length);
    }


    public void testDetectShareCycleOnClone() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        Workspace workspace = b1.getSession().getWorkspace();

        try {
            // clone underneath b1: this must fail
            workspace.clone(workspace.getName(), b1.getPath(),
                    b1.getPath() + "/c", false);
            fail("Share cycle not detected on clone.");
        } catch (RepositoryException e) {
            // expected
        }
    }


    public void testCloneToSameParent() throws Exception {
        // setup parent nodes and first child
        Node a = testRootNode.addNode("a");
        Node b1 = a.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        Workspace workspace = b1.getSession().getWorkspace();

        try {
            // clone to same parent
            workspace.clone(workspace.getName(), b1.getPath(),
                    a.getPath() + "/b2", false);
            fail("Cloning inside same parent should fail.");
        } catch (UnsupportedRepositoryOperationException e) {
            // expected
        }
    }


    public void testImportExportNtShare() throws Exception {
        // setup parent nodes and first child
        Node p = testRootNode.addNode("p");
        Node a1 = p.addNode("a1");
        Node a2 = p.addNode("a2");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // create temp file
        File tmpFile = File.createTempFile("test", null);
        tmpFile.deleteOnExit();

        // export system view of /p
        OutputStream out = new FileOutputStream(tmpFile);
        try {
            session.exportSystemView(p.getPath(), out, false, false);
        } finally {
            out.close();
        }

        // delete p and save
        p.remove();
        testRootNode.getSession().save();

        // and import again underneath test root
        InputStream in = new FileInputStream(tmpFile);
        try {
            workspace.importXML(testRootNode.getPath(), in,
                    ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // verify shared set consists of two nodes
        Node[] shared = getSharedSet(testRootNode.getNode("p/a1/b1"));
        assertEquals(2, shared.length);
    }


    public void testSessionImportDocumentViewCollision() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node a3 = testRootNode.addNode("a3");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child c to shareable nodes b1 & b2
        b1.addNode("c");
        b1.save();

        // create temp file
        File tmpFile = File.createTempFile("test", null);
        tmpFile.deleteOnExit();

        // export system view of /a1/b1
        OutputStream out = new FileOutputStream(tmpFile);
        try {
            session.exportSystemView(b1.getPath(), out, false, false);
        } finally {
            out.close();
        }

        // and import again underneath /a3
        InputStream in = new FileInputStream(tmpFile);
        try {
            session.importXML(a3.getPath(), in, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
            session.save();
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // verify there's another element in the shared set
        Node[] shared = getSharedSet(b1);
        assertEquals(3, shared.length);

        // verify child c has not been duplicated
        Node[] children = toArray(b1.getNodes());
        assertEquals(1, children.length);
    }


    public void testImportDocumentViewCollision() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node a3 = testRootNode.addNode("a3");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child c to shareable nodes b1 & b2
        b1.addNode("c");
        b1.save();

        // create temp file
        File tmpFile = File.createTempFile("test", null);
        tmpFile.deleteOnExit();

        // export system view of /a1/b1
        OutputStream out = new FileOutputStream(tmpFile);
        try {
            session.exportDocumentView(b1.getPath(), out, false, false);
        } finally {
            out.close();
        }

        // and import again underneath /a3
        InputStream in = new FileInputStream(tmpFile);
        try {
            workspace.importXML(a3.getPath(), in, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // verify there's another element in the shared set
        Node[] shared = getSharedSet(b1);
        assertEquals(3, shared.length);

        // verify child c has not been duplicated
        Node[] children = toArray(b1.getNodes());
        assertEquals(1, children.length);
    }


    public void testSessionImportSystemViewCollision() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node a3 = testRootNode.addNode("a3");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child c to shareable nodes b1 & b2
        b1.addNode("c");
        b1.save();

        // create temp file
        File tmpFile = File.createTempFile("test", null);
        tmpFile.deleteOnExit();

        // export system view of /a1/b1
        OutputStream out = new FileOutputStream(tmpFile);
        try {
            session.exportSystemView(b1.getPath(), out, false, false);
        } finally {
            out.close();
        }

        // and import again underneath /a3
        InputStream in = new FileInputStream(tmpFile);
        try {
            session.importXML(a3.getPath(), in, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
            session.save();
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // verify there's another element in the shared set
        Node[] shared = getSharedSet(b1);
        assertEquals(3, shared.length);

        // verify child c has not been duplicated
        Node[] children = toArray(b1.getNodes());
        assertEquals(1, children.length);
    }


    public void testImportSystemViewCollision() throws Exception {
        // setup parent nodes and first child
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node a3 = testRootNode.addNode("a3");
        Node b1 = a1.addNode("b1");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b1, mixShareable);
        b1.save();

        // clone
        Session session = b1.getSession();
        Workspace workspace = session.getWorkspace();
        workspace.clone(workspace.getName(), b1.getPath(),
                a2.getPath() + "/b2", false);

        // add child c to shareable nodes b1 & b2
        b1.addNode("c");
        b1.save();

        // create temp file
        File tmpFile = File.createTempFile("test", null);
        tmpFile.deleteOnExit();

        // export system view of /a1/b1
        OutputStream out = new FileOutputStream(tmpFile);
        try {
            session.exportSystemView(b1.getPath(), out, false, false);
        } finally {
            out.close();
        }

        // and import again underneath /a3
        InputStream in = new FileInputStream(tmpFile);
        try {
            workspace.importXML(a3.getPath(), in, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // verify there's another element in the shared set
        Node[] shared = getSharedSet(b1);
        assertEquals(3, shared.length);

        // verify child c has not been duplicated
        Node[] children = toArray(b1.getNodes());
        assertEquals(1, children.length);
    }


    public void testMoveShareableNode() throws Exception {
        // setup parent nodes and first children
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b = a1.addNode("b");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b, mixShareable);
        b.getSession().save();

        // move
        Workspace workspace = b.getSession().getWorkspace();

        // move shareable node
        String newPath = a2.getPath() + "/b";
        workspace.move(b.getPath(), newPath);
        // move was performed using the workspace, so refresh the session
        b.getSession().refresh(false);
        assertEquals(newPath, b.getPath());
    }


    public void testTransientMoveShareableNode() throws Exception {
        // setup parent nodes and first children
        Node a1 = testRootNode.addNode("a1");
        Node a2 = testRootNode.addNode("a2");
        Node b = a1.addNode("b");
        testRootNode.getSession().save();

        // add mixin
        ensureMixinType(b, mixShareable);
        b.getSession().save();

        // move
        Session session = superuser;

        // move shareable node
        String newPath = a2.getPath() + "/b";
        session.move(b.getPath(), newPath);
        session.save();
        assertEquals(newPath, b.getPath());
    }


    public void testMoveNodesOrderingSupportedByParent() throws RepositoryException {
        // test assumes that repositry supports Orderable Child Node Support (optional)
        String[] orderList = {nodeName1, nodeName2, nodeName3};

        // create a new node to move nodes
        Node newNode = testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();

        // copy node three times below a node and check the order
        for (int i = 0; i < orderList.length; i++) {
            workspace.copy(node1.getPath(), newNode.getPath() + "/" + orderList[i]);
        }

        // check regarding orderList with the counter if nodes are added at the end
        int cnt = 0;
        NodeIterator iter = node2.getNodes();
        while (iter.hasNext()) {
            Node n = iter.nextNode();

            assertTrue(n.getName().equals(orderList[cnt]));
            cnt++;
        }
    }


    public void testCopyNodesOrderingSupportedByParent() throws RepositoryException {
        // test assumes that repositry supports Orderable Child Node Support (optional)
        String[] orderList = {nodeName1, nodeName2, nodeName3};

        // copy node three times below a node and check the order
        for (int i = 0; i < orderList.length; i++) {
            workspace.copy(node1.getPath(), node2.getPath() + "/" + orderList[i]);
        }

        // check regarding orderList if nodes are added at the end
        int cnt = 0;
        NodeIterator iter = node2.getNodes();
        while (iter.hasNext()) {
            Node n = iter.nextNode();

            assertTrue(n.getName().equals(orderList[cnt]));
            cnt++;
        }
    }


    public void testCopyNodesOrderingSupportedByParent() throws RepositoryException {
        // test assumes that repositry supports Orderable Child Node Support (optional)
        String[] orderList = {nodeName1, nodeName2, nodeName3};

        // copy node three times below a node and check the order
        for (int i = 0; i < orderList.length; i++) {
            workspaceW2.copy(workspace.getName(), node1.getPath(), node2.getPath() + "/" + orderList[i]);
        }

        // check regarding orderList if nodes are added at the end
        int cnt = 0;
        NodeIterator iter = node2.getNodes();
        while (iter.hasNext()) {
            Node n = iter.nextNode();

            assertTrue(n.getName().equals(orderList[cnt]));
            cnt++;
        }
    }


    public void testCloneNodesOrderingSupportedByParent() throws RepositoryException {
        // test assumes that repositry supports Orderable Child Node Support (optional)
        String[] orderList = {nodeName1, nodeName2, nodeName3};

        // copy node three times below a node and check the order
        for (int i = 0; i < orderList.length; i++) {
            workspaceW2.clone(workspace.getName(), node1.getPath(), node2.getPath() + "/" + orderList[i], true);
        }


        // check regarding orderList with the counter if nodes are added at the end
        int cnt = 0;
        NodeIterator iter = node2.getNodes();
        while (iter.hasNext()) {
            Node n = iter.nextNode();

            assertTrue(n.getName().equals(orderList[cnt]));
            cnt++;
        }
    }


    public void testMoveNodesNodeExistsAtDestPath() throws RepositoryException {
        // create a parent node where allowSameNameSiblings are set to false
        Node snsfNode = testRootNode.addNode(nodeName3, sameNameSibsFalseNodeType.getName());
        testRootNode.getSession().save();

        String dstAbsPath = snsfNode.getPath() + "/" + node1.getName();
        workspace.copy(node1.getPath(), dstAbsPath);

        // try to copy again the node to same destAbsPath
        // property already exist
        try {
            workspace.move(node1.getPath(), dstAbsPath);
            fail("Node exists below '" + dstAbsPath + "'. Test should fail.");
        } catch (ItemExistsException e) {
            // successful
        }
    }


    public void testCloneNodesNodeExistsAtDestPath() throws RepositoryException {
        // create a parent node where allowSameNameSiblings are set to false
        Node snsfNode = testRootNodeW2.addNode(nodeName3, sameNameSibsFalseNodeType.getName());
        testRootNodeW2.save();

        String dstAbsPath = snsfNode.getPath() + "/" + node1W2.getName();
        workspaceW2.copy(node1W2.getPath(), dstAbsPath);

        // try to copy again the node to same destAbsPath
        // property already exist
        try {
            workspaceW2.clone(workspace.getName(), node1.getPath(), dstAbsPath, true);
            fail("Node exists below '" + dstAbsPath + "'. Test should fail.");
        } catch (ItemExistsException e) {
            // successful
        }
    }


    public void testCopyNodesNodeExistsAtDestPath() throws RepositoryException {
        // create a parent node where allowSameNameSiblings are set to false
        Node snsfNode = testRootNode.addNode(nodeName3, sameNameSibsFalseNodeType.getName());
        testRootNode.getSession().save();

        String dstAbsPath = snsfNode.getPath() + "/" + node1.getName();
        workspace.copy(node1.getPath(), dstAbsPath);

        // try to copy again the node to same destAbsPath where node already exists
        try {
            workspace.copy(node1.getPath(), dstAbsPath);
            fail("Node exists below '" + dstAbsPath + "'. Test should fail.");
        } catch (ItemExistsException e) {
            // successful
        }
    }


    public void testCopyNodesNodeExistsAtDestPath() throws RepositoryException {
        // create a parent node where allowSameNameSiblings are set to false
        Node snsfNode = testRootNodeW2.addNode(nodeName3, sameNameSibsFalseNodeType.getName());
        testRootNodeW2.save();

        String dstAbsPath = snsfNode.getPath() + "/" + node1.getName();
        workspaceW2.copy(node1.getPath(), dstAbsPath);

        // try to copy again the node to same destAbsPath
        // property already exist
        try {
            workspaceW2.copy(workspace.getName(), node1.getPath(), dstAbsPath);
            fail("Node exists below '" + dstAbsPath + "'. Test should fail.");
        } catch (ItemExistsException e) {
            // successful
        }
    }


    public void testSaveReferentialIntegrityException() throws RepositoryException, NotExecutableException {
        checkMixReferenceable();

        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node with a property of type PropertyType.REFERENCE
        Node referencingNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // create a node with a jcr:uuid property to serve as target
        Node refTargetNode = defaultRootNode.addNode(nodeName2, getProperty("nodetype2"));
        // make sure, mix:referenceable is effective. some impls may require a save() call.
        defaultRootNode.save();


        // abort test if the repository does not allow setting
        // reference properties on this node
        ensureCanSetProperty(referencingNode, propertyName1, referencingNode.getSession().getValueFactory().createValue(refTargetNode));

        // set the reference
        referencingNode.setProperty(propertyName1, refTargetNode);

        // save the new nodes
        defaultRootNode.save();

        // remove the referenced node
        refTargetNode.remove();

        // try to save
        try {
            defaultRootNode.save();
            fail("Saving a deleted node using Node.save() that is a reference target should throw ReferentialIntegrityException");
        } catch (ReferentialIntegrityException e) {
            // ok, works as expected
        }
    }


    public void testSaveReferentialIntegrityException() throws RepositoryException, NotExecutableException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node with a property of type PropertyType.REFERENCE
        Node referencingNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // create a node with a jcr:uuid property to serve as target
        Node refTargetNode = defaultRootNode.addNode(nodeName2, getProperty("nodetype2"));
        // implementations may only have the mix:referenceable active upon save
        defaultRootNode.save();

        if (!refTargetNode.isNodeType(mixReferenceable)) {
            throw new NotExecutableException("Cannot test referential integrity. Node is not referenceable.");
        }

        // abort test if the repository does not allow setting
        // reference properties on this node
        ensureCanSetProperty(referencingNode, propertyName1, referencingNode.getSession().getValueFactory().createValue(refTargetNode));

        // set the reference
        referencingNode.setProperty(propertyName1, refTargetNode);

        // save the new nodes
        superuser.save();

        // remove the referenced node
        refTargetNode.remove();

        // try to save
        try {
            superuser.save();
            fail("Saving a deleted node using Session.save() that is a reference target should throw ReferentialIntegrityException");
        } catch (ReferentialIntegrityException e) {
            // ok, works as expected
        }
    }


    public void testJoin() throws RepositoryException, NotExecutableException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        String testMixin = mixReferenceable;
        if (needsMixin(n1, testMixin)) {
            ensureMixinType(n1, testMixin);
        } else {
            testMixin = mixVersionable;
            if (needsMixin(n1, testMixin)) {
                ensureMixinType(n1, testMixin);
            }
        }

        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();

        assertFalse("Node at " + n2.getPath() + " should not have mixin " + testMixin, n2.isNodeType(testMixin));

        StringBuffer query = new StringBuffer("SELECT * FROM ");
        query.append(testNodeType).append(", ").append(testMixin);
        query.append(" WHERE ");
        query.append(testNodeType).append(".").append(jcrPath);
        query.append(" = ");
        query.append(testMixin).append(".").append(jcrPath);
        query.append(" AND ").append(jcrPath).append(" LIKE ");
        query.append("'").append(testRoot).append("/%'");

        executeSqlQuery(superuser, query.toString(), new Node[]{n1});
    }


    public void testJoinNtBase() throws RepositoryException,
            NotExecutableException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        String testMixin = mixReferenceable;
        if (needsMixin(n1, testMixin)) {
            ensureMixinType(n1, testMixin);
        } else {
            testMixin = mixVersionable;
            if (needsMixin(n1, testMixin)) {
                ensureMixinType(n1, testMixin);
            }
        }

        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();

        assertFalse("Node at " + n2.getPath() + " should not have mixin " + testMixin, n2.isNodeType(testMixin));

        StringBuffer query = new StringBuffer("SELECT * FROM ");
        query.append(testNodeType).append(", ").append(testMixin);
        query.append(" WHERE ");
        query.append(testNodeType).append(".").append(jcrPath);
        query.append(" = ");
        query.append(testMixin).append(".").append(jcrPath);
        query.append(" AND ").append(jcrPath).append(" LIKE ");
        query.append("'").append(testRoot).append("/%'");

        executeSqlQuery(superuser, query.toString(), new Node[]{n1});
    }


    public void testJoinFilterPrimaryType()
            throws RepositoryException, NotExecutableException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixReferenceable);
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node n2 = testRootNode.addNode(nodeName2, nodetype);
        ensureMixinType(n2, mixReferenceable);
        testRootNode.getSession().save();

        StringBuffer query = new StringBuffer("SELECT * FROM ");
        query.append(testNodeType).append(", ").append(ntBase);
        query.append(" WHERE ");
        query.append(testNodeType).append(".").append(jcrPath);
        query.append(" = ");
        query.append(ntBase).append(".").append(jcrPath);
        query.append(" AND ").append(jcrPath).append(" LIKE ");
        query.append("'").append(testRoot).append("/%'");

        executeSqlQuery(superuser, query.toString(), new Node[]{n1});
    }


    public void testJoinSNS() throws RepositoryException, NotExecutableException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        ensureMixinType(n1, mixReferenceable);
        if (!n1.getDefinition().allowsSameNameSiblings()) {
            throw new NotExecutableException("Node at " + testRoot + " does not allow same name siblings with name " + nodeName1);
        }
        testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        ensureMixinType(n2, mixReferenceable);
        testRootNode.getSession().save();

        StringBuffer query = new StringBuffer("SELECT * FROM ");
        query.append(testNodeType).append(", ").append(mixReferenceable);
        query.append(" WHERE ");
        query.append(testNodeType).append(".").append(jcrPath);
        query.append(" = ");
        query.append(mixReferenceable).append(".").append(jcrPath);
        query.append(" AND ").append(jcrPath).append(" LIKE ");
        query.append("'").append(testRoot).append("/%'");

        executeSqlQuery(superuser, query.toString(), new Node[]{n1, n2});
    }


    public void testFullTextSearch() throws Exception {
        setUpFullTextTest();
        QueryResult result = execute(getFullTextStatement());

        // must be 1
        checkResult(result, 1);

        // evaluate result
        RowIterator itr = result.getRows();
        while (itr.hasNext()) {
            Row row = itr.nextRow();
            Value value = row.getValue(propertyName1);
            if (value != null) {
                String fullText = value.getString();
                if (fullText.indexOf("cat") > 0) {
                    fail("Search Text: full text search not correct, returned prohibited text");
                }
            }
        }
    }


    public void testFullTextSearch() throws Exception {
        setUpFullTextTest();
        QueryResult result = execute(getFullTextStatement());

        // must be 1
        checkResult(result, 1);

        // evaluate result
        NodeIterator itr = result.getNodes();
        while (itr.hasNext()) {
            Value value = itr.nextNode().getProperty(propertyName1).getValue();
            if (value != null) {
                String fullText = value.getString();
                if (fullText.indexOf("cat") > 0) {
                    fail("Search Text: full text search not correct, returned prohibited text");
                }
            }
        }
    }


    public void testPathColumn() throws Exception {
        setUpFullTextTest();
        QueryResult result = execute(getFullTextStatement());
        RowIterator rows = result.getRows();
        if (getSize(rows) < 1) {
            fail("Query result did not return any nodes");
        }
        // re-aquire rows
        rows = result.getRows();

        // test mere existence
        rows.nextRow().getValue(jcrPath);
    }


    public void testPathColumn() throws Exception {
        setUpFullTextTest();
        QueryResult result = execute(getFullTextStatement());
        RowIterator rows = result.getRows();
        if (getSize(rows) < 1) {
            fail("Query result did not return any nodes");
        }
        // re-aquire rows
        rows = result.getRows();

        // test mere existence
        rows.nextRow().getValue(jcrPath);
    }


    private Statement getMultiValueStatement() {
        StringBuffer tmp = new StringBuffer("SELECT ");
        tmp.append(escapeIdentifierForSQL(propertyName1));
        tmp.append(" FROM ").append(escapeIdentifierForSQL(testNodeType));
        tmp.append(" WHERE 'two' IN ");
        tmp.append(escapeIdentifierForSQL(propertyName2));
        tmp.append(" AND 'existence' IN ");
        tmp.append(escapeIdentifierForSQL(propertyName1));
        tmp.append(" AND ").append(jcrPath).append(" LIKE '");
        tmp.append(testRoot).append("/%'");
        return new Statement(tmp.toString(), qsSQL);
    }


    private Statement getRangeStatement() {
        StringBuffer tmp = new StringBuffer("SELECT ");
        tmp.append(escapeIdentifierForSQL(propertyName1));
        tmp.append(" FROM ").append(escapeIdentifierForSQL(testNodeType));
        tmp.append(" WHERE ");
        tmp.append(escapeIdentifierForSQL(propertyName1));
        tmp.append(" <= 'b' AND ");
        tmp.append(escapeIdentifierForSQL(propertyName1));
        tmp.append(" > 'a'");
        tmp.append(" AND ").append(jcrPath).append(" LIKE '");
        tmp.append(testRoot).append("/%'");
        return new Statement(tmp.toString(), qsSQL);
    }


    public void testSetLimit() throws RepositoryException {
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.addNode(nodeName3, testNodeType);
        superuser.save();
        for (int i = 0; i < 5; i++) {
            Query query = qf.createQuery(
                    qf.selector(testNodeType, "s"),
                    qf.descendantNode("s", testRoot),
                    null, 
                    null
            );
            query.setLimit(i);
            long expected = Math.min(i, 3);
            assertEquals("Wrong numer of results", expected,
                    getSize(query.execute().getNodes()));
        }
    }


    public void testSetOffset() throws RepositoryException {
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.addNode(nodeName3, testNodeType);
        superuser.save();
        for (int i = 0; i < 5; i++) {
            Query query = qf.createQuery(
                    qf.selector(testNodeType, "s"),
                    qf.descendantNode("s", testRoot),
                    null,
                    null
            );
            query.setOffset(i);
            long expected = Math.max(3 - i, 0);
            assertEquals("Wrong numer of results", expected,
                    getSize(query.execute().getNodes()));
        }
    }


    private void docOrderTest(Statement stmt, String path)
            throws RepositoryException, NotExecutableException {
        if (!isSupported(Repository.QUERY_XPATH_DOC_ORDER)) {
            throw new NotExecutableException("Repository does not support document order on result set.");
        }

        int count = 0;
        // check precondition: at least 3 nodes
        for (NodeIterator it = testRootNode.getNodes(); it.hasNext(); it.nextNode()) {
            count++;
        }
        if (count < 3) {
            throw new NotExecutableException("Workspace does not contain enough content under: " + testRoot +
                    ". At least 3 nodes are required for this test.");
        }

        QueryResult result = execute(stmt);
        checkResult(result, 1);
        assertEquals("Wrong result node.", path, result.getNodes().nextNode().getPath());
    }


    private void docOrderTest(Statement stmt, String path)
            throws RepositoryException, NotExecutableException {
        if (!isSupported(Repository.QUERY_XPATH_POS_INDEX)) {
            throw new NotExecutableException("Repository does not support document order on result set.");
        }

        int count = 0;
        // check precondition: at least 3 nodes
        for (NodeIterator it = testRootNode.getNodes(); it.hasNext(); it.nextNode()) {
            count++;
        }
        if (count < 3) {
            throw new NotExecutableException("Workspace does not contain enough content under: " + testRoot +
                    ". At least 3 nodes are required for this test.");
        }

        QueryResult result = execute(stmt);
        checkResult(result, 1);
        assertEquals("Wrong result node.", path, result.getNodes().nextNode().getPath());
    }


    public void testDateOrderPositiveTimeZone() throws Exception {
        Calendar c1 = Calendar.getInstance(TimeZone.getTimeZone("GMT+1:00"));
        c1.set(2000, 6, 12, 15, 35, 19);
        c1.set(Calendar.MILLISECOND, 10);
        Calendar c2 = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c2.set(2000, 6, 12, 14, 35, 19);
        c2.set(Calendar.MILLISECOND, 9);
        Calendar c3 = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c3.set(2000, 6, 12, 14, 35, 19);
        c3.set(Calendar.MILLISECOND, 11);
        populate(new Calendar[]{c1, c2, c3});
        checkOrder(new String[]{nodeName2, nodeName1, nodeName3});
    }


    public void testDateOrderNegativeTimeZone() throws Exception {
        Calendar c1 = Calendar.getInstance(TimeZone.getTimeZone("GMT-1:00"));
        c1.set(2000, 6, 12, 13, 35, 19);
        c1.set(Calendar.MILLISECOND, 10);
        Calendar c2 = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c2.set(2000, 6, 12, 14, 35, 19);
        c2.set(Calendar.MILLISECOND, 9);
        Calendar c3 = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c3.set(2000, 6, 12, 14, 35, 19);
        c3.set(Calendar.MILLISECOND, 11);
        populate(new Calendar[]{c1, c2, c3});
        checkOrder(new String[]{nodeName2, nodeName1, nodeName3});
    }


    public void testStringLiteralInvalidName() throws RepositoryException {
        Value literal = vf.createValue("[" + nodeName1);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with STRING that cannot be converted to NAME must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = '" + literal.getString() + "'";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with STRING that cannot be converted to NAME must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testDateLiteral() throws RepositoryException {
        Value literal = vf.createValue(Calendar.getInstance());
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with DATE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST('" + literal.getString() + "' AS DATE)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with DATE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testLongLiteral() throws RepositoryException {
        Value literal = vf.createValue(283);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with LONG must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST(" + literal.getString() + " AS LONG)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with LONG must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testDoubleLiteral() throws RepositoryException {
        Value literal = vf.createValue(Math.PI);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with DOUBLE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST('" + literal.getString() + "' AS DOUBLE)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with DOUBLE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testDecimalLiteral() throws RepositoryException {
        Value literal = vf.createValue(new BigDecimal(283));
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with DECIMAL must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST('" + literal.getString() + "' AS DECIMAL)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with DECIMAL must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testBooleanLiteral() throws RepositoryException {
        Value literal = vf.createValue(true);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with BOOLEAN must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST(" + literal.getString() + " AS BOOLEAN)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with BOOLEAN must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testReferenceLiteral() throws RepositoryException,
            NotExecutableException {
        ensureMixinType(node1, mixReferenceable);
        superuser.save();
        Value literal = vf.createValue(node1);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with REFERENCE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST('" + literal.getString() + "' AS REFERENCE)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with REFERENCE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testWeakReferenceLiteral() throws RepositoryException,
            NotExecutableException {
        ensureMixinType(node1, mixReferenceable);
        superuser.save();
        Value literal = vf.createValue(node1, true);
        try {
            createQuery(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO, literal).execute();
            fail("NodeName comparison with WEAKREFERENCE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE NAME(s) = CAST('" + literal.getString() + "' AS WEAKREFERENCE)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("NAME() comparison with absolute WEAKREFERENCE must fail with InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testCreateQueryWithConstraintAndOrdering() throws RepositoryException {
        Selector selector = qf.selector(testNodeType, SELECTOR_NAME1);
        PropertyExistence propExist = qf.propertyExistence(SELECTOR_NAME1, propertyName1);
        PropertyValue propValue = qf.propertyValue(SELECTOR_NAME1, propertyName1);
        Ordering ordering = qf.ascending(propValue);
        QueryObjectModel qom = qf.createQuery(selector, propExist,
                new Ordering[]{ordering}, null);
        assertTrue("Not a selector source", qom.getSource() instanceof Selector);
        assertTrue("Not a property existence constraint", qom.getConstraint() instanceof PropertyExistence);
        assertEquals("Wrong size of orderings", 1, qom.getOrderings().length);
        assertEquals("Wrong size of columns", 0, qom.getColumns().length);
    }


    public void testCreateQueryFromSourceWithConstraintOrderingAndColumn() throws RepositoryException {
        Source selector = qf.selector(testNodeType, SELECTOR_NAME1);
        PropertyExistence propExist = qf.propertyExistence(SELECTOR_NAME1, propertyName1);
        PropertyValue propValue = qf.propertyValue(SELECTOR_NAME1, propertyName1);
        Ordering ordering = qf.ascending(propValue);
        Column column = qf.column(SELECTOR_NAME1, propertyName1, propertyName1);
        QueryObjectModel qom = qf.createQuery(selector, propExist,
                new Ordering[]{ordering}, new Column[]{column});
        assertTrue("Not a selector source", qom.getSource() instanceof Selector);
        assertTrue("Not a property existence constraint", qom.getConstraint() instanceof PropertyExistence);
        assertEquals("Wrong size of orderings", 1, qom.getOrderings().length);
        assertEquals("Wrong size of columns", 1, qom.getColumns().length);
    }


    public void testCreateQueryWithConstraintOrderingAndColumn() throws RepositoryException {
        Selector selector = qf.selector(testNodeType, SELECTOR_NAME1);
        PropertyExistence propExist = qf.propertyExistence(SELECTOR_NAME1, propertyName1);
        PropertyValue propValue = qf.propertyValue(SELECTOR_NAME1, propertyName1);
        Ordering ordering = qf.ascending(propValue);
        Column column = qf.column(SELECTOR_NAME1, propertyName1, propertyName1);
        QueryObjectModel qom = qf.createQuery(selector, propExist,
                new Ordering[]{ordering}, new Column[]{column});
        assertTrue("Not a selector source", qom.getSource() instanceof Selector);
        assertTrue("Not a property existence constraint", qom.getConstraint() instanceof PropertyExistence);
        assertEquals("Wrong size of orderings", 1, qom.getOrderings().length);
        assertEquals("Wrong size of columns", 1, qom.getColumns().length);
    }


    public void testCreateQueryFromSourceWithConstraintAndOrdering() throws RepositoryException {
        Source selector = qf.selector(testNodeType, SELECTOR_NAME1);
        PropertyExistence propExist = qf.propertyExistence(SELECTOR_NAME1, propertyName1);
        PropertyValue propValue = qf.propertyValue(SELECTOR_NAME1, propertyName1);
        Ordering ordering = qf.ascending(propValue);
        QueryObjectModel qom = qf.createQuery(selector, propExist,
                new Ordering[]{ordering}, null);
        assertTrue("Not a selector source", qom.getSource() instanceof Selector);
        assertTrue("Not a property existence constraint", qom.getConstraint() instanceof PropertyExistence);
        assertEquals("Wrong size of orderings", 1, qom.getOrderings().length);
        assertEquals("Wrong size of columns", 0, qom.getColumns().length);
    }


    public void testFullTextSearch() throws RepositoryException {
        FullTextSearch ftSearch = qf.fullTextSearch(
                SELECTOR_NAME1, propertyName1,
                qf.literal(vf.createValue(FULLTEXT_SEARCH_EXPR)));
        assertEquals("Wrong selector name", SELECTOR_NAME1, ftSearch.getSelectorName());
        assertEquals("Wrong propertyName", propertyName1, ftSearch.getPropertyName());

        StaticOperand op = ftSearch.getFullTextSearchExpression();
        assertNotNull(op);
        assertTrue("not a Literal", op instanceof Literal);
        Literal literal = (Literal) op;
        assertEquals(FULLTEXT_SEARCH_EXPR, literal.getLiteralValue().getString());
    }


    public void testFullTextSearchWithBindVariableValue() throws RepositoryException {
        FullTextSearch ftSearch = qf.fullTextSearch(
                SELECTOR_NAME1, propertyName1,
                qf.bindVariable(VARIABLE_NAME));
        assertEquals("Wrong selector name", SELECTOR_NAME1, ftSearch.getSelectorName());
        assertEquals("Wrong propertyName", propertyName1, ftSearch.getPropertyName());

        StaticOperand op = ftSearch.getFullTextSearchExpression();
        assertNotNull(op);
        assertTrue("not a BindVariableValue", op instanceof BindVariableValue);
        BindVariableValue value = (BindVariableValue) op;
        assertEquals(VARIABLE_NAME, value.getBindVariableName());
    }


    protected void setUp() throws Exception {
        super.setUp();
        String value = createRandomString(10);
        n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.setProperty(propertyName1, value);

        n2 = n1.addNode(nodeName2, testNodeType);
        n2.setProperty(propertyName1, value);
        n2.setProperty(propertyName2, value);
        ensureMixinType(n2, mixReferenceable);
        superuser.save();
    }


    protected void setUp() throws Exception {
        super.setUp();
        String value = "a";
        n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.setProperty(propertyName1, value);
        n1.setProperty(propertyName2, "b");

        n2 = n1.addNode(nodeName2, testNodeType);
        n2.setProperty(propertyName1, value);
        n2.setProperty(propertyName2, value);
        superuser.save();
    }


    public void testSyntacticallyInvalidName() throws RepositoryException {
        String invalidNodeType = testNodeType + "[";
        try {
            Query q = qf.createQuery(qf.selector(invalidNodeType, "s"),
                    null, null, null);
            q.execute();
            fail("Selector with syntactically invalid name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + invalidNodeType + "]";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("selectorName with syntactically invalid name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testDuplicateNodeType() throws RepositoryException {
        try {
            Query q = qf.createQuery(
                    qf.join(
                            qf.selector(testNodeType, "nt"),
                            qf.selector(testNodeType, "nt"),
                            QueryObjectModelConstants.JCR_JOIN_TYPE_INNER,
                            qf.descendantNodeJoinCondition("nt", "nt")),
                    null, null, null);
            q.execute();
            fail("Selector with two identical selector names must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS nt, [" +
                    testNodeType + "] AS nt nt INNER JOIN nt ON ISDESCENDANTNODE(nt, nt)";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("selectorName with syntactically invalid name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testNotASelectorName() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.sameNode("x", testRoot), null, null);
            q.execute();
            fail("SameNode with an invalid selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE ISSAMENODE(x, [" + testRoot + "]";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISSAMENODE with an invalid selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testRelativePath() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.childNode("s", testPath), null, null);
            q.execute();
            fail("ChildNode with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISCHILDNODE(s, [" + testPath + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISCHILDNODE() with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testRelativePath() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.sameNode("s", testPath), null, null);
            q.execute();
            fail("SameNode with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE ISSAMENODE(s, [" + testPath + "]";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISSAMENODE() with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testNotASelectorName() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.descendantNode("x", testRoot), null, null);
            q.execute();
            fail("DescendantNode with an unknown selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISDESCENDANTNODE(x, [" + testRoot + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISDESCENDANTNODE() with an unknown selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testRelativePath() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.descendantNode("s", testPath), null, null);
            q.execute();
            fail("DescendantNode with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISDESCENDANTNODE(s, [" + testPath + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISDESCENDANTNODE() with relative path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testNotASelectorName() throws RepositoryException {
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.childNode("x", testRoot), null, null);
            q.execute();
            fail("ChildNode with an unknown selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISCHILDNODE(x, [" + testRoot + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISCHILDNODE() with an unknown selector name must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testSyntacticallyInvalidPath() throws RepositoryException {
        String invalidPath = testRoot + "/" + nodeName1 + "[";
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.childNode("s", invalidPath),
                    null, null);
            q.execute();
            fail("ChildNode with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISCHILDNODE(s, [" + invalidPath + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISCHILDNODE() with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testSyntacticallyInvalidPath() throws RepositoryException {
        String invalidPath = testRoot + "/" + nodeName1 + "[";
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.descendantNode("s", invalidPath), null, null);
            q.execute();
            fail("DescendantNode with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s WHERE " +
                    "ISDESCENDANTNODE(s, [" + invalidPath + "])";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISDESCENDANTNODE() with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testSyntacticallyInvalidPath() throws RepositoryException {
        String invalidPath = testRoot + "/" + nodeName1 + "[";
        try {
            Query q = qf.createQuery(qf.selector(testNodeType, "s"),
                    qf.sameNode("s", invalidPath),
                    null, null);
            q.execute();
            fail("SameNode with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
        try {
            String stmt = "SELECT * FROM [" + testNodeType + "] AS s " +
                    "WHERE ISSAMENODE(s, [" + invalidPath + "]";
            qm.createQuery(stmt, Query.JCR_SQL2).execute();
            fail("ISSAMENODE() with syntactically invalid path argument must throw InvalidQueryException");
        } catch (InvalidQueryException e) {
            // expected
        }
    }


    public void testDescendantNodesDoNotMatchSelector()
            throws RepositoryException, NotExecutableException {
        testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator it = ntMgr.getPrimaryNodeTypes();
        NodeType testNt = ntMgr.getNodeType(testNodeType);
        while (it.hasNext()) {
            NodeType nt = it.nextNodeType();
            if (!testNt.isNodeType(nt.getName())) {
                // perform test
                QueryObjectModel qom = qf.createQuery(qf.selector(nt.getName(), "s"),
                        qf.descendantNode("s", testRoot), null, null);
                checkQOM(qom, new Node[]{});
                return;
            }
        }
        throw new NotExecutableException("No suitable node type found to " +
                "perform test against '" + testNodeType + "' nodes");
    }


    public void testChildNodesDoNotMatchSelector()
            throws RepositoryException, NotExecutableException {
        testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator it = ntMgr.getPrimaryNodeTypes();
        NodeType testNt = ntMgr.getNodeType(testNodeType);
        while (it.hasNext()) {
            NodeType nt = it.nextNodeType();
            if (!testNt.isNodeType(nt.getName())) {
                // perform test
                QueryObjectModel qom = qf.createQuery(qf.selector(nt.getName(), "s"),
                        qf.sameNode("s", testRoot + "/" + nodeName1), null, null);
                checkQOM(qom, new Node[]{});
                return;
            }
        }
        throw new NotExecutableException("No suitable node type found to " +
                "perform test against '" + testNodeType + "' nodes");
    }


    public void testChildNodesDoNotMatchSelector()
            throws RepositoryException, NotExecutableException {
        testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator it = ntMgr.getPrimaryNodeTypes();
        NodeType testNt = ntMgr.getNodeType(testNodeType);
        while (it.hasNext()) {
            NodeType nt = it.nextNodeType();
            if (!testNt.isNodeType(nt.getName())) {
                // perform test
                QueryObjectModel qom = qf.createQuery(
                        qf.selector(nt.getName(), "s"),
                        qf.childNode("s", testRoot), null, null);
                checkQOM(qom, new Node[]{});
                return;
            }
        }
        throw new NotExecutableException("No suitable node type found to " +
                "perform test against '" + testNodeType + "' nodes");
    }


    public void testName() throws RepositoryException {
        Value name = vf.createValue(STRING_VALUE, PropertyType.NAME);
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.setProperty(propertyName1, name);
        superuser.save();

        bindVariableValue(qomQuery, "v", name);
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", name);
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    public void testDecimal() throws RepositoryException {
        Value value = vf.createValue(DECIMAL_VALUE);
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.setProperty(propertyName1, value);
        superuser.save();

        bindVariableValue(qomQuery, "v", value);
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", value);
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    public void testPath() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        Value path = vf.createValue(n.getPath(), PropertyType.PATH);
        n.setProperty(propertyName1, path);
        superuser.save();

        bindVariableValue(qomQuery, "v", path);
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", path);
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    public void testURI() throws RepositoryException {
        Value value = vf.createValue(URI_VALUE, PropertyType.URI);
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.setProperty(propertyName1, value);
        superuser.save();

        bindVariableValue(qomQuery, "v", value);
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", value);
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    public void testReference() throws RepositoryException,
            NotExecutableException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        ensureMixinType(n, mixReferenceable);
        superuser.save();
        n.setProperty(propertyName1, n);
        superuser.save();


        bindVariableValue(qomQuery, "v", vf.createValue(n));
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", vf.createValue(n));
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    public void testWeakReference() throws RepositoryException,
            NotExecutableException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        superuser.save();

        ensureMixinType(n, mixReferenceable);
        superuser.save();
        n.setProperty(propertyName1, vf.createValue(n, true));
        superuser.save();

        bindVariableValue(qomQuery, "v", vf.createValue(n, true));
        checkResult(qomQuery.execute(), new Node[]{n});

        bindVariableValue(sqlQuery, "v", vf.createValue(n, true));
        checkResult(sqlQuery.execute(), new Node[]{n});
    }


    protected void checkResultOrder(QueryResult result,
                                    String[] selectorNames,
                                    Node[][] nodes)
            throws RepositoryException {
        // collect rows
        List<String> expectedPaths = new ArrayList<String>();
        log.println("expected:");
        for (int i = 0; i < nodes.length; i++) {
            StringBuffer aggregatedPaths = new StringBuffer();
            for (int j = 0; j < nodes[i].length; j++) {
                aggregatedPaths.append(getPath(nodes[i][j]));
                aggregatedPaths.append("|");
            }
            expectedPaths.add(aggregatedPaths.toString());
            log.println(aggregatedPaths.toString());
        }

        List<String> resultPaths = new ArrayList<String>();
        log.println("result:");
        for (RowIterator it = result.getRows(); it.hasNext();) {
            Row r = it.nextRow();
            StringBuffer aggregatedPaths = new StringBuffer();
            for (int i = 0; i < selectorNames.length; i++) {
                aggregatedPaths.append(getPath(r.getNode(selectorNames[i])));
                aggregatedPaths.append("|");
            }
            resultPaths.add(aggregatedPaths.toString());
            log.println(aggregatedPaths.toString());
        }

        assertEquals("wrong result order", expectedPaths, resultPaths);
    }


    protected void checkResult(QueryResult result,
                               String[] selectorNames,
                               Node[][] nodes)
            throws RepositoryException {
        // collect rows
        Set<String> expectedPaths = new HashSet<String>();
        log.println("expected:");
        for (int i = 0; i < nodes.length; i++) {
            StringBuffer aggregatedPaths = new StringBuffer();
            for (int j = 0; j < nodes[i].length; j++) {
                aggregatedPaths.append(getPath(nodes[i][j]));
                aggregatedPaths.append("|");
            }
            expectedPaths.add(aggregatedPaths.toString());
            log.println(aggregatedPaths.toString());
        }

        Set<String> resultPaths = new HashSet<String>();
        log.println("result:");
        for (RowIterator it = result.getRows(); it.hasNext();) {
            Row r = it.nextRow();
            StringBuffer aggregatedPaths = new StringBuffer();
            for (int i = 0; i < selectorNames.length; i++) {
                aggregatedPaths.append(getPath(r.getNode(selectorNames[i])));
                aggregatedPaths.append("|");
            }
            resultPaths.add(aggregatedPaths.toString());
            log.println(aggregatedPaths.toString());
        }

        // check if all expected are in result
        for (Iterator<String> it = expectedPaths.iterator(); it.hasNext();) {
            String path = it.next();
            assertTrue(path + " is not part of the result set", resultPaths.contains(path));
        }
        // check result does not contain more than expected
        for (Iterator<String> it = resultPaths.iterator(); it.hasNext();) {
            String path = it.next();
            assertTrue(path + " is not expected to be part of the result set", expectedPaths.contains(path));
        }
    }


    public void testOrdering() throws RepositoryException {
        QueryObjectModel qom = qf.createQuery(
                qf.selector(testNodeType, "s"),
                qf.and(
                        qf.fullTextSearch("s", null, qf.literal(vf.createValue("fox"))),
                        qf.descendantNode("s", testRootNode.getPath())
                ),
                new Ordering[]{qf.ascending(qf.fullTextSearchScore("s"))},
                null
        );
        forQOMandSQL2(qom, new Callable() {
            public Object call(Query query) throws RepositoryException {
                RowIterator rows = query.execute().getRows();
                double previousScore = Double.NaN;
                while (rows.hasNext()) {
                    double score = rows.nextRow().getScore("s");
                    if (!Double.isNaN(previousScore)) {
                        assertTrue("wrong order", previousScore <= score);
                    }
                    previousScore = score;
                }
                return null;
            }
        });
    }


    public void testConstraint() throws RepositoryException {
        QueryObjectModel qom = qf.createQuery(
                qf.selector(testNodeType, "s"),
                qf.and(
                        qf.and(
                                qf.fullTextSearch("s", null, qf.literal(vf.createValue("fox"))),
                                qf.comparison(
                                        qf.fullTextSearchScore("s"),
                                        QueryObjectModelFactory.JCR_OPERATOR_GREATER_THAN,
                                        qf.literal(vf.createValue(Double.MIN_VALUE))
                                )
                        ),
                        qf.descendantNode("s", testRootNode.getPath())
                ),
                new Ordering[]{qf.descending(qf.fullTextSearchScore("s"))},
                null
        );
        forQOMandSQL2(qom, new Callable() {
            public Object call(Query query) throws RepositoryException {
                RowIterator rows = query.execute().getRows();
                while (rows.hasNext()) {
                    double score = rows.nextRow().getScore("s");
                    if (!Double.isNaN(score)) {
                        assertTrue("wrong full text search score", Double.MIN_VALUE < score);
                    }
                }
                return null;
            }
        });
    }


    public void testGetSize() throws RepositoryException, NotExecutableException {
        NodeIterator it = execute(xpathRoot + "//*", qsXPATH).getNodes();
        long size = testRootNode.getNodes().getSize();
        if (size != -1) {
            long count = 0;
            while (it.hasNext()) {
                it.nextNode();
                count++;
            }
            assertEquals("NodeIterator.getSize does not return correct number.", size, count);
        } else {
            throw new NotExecutableException("NodeIterator.getSize() does not return size information.");
        }
    }


    public void testGetSize() throws RepositoryException, NotExecutableException {
        NodeIterator iter = testRootNode.getNodes();
        long size = testRootNode.getNodes().getSize();
        if (size != -1) {
            long count = 0;
            while (iter.hasNext()) {
                iter.nextNode();
                count++;
            }
            assertEquals("NodeIterator.getSize does not return correct number.", size, count);
        } else {
            throw new NotExecutableException("NodeIterator.getSize() does not return size information.");
        }
    }


    public void testNoSuchElementException() throws RepositoryException, NotExecutableException {
        NodeIterator it = execute(xpathRoot + "//*", qsXPATH).getNodes();
        while (it.hasNext()) {
            it.nextNode();
        }
        try {
            it.nextNode();
            fail("nextNode() must throw a NoSuchElementException when no nodes are available");
        } catch (NoSuchElementException e) {
            // success
        }
    }


    public void testNoSuchElementException() throws RepositoryException {
        NodeIterator iter = testRootNode.getNodes();
        while (iter.hasNext()) {
            iter.nextNode();
        }
        try {
            iter.nextNode();
            fail("nextNode() must throw a NoSuchElementException when no nodes are available");
        } catch (NoSuchElementException e) {
            // success
        }
    }


    public void testSkip() throws RepositoryException, NotExecutableException {
        String query = xpathRoot + "//*";
        QueryResult rs = execute(query, qsXPATH);
        NodeIterator it = rs.getNodes();

        // find out if there is anything we can skip
        int count = 0;
        while (it.hasNext()) {
            it.nextNode();
            count++;
        }
        if (count > 1) {
            // re-execute the query
            rs = execute(query, qsXPATH);
            it = rs.getNodes();
            // skip all but one
            it.skip(count - 1);
            // get last one
            it.nextNode();
            try {
                it.nextNode();
                fail("nextNode() must throw a NoSuchElementException when no nodes are available");
            } catch (NoSuchElementException e) {
                // success
            }

            // re-execute the query
            rs = execute(query, qsXPATH);
            it = rs.getNodes();
            try {
                it.skip(count + 1);
                fail("skip() must throw a NoSuchElementException if one tries to skip past the end of the iterator");
            } catch (NoSuchElementException e) {
                // success
            }
        }
    }


    public void testSkip() throws RepositoryException {
        NodeIterator iter = testRootNode.getNodes();
        // find out if there is anything we can skip
        int count = 0;
        while (iter.hasNext()) {
            iter.nextNode();
            count++;
        }
        if (count > 0) {
            // re-aquire iterator
            iter = testRootNode.getNodes();
            iter.skip(count);
            try {
                iter.nextNode();
                fail("nextNode() must throw a NoSuchElementException when no nodes are available");
            } catch (NoSuchElementException e) {
                // success
            }

            // re-aquire iterator
            iter = testRootNode.getNodes();
            try {
                iter.skip(count + 1);
                fail("skip() must throw a NoSuchElementException if one tries to skip past the end of the iterator");
            } catch (NoSuchElementException e) {
                // success
            }
        }
    }


    public void testNonReferenceable() throws RepositoryException, NotExecutableException {
        Node nonReferenceable = null;
        if (testRootNode.isNodeType(mixReferenceable)) {
            Node child = testRootNode.addNode(nodeName1, testNodeType);
            superuser.save();
            if (!child.isNodeType(mixReferenceable)) {
                nonReferenceable = child;
            }
        } else {
            nonReferenceable = testRootNode;
        }

        if (nonReferenceable == null) {
            throw new NotExecutableException("Test node is referenceable.");
        }

        // getReferences must return an empty iterator and must not throw.        
        assertFalse(nonReferenceable.getReferences().hasNext());
    }


    public void testNonReferenceable() throws RepositoryException, NotExecutableException {
        Node nonReferenceable = null;
        if (testRootNode.isNodeType(mixReferenceable)) {
            Node child = testRootNode.addNode(nodeName1, testNodeType);
            superuser.save();
            if (!child.isNodeType(mixReferenceable)) {
                nonReferenceable = child;
            }
        } else {
            nonReferenceable = testRootNode;
        }

        if (nonReferenceable == null) {
            throw new NotExecutableException("Test node is referenceable.");
        }

        // getWeakReferences must return an empty iterator and must not throw.
        assertFalse(nonReferenceable.getWeakReferences().hasNext());
    }


    private Node locateNodeWithMixinNodeTypes(Node node)
            throws RepositoryException {

        if (node.getMixinNodeTypes().length != 0) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = this.locateNodeWithMixinNodeTypes(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    private Node locateReferenceableNode(Node node)
            throws RepositoryException {

        if (node.isNodeType(mixReferenceable)) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = locateReferenceableNode(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    private Node locateNonReferenceableNode(Node node)
            throws RepositoryException {

        if (!node.isNodeType(mixReferenceable)) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = locateNonReferenceableNode(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    private Node locateNodeWithoutPrimaryItem(Node node)
            throws RepositoryException {

        if (node.getPrimaryNodeType().getPrimaryItemName() == null) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node n = locateNodeWithoutPrimaryItem(nodes.nextNode());
            if (n != null) {
                return n;
            }
        }
        return null;
    }


    private Node locateNodeWithPrimaryItem(Node node)
            throws RepositoryException {

        if (node.getPrimaryNodeType().getPrimaryItemName() != null) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = locateNodeWithPrimaryItem(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    private Node locateNodeWithoutPrimaryItem(Node node)
            throws RepositoryException {

        try {
            node.getPrimaryItem();
        } catch (ItemNotFoundException e) {
            return node;
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = this.locateNodeWithoutPrimaryItem(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    private Node locateNodeWithReference(Node node)
            throws RepositoryException {

        PropertyIterator properties = node.getProperties();
        while (properties.hasNext()) {
            Property p = properties.nextProperty();
            if (p.getType() == PropertyType.REFERENCE && !p.getDefinition().isMultiple()) {
                return node;
            }
        }

        NodeIterator nodes = node.getNodes();
        while (nodes.hasNext()) {
            Node returnedNode = locateNodeWithReference(nodes.nextNode());
            if (returnedNode != null) {
                return returnedNode;
            }
        }
        return null;
    }


    public void testGetCorrespondingNodePath() throws RepositoryException, NotExecutableException {

        // make sure the repository supports multiple workspaces
        super.ensureMultipleWorkspacesSupported();

        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create test node in default workspace
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        // save changes
        superuser.save();

        // get the root node in the second workspace
        Node rootNodeW2 = (Node) superuserW2.getItem(testRootNode.getPath());

        // create test node in second workspace
        rootNodeW2.addNode(nodeName1, testNodeType);

        // save changes
        superuserW2.save();

        // call the update method on test node in default workspace
        defaultTestNode.getCorrespondingNodePath(workspaceName);

        // ok, works as expected
    }


    public void testUpdate() throws RepositoryException, NotExecutableException {

        // make sure the repository supports multiple workspaces
        super.ensureMultipleWorkspacesSupported();

        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create test node in default workspace
        Node defaultTestNode = defaultRootNode.addNode(nodeName1, testNodeType);

        defaultTestNode.setProperty(propertyName1, "test");

        // save changes
        superuser.save();

        // get the root node in the second workspace
        Node rootNodeW2 = (Node) superuserW2.getItem(testRootNode.getPath());

        // create test node in second workspace
        Node testNodeW2 = rootNodeW2.addNode(nodeName1, testNodeType);

        // add a child node
        testNodeW2.addNode(nodeName2, testNodeType);

        // save changes
        superuserW2.save();

        // call the update method on test node in default workspace
        defaultTestNode.update(workspaceName);

        // ok first check if node has no longer properties
        assertFalse("Node updated with Node.update() should have property removed", defaultTestNode.hasProperty(propertyName1));
        // ok check if the child has been added
        assertTrue("Node updated with Node.update() should have received childrens", defaultTestNode.hasNode(nodeName2));
    }


    public void testRefreshBooleanFalse() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode1Session1 = defaultRootNode.addNode(nodeName1, testNodeType);
        // create a second node
        Node testNode2Session1 = defaultRootNode.addNode(nodeName2, testNodeType);

        // save the new nodes
        defaultRootNode.save();

        // add child node to test node 1 using session 1
        testNode1Session1.addNode(nodeName2, testNodeType);

        // get session 2
        Session session2 = getHelper().getReadWriteSession();

        try {
            // get the second node
            Node testNode2Session2 = (Node) session2.getItem(testNode2Session1.getPath());

            // adds a child node
            testNode2Session2.addNode(nodeName3, testNodeType);

            // save the changes
            session2.save();
            // call refresh on session 1
            defaultRootNode.refresh(false);

            // check if session 1 flag has been cleared
            assertFalse("Session should have no pending changes recorded after Node.refresh(false)!", superuser.hasPendingChanges());

            // check if added child node for node 1 by session 1 has been removed
            assertFalse("Node Modifications have not been flushed after Node.refresh(false)", testNode1Session1.hasNodes());

            // check if added child node for node 2 by session 2 has become visible in session 1
            assertTrue("Node modified by a different session has not been updated after Node.refresh(false)", testNode2Session1.hasNodes());
        } finally {
            session2.logout();
        }
    }


    public void testRefreshBooleanTrue() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode1Session1 = defaultRootNode.addNode(nodeName1, testNodeType);
        // create a second node
        Node testNode2Session1 = defaultRootNode.addNode(nodeName2, testNodeType);

        // save the new nodes
        defaultRootNode.save();

        // add child node to test node 1 using session 1
        testNode1Session1.addNode(nodeName2, testNodeType);

        // get session 2
        Session session2 = getHelper().getReadWriteSession();

        try {
            // get the second node
            Node testNode2Session2 = (Node) session2.getItem(testNode2Session1.getPath());

            // adds a child node
            testNode2Session2.addNode(nodeName3, testNodeType);

            // save the changes
            session2.save();

            // call refresh on session 1
            defaultRootNode.refresh(true);

            // check if session 1 flag has been cleared
            assertTrue("Session should still have pending changes recorded after Node.refresh(true)!", superuser.hasPendingChanges());

            // check if added child node for node 1 by session 1 is still there
            assertTrue("Node Modifications are lost after Node.refresh(true)", testNode1Session1.hasNodes());

            // check if added child node for node 2 by session 2 has become visible in session 1
            assertTrue("Node modified by a different session has not been updated after Node.refresh(true)", testNode2Session1.hasNodes());
        } finally {
            session2.logout();
        }
    }


    public void testRefreshBooleanFalse() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode1Session1 = defaultRootNode.addNode(nodeName1, testNodeType);
        // create a second node
        Node testNode2Session1 = defaultRootNode.addNode(nodeName2, testNodeType);

        // save the new nodes
        superuser.save();

        // add child node to test node 1 using session 1
        testNode1Session1.addNode(nodeName2, testNodeType);

        // get session 2
        Session session2 = getHelper().getReadWriteSession();

        try {
            // get the second node
            Node testNode2Session2 = (Node) session2.getItem(testNode2Session1.getPath());

            // adds a child node
            testNode2Session2.addNode(nodeName3, testNodeType);

            // save the changes
            session2.save();

            // call refresh on session 1
            superuser.refresh(false);

            // check if session 1 flag has been cleared
            assertFalse("Session should have no pending changes recorded after Session.refresh(false)!", superuser.hasPendingChanges());

            // check if added child node for node 1 by session 1 has been removed
            assertFalse("Node Modifications have not been flushed after session.refresh(false)", testNode1Session1.hasNodes());

            // check if added child node for node 2 by session 2 has become visible in session 1
            assertTrue("Node modified by a different session has not been updated after Session.refresh(false)", testNode2Session1.hasNodes());
        } finally {
            session2.logout();
        }
    }


    public void testRefreshBooleanTrue() throws RepositoryException {
        // get default workspace test root node using superuser session
        Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());

        // create a node
        Node testNode1Session1 = defaultRootNode.addNode(nodeName1, testNodeType);
        // create a second node
        Node testNode2Session1 = defaultRootNode.addNode(nodeName2, testNodeType);

        // save the new nodes
        superuser.save();

        // add child node to test node 1 using session 1
        testNode1Session1.addNode(nodeName2, testNodeType);

        // get session 2
        Session session2 = getHelper().getReadWriteSession();

        try {
            // get the second node
            Node testNode2Session2 = (Node) session2.getItem(testNode2Session1.getPath());

            // adds a child node
            testNode2Session2.addNode(nodeName3, testNodeType);

            // save the changes
            session2.save();

            // call refresh on session 1
            superuser.refresh(true);

            // check if session 1 flag has been cleared
            assertTrue("Session should still have pending changes recorded after Session.refresh(true)!", superuser.hasPendingChanges());

            // check if added child node for node 1 by session 1 is still there
            assertTrue("Node Modifications are lost after session.refresh(true)", testNode1Session1.hasNodes());

            // check if added child node for node 2 by session 2 has become visible in session 1
            assertTrue("Node modified by a different session has not been updated after Session.refresh(true)", testNode2Session1.hasNodes());
        } finally {
            session2.logout();
        }
    }


    public void testReadOnlyPermission() throws Exception {
        Node n = testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        Session readOnly = getHelper().getReadOnlySession();
        try {
            String path = n.getPath();

            assertTrue(readOnly.hasPermission(path, Session.ACTION_READ));
            assertFalse(readOnly.hasPermission(path + "newNode", Session.ACTION_ADD_NODE));
            assertFalse(readOnly.hasPermission(path, Session.ACTION_REMOVE));
            assertFalse(readOnly.hasPermission(path, Session.ACTION_SET_PROPERTY));
            assertFalse(readOnly.hasPermission(path, ACTION_ALL));
            assertFalse(readOnly.hasPermission(path, Session.ACTION_REMOVE + "," + Session.ACTION_SET_PROPERTY));
        } finally {
            readOnly.logout();
        }
    }


    public void testReadWritePermission() throws Exception {
        Node n = testRootNode.addNode(nodeName2, testNodeType);
        superuser.save();

        String path = n.getPath();
        Session rwSession = getHelper().getReadWriteSession();
        try {
            assertTrue(rwSession.hasPermission(path, Session.ACTION_READ));
            assertTrue(rwSession.hasPermission(path + "newNode", Session.ACTION_ADD_NODE));
            assertTrue(rwSession.hasPermission(path, Session.ACTION_REMOVE));
            assertTrue(rwSession.hasPermission(path, Session.ACTION_SET_PROPERTY));
            assertTrue(rwSession.hasPermission(path, ACTION_ALL));
        } finally {
            rwSession.logout();
        }
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            String nodePath = prop.getParent().getPath();
            String propName = prop.getName();

            // absolute nodes path
            prop.getParent().setProperty(propName, nodePath, PropertyType.PATH);
            String value = prop.getString();
            Node n = prop.getNode();
            assertEquals("The path of the dereferenced property must be equal to the value", n.getPath(), value);
            assertTrue("The property value must be resolved to the correct node.", prop.getParent().isSame(n));

            // relative node path
            prop.getParent().setProperty(propName, ".", PropertyType.PATH);
            n = prop.getNode();
            assertTrue("The property value must be resolved to the correct node.", prop.getParent().getNode(".").isSame(n));

            // non-existing property path
            while (session.nodeExists(nodePath)) {
                nodePath += "x";
            }
            prop.getParent().setProperty(propName, nodePath, PropertyType.PATH);
            try {
                prop.getNode();
                fail("Calling Property.getNode() for a PATH value that doesn't have a corresponding Node, ItemNotFoundException is expected");
            } catch (ItemNotFoundException e) {
                //ok
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            String propPath = prop.getPath();
            String propName = prop.getName();

            // absolute property path
            prop.getParent().setProperty(propName, propPath, PropertyType.PATH);
            String path = prop.getString();
            Property p = prop.getProperty();
            assertEquals("The path of the dereferenced property must be equal to the value", path, p.getPath());
            assertTrue("The property value must be resolved to the correct property.", prop.isSame(p));

            // relative property path
            prop.getParent().setProperty(propName, propName, PropertyType.PATH);
            path = prop.getString();
            p = prop.getProperty();
            assertEquals("The path of the dereferenced property must be equal to the value", path, p.getName());
            assertTrue("The property value must be resolved to the correct property.", prop.getParent().getProperty(path).isSame(p));

            // non-existing property path
            while (session.propertyExists(propPath)) {
                propPath += "x";
            }
            prop.getParent().setProperty(propName, propPath, PropertyType.PATH);
            try {
                prop.getProperty();
                fail("Calling Property.getProperty() for a PATH value that doesn't have a corresponding Property, ItemNotFoundException is expected");
            } catch (ItemNotFoundException e) {
                //ok
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        BufferedInputStream in = new BufferedInputStream(val.getStream());
        Value otherVal = PropertyUtil.getValue(prop);
        InputStream ins = null;
        byte[] utf8bytes = otherVal.getString().getBytes(UTF8);
        // if yet utf-8 encoded these bytes should be equal
        // to the ones received from the stream
        int i = 0;
        byte[] b = new byte[1];
        while (in.read(b) != -1) {
            assertTrue("Boolean as a Stream is not utf-8 encoded",
                    b[0] == utf8bytes[i]);
            i++;
        }
        try {
            val.getBoolean();
        } catch (IllegalStateException ise) {
            fail("Non stream method call after stream method call " +
                    "should not throw an IllegalStateException");
        }
        try {
            ins = otherVal.getStream();
        } catch (IllegalStateException ise) {
            fail("Stream method call after a non stream method call " +
                    "should not throw an IllegalStateException");
        } finally {
            if (in != null) {
                in.close();
            }
            if (ins != null) {
                ins.close();
            }
        }
    }


    public void testGetStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        BufferedInputStream in = new BufferedInputStream(val.getStream());
        Value otherVal = PropertyUtil.getValue(prop);
        InputStream ins = null;
        byte[] utf8bytes = otherVal.getString().getBytes(UTF8);
        // if yet utf-8 encoded these bytes should be equal
        // to the ones received from the stream
        int i = 0;
        byte b[] = new byte[1];
        while (in.read(b) != -1) {
            assertEquals("Long as a Stream is not utf-8 encoded.",
                    utf8bytes[i], b[0]);
            i++;
        }
        try {
            val.getLong();
        } catch (IllegalStateException ise) {
            fail("Non stream method call after stream method call " +
                    "should not throw an IllegalStateException.");
        }
        try {
            ins = otherVal.getStream();
        } catch (IllegalStateException ise) {
            fail("Stream method call after a non stream method call " +
                    "should not throw an IllegalStateException.");
        } finally {
            if (in != null) {
                in.close();
            }
            if (ins != null) {
                ins.close();
            }
        }
    }


    public void testGetStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        BufferedInputStream in = new BufferedInputStream(val.getStream());
        Value otherVal = PropertyUtil.getValue(prop);
        InputStream ins = null;
        byte[] utf8bytes = otherVal.getString().getBytes(UTF8);
        // if yet utf-8 encoded these bytes should be equal
        // to the ones received from the stream
        int i = 0;
        byte b[] = new byte[1];
        while (in.read(b) != -1) {
            assertTrue("Date as a Stream is not utf-8 encoded.",
                    b[0] == utf8bytes[i]);
            i++;
        }
        try {
            val.getDate();
        } catch (IllegalStateException ise) {
            fail("Non stream method call after stream method call " +
                    "should not throw an IllegalStateException.");
        }
        try {
            ins = otherVal.getStream();
        } catch (IllegalStateException ise) {
            fail("Stream method call after a non stream method call " +
                    "should not throw an IllegalStateException.");
        } finally {
            if (in != null) {
                in.close();
            }
            if (ins != null) {
                ins.close();
            }
        }
    }


    public void testGetStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        BufferedInputStream in = new BufferedInputStream(val.getStream());
        Value otherVal = PropertyUtil.getValue(prop);
        InputStream ins = null;
        byte[] utf8bytes = otherVal.getString().getBytes();
        // if yet utf-8 encoded these bytes should be equal
        // to the ones received from the stream
        int i = 0;
        byte b = (byte) in.read();
        while (b != -1) {
            assertTrue("Double as a Stream is not utf-8 encoded.",
                    b == utf8bytes[i]);
            b = (byte) in.read();
            i++;
        }
        try {
            val.getDouble();
        } catch (IllegalStateException ise) {
            fail("Non stream method call after stream method call " +
                    "should not throw an IllegalStateException.");
        }
        try {
            ins = otherVal.getStream();
        } catch (IllegalStateException ise) {
            fail("Stream method call after a non stream method call " +
                    "should not throw an IllegalStateException.");
        } finally {
            if (in != null) {
                in.close();
            }
            if (ins != null) {
                ins.close();
            }
        }
    }


    public void testGetStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        BufferedInputStream in = new BufferedInputStream(val.getStream());
        Value otherVal = PropertyUtil.getValue(prop);
        byte[] utf8bytes = otherVal.getString().getBytes(UTF8);
        // compare the bytearray with the bytes received from a Stream created with this String
        int i = 0;
        byte b[] = new byte[1];
        while (in.read(b) != -1) {
            assertEquals("String as a Stream is not utf-8 encoded", utf8bytes[i], b[0]);
            i++;
        }
        try {
            val.getString();
        } catch (IllegalStateException ise) {
            fail("Non stream method call after stream method call " +
                    "should not throw an IllegalStateException.");
        }
        try {
            otherVal.getStream();
        } catch (IllegalStateException ise) {
            fail("Stream method call after a non stream method call " +
                    "should not throw an IllegalStateException.");
        }
        in.close();
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getNode();
                fail("Conversion from a Boolean value to a Reference or Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getProperty();
                fail("Conversion from a Date value to a Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getProperty() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getProperty();
                fail("Conversion from a Double value to a Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException e) {
                // success.
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getProperty() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getNode();
                fail("Conversion from a Date value to a Reference or Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getNode();
                fail("Conversion from a Long value to a Reference or Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException e) {
                // success.
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        }
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getNode();
                fail("Conversion from a Double value to a Reference or Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException e) {
                // success.
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getProperty();
                fail("Conversion from a Long value to a Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException e) {
                // success.
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getProperty() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            try {
                prop.getProperty();
                fail("Conversion from a Boolean value to a Path value " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getProperty() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                assertEquals("Property.getLength() returns wrong number of bytes.",
                        length, prop.getString().length());
            }
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                assertEquals("Property.getLength() returns wrong number of bytes.",
                        length, prop.getString().length());
            }
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                assertEquals("Property.getLength() returns wrong number of bytes.",
                        length, prop.getString().length());
            }
        }
    }


    public void testValue() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLong();
                fail("Property.getLong() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long l = prop.getValue().getLong();
            long ll = prop.getLong();
            assertEquals("Value.getLong() and Property.getLong() return different values.", l, ll);
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                long bytes = PropertyUtil.countBytes(prop.getValue());
                if (bytes != -1) {
                    assertEquals("Property.getLength() returns wrong number of bytes.",
                            bytes, length);
                }

            }
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                assertEquals("Property.getLength() returns wrong number of bytes.",
                        length, prop.getString().length());
            }
        }
    }


    public void testGetLength() throws RepositoryException {
        if (multiple) {
            try {
                prop.getLength();
                fail("Property.getLength() called on a multivalue property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        } else {
            long length = prop.getLength();
            if (length > -1) {
                assertEquals("Property.getLength() returns wrong number of bytes.",
                        length, prop.getString().length());
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                if (lengths[i] > -1) {
                    assertEquals("Property.getLengths() returns " +
                            "wrong array of the lengths of a multivalue property.",
                            values[i].getString().length(), lengths[i]);
                }
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                if (lengths[i] > -1) {
                    assertEquals("Property.getLengths() returns " +
                            "wrong array of the lengths of a multivalue property.",
                            values[i].getString().length(), lengths[i]);
                }
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                if (lengths[i] > -1) {
                    assertEquals("Property.getLengths() returns " +
                            "wrong array of the lengths of a multivalue property.",
                            values[i].getString().length(), lengths[i]);
                }
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                long length = PropertyUtil.countBytes(values[i]);
                assertEquals("Property.getLengths() returns " +
                        "wrong array of the lengths of a multivalue property.",
                        length, lengths[i]);
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                if (lengths[i] > -1) {
                    assertEquals("Property.getLengths() returns " +
                            "wrong array of the lengths of a multivalue property.",
                            values[i].getString().length(), lengths[i]);
                }
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLengths() throws RepositoryException {
        if (multiple) {
            Value[] values = prop.getValues();
            long[] lengths = prop.getLengths();
            for (int i = 0; i < lengths.length; i++) {
                if (lengths[i] > -1) {
                    assertEquals("Property.getLengths() returns " +
                            "wrong array of the lengths of a multivalue property.",
                            values[i].getString().length(), lengths[i]);
                }
            }
        } else {
            try {
                prop.getLengths();
                fail("Property.getLengths() called on a sinlge value property " +
                        "should throw a ValueFormatException.");

            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testMoveNodesVersionableAndCheckedIn() throws RepositoryException, NotExecutableException {
        // prepare the test data
        // create a non-versionable node below a versionable node
        // required for having a nearest versionable ancestor to a nonversionable sub node
        String dstAbsPath = node1.getPath() + "/" + node2.getName();
        workspace.copy(node2.getPath(), dstAbsPath);

        try {
            // make parent node versionable and check-in
            addMixinVersionableToNode(testRootNode, node1);
            node1.checkin();
        }
        catch (ConstraintViolationException ex) {
            throw new NotExecutableException("server does not support making the parent versionable: " + ex.getMessage());
        }

        // 1. parent node of destAbsPath is non-versionable but its nearest versionable ancestor is checked-in
        try {
            workspace.move(node2.getPath(), dstAbsPath + "/" + node2.getName());
            fail("Copying a node to a node's versionable and checked-in nearest ancestor node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }

        // 2. parent node of destAbsPath is versionable and checked-in
        try {
            workspace.move(node2.getPath(), node1.getPath() + "/" + node2.getName());
            fail("Copying a node to a versionable and checked-in parent node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }
    }


    public void testCopyNodesVersionableAndCheckedIn() throws RepositoryException, NotExecutableException {
        // prepare the test data
        // create a non-versionable node below a versionable node
        // required for having a nearest versionable ancestor to a nonversionable sub node
        String dstAbsPath = node1.getPath() + "/" + node2.getName();
        workspace.copy(node2.getPath(), dstAbsPath);

        try {
            // make parent node versionable and check-in
            addMixinVersionableToNode(testRootNode, node1);
            node1.checkin();
        }
        catch (ConstraintViolationException ex) {
            throw new NotExecutableException("server does not support making the parent versionable: " + ex.getMessage());
        }

        // 1. parent node of destAbsPath is non-versionable but its nearest versionable ancestor is checked-in
        try {
            workspace.copy(node2.getPath(), dstAbsPath + "/" + node2.getName());
            fail("Copying a node to a node's versionable and checked-in nearest ancestor node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }

        // 2. parent node of destAbsPath is versionable and checked-in
        try {
            workspace.copy(node2.getPath(), node1.getPath() + "/" + node2.getName());
            fail("Copying a node to a versionable and checked-in parent node of destAbsPath should throw VersionException.");
        } catch (VersionException e) {
            // successful
        }
    }


    public void doTestVersioningExceptionFileParent(boolean useWorkspace, boolean useHandler)
            throws Exception {
        Node n = initVersioningException(true);

        FileInputStream in = new FileInputStream(file);
        try {
            doImport(n.getPath(), in, useWorkspace, useHandler);
            fail("Importing to a checked-in node must throw a ConstraintViolationException.");
        } catch (VersionException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testSessionImportXmlExceptions() throws RepositoryException, IOException {
        exportRepository(SKIPBINARY, RECURSE);
        FileInputStream in = new FileInputStream(file);

        // If no node exists at parentAbsPath, a PathNotFoundException is thrown.
        try {
            session.importXML(treeComparator.targetFolder + "/thisNodeDoesNotExist",
                    in, ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
            fail("Importing to a non-existing node does not throw a PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void doTestVersioningExceptionFileChild(boolean useWorkspace, boolean useHandler)
            throws Exception {
        Node n = initVersioningException(false);

        FileInputStream in = new FileInputStream(file);
        try {
            doImport(n.getPath(), in, useWorkspace, useHandler);
            fail("Importing to a child of a checked-in node must throw a ConstraintViolationException.");
        } catch (VersionException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testWorkspaceImportXmlExceptions() throws RepositoryException, IOException {
        exportRepository(SKIPBINARY, RECURSE);
        FileInputStream in = new FileInputStream(file);

        //If no node exists at parentAbsPath, a PathNotFoundException is thrown.
        try {
            workspace.importXML(treeComparator.targetFolder + "/thisNodeDoesNotExist", in, 0);
            fail("Importing to a non-existing node does not throw a PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void doTestOverwriteException(boolean useWorkspace, boolean useHandler)
            throws Exception {
        //If deserialization would overwrite an existing item,
        // an ItemExistsException respective a SAXException is thrown.

        Node folder = testRootNode.addNode("myFolder", treeComparator.sc.sameNameSibsFalseChildNodeDefinition);
        Node subfolder = folder.addNode("subfolder");

        session.save();
        FileOutputStream out = new FileOutputStream(file);
        try {
            session.exportSystemView(subfolder.getPath(), out, true, true);
        } finally {
            out.close();
        }

        FileInputStream in = new FileInputStream(file);
        try {
            if (useHandler) {
                try {
                    doImport(folder.getPath(), in, useWorkspace, useHandler);
                    fail("Overwriting an existing node during import must throw a SAXException");
                } catch (SAXException e) {
                    // success
                }
            } else {
                try {
                    doImport(folder.getPath(), in, useWorkspace, useHandler);
                    fail("Overwriting an existing node during import must throw an ItemExistsException");
                } catch (ItemExistsException e) {
                    // success
                }
            }
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void doTestNodeTypeConstraintViolation(boolean useWorkspace, boolean useHandler)
            throws Exception {

        treeComparator.createExampleTree();
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node node = testRootNode.addNode("ntBase", nodetype);
        session.save();

        FileInputStream in = new FileInputStream(file);
        try {
            if (useHandler) {
                try {
                    doImport(node.getPath(), in, useWorkspace, useHandler);
                    fail("Node type constraint violation should throw a SAXException " +
                            "during xml import using a Contenthandler.");
                } catch (SAXException se) {
                    // ok
                }
            } else {
                try {
                    doImport(node.getPath(), in, useWorkspace, useHandler);
                    fail("Node type constraint violation should throw a  " +
                            " InvalidSerializedDataException during xml import " +
                            "using a Contenthandler.");
                } catch (InvalidSerializedDataException isde) {
                    // ok
                }
            }
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testSessionImportXml() throws RepositoryException, IOException {
        FileInputStream in = new FileInputStream(file);
        try {
            exportRepository(SAVEBINARY, RECURSE);
            session.importXML(treeComparator.targetFolder, in,
                    ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // after logout/login, no nodes are in the session
        session.logout();
        superuser = null; //so tearDown won't fail

        session = getHelper().getReadWriteSession();
        treeComparator.setSession(session);
        treeComparator.compare(treeComparator.CHECK_EMPTY);
    }


    public void testSessionGetContentHandler() throws Exception {
        FileInputStream in = new FileInputStream(file);
        try {
            exportRepository(SAVEBINARY, RECURSE);
            doImportNoSave(treeComparator.targetFolder, in, CONTENTHANDLER);
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // after logout/login, no nodes are in the session
        session.logout();
        superuser = null; //so tearDown won't fail

        session = getHelper().getReadWriteSession();
        treeComparator.setSession(session);
        treeComparator.compare(treeComparator.CHECK_EMPTY);
    }


    public void testGetDate() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        if (PropertyUtil.isDateFormat(val.getString())) {
            val.getDate();
        } else {
            try {
                val.getDate();
                fail("Conversion from a malformed String to a Date " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetDate() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        if (PropertyUtil.isDateFormat(val.getString())) {
            val.getDate();
        } else {
            try {
                val.getDate();
                fail("Conversion from a malformed String to a Date " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetDouble() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        String str = val.getString();
        // double
        try {
            Double.parseDouble(str);
            double d = val.getDouble();
            assertEquals("Wrong conversion from String to Double.",
                    new Double(d), Double.valueOf(str));
        } catch (NumberFormatException nfe) {
            try {
                val.getDouble();
                fail("Conversion from malformed String to Double should throw ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetDouble() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        String str = val.getString();
        // double
        try {
            Double.parseDouble(str);
            double d = val.getDouble();
            assertEquals("Wrong conversion from Binary to Double",
                    new Double(d), Double.valueOf(str));
        } catch (NumberFormatException nfe) {
            try {
                val.getDouble();
                fail("Conversion from malformed Binary to Double " +
                        "should throw ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLong() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        String str = val.getString();
        try {
            Long.parseLong(str);
            long l = val.getLong();
            assertEquals("Wrong conversion from String to Long.",
                    new Long(l), Long.valueOf(str));
        } catch (NumberFormatException nfe) {
            try {
                val.getLong();
                fail("Conversion from malformed String to Long " +
                        "should throw ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetLong() throws RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        String str = val.getString();
        try {
            Long.parseLong(str);
            long l = val.getLong();
            assertEquals("Wrong conversion from Binary to Long",
                    new Long(l), Long.valueOf(str));
        } catch (NumberFormatException nfe) {
            try {
                val.getLong();
                fail("Conversion from malformed Binary to Long " +
                        "should throw ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetNode() throws RepositoryException, NotExecutableException {
        if (!multiple) {
            // not testable since format of ID is implementation specific
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException, NotExecutableException {
        if (!multiple) {
            // not testable as a STRING may or may not be convertable to Path or Reference
        } else {
            try {
                prop.getProperty();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetNode() throws RepositoryException, NotExecutableException {
        if (!multiple) {
            // not testable since format of ID is implementation specific
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException, NotExecutableException {
        if (!multiple) {
            // not testable since format of ID is implementation specific
        } else {
            try {
                prop.getProperty();
                fail("Property.getProperty() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testBinaryProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BINARY, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied1 = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        Value valueNotSatisfied2 = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied1 == null || valueNotSatisfied2 == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), valueSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(InputStream value)
        InputStream in = valueNotSatisfied1.getStream();
        try {
            prop.setValue(in);
            node.save();
            fail("setValue(InputStream value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(valueNotSatisfied2);
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testLongProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.LONG, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), valueSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(long value)
        try {
            prop.setValue(valueNotSatisfied.getLong());
            node.save();
            fail("setValue(long value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(valueNotSatisfied);
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testDateProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DATE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), valueSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(Calendar value)
        try {
            prop.setValue(valueNotSatisfied.getDate());
            node.save();
            fail("setValue(Date value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(valueNotSatisfied);
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testDoubleProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DOUBLE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), valueSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(double value)
        try {
            prop.setValue(valueNotSatisfied.getDouble());
            node.save();
            fail("setValue(double value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(valueNotSatisfied);
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testBooleanProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BOOLEAN, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), valueSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(boolean value)
        try {
            prop.setValue(valueNotSatisfied.getBoolean());
            node.save();
            fail("setValue(boolean value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(valueNotSatisfied);
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testBinaryProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BINARY, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied1 = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        Value valueNotSatisfied2 = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied1 == null || valueNotSatisfied2 == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, InputStream value)
        InputStream in = valueNotSatisfied1.getStream();
        try {
            node.setProperty(propDef.getName(), in);
            node.save();
            fail("setProperty(String name, InputStream value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied2);
            node.save();
            fail("setProperty(String name, Value value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testLongProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.LONG, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, long value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied.getLong());
            node.save();
            fail("setProperty(String name, long value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied);
            node.save();
            fail("setProperty(String name, Value value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testDateProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DATE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, Calendar value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied.getDate());
            node.save();
            fail("setProperty(String name, Calendar value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied);
            node.save();
            fail("setProperty(String name, Value value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testDoubleProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DOUBLE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, double value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied.getDouble());
            node.save();
            fail("setProperty(String name, double value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied);
            node.save();
            fail("setProperty(String name, Value value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testBooleanProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BOOLEAN, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, boolean value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied.getBoolean());
            node.save();
            fail("setProperty(String name, boolean value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), valueNotSatisfied);
            node.save();
            fail("setProperty(String name, boolean value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testReferenceProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.REFERENCE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No reference property def with " +
                    "testable value constraints has been found");
        }

        String valueConstraints[] = propDef.getValueConstraints();
        if (valueConstraints == null || valueConstraints.length == 0) {
            throw new NotExecutableException("No reference property def with "
                    + "testable value constraints has been found");
        }
        List<String> constraints = Arrays.asList(valueConstraints);
        String nodeTypeSatisfied = constraints.get(0);
        String nodeTypeNotSatisfied = null;

        NodeTypeManager manager = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        // find a NodeType which is not satisfying the constraints
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            String name = type.getName();
            if (constraints.contains(name) || ntFrozenNode.equals(name)) {
                continue;
            }
            if (type.getChildNodeDefinitions() != null
                    && type.getChildNodeDefinitions().length > 0) {
                continue;
            }
            nodeTypeNotSatisfied = name;
            break;
        }

        if (nodeTypeNotSatisfied == null) {
            throw new NotExecutableException("No reference property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        Node nodeSatisfied;
        Node nodeNotSatisfied;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);

            // create a referenceable node satisfying the constraint
            nodeSatisfied = testRootNode.addNode(nodeName3, nodeTypeSatisfied);
            ensureMixinType(nodeSatisfied, mixReferenceable);

            // create a referenceable node not satisfying the constraint
            nodeNotSatisfied = testRootNode.addNode(nodeName4, nodeTypeNotSatisfied);
            ensureMixinType(nodeNotSatisfied, mixReferenceable);

            // some implementations may require a save after addMixin()
            testRootNode.getSession().save();

            prop = node.setProperty(propDef.getName(), nodeSatisfied);
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(Node value)
        try {
            prop.setValue(nodeNotSatisfied);
            node.save();
            fail("setValue(Node value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(superuser.getValueFactory().createValue(nodeNotSatisfied));
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleReferenceProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.REFERENCE, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple reference property def with " +
                    "testable value constraints has been found");
        }

        String valueConstraints[] = propDef.getValueConstraints();
        if (valueConstraints == null || valueConstraints.length == 0) {
            throw new NotExecutableException("No reference property def with "
                    + "testable value constraints has been found");
        }
        List<String> constraints = Arrays.asList(valueConstraints);
        String nodeTypeSatisfied = constraints.get(0);
        String nodeTypeNotSatisfied = null;

        NodeTypeManager manager = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        // find a NodeType which is not satisfying the constraints
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            String name = type.getName();
            if (constraints.contains(name) || ntFrozenNode.equals(name)) {
                continue;
            }
            if (type.getChildNodeDefinitions() != null
                    && type.getChildNodeDefinitions().length > 0) {
                continue;
            }
            nodeTypeNotSatisfied = name;
            break;
        }

        if (nodeTypeNotSatisfied == null) {
            throw new NotExecutableException("No reference property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        Node nodeSatisfied;
        Node nodeNotSatisfied;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);

            // create a referenceable node satisfying the constraint
            nodeSatisfied = testRootNode.addNode(nodeName3, nodeTypeSatisfied);
            ensureMixinType(nodeSatisfied, mixReferenceable);

            // create a referenceable node not satisfying the constraint
            nodeNotSatisfied = testRootNode.addNode(nodeName4, nodeTypeNotSatisfied);
            ensureMixinType(nodeNotSatisfied, mixReferenceable);

            // some implementations may require a save after addMixin()
            testRootNode.getSession().save();

            Value valueSatisfied = superuser.getValueFactory().createValue(nodeSatisfied);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(Value value)
        try {
            Value valueNotSatisfied = superuser.getValueFactory().createValue(nodeNotSatisfied);
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value[] values) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testReferenceProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.REFERENCE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No reference property def with " +
                    "testable value constraints has been found");
        }

        String valueConstraints[] = propDef.getValueConstraints();
        if (valueConstraints == null || valueConstraints.length == 0) {
            throw new NotExecutableException("No reference property def with "
                    + "testable value constraints has been found");
        }
        List<String> constraints = Arrays.asList(valueConstraints);
        String nodeTypeNotSatisfied = null;

        NodeTypeManager manager = superuser.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        // find a NodeType which is not satisfying the constraints
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            String name = type.getName();
            if (constraints.contains(name) || ntFrozenNode.equals(name)) {
                continue;
            }
            if (type.getChildNodeDefinitions() != null
                    && type.getChildNodeDefinitions().length > 0) {
                continue;
            }
            nodeTypeNotSatisfied = name;
            break;
        }

        if (nodeTypeNotSatisfied == null) {
            throw new NotExecutableException("No reference property def with " +
                    "testable value constraints has been found");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        Node node;
        Node nodeNotSatisfied;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);

            // create a referenceable node not satisfying the constraint
            nodeNotSatisfied = testRootNode.addNode(nodeName4, nodeTypeNotSatisfied);
            ensureMixinType(nodeNotSatisfied, mixReferenceable);

            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setProperty(String name, Node value)
        try {
            node.setProperty(propDef.getName(), nodeNotSatisfied);
            node.save();
            fail("setProperty(String name, Node value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }

        // test of signature setProperty(String name, Value value)
        try {
            node.setProperty(propDef.getName(), superuser.getValueFactory().createValue(nodeNotSatisfied));
            node.save();
            fail("setProperty(String name, Value value) must throw a " +
                    "ConstraintViolationException if the change would violate a " +
                    "node type constraint either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleBinaryProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BINARY, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple binary property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No multiple binary property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        try {
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value[] values) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleLongProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.LONG, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple long property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No multiple long property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value value) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleDateProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DATE, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple date property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No multiple date property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        try {
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value[] values) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleBooleanProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.BOOLEAN, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple boolean property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No multiple boolean property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        try {
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value[] values) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testMultipleDoubleProperty()
            throws NotExecutableException, RepositoryException {

        // locate a PropertyDefinition with ValueConstraints
        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(superuser, PropertyType.DOUBLE, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple double property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does not satisfy the ValueConstraints of propDef
        Value valueNotSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (valueNotSatisfied == null) {
            throw new NotExecutableException("No multiple double property def with " +
                    "testable value constraints has been found");
        }

        // find a Value that does satisfy the ValueConstraints of propDef
        Value valueSatisfied = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, true);
        if (valueSatisfied == null) {
            throw new NotExecutableException("The value constraints do not allow any value.");
        }

        // create a sub node of testRootNode of type propDef.getDeclaringNodeType()
        // and add a property with constraints to this node
        Node node;
        Property prop;
        try {
            String nodeType = propDef.getDeclaringNodeType().getName();
            node = testRootNode.addNode(nodeName2, nodeType);
            prop = node.setProperty(propDef.getName(), new Value[]{valueSatisfied});
            testRootNode.getSession().save();
        } catch (ConstraintViolationException e) {
            // implementation specific constraints do not allow to set up test environment
            throw new NotExecutableException("Not able to create required test items.");
        }

        // test of signature setValue(Value value)
        try {
            prop.setValue(new Value[]{valueNotSatisfied});
            node.save();
            fail("setValue(Value[] values) must throw a ConstraintViolationException " +
                    "if the change would violate a node type constraint " +
                    "either immediately or on save");
        } catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testOrderBeforePlaceAtEndParentSave()
            throws RepositoryException, NotExecutableException {
        checkOrderableNodeType(getProperty("nodetype2"));
        prepareTest();

        // ok lets reorder and save
        parentNode.orderBefore(initialFirstNode.getName(), null);
        parentNode.save();

        // get child node refs
        NodeIterator it = parentNode.getNodes();
        Node firstNode = it.nextNode();
        Node secondNode = it.nextNode();

        // lets see if reordering worked
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", firstNode.isSame(initialSecondNode));
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", secondNode.isSame(initialFirstNode));
    }


    public void testOrderBeforeSecondToFirstParentSave()
            throws RepositoryException, NotExecutableException {
        checkOrderableNodeType(getProperty("nodetype2"));
        prepareTest();

        // ok lets reorder and save
        parentNode.orderBefore(initialSecondNode.getName(), initialFirstNode.getName());
        parentNode.save();

        // get child node refs
        NodeIterator it = parentNode.getNodes();
        Node firstNode = it.nextNode();
        Node secondNode = it.nextNode();

        // lets see if reordering worked
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", firstNode.isSame(initialSecondNode));
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", secondNode.isSame(initialFirstNode));
    }


    public void testOrderBeforePlaceAtEndSessionSave()
            throws RepositoryException, NotExecutableException {
        checkOrderableNodeType(getProperty("nodetype2"));
        prepareTest();

        // ok lets reorder and save
        parentNode.orderBefore(initialFirstNode.getName(), null);
        superuser.save();

        // get child node refs
        NodeIterator it = parentNode.getNodes();
        Node firstNode = it.nextNode();
        Node secondNode = it.nextNode();

        // lets see if reordering worked
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", firstNode.isSame(initialSecondNode));
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", secondNode.isSame(initialFirstNode));
    }


    public void testOrderBeforeSecondToFirstSessionSave()
            throws RepositoryException, NotExecutableException {
        checkOrderableNodeType(getProperty("nodetype2"));
        prepareTest();

        // ok lets reorder and save
        parentNode.orderBefore(initialSecondNode.getName(), initialFirstNode.getName());
        superuser.save();

        // get child node refs
        NodeIterator it = parentNode.getNodes();
        Node firstNode = it.nextNode();
        Node secondNode = it.nextNode();

        // lets see if reordering worked
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", firstNode.isSame(initialSecondNode));
        assertTrue("Child nodes are not added in proper order after Node.orderBefore()!", secondNode.isSame(initialFirstNode));
    }


    private void assertEffect(Node targetNode, String childName,
                                        String propName, String childName2,
                                        String propName2) throws RepositoryException {
        Session s = targetNode.getSession();
        try {
            Node child = targetNode.getNode(childName);
            child.remove();
            s.save();
            fail("Hold present must prevent a child node from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Property p = targetNode.getProperty(propName);
            p.remove();
            s.save();
            fail("Hold present must prevent a child property from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Property p = targetNode.getProperty(propName);
            p.setValue("test2");
            s.save();
            fail("Hold present must prevent the child property from being modified.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            targetNode.addNode(childName2);
            s.save();
            fail("Hold present must prevent the target node from having new nodes added.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Value v = getJcrValue(s, RepositoryStub.PROP_PROP_VALUE2, RepositoryStub.PROP_PROP_TYPE2, "test");
            targetNode.setProperty(propName2, v);
            s.save();
            fail("Hold present must prevent the target node from having new properties set.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }

        NodeType[] mixins = targetNode.getMixinNodeTypes();
        if (mixins.length > 0) {
            try {
                targetNode.removeMixin(mixins[0].getName());
                s.save();
                fail("Hold present must prevent the target node from having it's mixin types changed.");
            }  catch (RepositoryException e) {
                // success
                s.refresh(false);
            }
        }
        try {
            targetNode.remove();
            s.save();
            fail("Hold present must prevent the target node from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
    }


    private void assertEffect(Node targetNode, String childName,
                                        String propName, String childName2,
                                        String propName2) throws RepositoryException {
        Session s = targetNode.getSession();
        try {
            Node child = targetNode.getNode(childName);
            child.remove();
            s.save();
            fail("Retention policy present must prevent a child node from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Property p = targetNode.getProperty(propName);
            p.remove();
            s.save();
            fail("Retention policy present must prevent a child property from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Property p = targetNode.getProperty(propName);
            p.setValue("test2");
            s.save();
            fail("Retention policy present must prevent the child property from being modified.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            targetNode.addNode(childName2);
            s.save();
            fail("Retention policy present must prevent the target node from having new nodes added.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            Value v = getJcrValue(s, RepositoryStub.PROP_PROP_VALUE2, RepositoryStub.PROP_PROP_TYPE2, "test");
            targetNode.setProperty(propName2, v);
            s.save();
            fail("Retention policy present must prevent the target node from having new properties set.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
        try {
            targetNode.remove();
            s.save();
            fail("Hold present must prevent the target node from being removed.");
        } catch (RepositoryException e) {
            // success
            s.refresh(false);
        }
    }


    public void testNonExistingNodePath() throws RepositoryException, NotExecutableException {
        String invalidPath = testNodePath + "/nonexisting";
        int cnt = 0;
        while (superuser.nodeExists(invalidPath)) {
            invalidPath += cnt++;
        }

        try {
            retentionMgr.getHolds(invalidPath);
            fail("Accessing holds from non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.addHold(invalidPath, getHoldName(), true);
            fail("Adding a hold for a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            Hold h = retentionMgr.addHold(testNodePath, getHoldName(), true);
            retentionMgr.removeHold(invalidPath, h);
            fail("Removing a hold at a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    public void testNonExistingNodePath() throws RepositoryException, NotExecutableException {
        String invalidPath = testNodePath + "/nonexisting";
        int cnt = 0;
        while (superuser.nodeExists(invalidPath)) {
            invalidPath += cnt++;
        }

        try {
            retentionMgr.getRetentionPolicy(invalidPath);
            fail("Accessing retention policy from non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.setRetentionPolicy(invalidPath, getApplicableRetentionPolicy());
            fail("Setting retention policy for a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.removeRetentionPolicy(invalidPath);
            fail("Removing retention policy at a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    public void testPropertyPath() throws RepositoryException, NotExecutableException {
        String propPath = null;
        for (PropertyIterator it = testRootNode.getProperties(); it.hasNext();) {
            String path = it.nextProperty().getPath();
            if (! superuser.nodeExists(path)) {
                propPath = path;
                break;
            }
        }
        if (propPath == null) {
            throw new NotExecutableException();
        }
        try {
            retentionMgr.getHolds(propPath);
            fail("Accessing holds from non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.addHold(propPath, getHoldName(), true);
            fail("Adding a hold for a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            Hold h = retentionMgr.addHold(testNodePath, getHoldName(), true);
            retentionMgr.removeHold(propPath, h);
            fail("Removing a hold at a non-existing node must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    public void testPropertyPath() throws RepositoryException, NotExecutableException {
        String propPath = null;
        for (PropertyIterator it = testRootNode.getProperties(); it.hasNext();) {
            String path = it.nextProperty().getPath();
            if (!superuser.nodeExists(path)) {
                propPath = path;
                break;
            }
        }
        if (propPath == null) {
            throw new NotExecutableException();
        }
        try {
            retentionMgr.getRetentionPolicy(propPath);
            fail("Accessing retention policy from property must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.setRetentionPolicy(propPath, getApplicableRetentionPolicy());
            fail("Setting retention policy for property must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
        try {
            retentionMgr.removeRetentionPolicy(propPath);
            fail("Removing retention policy at property path must throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // success
        }
    }


    public void testRemoveHoldOnLockedNode() throws NotExecutableException, RepositoryException {
        Node child = getLockedChildNode();
        Hold h = retentionMgr.addHold(child.getPath(), getHoldName(), false);
        testRootNode.getSession().save();

        javax.jcr.Session otherS = getHelper().getSuperuserSession();
        try {
            RetentionManager rmgr = getRetentionManager(otherS);
            Hold[] holds = rmgr.getHolds(child.getPath());

            if (holds.length > 0) {
                rmgr.removeHold(child.getPath(), holds[0]);
                otherS.save();
                fail("Removing a hold on a locked node must throw LockException.");
            }
        } catch (LockException e) {
            // success
        } finally {
            otherS.logout();

            // clear hold added before
            try {
                retentionMgr.removeHold(child.getPath(), h);
                superuser.save();
            } catch (RepositoryException e) {
                // should not get here if test is correctly executed.
            }
        }
    }


    public void testRemoveHoldOnCheckedInNode() throws NotExecutableException, RepositoryException {
        Node vn = getVersionableChildNode();
        vn.checkout();
        Node n = vn.addNode(nodeName2);
        Hold h = retentionMgr.addHold(n.getPath(), getHoldName(), false);
        superuser.save();

        // checkin on the parent node make the hold-containing node checked-in.
        vn.checkin();

        javax.jcr.Session otherS = getHelper().getSuperuserSession();
        try {
            RetentionManager rmgr = getRetentionManager(otherS);
            Hold[] holds = rmgr.getHolds(n.getPath());

            if (holds.length > 0) {
                rmgr.removeHold(n.getPath(), holds[0]);
                otherS.save();
                fail("Removing a hold on a checked-in node must throw VersionException.");
            }
        } catch (VersionException e) {
            // success
        } finally {
            otherS.logout();

            // clear hold added before
            vn.checkout();
            try {
                retentionMgr.removeHold(n.getPath(), h);
                superuser.save();
            } catch (RepositoryException e) {
                // should not get here if test is correctly executed.
            }
        }
    }


    public void testSetRetentionPolicyOnCheckedInNode() throws NotExecutableException, RepositoryException {
        Node child = getVersionableChildNode();
        child.checkout();
        child.checkin();
        String childPath = child.getPath();

        // get another session.
        Session otherS = getHelper().getSuperuserSession();
        try {
            RetentionManager rmgr = getRetentionManager(otherS);
            rmgr.setRetentionPolicy(childPath, getApplicableRetentionPolicy());
            otherS.save();

            fail("Setting a retention policy on a checked-in node must throw VersionException.");
        } catch (VersionException e) {
            // success
        } finally {
            otherS.logout();

            // clear policies (in case of test failure)
            try {
                retentionMgr.removeRetentionPolicy(childPath);
                superuser.save();
            } catch (RepositoryException e) {
                // ignore.
            }
        }
    }


    public void testRemoveRetentionPolicyOnCheckedInNode() throws NotExecutableException, RepositoryException {
        Node child = getVersionableChildNode();
        child.checkout();
        retentionMgr.setRetentionPolicy(child.getPath(), getApplicableRetentionPolicy());
        superuser.save();
        child.checkin();

        Session otherS = getHelper().getSuperuserSession();
        try {
            RetentionManager rmgr = getRetentionManager(otherS);
            rmgr.removeRetentionPolicy(child.getPath());
            otherS.save();
            fail("Removing a retention policy on a checked-in node must throw VersionException.");
        } catch (VersionException e) {
            // success
        } finally {
            otherS.logout();

            // clear policy added before
            child.checkout();
            try {
                retentionMgr.removeRetentionPolicy(child.getPath());
                superuser.save();
            } catch (RepositoryException e) {
                // should not get here if test is correctly executed.
            }
        }
    }


    public void testSetRetentionPolicyBelow() throws RepositoryException, NotExecutableException {
        Node childN = testRootNode.addNode(nodeName2);
        superuser.save();

        try {
            retentionMgr.setRetentionPolicy(testNodePath, getApplicableRetentionPolicy());
            retentionMgr.setRetentionPolicy(childN.getPath(), getApplicableRetentionPolicy());
            superuser.save();
        } finally {
            superuser.refresh(false);
            if (retentionMgr.getRetentionPolicy(testNodePath) != null) {
                retentionMgr.removeRetentionPolicy(testNodePath);
            }
            if (retentionMgr.getRetentionPolicy(childN.getPath()) != null) {
                retentionMgr.removeRetentionPolicy(childN.getPath());
            }
            superuser.save();
        }
    }


    public void testOtherSessionSetsRetentionPolicyBelow() throws RepositoryException, NotExecutableException {
        Node childN = testRootNode.addNode(nodeName2);
        superuser.save();

        Session otherS = getHelper().getSuperuserSession();
        try {
            retentionMgr.setRetentionPolicy(testNodePath, getApplicableRetentionPolicy());
            superuser.save();

            getRetentionManager(otherS).setRetentionPolicy(childN.getPath(), getApplicableRetentionPolicy());
            otherS.save();
        } finally {
            // logout the other session
            otherS.logout();

            // remove the retention policies again.
            superuser.refresh(false);
            if (retentionMgr.getRetentionPolicy(testNodePath) != null) {
                retentionMgr.removeRetentionPolicy(testNodePath);
            }
            if (retentionMgr.getRetentionPolicy(childN.getPath()) != null) {
                retentionMgr.removeRetentionPolicy(childN.getPath());
            }
            superuser.save();
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        // we assume versioning is supported by repository
        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();

        // assert that this repository supports versioning
        try {
            NodeType versionableNt = ntMgr.getNodeType(mixVersionable);
            if (versionableNt == null) {
                throw new NotExecutableException("Repository does not support versioning: mixin nodetype '" + mixVersionable + "' is missing.");
            }
        } catch (NoSuchNodeTypeException e) {
            throw new NotExecutableException("Repository does not support versioning: mixin nodetype '" + mixVersionable + "' is missing.");
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        // we assume referencing is supported by repository
        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();

        // assert that this repository supports references
        try {
            NodeType referenceableNt = ntMgr.getNodeType(mixReferenceable);
            if (referenceableNt == null) {
                throw new NotExecutableException("Repository does not support Referencing: mixin nodetype '" + mixReferenceable + "' is missing.");
            }
        } catch (NoSuchNodeTypeException e) {
            throw new NotExecutableException("Repository does not support Referencing: mixin nodetype '" + mixReferenceable + "' is missing.");
        }
    }


    public void testMoveNode() throws Exception {
        Node n = (Node) readOnlySession.getItem(testNodePath);
        String destPath = testRootNode.getPath() + "/" + nodeName2;

        try {
            readOnlySession.move(n.getPath(), destPath);
            readOnlySession.save();
            fail("A read only session must not be allowed to move a node");
        } catch (AccessDeniedException e) {
            // expected
            log.debug(e.getMessage());
        }
    }


    public void testCopyNode() throws Exception {
        Node n = (Node) readOnlySession.getItem(testNodePath);
        String destPath = testRootNode.getPath() + "/" + nodeName2;
        try {
            readOnlySession.getWorkspace().copy(n.getPath(), destPath);
            fail("A read only session must not be allowed to copy a node");
        } catch (AccessDeniedException e) {
            // expected
            log.debug(e.getMessage());
        }
    }


    public void testWorkspaceMoveNode() throws Exception {
        Node n = (Node) readOnlySession.getItem(testNodePath);
        String destPath = testRootNode.getPath() + "/" + nodeName2;
        try {
            readOnlySession.getWorkspace().move(n.getPath(), destPath);
            fail("A read only session must not be allowed to move a node");
        } catch (AccessDeniedException e) {
            // expected
            log.debug(e.getMessage());
        }
    }


    public void testSetPolicy() throws RepositoryException, AccessDeniedException, NotExecutableException {
        checkCanModifyAc(path);
        AccessControlPolicyIterator it = acMgr.getApplicablePolicies(path);
        if (it.hasNext()) {
            AccessControlPolicy policy = it.nextAccessControlPolicy();
            acMgr.setPolicy(path, policy);
        } else {
            throw new NotExecutableException();
        }
    }


    public void testNodeIsModifiedAfterSetPolicy() throws RepositoryException, AccessDeniedException, NotExecutableException {
        checkCanModifyAc(path);
        AccessControlPolicyIterator it = acMgr.getApplicablePolicies(path);
        if (it.hasNext()) {
            Item item = superuser.getItem(path);

            AccessControlPolicy policy = it.nextAccessControlPolicy();
            acMgr.setPolicy(path, policy);

            assertTrue("After setting a policy the node must be marked modified.", item.isModified());
        } else {
            throw new NotExecutableException();
        }
    }


    public void testGetPolicyAfterSet() throws RepositoryException, AccessDeniedException, NotExecutableException {
        checkCanReadAc(path);
        checkCanModifyAc(path);

        AccessControlPolicyIterator it = acMgr.getApplicablePolicies(path);
        if (it.hasNext()) {
            AccessControlPolicy policy = it.nextAccessControlPolicy();
            acMgr.setPolicy(path, policy);

            AccessControlPolicy[] policies = acMgr.getPolicies(path);
            for (int i = 0; i < policies.length; i++) {
                if (policy.equals(policies[i])) {
                    // ok
                    return;
                }
            }
            fail("GetPolicies must at least return the policy that has been set before.");
        } else {
            throw new NotExecutableException();
        }
    }


    public void testRemovePolicy() throws RepositoryException, AccessDeniedException, NotExecutableException {
        checkCanModifyAc(path);

        AccessControlPolicyIterator it = acMgr.getApplicablePolicies(path);
        if (it.hasNext()) {
            AccessControlPolicy policy = it.nextAccessControlPolicy();
            acMgr.setPolicy(path, policy);
            acMgr.removePolicy(path, policy);

            AccessControlPolicy[] plcs = acMgr.getPolicies(path);
            for (int i = 0; i < plcs.length; i++) {
                if (plcs[i].equals(policy)) {
                    fail("RemovePolicy must remove the policy that has been set before.");
                }
            }
        } else {
            throw new NotExecutableException();
        }
    }


    public void testAddAggregatePrivilege() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);

        Privilege aggregate = null;
        for (int i = 0; i < privs.length; i++) {
            if (privs[i].isAggregate()) {
                aggregate = privs[i];
                break;
            }
        }
        if (aggregate == null) {
            throw new NotExecutableException("No aggregate privilege supported at " + path);
        }

        AccessControlList acl = getList(acMgr, path);
        acl.addAccessControlEntry(testPrincipal, new Privilege[] {aggregate});

        // make sure all privileges are present now
        List<Privilege> privs = currentPrivileges(acl, testPrincipal);
        assertTrue("Privileges added through 'addAccessControlEntry' must be " +
                "reflected upon getAccessControlEntries",
                privs.contains(aggregate) || privs.containsAll(Arrays.asList(aggregate.getAggregatePrivileges())));
    }


    public void testAddAggregatedPrivilegesSeparately() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);

        Privilege aggregate = null;
        for (int i = 0; i < privs.length; i++) {
            if (privs[i].isAggregate()) {
                aggregate = privs[i];
                break;
            }
        }
        if (aggregate == null) {
            throw new NotExecutableException("No aggregate privilege supported at " + path);
        }

        AccessControlList acl = getList(acMgr, path);
        acl.addAccessControlEntry(testPrincipal, new Privilege[] {aggregate});

        Privilege[] privs = aggregate.getAggregatePrivileges();
        for (int i = 0; i < privs.length; i++) {
            boolean modified = acl.addAccessControlEntry(testPrincipal, new Privilege[] {privs[i]});
            assertFalse("Adding the aggregated privs individually later on must not modify the policy", modified);
        }
    }


    public void testAddAbstractPrivilege() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);

        Privilege abstractPriv = null;
        Privilege[] allPrivs = acMgr.privilegeFromName(Privilege.JCR_ALL).getAggregatePrivileges();
        for (int i = 0; i < allPrivs.length; i++) {
            if (allPrivs[i].isAbstract()) {
                abstractPriv = allPrivs[i];
                break;
            }
        }
        if (abstractPriv == null) {
            throw new NotExecutableException("No abstract privilege found.");
        }

        AccessControlList acl = getList(acMgr, path);
        try {
            acl.addAccessControlEntry(testPrincipal, new Privilege[] {abstractPriv});
            fail("Adding an ACE with an abstract privilege must fail.");
        } catch (AccessControlException e) {
            // success
        }
    }


    public void testAddAccessControlEntryAndSetPolicy() throws RepositoryException, NotExecutableException {
        checkCanModifyAc(path);

        AccessControlList acl = getList(acMgr, path);
        List<AccessControlEntry> originalAces = Arrays.asList(acl.getAccessControlEntries());

        if (!acl.addAccessControlEntry(testPrincipal, privs)) {
            throw new NotExecutableException();
        }

        // re-access ACL from AC-Manager -> must not yet have changed
        assertEquals("Before calling setPolicy any modifications to an ACL must not be reflected in the policies", originalAces, Arrays.asList(getList(acMgr, path).getAccessControlEntries()));

        // setting the modified policy -> policy must change.
        acMgr.setPolicy(path, acl);
        assertEquals("Before calling setPolicy any modifications to an ACL must not be reflected in the policies", Arrays.asList(acl.getAccessControlEntries()), Arrays.asList(getList(acMgr, path).getAccessControlEntries()));
    }


    public void testAddAccessControlEntryIsTransient() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);

        AccessControlList acl = getList(acMgr, path);
        List<AccessControlEntry> originalAces = Arrays.asList(acl.getAccessControlEntries());

        if (!acl.addAccessControlEntry(testPrincipal, privs)) {
            throw new NotExecutableException();
        }
        // set the policy (see #testAddAccessControlEntryAndSetPolicy)
        acMgr.setPolicy(path, acl);

        // revert the changes made
        superuser.refresh(false);
        assertEquals("After calling Session.refresh() any changes to a nodes policies must be reverted.", originalAces, Arrays.asList(getList(acMgr, path).getAccessControlEntries()));
    }


    public void testAddAccessControlEntryInvalidPrincipal() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);
        try {
            Principal invalidPrincipal = getHelper().getUnknownPrincipal(superuser);
            AccessControlList acl = getList(acMgr, path);
            acl.addAccessControlEntry(invalidPrincipal, privs);
            fail("Adding an entry with an unknown principal must throw AccessControlException.");
        } catch (AccessControlException e) {
            // success.
        } finally {
            superuser.refresh(false);
        }
    }


    public void testAddAccessControlEntryEmptyPrivilegeArray() throws NotExecutableException, RepositoryException {
        checkCanModifyAc(path);

        try {
            Privilege[] invalidPrivs = new Privilege[0];
            AccessControlList acl = getList(acMgr, path);
            acl.addAccessControlEntry(testPrincipal, invalidPrivs);
            fail("Adding an entry with an invalid privilege array must throw AccessControlException.");
        } catch (AccessControlException e) {
            // success.
        } finally {
            superuser.refresh(false);
        }
    }


    public void testGetNode()
            throws NotExecutableException, RepositoryException {

        StringBuffer notExistingPath = new StringBuffer("X");
        NodeIterator nodes = testRootNode.getNodes();
        while (nodes.hasNext()) {
            // build a path that for sure is not existing
            // (":" of namespace prefix will be replaced later on)
            notExistingPath.append(nodes.nextNode().getName());
        }

        try {
            testRootNode.getNode(notExistingPath.toString().replaceAll(":", ""));
            fail("getNode(String relPath) must throw a PathNotFoundException" +
                    "if no node exists at relPath");
        } catch (PathNotFoundException e) {
            // success
        }

        try {
            NodeIterator nodes2 = testRootNode.getNodes();
            Node node = nodes2.nextNode();
            assertTrue("Node from Iterator is not the same as the Node from getNode()",
                    testRootNode.getNode(node.getName()).isSame(node));
        } catch (NoSuchElementException e) {
            throw new NotExecutableException("Workspace does not have sufficient content for this test. " +
                    "Root node must have at least one child node.");
        }
    }


    public void testGetProperty()
            throws NotExecutableException, RepositoryException {
        StringBuffer notExistingPath = new StringBuffer("X");
        PropertyIterator properties = testRootNode.getProperties();
        while (properties.hasNext()) {
            // build a path that for sure is not existing
            // (":" of namespace prefix will be replaced later on)
            notExistingPath.append(properties.nextProperty().getName());
        }

        try {
            testRootNode.getProperty(notExistingPath.toString().replaceAll(":", ""));
            fail("getProperty(String relPath) must throw a " +
                    "PathNotFoundException if no node exists at relPath");
        } catch (PathNotFoundException e) {
            // success
        }

        try {
            PropertyIterator properties2 = testRootNode.getProperties();
            Property property = properties2.nextProperty();
            assertTrue("Property returned by getProperties() is not the same as returned by getProperty(String).",
                    testRootNode.getProperty(property.getName()).isSame(property));
        } catch (NoSuchElementException e) {
            fail("Root node must always have at least one property: jcr:primaryType");
        }
    }


    public void testGetNodesNamePattern()
            throws NotExecutableException, RepositoryException {

        // get root node and build an ArrayList of its sub nodes
        Node node = testRootNode;
        if (!node.hasNodes()) {
            throw new NotExecutableException("Workspace does not have sufficient content for this test. " +
                    "Root node must have at least one child node.");
        }
        NodeIterator allNodesIt = node.getNodes();
        List<Node> allNodes = new ArrayList<Node>();
        while (allNodesIt.hasNext()) {
            Node n = allNodesIt.nextNode();
            allNodes.add(n);
        }

        // test if an empty NodeIterator is returned
        // when the pattern is not matching any child node
        String pattern0 = "";
        NodeIterator nodes0 = node.getNodes(pattern0);
        try {
            nodes0.nextNode();
            fail("An empty NodeIterator must be returned if pattern does" +
                    "not match any child node.");
        } catch (NoSuchElementException e) {
            // success
        }

        // all further tests are using root's first sub node
        Node firstNode = allNodes.get(0);

        // test pattern "*"
        String pattern1 = "*";
        String assertString1 = "node.getNodes(\"" + pattern1 + "\"): ";
        NodeIterator nodes1 = node.getNodes(pattern1);
        // test if the number of found nodes is correct
        assertEquals(assertString1 + "number of nodes found: ",
                allNodes.size(),
                getSize(nodes1));

        // test pattern "nodeName"
        String pattern2 = firstNode.getName();
        String assertString2 = "node.getNodes(\"" + pattern2 + "\"): ";
        // test if the names of the found nodes are matching the pattern
        NodeIterator nodes2 = node.getNodes(pattern2);
        while (nodes2.hasNext()) {
            Node n = nodes2.nextNode();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstNode.getName(),
                    n.getName());
        }
        // test if the number of found nodes is correct
        int numExpected2 = 0;
        for (int i = 0; i < allNodes.size(); i++) {
            Node n = allNodes.get(i);
            if (n.getName().equals(firstNode.getName())) {
                numExpected2++;
            }
        }
        nodes2 = node.getNodes(pattern2);
        assertEquals(assertString2 + "number of nodes found: ",
                numExpected2,
                getSize(nodes2));


        // test pattern "nodeName|nodeName"
        String pattern3 = firstNode.getName() + "|" + firstNode.getName();
        String assertString3 = "node.getNodes(\"" + pattern3 + "\"): ";
        // test if the names of the found nodes are matching the pattern
        NodeIterator nodes3 = node.getNodes(pattern3);
        while (nodes3.hasNext()) {
            Node n = nodes3.nextNode();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstNode.getName(),
                    n.getName());
        }
        // test if the number of found nodes is correct
        int numExpected3 = 0;
        for (int i = 0; i < allNodes.size(); i++) {
            Node n = allNodes.get(i);
            if (n.getName().equals(firstNode.getName())) {
                numExpected3++;
            }
        }
        nodes3 = node.getNodes(pattern3);
        assertEquals(assertString3 + "number of nodes found: ",
                numExpected3,
                getSize(nodes3));


        // test pattern "*odeNam*"
        if (firstNode.getName().length() > 2) {
            String name = firstNode.getName();
            String shortenName = name.substring(1, name.length() - 1);
            String pattern4 = "*" + shortenName + "*";
            String assertString4 = "node.getNodes(\"" + pattern4 + "\"): ";
            // test if the names of the found nodes are matching the pattern
            NodeIterator nodes4 = node.getNodes(pattern4);
            while (nodes4.hasNext()) {
                Node n = nodes4.nextNode();
                assertTrue(assertString4 + "name comparison failed: *" +
                        shortenName + "* not found in " + n.getName(),
                        n.getName().indexOf(shortenName) != -1);
            }
            // test if the number of found nodes is correct
            int numExpected4 = 0;
            for (int i = 0; i < allNodes.size(); i++) {
                Node n = allNodes.get(i);
                if (n.getName().indexOf(shortenName) != -1) {
                    numExpected4++;
                }
            }
            nodes4 = node.getNodes(pattern4);
            assertEquals(assertString4 + "number of nodes found: ",
                    numExpected4,
                    getSize(nodes4));
        }
    }


    public void testGetPropertiesNamePattern()
            throws NotExecutableException, RepositoryException {

        // get root node and build an ArrayList of its sub nodes
        Node node = testRootNode;
        if (!node.hasProperties()) {
            fail("Root node must always have at least one property: jcr:primaryType");
        }
        PropertyIterator allPropertiesIt = node.getProperties();
        List<Property> allProperties = new ArrayList<Property>();
        StringBuffer notExistingPropertyName = new StringBuffer();
        while (allPropertiesIt.hasNext()) {
            Property p = allPropertiesIt.nextProperty();
            allProperties.add(p);
            notExistingPropertyName.append(p.getName() + "X");
        }


        // test that an empty NodeIterator is returned
        // when the pattern is not matching any child node
        String pattern0 = notExistingPropertyName.toString().replaceAll(":", "");
        NodeIterator properties0 = node.getNodes(pattern0);
        try {
            properties0.nextNode();
            fail("An empty NodeIterator must be returned if pattern does" +
                    "not match any child node.");
        } catch (NoSuchElementException e) {
            // success
        }

        // all tests are running using root's first property
        Property firstProperty = allProperties.get(0);

        // test: getProperties("*")
        String pattern1 = "*";
        String assertString1 = "node.getProperties(\"" + pattern1 + "\"): ";
        PropertyIterator properties1 = node.getProperties(pattern1);
        assertEquals(assertString1 + "number of properties found: ",
                allProperties.size(),
                getSize(properties1));

        // test: getProperties("propertyName")
        String pattern2 = firstProperty.getName();
        String assertString2 = "node.getProperties(\"" + pattern2 + "\"): ";
        // test if the names of the found properties are matching the pattern
        PropertyIterator properties2 = node.getProperties(pattern2);
        while (properties2.hasNext()) {
            Property p = properties2.nextProperty();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstProperty.getName(),
                    p.getName());
        }
        // test if the number of found properties is correct
        int numExpected2 = 0;
        for (int i = 0; i < allProperties.size(); i++) {
            Property p = allProperties.get(i);
            if (p.getName().equals(firstProperty.getName())) {
                numExpected2++;
            }
        }
        properties2 = node.getProperties(pattern2);
        assertEquals(assertString2 + "number of properties found: ",
                numExpected2,
                getSize(properties2));


        // test: getProperties("propertyName|propertyName")
        String pattern3 = firstProperty.getName() + "|" + firstProperty.getName();
        String assertString3 = "node.getProperties(\"" + pattern3 + "\"): ";
        // test if the names of the found properties are matching the pattern
        PropertyIterator properties3 = node.getProperties(pattern3);
        while (properties3.hasNext()) {
            Property p = properties3.nextProperty();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstProperty.getName(),
                    p.getName());
        }
        // test if the number of found properties is correct
        int numExpected3 = 0;
        for (int i = 0; i < allProperties.size(); i++) {
            Property p = allProperties.get(i);
            if (p.getName().equals(firstProperty.getName())) {
                numExpected3++;
            }
        }
        properties3 = node.getProperties(pattern3);
        assertEquals(assertString3 + "number of properties found: ",
                numExpected3,
                getSize(properties3));


        // test: getProperties("*opertyNam*")
        if (firstProperty.getName().length() > 2) {
            String name = firstProperty.getName();
            String shortenName = name.substring(1, name.length() - 1);
            String pattern4 = "*" + shortenName + "*";
            String assertString4 = "node.getProperties(\"" + pattern4 + "\"): ";
            // test if the names of the found properties are matching the pattern
            PropertyIterator properties4 = node.getProperties(pattern4);
            while (properties4.hasNext()) {
                Property p = properties4.nextProperty();
                assertTrue(assertString4 + "name comparison failed: *" +
                        shortenName + "* not found in " + p.getName(),
                        p.getName().indexOf(shortenName) != -1);
            }
            // test if the number of found properties is correct
            int numExpected4 = 0;
            for (int i = 0; i < allProperties.size(); i++) {
                Property p = allProperties.get(i);
                if (p.getName().indexOf(shortenName) != -1) {
                    numExpected4++;
                }
            }
            properties4 = node.getProperties(pattern4);
            assertEquals(assertString4 + "number of properties found: ",
                    numExpected4,
                    getSize(properties4));
        }
    }


    public void testGetNodesNamePatternArray()
            throws NotExecutableException, RepositoryException {

        // get root node and build an ArrayList of its sub nodes
        Node node = testRootNode;
        if (!node.hasNodes()) {
            throw new NotExecutableException("Workspace does not have sufficient content for this test. " +
                    "Root node must have at least one child node.");
        }
        NodeIterator allNodesIt = node.getNodes();
        List<Node> allNodes = new ArrayList<Node>();
        while (allNodesIt.hasNext()) {
            Node n = allNodesIt.nextNode();
            allNodes.add(n);
        }

        // test if an empty NodeIterator is returned
        // when the pattern is not matching any child node
        String pattern0 = "";
        NodeIterator nodes0 = node.getNodes(new String[] { pattern0 });
        try {
            nodes0.nextNode();
            fail("An empty NodeIterator must be returned if pattern does" +
                    "not match any child node.");
        } catch (NoSuchElementException e) {
            // success
        }

        // all further tests are using root's first sub node
        Node firstNode = allNodes.get(0);

        // test pattern "*"
        String pattern1 = "*";
        String assertString1 = "node.getNodes(\"" + pattern1 + "\"): ";
        NodeIterator nodes1 = node.getNodes(new String[] { pattern1 });
        // test if the number of found nodes is correct
        assertEquals(assertString1 + "number of nodes found: ",
                allNodes.size(),
                getSize(nodes1));

        // test pattern "nodeName"
        String pattern2 = firstNode.getName();
        String assertString2 = "node.getNodes(\"" + pattern2 + "\"): ";
        // test if the names of the found nodes are matching the pattern
        NodeIterator nodes2 = node.getNodes(new String[] { pattern2 });
        while (nodes2.hasNext()) {
            Node n = nodes2.nextNode();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstNode.getName(),
                    n.getName());
        }
        // test if the number of found nodes is correct
        int numExpected2 = 0;
        for (int i = 0; i < allNodes.size(); i++) {
            Node n = allNodes.get(i);
            if (n.getName().equals(firstNode.getName())) {
                numExpected2++;
            }
        }
        assertEquals(assertString2 + "number of nodes found: ",
                numExpected2,
                getSize(nodes2));

        // test pattern "nodeName", "nodeName"
        String pattern4 = firstNode.getName() + "," + firstNode.getName();
        String assertString4 = "node.getNodes(\"" + pattern4 + "\"): ";
        // test if the names of the found nodes are matching the pattern
        NodeIterator nodes4 = node.getNodes(new String[] { firstNode.getName(), firstNode.getName() });
        while (nodes4.hasNext()) {
            Node n = nodes4.nextNode();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstNode.getName(),
                    n.getName());
        }
        // test if the number of found nodes is correct
        int numExpected4 = 0;
        for (int i = 0; i < allNodes.size(); i++) {
            Node n = allNodes.get(i);
            if (n.getName().equals(firstNode.getName())) {
                numExpected4++;
            }
        }
        assertEquals(assertString4 + "number of nodes found: ",
                numExpected4,
                getSize(nodes4));


        // test pattern "*odeNam*"
        if (firstNode.getName().length() > 2) {
            String name = firstNode.getName();
            String shortenName = name.substring(1, name.length() - 1);
            String pattern5 = "*" + shortenName + "*";
            String assertString5 = "node.getNodes(\"" + pattern5 + "\"): ";
            // test if the names of the found nodes are matching the pattern
            NodeIterator nodes5 = node.getNodes(new String[] { pattern5 });
            while (nodes5.hasNext()) {
                Node n = nodes5.nextNode();
                assertTrue(assertString5 + "name comparison failed: *" +
                        shortenName + "* not found in " + n.getName(),
                        n.getName().indexOf(shortenName) != -1);
            }
            // test if the number of found nodes is correct
            int numExpected5 = 0;
            for (int i = 0; i < allNodes.size(); i++) {
                Node n = allNodes.get(i);
                if (n.getName().indexOf(shortenName) != -1) {
                    numExpected5++;
                }
            }
            assertEquals(assertString5 + "number of nodes found: ",
                    numExpected5,
                    getSize(nodes5));
        }
    }


    public void testGetPropertiesNamePatternArray()
            throws NotExecutableException, RepositoryException {

        // get root node and build an ArrayList of its sub nodes
        Node node = testRootNode;
        if (!node.hasProperties()) {
            fail("Root node must always have at least one property: jcr:primaryType");
        }
        PropertyIterator allPropertiesIt = node.getProperties();
        List<Property> allProperties = new ArrayList<Property>();
        StringBuffer notExistingPropertyName = new StringBuffer();
        while (allPropertiesIt.hasNext()) {
            Property p = allPropertiesIt.nextProperty();
            allProperties.add(p);
            notExistingPropertyName.append(p.getName() + "X");
        }

        // all tests are running using root's first property
        Property firstProperty = allProperties.get(0);

        // test: getProperties("*")
        String pattern1 = "*";
        String assertString1 = "node.getProperties(\"" + pattern1 + "\"): ";
        PropertyIterator properties1 = node.getProperties(new String[] { pattern1 });
        assertEquals(assertString1 + "number of properties found: ",
                allProperties.size(),
                getSize(properties1));

        // test: getProperties("propertyName")
        String pattern2 = firstProperty.getName();
        String assertString2 = "node.getProperties(\"" + pattern2 + "\"): ";
        // test if the names of the found properties are matching the pattern
        PropertyIterator properties2 = node.getProperties(new String[] { pattern2 });
        while (properties2.hasNext()) {
            Property p = properties2.nextProperty();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstProperty.getName(),
                    p.getName());
        }
        // test if the number of found properties is correct
        int numExpected2 = 0;
        for (int i = 0; i < allProperties.size(); i++) {
            Property p = allProperties.get(i);
            if (p.getName().equals(firstProperty.getName())) {
                numExpected2++;
            }
        }
        assertEquals(assertString2 + "number of properties found: ",
                numExpected2,
                getSize(properties2));

        // test: getProperties("propertyName|propertyName")
        // test: getProperties("propertyName", "propertyName")
        String pattern4 = firstProperty.getName() + "," + firstProperty.getName();
        String assertString4 = "node.getProperties(\"" + pattern4 + "\"): ";
        // test if the names of the found properties are matching the pattern
        PropertyIterator properties4 = node.getProperties(new String[] { firstProperty.getName(), firstProperty.getName() });
        while (properties4.hasNext()) {
            Property p = properties4.nextProperty();
            assertEquals(assertString2 + "name comparison failed: ",
                    firstProperty.getName(),
                    p.getName());
        }
        // test if the number of found properties is correct
        int numExpected4 = 0;
        for (int i = 0; i < allProperties.size(); i++) {
            Property p = allProperties.get(i);
            if (p.getName().equals(firstProperty.getName())) {
                numExpected4++;
            }
        }
        assertEquals(assertString4 + "number of properties found: ",
                numExpected4,
                getSize(properties4));

        // test: getProperties("*opertyNam*")
        if (firstProperty.getName().length() > 2) {
            String name = firstProperty.getName();
            String shortenName = name.substring(1, name.length() - 1);
            String pattern5 = "*" + shortenName + "*";
            String assertString5 = "node.getProperties(\"" + pattern5 + "\"): ";
            // test if the names of the found properties are matching the pattern
            PropertyIterator properties5 = node.getProperties(new String[] { pattern5 });
            while (properties5.hasNext()) {
                Property p = properties5.nextProperty();
                assertTrue(assertString5 + "name comparison failed: *" +
                        shortenName + "* not found in " + p.getName(),
                        p.getName().indexOf(shortenName) != -1);
            }
            // test if the number of found properties is correct
            int numExpected5 = 0;
            for (int i = 0; i < allProperties.size(); i++) {
                Property p = allProperties.get(i);
                if (p.getName().indexOf(shortenName) != -1) {
                    numExpected5++;
                }
            }
            properties5 = node.getProperties(pattern5);
            assertEquals(assertString5 + "number of properties found: ",
                    numExpected5,
                    getSize(properties5));
        }
    }


    public void testHasNode()
            throws NotExecutableException, RepositoryException {

        Node node = testRootNode;

        NodeIterator nodes = node.getNodes();
        StringBuffer notExistingNodeName = new StringBuffer();
        while (nodes.hasNext()) {
            Node n = nodes.nextNode();
            assertTrue("hasNode(String relPath) returns false although " +
                    "node at relPath is existing",
                    node.hasNode(n.getName()));
            notExistingNodeName.append(n.getName() + "X");
        }
        if (notExistingNodeName.toString().equals("")) {
            throw new NotExecutableException("Workspace does not have sufficient content for this test. " +
                    "Root node must have at least one child node.");
        }

        assertFalse("hasNode(String relPath) returns true although " +
                "node at relPath is not existing",
                node.hasNode(notExistingNodeName.toString().replaceAll(":", "")));
    }


    public void testHasProperty()
            throws NotExecutableException, RepositoryException {

        Node node = testRootNode;

        PropertyIterator properties = node.getProperties();
        StringBuffer notExistingPropertyName = new StringBuffer();
        while (properties.hasNext()) {
            Property p = properties.nextProperty();
            assertTrue("node.hasProperty(\"relPath\") returns false " +
                    "although property at relPath is existing",
                    node.hasProperty(p.getName()));
            notExistingPropertyName.append(p.getName() + "X");
        }
        if (notExistingPropertyName.toString().equals("")) {
            fail("Root node must at least have one property: jcr:primaryType");
        }

        assertFalse("node.hasProperty(\"relPath\") returns true " +
                "although property at relPath is not existing",
                node.hasProperty(notExistingPropertyName.toString().replaceAll(":", "")));
    }


    public void testHasNodes() throws RepositoryException {
        Node node = testRootNode;
        NodeIterator nodes = node.getNodes();

        int i = 0;
        while (nodes.hasNext()) {
            nodes.nextNode();
            i++;
        }

        if (i == 0) {
            assertFalse("node.hasNodes() returns true although " +
                    "no sub nodes existing",
                    node.hasNodes());
        } else {
            assertTrue("node.hasNodes() returns false althuogh " +
                    "sub nodes are existing",
                    node.hasNodes());
        }
    }


    public void testHasProperties() throws RepositoryException {
        Node node = testRootNode;
        PropertyIterator properties = node.getProperties();

        int i = 0;
        while (properties.hasNext()) {
            Property p = properties.nextProperty();
            log.println(p.getName());
            i++;
        }

        if (i == 0) {
            assertFalse("Must return false when no properties exist",
                    node.hasProperties());
        } else {
            assertTrue("Must return true when one or more properties exist",
                    node.hasProperties());
        }
    }


    public void testRemoveValueSession() throws RepositoryException {
        Value sv = null;
        property1.setValue(sv);
        superuser.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null Value has been assigned");
        } catch (PathNotFoundException e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    public void testRemoveStringParent() throws RepositoryException {
        String sv = null;
        property1.setValue(sv);
        node.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null String has been assigned");
        } catch (PathNotFoundException e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    public void testRemoveStringSession() throws RepositoryException {
        String sv = null;
        property1.setValue(sv);
        superuser.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null String has been assigned");
        } catch (PathNotFoundException e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    public void testRemoveValueParent() throws RepositoryException {
        Value sv = null;
        property1.setValue(sv);
        node.save();

        try {
            node.getProperty(propertyName1);
            fail("The property should not exist anymore, as a null Value has been assigned");
        } catch (PathNotFoundException e) {
            //success : the property has been deleted by assigning it a null value
        }
    }


    public void testMultiStringSession() throws RepositoryException {
        String[] mv = new String[]{PROP_VALUE_1, PROP_VALUE_2};
        property2.setValue(mv);
        superuser.save();
        Value[] values = property2.getValues();
        List<String> strValues = new ArrayList<String>();
        for (int i = 0; i < values.length; i++) {
            strValues.add(values[i].getString());
        }
        assertEquals("Node property not saved", Arrays.asList(mv), strValues);
    }


    public void testMultiStringParent() throws RepositoryException {
        String[] mv = new String[]{PROP_VALUE_1, PROP_VALUE_2};
        property2.setValue(mv);
        node.save();
        Value[] values = property2.getValues();
        List<String> strValues = new ArrayList<String>();
        for (int i = 0; i < values.length; i++) {
            strValues.add(values[i].getString());
        }
        assertEquals("Node property not saved", Arrays.asList(mv), strValues);
    }


    public void testCopyNodesConstraintViolationException() throws RepositoryException {
        // if parent node is nt:base then no sub nodes can be created
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node subNodesNotAllowedNode = testRootNode.addNode(nodeName3, nodetype);
        testRootNode.getSession().save();
        try {
            String dstAbsPath = subNodesNotAllowedNode.getPath() + "/" + node2.getName();
            workspace.copy(node2.getPath(), dstAbsPath);
            fail("Copying a node below a node which can not have any sub nodes should throw a ConstraintViolationException.");
        } catch (ConstraintViolationException e) {
            // successful
        }
    }


    public void testMoveNodesConstraintViolationException() throws RepositoryException {
        // if parent node is nt:base then no sub nodes can be created
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node subNodesNotAllowedNode = testRootNode.addNode(nodeName3, nodetype);
        testRootNode.getSession().save();
        try {
            String dstAbsPath = subNodesNotAllowedNode.getPath() + "/" + node2.getName();
            workspace.move(node2.getPath(), dstAbsPath);
            fail("Moving a node below a node which can not have any sub nodes should throw a ConstraintViolationException.");
        } catch (ConstraintViolationException e) {
            // successful
        }
    }


    public void testCloneNodesConstraintViolationException() throws RepositoryException {
        // if parent node is nt:base then no sub nodes can be created
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node subNodesNotAllowedNode = testRootNodeW2.addNode(nodeName3, nodetype);
        testRootNodeW2.save();
        try {
            String dstAbsPath = subNodesNotAllowedNode.getPath() + "/" + node2.getName();
            workspaceW2.clone(workspace.getName(), node2.getPath(), dstAbsPath, true);
            fail("Cloning a node below a node which can not have any sub nodes should throw a ConstraintViolationException.");
        } catch (ConstraintViolationException e) {
            // successful
        }
    }


    public void testCopyNodesConstraintViolationException() throws RepositoryException {
        // if parent node is nt:base then no sub nodes can be created
        String nodetype = testNodeTypeNoChildren == null ? ntBase : testNodeTypeNoChildren;
        Node subNodesNotAllowedNode = testRootNodeW2.addNode(nodeName3, nodetype);
        testRootNodeW2.save();
        try {
            String dstAbsPath = subNodesNotAllowedNode.getPath() + "/" + node2.getName();
            workspaceW2.copy(workspace.getName(), node2.getPath(), dstAbsPath);
            fail("Copying a node below a node which can not have any sub nodes should throw a ConstraintViolationException.");
        } catch (ConstraintViolationException e) {
            // successful
        }
    }


    public void testCopyNodesAccessDenied() throws RepositoryException {
        Session readOnlySuperuser = getHelper().getReadOnlySession();
        try {
            String dstAbsPath = node2.getPath() + "/" + node1.getName();
            try {
                readOnlySuperuser.getWorkspace().copy(node1.getPath(), dstAbsPath);
                fail("Copy in a read-only session should throw an AccessDeniedException.");
            } catch (AccessDeniedException e) {
                // successful
            }
        } finally {
            readOnlySuperuser.logout();
        }
    }


    public void testCopyNodesAccessDenied() throws RepositoryException {
        Session readOnlySuperuser = getHelper().getReadOnlySession();
        try {
            String dstAbsPath = node2.getPath() + "/" + node1.getName();
            try {
                readOnlySuperuser.getWorkspace().copy(workspaceW2.getName(), node1W2.getPath(), dstAbsPath);
                fail("Copy in a read-only session should throw an AccessDeniedException.");
            } catch (AccessDeniedException e) {
                // successful
            }
        } finally {
            readOnlySuperuser.logout();
        }
    }


    public void testMoveNodesAccessDenied() throws RepositoryException {
        Session readOnlySuperuser = getHelper().getReadOnlySession();
        try {
            String dstAbsPath = node2.getPath() + "/" + node1.getName();
            try {
                readOnlySuperuser.getWorkspace().move(node1.getPath(), dstAbsPath);
                fail("Copy in a read-only session should throw an AccessDeniedException.");
            } catch (AccessDeniedException e) {
                // successful
            }
        } finally {
            readOnlySuperuser.logout();
        }
    }


    public void testCloneNodesAccessDenied() throws RepositoryException {
        // get read only session
        Session readOnlySuperuser = getHelper().getReadOnlySession();
        try {
            String dstAbsPath = node2.getPath() + "/" + node1.getName();
            try {
                readOnlySuperuser.getWorkspace().clone(workspaceW2.getName(), node1.getPath(), dstAbsPath, true);
                fail("Cloning in a read-only session should throw an AccessDeniedException.");
            } catch (AccessDeniedException e) {
                // successful
            }
        } finally {
            readOnlySuperuser.logout();
        }
    }


    public void testCopyNodesPathNotExisting() throws RepositoryException {

        String srcAbsPath = node1.getPath();
        String dstAbsPath = node2.getPath() + "/" + node1.getName();

        // srcAbsPath is not existing
        String invalidSrcPath = srcAbsPath + "invalid";
        try {
            workspace.copy(invalidSrcPath, dstAbsPath);
            fail("Not existing source path '" + invalidSrcPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }

        // dstAbsPath parent is not existing
        String invalidDstParentPath = node2.getPath() + "invalid/" + node1.getName();
        try {
            workspace.copy(srcAbsPath, invalidDstParentPath);
            fail("Not existing destination parent path '" + invalidDstParentPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }
    }


    public void testCloneNodesPathNotExisting() throws RepositoryException {

        String srcAbsPath = node1.getPath();
        String dstAbsPath = node2W2.getPath() + "/" + node1.getName();

        // srcAbsPath is not existing
        String invalidSrcPath = srcAbsPath + "invalid";
        try {
            workspaceW2.clone(workspace.getName(), invalidSrcPath, dstAbsPath, true);
            fail("Not existing source path '" + invalidSrcPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }

        // dstAbsPath parent is not existing
        String invalidDstParentPath = node2W2.getPath() + "invalid/" + node1.getName();
        try {
            workspaceW2.clone(workspace.getName(), srcAbsPath, invalidDstParentPath, true);
            fail("Not existing destination parent path '" + invalidDstParentPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }
    }


    public void testMoveNodesPathNotExisting() throws RepositoryException {

        String srcAbsPath = node1.getPath();
        String dstAbsPath = node2.getPath() + "/" + node1.getName();

        // srcAbsPath is not existing
        String invalidSrcPath = srcAbsPath + "invalid";
        try {
            workspace.move(invalidSrcPath, dstAbsPath);
            fail("Not existing source path '" + invalidSrcPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }

        // dstAbsPath parent is not existing
        String invalidDstParentPath = node2.getPath() + "invalid/" + node1.getName();
        try {
            workspace.move(srcAbsPath, invalidDstParentPath);
            fail("Not existing destination parent path '" + invalidDstParentPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }
    }


    public void testCopyNodesPathNotExisting() throws RepositoryException {

        String srcAbsPath = node1.getPath();
        String dstAbsPath = node2W2.getPath() + "/" + node1.getName();

        // srcAbsPath is not existing
        String invalidSrcPath = srcAbsPath + "invalid";
        try {
            workspaceW2.copy(workspace.getName(), invalidSrcPath, dstAbsPath);
            fail("Not existing source path '" + invalidSrcPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }

        // dstAbsPath parent is not existing
        String invalidDstParentPath = node2W2.getPath() + "invalid/" + node1.getName();
        try {
            workspaceW2.copy(workspace.getName(), srcAbsPath, invalidDstParentPath);
            fail("Not existing destination parent path '" + invalidDstParentPath + "' should throw PathNotFoundException.");
        } catch (PathNotFoundException e) {
            // successful
        }
    }


    public void testCopyNodesLocked() throws RepositoryException,
            NotExecutableException {
        // we assume repository supports locking
        String dstAbsPath = node2.getPath() + "/" + node1.getName();

        // get other session
        Session otherSession = getHelper().getReadWriteSession();

        try {
            // get lock target node in destination wsp through other session
            Node lockTarget = (Node) otherSession.getItem(node2.getPath());

            // add mixin "lockable" to be able to lock the node
            ensureMixinType(lockTarget, mixLockable);
            lockTarget.getParent().save();

            // lock dst parent node using other session
            lockTarget.lock(true, true);

            try {
                workspace.copy(node1.getPath(), dstAbsPath);
                fail("LockException was expected.");
            } catch (LockException e) {
                // successful
            } finally {
                lockTarget.unlock();
            }
        } finally {
            otherSession.logout();
        }
    }


    public void testMoveNodesLocked() throws RepositoryException,
            NotExecutableException {
        // we assume repository supports locking
        String dstAbsPath = node2.getPath() + "/" + node1.getName();

        // get other session
        Session otherSession = getHelper().getReadWriteSession();

        try {
            // get lock target node in destination wsp through other session
            Node lockTarget = (Node) otherSession.getItem(node2.getPath());

            // add mixin "lockable" to be able to lock the node
            ensureMixinType(lockTarget, mixLockable);
            lockTarget.getParent().save();

            // lock dst parent node using other session
            lockTarget.lock(true, true);

            try {
                workspace.move(node1.getPath(), dstAbsPath);
                fail("LockException was expected.");
            } catch (LockException e) {
                // successful
            } finally {
                lockTarget.unlock();
            }
        } finally {
            otherSession.logout();
        }
    }


    public void testActivitiesRelation() throws Exception {
        
        Node an = null;
        
        try {
            an = vm.createActivity("foobar");
            vm.setActivity(an);
            
            String path = versionableNode.getPath();
            
            if (versionableNode.isCheckedOut()) {
                vm.checkin(path);
            }
            
            vm.checkout(path);
            
            versionableNode = superuser.getNode(path);
            Property act = versionableNode.getProperty(Property.JCR_ACTIVITY);
            assertNotNull(act);
            assertEquals(PropertyType.REFERENCE, act.getType());
            assertTrue(act.getNode().isSame(an));
            
            versionableNode.remove();
            versionableNode.getSession().save();
        }
        finally {
            if (an != null) {
                vm.removeActivity(an);
            }
        }
    }


    public void testActivitiesRelationWithCheckpoint() throws Exception {

        Node an = null;

        try {
            an = vm.createActivity("foobar2");
            vm.setActivity(an);

            String path = versionableNode.getPath();

            vm.checkpoint(path);

            versionableNode = superuser.getNode(path);
            Property act = versionableNode.getProperty(Property.JCR_ACTIVITY);
            assertNotNull(act);
            assertEquals(PropertyType.REFERENCE, act.getType());
            assertTrue(act.getNode().isSame(an));

            versionableNode.remove();
            superuser.save();
        }
        finally {
            if (an != null) {
                vm.removeActivity(an);
            }
        }
    }


    public void testMergeNodeCancelMerge() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // second workspace
        nodeToMerge.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        nodeToMerge.checkout();
        nodeToMerge.merge(workspace.getName(), true);

        // get predecessors
        Version[] predecessors = nodeToMerge.getBaseVersion().getPredecessors();
        // get mergeFailed property
        Property mergeFailedProperty = nodeToMerge.getProperty(jcrMergeFailed);
        Value[] mergeFailedReferences = mergeFailedProperty.getValues();

        for (int i = 0; i < mergeFailedReferences.length; i++) {
            String uuid = mergeFailedReferences[i].getString();
            nodeToMerge.cancelMerge((Version) superuser.getNodeByUUID(uuid));
        }

        // check predecessors - unchanged
        Version[] predecessorsAfterCancel = nodeToMerge.getBaseVersion().getPredecessors();
        assertTrue(predecessors.length == predecessorsAfterCancel.length);

        // check mergeFailed property - reference removed
        if (nodeToMerge.hasProperty(jcrMergeFailed)) {
            Property mergeFailedPropertyAfterCancelMerge = nodeToMerge.getProperty(jcrMergeFailed);
            Value[] mergeFailedReferencesAfterCancelMerge = mergeFailedPropertyAfterCancelMerge.getValues();
            assertTrue(mergeFailedReferences.length > mergeFailedReferencesAfterCancelMerge.length);
        }
    }


    public void testMergeNodeDoneMerge() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        originalNode.checkout();
        originalNode.checkin();

        // second workspace
        nodeToMerge.checkin();

        // "merge" the clonedNode with the newNode from the default workspace
        nodeToMerge.checkout();
        nodeToMerge.merge(workspace.getName(), true);

        // get predecessors
        Version[] predecessors = nodeToMerge.getBaseVersion().getPredecessors();
        // get mergeFailed property
        Property mergeFailedProperty = nodeToMerge.getProperty(jcrMergeFailed);
        Value[] mergeFailedReferences = mergeFailedProperty.getValues();

        for (int i = 0; i < mergeFailedReferences.length; i++) {
            String uuid = mergeFailedReferences[i].getString();
            nodeToMerge.doneMerge((Version) superuser.getNodeByUUID(uuid));
        }

        // check mergeFailed property - reference moved to predecessor
        if (nodeToMerge.hasProperty(jcrMergeFailed)) {
            Property mergeFailedPropertyAfterCancelMerge = nodeToMerge.getProperty(jcrMergeFailed);
            Value[] mergeFailedReferencesAfterCancelMerge = mergeFailedPropertyAfterCancelMerge.getValues();
            assertTrue(mergeFailedReferences.length > mergeFailedReferencesAfterCancelMerge.length);
        }
    }


    protected void initNodes() throws RepositoryException {

        VersionManager versionManager = testRootNode.getSession().getWorkspace().getVersionManager();

        // create a versionable node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());
        String path = topVNode.getPath();

        // save default workspace
        testRootNode.getSession().save();
        versionManager.checkin(path);
        versionManager.checkout(path);

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    protected void initNodes() throws RepositoryException {

        VersionManager versionManager = testRootNode.getSession().getWorkspace().getVersionManager();

        // create a versionable node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());
        String path = topVNode.getPath();

        // save default workspace
        testRootNode.getSession().save();
        versionManager.checkin(path);
        versionManager.checkout(path);

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        // todo clone on testRootNode does not seem to work.
        // workspaceW2.clone(workspace.getName(), testRootNode.getPath(), testRootNode.getPath(), true);
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    protected void initNodes() throws RepositoryException {

        VersionManager versionManager = testRootNode.getSession().getWorkspace().getVersionManager();

        // create a versionable node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());
        String path = topVNode.getPath();

        // save default workspace
        testRootNode.getSession().save();
        versionManager.checkin(path);
        versionManager.checkout(path);

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    public void testMergeNodeCancelMergeJcr2() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node
    
        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);
    
        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);
    
        // "merge" the clonedNode with the newNode from the default workspace
        vmWsp2.checkout(path);
        vmWsp2.merge(path, workspace.getName(), true);
    
        // get predecessors
        Version[] predecessors = vmWsp2.getBaseVersion(path).getPredecessors();
        // get mergeFailed property
        Property mergeFailedProperty = nodeToMerge.getProperty(jcrMergeFailed);
        Value[] mergeFailedReferences = mergeFailedProperty.getValues();
    
        for (int i = 0; i < mergeFailedReferences.length; i++) {
            String id = mergeFailedReferences[i].getString();
            vmWsp2.cancelMerge(path, (Version) superuser.getNodeByIdentifier(id));
        }
    
        // check predecessors - unchanged
        Version[] predecessorsAfterCancel = vmWsp2.getBaseVersion(path).getPredecessors();
        assertTrue(predecessors.length == predecessorsAfterCancel.length);
    
        // check mergeFailed property - reference removed
        if (nodeToMerge.hasProperty(jcrMergeFailed)) {
            Property mergeFailedPropertyAfterCancelMerge = nodeToMerge.getProperty(jcrMergeFailed);
            Value[] mergeFailedReferencesAfterCancelMerge = mergeFailedPropertyAfterCancelMerge.getValues();
            assertTrue(mergeFailedReferences.length > mergeFailedReferencesAfterCancelMerge.length);
        }
    }


    public void testMergeNodeBestEffortTrueCheckMergeFailedPropertyJcr2() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);

        // "merge" the clonedNode with the newNode from the default workspace
        // besteffort set to true to report all failures
        vmWsp2.checkout(path);
        vmWsp2.merge(path, workspace.getName(), true);

        // success merge exception was raised as expected
        // jcrMergeFailed should contains reference to the V' as it is a different branche
        String expectedReferenceUUID = originalNode.getBaseVersion().getUUID();
        Property mergeFailedProperty = nodeToMerge.getProperty(jcrMergeFailed);
        Value[] references = mergeFailedProperty.getValues();
        boolean referenceFound = false;
        if (references != null) {
            for (int i = 0; i < references.length; i++) {
                String referenceUUID = references[i].getString();
                if (referenceUUID.equals(expectedReferenceUUID)) {
                    referenceFound = true;
                    break; // it's not necessary to loop thru all the references
                }
            }

            assertTrue("reference to expected version that give the failure wasnt found in the mergeFailed", referenceFound);
        }
    }


    public void testMergeNodeDoneMergeJcr2() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);

        // "merge" the clonedNode with the newNode from the default workspace
        vmWsp2.checkout(path);
        vmWsp2.merge(path, workspace.getName(), true);

        // get predecessors
        Version[] predecessors = nodeToMerge.getBaseVersion().getPredecessors();
        // get mergeFailed property
        Property mergeFailedProperty = nodeToMerge.getProperty(jcrMergeFailed);
        Value[] mergeFailedReferences = mergeFailedProperty.getValues();

        for (int i = 0; i < mergeFailedReferences.length; i++) {
            String id = mergeFailedReferences[i].getString();
            vmWsp2.doneMerge(path, (Version) superuser.getNodeByIdentifier(id));
        }

        // check mergeFailed property - reference moved to predecessor
        if (nodeToMerge.hasProperty(jcrMergeFailed)) {
            Property mergeFailedPropertyAfterCancelMerge = nodeToMerge.getProperty(jcrMergeFailed);
            Value[] mergeFailedReferencesAfterCancelMerge = mergeFailedPropertyAfterCancelMerge.getValues();
            assertTrue(mergeFailedReferences.length > mergeFailedReferencesAfterCancelMerge.length);
        }
    }


    public void testRestoreProp() throws RepositoryException {

        Node propParent = p.getParent();
        propParent.checkout();
        Version v = propParent.checkin();
        propParent.checkout();

        p.setValue(newPropValue);
        p.save();

        propParent.restore(v, false);

        assertEquals("On restore of a OnParentVersion-IGNORE property P, the current value of P must be left unchanged.", p.getString(), newPropValue);
    }


    public void testRestoreProp() throws RepositoryException {

        Node propParent = p.getParent();
        propParent.checkout();
        Version v = propParent.checkin();
        propParent.checkout();

        p.setValue(newPropValue);
        p.save();

        propParent.restore(v, false);

        assertEquals("On restore of a OnParentVersion-INITIALIZE property P, the current value of P must be left unchanged.", p.getString(), newPropValue);
    }


    public void testRestoreProp() throws RepositoryException {

        Node propParent = p.getParent();
        propParent.checkout();
        Version v = propParent.checkin();
        propParent.checkout();

        p.setValue(newPropValue);
        p.save();

        propParent.restore(v, false);

        assertEquals("On restore of a OnParentVersion-COMPUTE property P, the current P in the workspace will be left unchanged.", p.getString(), newPropValue);
    }


    public void testRestorePropJcr2() throws RepositoryException {

        Node propParent = p.getParent();
        VersionManager versionManager = propParent.getSession().getWorkspace().getVersionManager();
        String path = propParent.getPath();
        versionManager.checkout(path);
        Version v = versionManager.checkin(path);
        versionManager.checkout(path);

        p.setValue(newPropValue);
        p.getSession().save();

        versionManager.restore(v, false);

        assertEquals("On restore of a OnParentVersion-IGNORE property P, the current value of P must be left unchanged.", p.getString(), newPropValue);
    }


    public void testRestorePropJcr2() throws RepositoryException {

        Node propParent = p.getParent();
        VersionManager versionManager = propParent.getSession().getWorkspace().getVersionManager();
        String path = propParent.getPath();
        versionManager.checkout(path);
        Version v = versionManager.checkin(path);
        versionManager.checkout(path);

        p.setValue(newPropValue);
        p.getSession().save();

        versionManager.restore(v, false);

        assertEquals("On restore of a OnParentVersion-COMPUTE property P, the current P in the workspace will be left unchanged.", p.getString(), newPropValue);
    }


    public void testRestorePropJcr2() throws RepositoryException {

        Node propParent = p.getParent();
        VersionManager versionManager = propParent.getSession().getWorkspace().getVersionManager();
        String path = propParent.getPath();
        versionManager.checkout(path);
        Version v = versionManager.checkin(path);
        versionManager.checkout(path);

        p.setValue(newPropValue);
        p.getSession().save();

        versionManager.restore(v, false);

        assertEquals("On restore of a OnParentVersion-INITIALIZE property P, the current value of P must be left unchanged.", p.getString(), newPropValue);
    }


    protected void tearDown() throws Exception {
        // remove copied node
        try {
            String dstPath = getProperty("destination");
            superuser.getNode(dstPath).remove();
            testRootNode.getSession().save();
        } catch (Exception e) {
            log.println("Exception in tearDown: " + e.toString());
        } finally {
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        // remove copied node
        try {
            String dstPath = getProperty("destination");
            superuser.getNode(dstPath).remove();
            testRootNode.getSession().save();
        } catch (Exception e) {
            log.println("Exception in tearDown: " + e.toString());
        } finally {
            super.tearDown();
        }
    }


    public void testCopy() throws RepositoryException {
        Workspace wsp = superuser.getWorkspace();
        VersionManager vMgr = wsp.getVersionManager();
        String srcPath = versionableNode.getPath();
        String dstPath = getProperty("destination");
        wsp.copy(srcPath, dstPath);

        // check versionable
        Node v = superuser.getNode(dstPath);
        assertTrue("Copied Node.isNodeType(mix:cersionable) must return true.",
                v.isNodeType(mixVersionable));

        // check different version history
        VersionHistory vh1 = vMgr.getVersionHistory(srcPath);
        VersionHistory vh2 = vMgr.getVersionHistory(dstPath);
        assertFalse("Copied node needs a new version history.", vh1.isSame(vh2));

        // check if 1 version
        assertEquals("Copied node must have 1 version.", 1, getNumberOfVersions(vh2));

        // check if jcr:copiedFrom is set correctly
        assertTrue("Version history of desination must have a jcr:copiedFrom property", vh2.hasProperty(jcrCopiedFrom));

        Node ref = vh2.getProperty(jcrCopiedFrom).getNode();
        Version base = vMgr.getBaseVersion(srcPath);
        assertTrue("jcr:copiedFrom must point to the base version of the original.", ref.isSame(base));
    }


    public void testCopy() throws RepositoryException {
        Workspace wsp = superuser.getWorkspace();
        VersionManager vMgr = wsp.getVersionManager();
        String srcPath = versionableNode.getPath();
        String dstPath = getProperty("destination");
        wsp.copy(srcPath, dstPath);

        // check versionable
        Node v = superuser.getNode(dstPath);
        assertTrue("Copied Node.isNodeType(mix:simpleVersionable) must return true.",
                v.isNodeType(mixSimpleVersionable));
        assertFalse("Copied Node.isNodeType(mix:versionable) must return false.",
                v.isNodeType(mixVersionable));

        // check different version history
        VersionHistory vh1 = vMgr.getVersionHistory(srcPath);
        VersionHistory vh2 = vMgr.getVersionHistory(dstPath);
        assertFalse("Copied node needs a new version history.", vh1.isSame(vh2));

        // check if 1 version
        assertEquals("Copied node must have 1 version.", 1, getNumberOfVersions(vh2));
    }


    public void testMultipleCheckinHasNoEffectJcr2() throws RepositoryException {

        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        try {
            Version v2 = versionManager.checkin(path);

            assertTrue("Calling VersionManager.checkin(P) must not have an if the path P resolves to a node that is already checked-in.", v.isSame(v2));
        } catch (RepositoryException e) {
            fail("Calling VersionManager.checkin(P) must not throw an exception if the path P resolves to a node that is already checked-in.");
        }
    }


    public void testMultipleCheckinHasNoEffectJcr2() throws RepositoryException {

        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        try {
            Version v2 = versionManager.checkin(path);

            assertTrue("Calling VersionManager.checkin(P) must not have an if the path P resolves to a node that is already checked-in.", v.isSame(v2));
        } catch (RepositoryException e) {
            fail("Calling VersionManager.checkin(P) must not throw an exception if the path P resolves to a node that is already checked-in.");
        }
    }


    public void testInitialNodePredecessors() throws RepositoryException {

        Property predecessors = versionableNode.getProperty(jcrPredecessors);
        Value[] values = predecessors.getValues();
        Version rV = versionableNode.getVersionHistory().getRootVersion();
        if (values.length != 1) {
            fail("The jcr:predecessors property of a versionable node must be initialized to contain a single value");
        }

        Value initialVal = values[0];

        assertTrue("The jcr:predecessors property of a versionable node is initialized to contain a single UUID, that of the root version", initialVal.equals(superuser.getValueFactory().createValue(rV)));
    }


    public void testInitialNodePredecessorsJcr2() throws RepositoryException {

        Property predecessors = versionableNode.getProperty(jcrPredecessors);
        Value[] values = predecessors.getValues();
        Version rV = versionableNode.getSession().getWorkspace().getVersionManager().getVersionHistory(versionableNode.getPath()).getRootVersion();
        if (values.length != 1) {
            fail("The jcr:predecessors property of a versionable node must be initialized to contain a single value");
        }

        Value initialVal = values[0];

        assertTrue("The jcr:predecessors property of a versionable node is initialized to contain a single UUID, that of the root version", initialVal.equals(superuser.getValueFactory().createValue(rV)));
    }


    public void testAddNode() throws Exception {
        try {
            version.addNode(nodeName4);
            version.getSession().save();
            fail("Version should be read-only: Version.addNode(String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.addNode(nodeName4, ntBase);
            version.getSession().save();
            fail("Version should be read-only: Version.addNode(String,String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testAddNode() throws Exception {
        try {
            vHistory.addNode(nodeName4);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.addNode(String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.addNode(nodeName4, ntBase);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.addNode(String,String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testGetProperties() throws Exception {
        PropertyIterator pi = version.getProperties();
        boolean hasPropertyCreated = false;
        while (pi.hasNext()) {
            if (pi.nextProperty().getName().equals(jcrCreated)) {
                hasPropertyCreated = true;
            }
        }
        assertTrue("Version.getProperties() does not return property jcr:created", hasPropertyCreated);

        pi = version.getProperties(superuser.getNamespacePrefix(NS_JCR_URI) + ":*");
        hasPropertyCreated = false;
        while (pi.hasNext()) {
            if (pi.nextProperty().getName().equals(jcrCreated)) {
                hasPropertyCreated = true;
            }
        }
        assertTrue("Version.getProperties(String) does not return property jcr:created", hasPropertyCreated);
    }


    public void testGetProperties() throws Exception {
        PropertyIterator pi = vHistory.getProperties();
        boolean hasPropertyUUID = false;
        while (pi.hasNext()) {
            if (pi.nextProperty().getName().equals(jcrUUID)) {
                hasPropertyUUID = true;
            }
        }
        assertTrue("VersionHistory.getProperties() does not return property jcr:UUID", hasPropertyUUID);

        pi = vHistory.getProperties(superuser.getNamespacePrefix(NS_JCR_URI) + ":*");
        hasPropertyUUID = false;
        while (pi.hasNext()) {
            if (pi.nextProperty().getName().equals(jcrUUID)) {
                hasPropertyUUID = true;
            }
        }
        assertTrue("VersionHistory.getProperties(String) does not return property jcr:UUID", hasPropertyUUID);
    }


    public void testLock() throws Exception {
        try {
            version.lock(true, true);
            fail("Version should not be lockable: Version.lock(true,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            version.lock(true, false);
            fail("Version should not be lockable: Version.lock(true,false) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            version.lock(false, true);
            fail("Version should not be lockable: Version.lock(false,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            version.lock(false, false);
            fail("Version should not be lockable: Version.lock(false,false) did not throw a LockException");
        } catch (LockException success) {
        }
    }


    public void testLockJcr2() throws Exception {
        LockManager lockManager = version.getSession().getWorkspace().getLockManager();
        String path = version.getPath();
        try {
            lockManager.lock(path, true, true, 60, "");
            fail("Version should not be lockable: Version.lock(true,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, true, false, 60, "");
            fail("Version should not be lockable: Version.lock(true,false) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, false, true, 60, "");
            fail("Version should not be lockable: Version.lock(false,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, false, false, 60, "");
            fail("Version should not be lockable: Version.lock(false,false) did not throw a LockException");
        } catch (LockException success) {
        }
    }


    public void testLock() throws Exception {
        try {
            vHistory.lock(true, true);
            fail("VersionHistory should not be lockable: VersionHistory.lock(true,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            vHistory.lock(true, false);
            fail("VersionHistory should not be lockable: VersionHistory.lock(true,false) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            vHistory.lock(false, true);
            fail("VersionHistory should not be lockable: VersionHistory.lock(false,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            vHistory.lock(false, false);
            fail("VersionHistory should not be lockable: VersionHistory.lock(false,false) did not throw a UnsupportedRepositoryOperationException");
        } catch (LockException success) {
        }
    }


    public void testLockJcr2() throws Exception {
        LockManager lockManager = vHistory.getSession().getWorkspace().getLockManager();
        String path = vHistory.getPath();
        try {
            lockManager.lock(path, true, true, 60, "");
            fail("VersionHistory should not be lockable: VersionHistory.lock(true,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, true, false, 60, "");
            fail("VersionHistory should not be lockable: VersionHistory.lock(true,false) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, false, true, 60, "");
            fail("VersionHistory should not be lockable: VersionHistory.lock(false,true) did not throw a LockException");
        } catch (LockException success) {
        }
        try {
            lockManager.lock(path, false, false, 60, "");
            fail("VersionHistory should not be lockable: VersionHistory.lock(false,false) did not throw a UnsupportedRepositoryOperationException");
        } catch (LockException success) {
        }
    }


    public void testMerge() throws Exception {
        try {
            version.merge(workspaceName, true);
            fail("Version.merge(String, true) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.merge(workspaceName, false);
            fail("Version.merge(String, false) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testMerge() throws Exception {
        try {
            vHistory.merge(workspaceName, true);
            fail("VersionHistory.merge(String, true) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.merge(workspaceName, false);
            fail("VersionHistory.merge(String, false) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testRestore() throws Exception {
        try {
            version.restore("abc", true);
            fail("Version.restore(String,boolean) did not throw an UnsupportedRepositoryOperationException");
        } catch (UnsupportedRepositoryOperationException success) {
        }
        try {
            version.restore(version2, true);
            fail("Version.restore(Version,boolean) did not throw an UnsupportedRepositoryOperationException");
        } catch (UnsupportedRepositoryOperationException success) {
        }
        try {
            version.restore(version2, "abc", true);
            fail("Version.restore(Version,String,boolean) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testRestore() throws Exception {
        try {
            vHistory.restore("abc", true);
            fail("VersionHistory.restore(String,boolean) did not throw an UnsupportedRepositoryOperationException");
        } catch (UnsupportedRepositoryOperationException success) {
        }
        try {
            vHistory.restore(version, true);
            fail("VersionHistory.restore(Version,boolean) did not throw an UnsupportedRepositoryOperationException");
        } catch (UnsupportedRepositoryOperationException success) {
        }
        try {
            vHistory.restore(version, "abc", true);
            fail("VersionHistory.restore(Version,String,boolean) did not throw an ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testSetProperty() throws Exception {

        // create Value[] object
        Value[] vArray = new Value[3];
        vArray[0] = superuser.getValueFactory().createValue("abc");
        vArray[1] = superuser.getValueFactory().createValue("xyz");
        vArray[2] = superuser.getValueFactory().createValue("123");

        // create String array
        String[] s = {"abc", "xyz", "123"};

        try {
            version.setProperty(propertyName1, s);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,String[]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, s, PropertyType.STRING);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,String[],int) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, vArray);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,Value[]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, vArray, PropertyType.STRING);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,Value[],int]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, true);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,boolean) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, 123);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,double) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            byte[] bytes = {73, 26, 32, -36, 40, -43, -124};
            InputStream inpStream = new ByteArrayInputStream(bytes);
            version.setProperty(propertyName1, inpStream);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,InputStream) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, "abc");
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            Calendar c = new GregorianCalendar(1945, 1, 6, 16, 20, 0);
            version.setProperty(propertyName1, c);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,Calendar) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, version);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,Node) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            Value v = superuser.getValueFactory().createValue("abc");
            version.setProperty(propertyName1, v);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,Value) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            version.setProperty(propertyName1, -2147483650L);
            version.getSession().save();
            fail("Version should be read-only: Version.setProperty(String,long) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testSetProperty() throws Exception {

        // create Value[] object
        Value[] vArray = new Value[3];
        vArray[0] = superuser.getValueFactory().createValue("abc");
        vArray[1] = superuser.getValueFactory().createValue("xyz");
        vArray[2] = superuser.getValueFactory().createValue("123");

        // create String array
        String[] s = {"abc", "xyz", "123"};

        try {
            vHistory.setProperty(propertyName1, s);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,String[]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, s, PropertyType.STRING);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,String[],int) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, vArray);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,Value[]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, vArray, PropertyType.STRING);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,Value[],int]) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, true);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,boolean) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, 123);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,double) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            byte[] bytes = {73, 26, 32, -36, 40, -43, -124};
            InputStream inpStream = new ByteArrayInputStream(bytes);
            vHistory.setProperty(propertyName1, inpStream);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,InputStream) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, "abc");
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,String) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            Calendar c = new GregorianCalendar(1945, 1, 6, 16, 20, 0);
            vHistory.setProperty(propertyName1, c);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,Calendar) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, vHistory);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,Node) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            Value v = superuser.getValueFactory().createValue("abc");
            vHistory.setProperty(propertyName1, v);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,Value) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
        try {
            vHistory.setProperty(propertyName1, -2147483650L);
            vHistory.getSession().save();
            fail("VersionHistory should be read-only: VersionHistory.setProperty(String,long) did not throw a ConstraintViolationException");
        } catch (ConstraintViolationException success) {
        }
    }


    public void testMergeNodeNonVersionableSubNodeUpdate() throws RepositoryException {
        // modify non versionable subnode so we can check if it's updated after merge
        String changedString = CHANGED_STRING + System.currentTimeMillis();
        String nvSubNodePath = nodeName2 + "/" + nodeName3;

        // versionable ancestor to merge in first workspace (N)
        Node n = testRootNodeW2.getNode(nodeName1);

        // versionable ancestor to merge in second workspace (N')
        Node np = testRootNodeW2.getNode(nodeName1);

        // checkout N and make change
        n.checkout();
        Node nvSubNode = n.getNode(nvSubNodePath);
        nvSubNode.setProperty(propertyName1, changedString);
        n.save();
        n.checkin();

        // merge change into N'
        np.merge(workspaceW2.getName(), true);

        // corresponding node to nvSubNode in 2nd workspace
        Node nvSubNodeP = np.getNode(nvSubNodePath);

        // test if modification on N was merged into N' subnode
        assertTrue(nvSubNodeP.getProperty(propertyName1).getString().equals(changedString));
    }


    public void testMergeNodeNonVersionableSubNodeLeave() throws RepositoryException {
        // modify non versionable subnode so we can check if it's updated after merge
        String changedString = CHANGED_STRING + System.currentTimeMillis();
        String nvSubNodePath = nodeName2 + "/" + nodeName3;

        // versionable ancestor to merge in first workspace (N)
        Node n = testRootNodeW2.getNode(nodeName1);

        // versionable ancestor to merge in second workspace (N')
        Node np = testRootNodeW2.getNode(nodeName1);

        // checkout N' and make change
        np.checkout();
        Node nvSubNodeP = np.getNode(nvSubNodePath);
        nvSubNodeP.setProperty(propertyName1, changedString);
        np.save();
        np.checkin();

        // merge into N'
        np.merge(workspaceW2.getName(), true);

        // corresponding node to nvSubNode in 2nd workspace
        Node nvSubNode = np.getNode(nvSubNodePath);

        // test if modification on N' was not modified
        assertTrue(nvSubNode.getProperty(propertyName1).getString().equals(changedString));
    }


    public void testMergeNodeNonVersionableSubNodeUpdateJcr2() throws RepositoryException {
        // modify non versionable subnode so we can check if it's updated after merge
        String changedString = CHANGED_STRING + System.currentTimeMillis();
        String nvSubNodePath = nodeName2 + "/" + nodeName3;

        // versionable ancestor to merge in first workspace (N)
        Node n = testRootNodeW2.getNode(nodeName1);

        // versionable ancestor to merge in second workspace (N')
        Node np = testRootNodeW2.getNode(nodeName1);

        // checkout N and make change
        n.getSession().getWorkspace().getVersionManager().checkout(n.getPath());
        Node nvSubNode = n.getNode(nvSubNodePath);
        nvSubNode.setProperty(propertyName1, changedString);
        n.getSession().save();
        n.getSession().getWorkspace().getVersionManager().checkin(n.getPath());

        // merge change into N'
        np.getSession().getWorkspace().getVersionManager().merge(np.getPath(), workspaceW2.getName(), true);

        // corresponding node to nvSubNode in 2nd workspace
        Node nvSubNodeP = np.getNode(nvSubNodePath);

        // test if modification on N was merged into N' subnode
        assertTrue(nvSubNodeP.getProperty(propertyName1).getString().equals(changedString));
    }


    public void testMergeNodeNonVersionableSubNodeLeaveJcr2() throws RepositoryException {
        // modify non versionable subnode so we can check if it's updated after merge
        String changedString = CHANGED_STRING + System.currentTimeMillis();
        String nvSubNodePath = nodeName2 + "/" + nodeName3;

        // versionable ancestor to merge in first workspace (N)
        Node n = testRootNodeW2.getNode(nodeName1);

        // versionable ancestor to merge in second workspace (N')
        Node np = testRootNodeW2.getNode(nodeName1);

        // checkout N' and make change
        np.getSession().getWorkspace().getVersionManager().checkout(np.getPath());
        Node nvSubNodeP = np.getNode(nvSubNodePath);
        nvSubNodeP.setProperty(propertyName1, changedString);
        np.getSession().save();
        np.getSession().getWorkspace().getVersionManager().checkin(np.getPath());

        // merge into N'
        np.getSession().getWorkspace().getVersionManager().merge(np.getPath(), workspaceW2.getName(), true);

        // corresponding node to nvSubNode in 2nd workspace
        Node nvSubNode = np.getNode(nvSubNodePath);

        // test if modification on N' was not modified
        assertTrue(nvSubNode.getProperty(propertyName1).getString().equals(changedString));
    }


    protected void initNodes() throws RepositoryException {
        // create a versionable parent node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());

        // create a non'versionable sub node
        // nodeName1/nodeName2
        Node subNvNode = topVNode.addNode(nodeName2, testNodeType);
        subNvNode.setProperty(propertyName1, subNvNode.getName());

        // create a non'versionable sub node below nonversionable node
        // nodeName1/nodeName2/nodeName3
        Node subSubNvNode = subNvNode.addNode(nodeName3, testNodeType);
        subSubNvNode.setProperty(propertyName1, subSubNvNode.getName());

        // save default workspace
        testRootNode.getSession().save();

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    protected void initNodes() throws RepositoryException {
        // create a versionable parent node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());

        // create a versionable sub node
        // nodeName1/nodeName2
        Node subNvNode = topVNode.addNode(nodeName2, versionableNodeType);
        subNvNode.setProperty(propertyName1, subNvNode.getName());

        // save default workspace
        testRootNode.getSession().save();

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    protected void initNodes() throws RepositoryException {
        // create a versionable parent node
        // nodeName1
        Node topVNode = testRootNode.addNode(nodeName1, versionableNodeType);
        topVNode.setProperty(propertyName1, topVNode.getName());

        // create a versionable sub node
        // nodeName1/nodeName2
        Node subNvNode = topVNode.addNode(nodeName2, versionableNodeType);
        subNvNode.setProperty(propertyName1, subNvNode.getName());

        // save default workspace
        testRootNode.getSession().save();

        log.println("test nodes created successfully on " + workspace.getName());

        // clone the newly created node from src workspace into second workspace
        workspaceW2.clone(workspace.getName(), topVNode.getPath(), topVNode.getPath(), true);
        log.println(topVNode.getPath() + " cloned on " + superuserW2.getWorkspace().getName() + " at " + topVNode.getPath());

        testRootNodeW2 = (Node) superuserW2.getItem(testRoot);
    }


    public void testFailIfCorrespondingNodeIsSuccessorJcr2() throws RepositoryException {
        // make V' of a subnode N' in source workspace be a successor version of
        // the base version of the corresponding subnode.
        Node n = testRootNode.getNode(nodeName1 + "/" + nodeName2);
        VersionManager versionManager = n.getSession().getWorkspace().getVersionManager();
        String path = n.getPath();
        versionManager.checkout(path);
        versionManager.checkin(path);
        versionManager.checkout(path);

        try {
            // merge, besteffort set to false to stop at the first failure
            nodeToMerge.getSession().getWorkspace().getVersionManager().merge(nodeToMerge.getPath(), workspace.getName(), false);
            fail("Merging a checkedout node if the version V' of the corresponding node is a successor of this node's base version must fail.");

        } catch (MergeException e) {
            // success
        }
    }


    public void testMergeNodeBestEffortFalseJcr2() throws RepositoryException {
        /// create successor versions for a node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // "merge" the clonedNode with the newNode from the default workspace
        // merge, besteffort set to false
        try {
            nodeToMerge.getSession().getWorkspace().getVersionManager().merge(
                    nodeToMerge.getPath(), workspace.getName(), false);
            fail("bestEffort is false and any merge should throw a MergeException.");
        } catch (MergeException e) {
            // successful
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        if (!versionManager.isCheckedOut(path)) {
            fail("A versionable node must be checked-out after persistent creation.");
        }
        if (!versionableNode.isCheckedOut()) {
            fail("A versionable node must be checked-out after persistent creation.");
        }
        versionManager.checkin(path);
    }


    protected void setUp() throws Exception {
         super.setUp();

         VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
         String path = versionableNode.getPath();
         if (!versionManager.isCheckedOut(path)) {
             fail("A versionable node must be checked-out after persistent creation.");
         }
         if (!versionableNode.isCheckedOut()) {
             fail("A versionable node must be checked-out after persistent creation.");
         }
        try {
            versionManager.checkin(path);
        } catch (RepositoryException e) {
            cleanUp();
            throw e;
        }
    }


    public void testIsCheckedOutNonVersionableNode() throws RepositoryException {
        boolean isCheckedOut = nonVersionableNode.isCheckedOut();
        Node vParent = null;
        try {
            vParent = nonVersionableNode.getParent();
            while (!vParent.isNodeType(mixVersionable)) {
                vParent = vParent.getParent();
            }
        } catch (ItemNotFoundException e) {
            // root reached.
        }

        if (vParent != null && vParent.isNodeType(mixVersionable)) {
            if (vParent.isCheckedOut()) {
                assertTrue("Node.isCheckedOut() must return true if the node is non-versionable and its nearest versionable ancestor is checked-out.", isCheckedOut);
            } else {
                assertFalse("Node.isCheckedOut() must return false if the node is non-versionable and its nearest versionable ancestor is checked-in.", isCheckedOut);
            }
        } else {
            assertTrue("Node.isCheckedOut() must return true if the node is non-versionable and has no versionable ancestor", isCheckedOut);
        }
    }


     public void testIsCheckedOutNonVersionableNode() throws RepositoryException {
         boolean isCheckedOut = nonVersionableNode.isCheckedOut();
         Node vParent = null;
         try {
             vParent = nonVersionableNode.getParent();
             while (!vParent.isNodeType(mixVersionable)) {
                 vParent = vParent.getParent();
             }
         } catch (ItemNotFoundException e) {
             // root reached.
         }

         if (vParent != null && vParent.isNodeType(mixVersionable)) {
             if (vParent.isCheckedOut()) {
                 assertTrue("Node.isCheckedOut() must return true if the node is non-versionable and its nearest versionable ancestor is checked-out.", isCheckedOut);
             } else {
                 assertFalse("Node.isCheckedOut() must return false if the node is non-versionable and its nearest versionable ancestor is checked-in.", isCheckedOut);
             }
         } else {
             assertTrue("Node.isCheckedOut() must return true if the node is non-versionable and has no versionable ancestor", isCheckedOut);
         }
     }


    public void testIsCheckedOutNonVersionableNodeJcr2() throws RepositoryException {
        VersionManager versionManager = nonVersionableNode.getSession().getWorkspace().getVersionManager();
        String path = nonVersionableNode.getPath();
        boolean isCheckedOut = versionManager.isCheckedOut(path);
        Node vParent = null;
        try {
            vParent = nonVersionableNode.getParent();
            while (!vParent.isNodeType(mixVersionable)) {
                vParent = vParent.getParent();
            }
        } catch (ItemNotFoundException e) {
            // root reached.
        }

        if (vParent != null && vParent.isNodeType(mixVersionable)) {
            String parentPath = vParent.getPath();
            if (versionManager.isCheckedOut(parentPath)) {
                assertTrue("VersionManager.isCheckedOut(P) must return true if P denotes the absolute path of a non-versionable node whose nearest versionable ancestor is checked-out.", isCheckedOut);
            } else {
                assertFalse("VersionManager.isCheckedOut(P) must return false if P denotes the absolute path of a non-versionable node whose nearest versionable ancestor is checked-in.", isCheckedOut);
            }
        } else {
            assertTrue("VersionManager.isCheckedOut(P) must return true if P denotes the absolute path of a non-versionable node that has no versionable ancestor", isCheckedOut);
        }
    }


     public void testIsCheckedOutNonVersionableNodeJcr2() throws RepositoryException {
         VersionManager versionManager = nonVersionableNode.getSession().getWorkspace().getVersionManager();
         String path = nonVersionableNode.getPath();
         boolean isCheckedOut = versionManager.isCheckedOut(path);
         Node vParent = null;
         try {
             vParent = nonVersionableNode.getParent();
             while (!vParent.isNodeType(mixVersionable)) {
                 vParent = vParent.getParent();
             }
         } catch (ItemNotFoundException e) {
             // root reached.
         }

         if (vParent != null && vParent.isNodeType(mixVersionable)) {
             String parentPath = vParent.getPath();
             if (versionManager.isCheckedOut(parentPath)) {
                 assertTrue("VersionManager.isCheckedOut(P) must return true if P denotes the absolute path of a non-versionable node whose nearest versionable ancestor is checked-out.", isCheckedOut);
             } else {
                 assertFalse("VersionManager.isCheckedOut(P) must return false if P denotes the absolute path of a non-versionable node whose nearest versionable ancestor is checked-in.", isCheckedOut);
             }
         } else {
             assertTrue("VersionManager.isCheckedOut(P) must return true if P denotes the absolute path of a non-versionable node that has no versionable ancestor", isCheckedOut);
         }
     }


    public void testCheckoutCopiesBaseValueToPredecessorProperty() throws RepositoryException {
        Value baseVersionValue = versionableNode.getProperty(jcrBaseVersion).getValue();
        versionableNode.checkout();
        Value[] predecessorsValues = versionableNode.getProperty(jcrPredecessors).getValues();

        // loop over all values of jcr:predecessors property as it's not sure
        // on which position jcr:baseVersion is copied.
        boolean foundBaseVersionProp = false;
        int i = 0;
        while (i < predecessorsValues.length && !foundBaseVersionProp) {
            if (predecessorsValues[i].equals(baseVersionValue)) {
                foundBaseVersionProp = true;
            }
            i++;
        }
        if (!foundBaseVersionProp) {
            fail("After calling Node.checkout() the current value of node's jcr:baseVersion must be copied to node's jcr:predecessors property");
        }
    }


    public void testCheckoutCopiesBaseValueToPredecessorPropertyJcr2() throws RepositoryException {
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Value baseVersionValue = versionableNode.getProperty(jcrBaseVersion).getValue();
        versionManager.checkout(path);
        Value[] predecessorsValues = versionableNode.getProperty(jcrPredecessors).getValues();

        // loop over all values of jcr:predecessors property as it's not sure
        // on which position jcr:baseVersion is copied.
        boolean foundBaseVersionProp = false;
        int i = 0;
        while (i < predecessorsValues.length && !foundBaseVersionProp) {
            if (predecessorsValues[i].equals(baseVersionValue)) {
                foundBaseVersionProp = true;
            }
            i++;
        }
        if (!foundBaseVersionProp) {
            fail("After calling Node.checkout() the current value of node's jcr:baseVersion must be copied to node's jcr:predecessors property");
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        super.checkSupportedOption(Repository.OPTION_VERSIONING_SUPPORTED);

        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();

        // assert that this repository support versioning
        try {
            NodeType versionableNt = ntMgr.getNodeType(mixVersionable);
            if (versionableNt == null) {
               fail("Repository does not support Versioning: mixin nodetype 'mix:versionable' is missing.");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Repository does not support Versioning: mixin nodetype 'mix:versionable' is missing.");
        }

        // retrieve versionable nodetype
        String versionableNodeTypeName = getProperty("versionableNodeType");
        try {
            versionableNodeType = ntMgr.getNodeType(versionableNodeTypeName);
            if (versionableNodeType == null) {
               fail("Property 'versionableNodeType' does not define a valid nodetype: '"+versionableNodeTypeName+"'");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Property 'versionableNodeType' does not define an existing nodetype: '"+versionableNodeTypeName+"'");
        }

        // make sure 'non-versionable' nodetype is properly defined
        try {
            nonVersionableNodeType = ntMgr.getNodeType(testNodeType);
            if (nonVersionableNodeType == null || nonVersionableNodeType.isNodeType(mixVersionable)) {
               fail("Property 'testNodeType' does define a versionable nodetype: '"+testNodeType+"'");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Property 'testNodeType' does not define an existing nodetype: '"+testNodeType+"'");
        }

        // build persistent versionable and non-versionable nodes
        try {
            versionableNode = createVersionableNode(testRootNode, nodeName1, versionableNodeType);
        } catch (RepositoryException e) {
            fail("Failed to create versionable test node." + e.getMessage());
        }
        try {
            nonVersionableNode = testRootNode.addNode(nodeName3, nonVersionableNodeType.getName());
            testRootNode.getSession().save();
        } catch (RepositoryException e) {
            fail("Failed to create non-versionable test node." + e.getMessage());
        }

        propertyValue = getProperty("propertyValue");
        if (propertyValue == null) {
            fail("Property 'propertyValue' is not defined.");
        }
    }


    protected void setUp() throws Exception {
        super.setUp();

        super.checkSupportedOption(Repository.OPTION_SIMPLE_VERSIONING_SUPPORTED);

        NodeTypeManager ntMgr = superuser.getWorkspace().getNodeTypeManager();

        // assert that this repository support versioning
        try {
            NodeType versionableNt = ntMgr.getNodeType(mixSimpleVersionable);
            if (versionableNt == null) {
               fail("Repository does not support Versioning: mixin nodetype 'mix:simpleVersionable' is missing.");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Repository does not support Versioning: mixin nodetype 'mix:simpleVersionable' is missing.");
        }

        // retrieve versionable nodetype
        String versionableNodeTypeName = getProperty("versionableNodeType");
        try {
            versionableNodeType = ntMgr.getNodeType(versionableNodeTypeName);
            if (versionableNodeType == null) {
               fail("Property 'versionableNodeType' does not define a valid nodetype: '"+versionableNodeTypeName+"'");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Property 'simpleVersionableNodeType' does not define an existing nodetype: '"+versionableNodeTypeName+"'");
        }

        // make sure 'non-versionable' nodetype is properly defined
        try {
            nonVersionableNodeType = ntMgr.getNodeType(testNodeType);
            if (nonVersionableNodeType == null || nonVersionableNodeType.isNodeType(mixVersionable)) {
               fail("Property 'testNodeType' does define a versionable nodetype: '"+testNodeType+"'");
            }
        } catch (NoSuchNodeTypeException e) {
            fail("Property 'testNodeType' does not define an existing nodetype: '"+testNodeType+"'");
        }

        // build persistent versionable and non-versionable nodes
        try {
            versionableNode = createVersionableNode(testRootNode, nodeName1, versionableNodeType);
        } catch (RepositoryException e) {
            fail("Failed to create versionable test node." + e.getMessage());
        }
        try {
            nonVersionableNode = testRootNode.addNode(nodeName3, nonVersionableNodeType.getName());
            testRootNode.getSession().save();
        } catch (RepositoryException e) {
            fail("Failed to create non-versionable test node." + e.getMessage());
        }

        propertyValue = getProperty("propertyValue");
        if (propertyValue == null) {
            fail("Property 'propertyValue' is not defined.");
        }
    }


    public void testGetAllVersions() throws RepositoryException {
        int cnt = 5;
        Map<String, Version> versions = new HashMap<String, Version>();
        Version v = vHistory.getRootVersion();
        versions.put(v.getUUID(), v);
        for (int i = 0; i < cnt; i++) {
            v = versionableNode.checkin();
            versions.put(v.getUUID(), v);
            versionableNode.checkout();
        }

        VersionIterator it = vHistory.getAllVersions();
        while (it.hasNext()) {
            v = it.nextVersion();
            if (!versions.containsKey(v.getUUID())) {
                fail("VersionHistory.getAllVersions() must only contain the root version and versions, that have been created by a Node.checkin() call.");
            }
            versions.remove(v.getUUID());
        }
        assertTrue("VersionHistory.getAllVersions() must contain the root version and all versions that have been created with a Node.checkin() call.", versions.isEmpty());
    }


    public void testGetAllVersionsJcr2() throws RepositoryException {
        int cnt = 5;
        Map<String, Version> versions = new HashMap<String, Version>();
        List<String> vnames = new ArrayList<String>();
        Version v = vHistory.getRootVersion();
        versions.put(v.getIdentifier(), v);
        vnames.add(v.getIdentifier());
        for (int i = 0; i < cnt; i++) {
            v = versionManager.checkin(versionableNode.getPath());
            vnames.add(v.getIdentifier());
            versions.put(v.getIdentifier(), v);
            versionManager.checkout(versionableNode.getPath());
        }

        VersionIterator it = vHistory.getAllVersions();
        while (it.hasNext()) {
            v = it.nextVersion();
            if (!versions.containsKey(v.getIdentifier())) {
                fail("VersionHistory.getAllVersions() must only contain the root version and versions, that have been created by a Node.checkin() call.");
            }
            versions.remove(v.getIdentifier());
            // check order of linear version history (see JCR 2.0, 15.1.1.2)
            assertEquals("versions in a linear version history should be sorted by creation time", vnames.remove(0), v.getIdentifier());
        }
        assertTrue("VersionHistory.getAllVersions() must only contain the root version and all versions that have been created with a Node.checkin() call.", versions.isEmpty());
    }


    public void testMergeRecursive() throws RepositoryException {
        VersionManager vm2 = testRootNodeW2.getSession().getWorkspace().getVersionManager();
        NodeIterator iter = vm2.merge(nodeToMerge.getPath(),
                superuser.getWorkspace().getName(), true, false);
        if (iter.hasNext()) {
            StringBuffer failed = new StringBuffer();
            while (iter.hasNext()) {
                failed.append(iter.nextNode().getPath());
                failed.append(", ");
            }
            fail("Merge must not fail. failed nodes: " + failed);
            return;
        }

        String p1 = nodeToMerge.getProperty(propertyName1).getString();
        String p2 = nodeToMerge.getProperty(nodeName2 + "/" + propertyName1).getString();
        assertEquals("Recursive merge did not restore property on level 1.", newValue, p1);
        assertEquals("Recursive merge did not restore property on level 2.", newValue, p2);

    }


    public void testMergeShallow() throws RepositoryException {
        String oldP2 = nodeToMerge.getProperty(nodeName2 + "/" + propertyName1).getString();

        VersionManager vm2 = testRootNodeW2.getSession().getWorkspace().getVersionManager();
        NodeIterator iter = vm2.merge(nodeToMerge.getPath(),
                superuser.getWorkspace().getName(), true, true);
        if (iter.hasNext()) {
            StringBuffer failed = new StringBuffer();
            while (iter.hasNext()) {
                failed.append(iter.nextNode().getPath());
                failed.append(", ");
            }
            fail("Merge must not fail. failed nodes: " + failed);
            return;
        }

        String p1 = nodeToMerge.getProperty(propertyName1).getString();
        String p2 = nodeToMerge.getProperty(nodeName2 + "/" + propertyName1).getString();
        assertEquals("Shallow merge did not restore property on level 1.", newValue, p1);
        assertEquals("Shallow merge did restore property on level 2.", oldP2, p2);

    }


    protected void setUp() throws Exception {
        super.setUp();
        versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        propertyValue1 = getProperty("propertyValue1");
        propertyValue2 = getProperty("propertyValue2");
        versionableNode.setProperty(propertyName1, propertyValue1);
        versionableNode.getSession().save();
        version = versionManager.checkin(path);
        versionManager.checkout(path);
        versionableNode.setProperty(propertyName1, propertyValue2);
        versionableNode.getSession().save();
        version2 = versionManager.checkin(path);
        versionManager.checkout(path);
        rootVersion = versionManager.getVersionHistory(path).getRootVersion();

        // build a second versionable node below the testroot
        try {
            versionableNode2 = createVersionableNode(testRootNode, nodeName2, versionableNodeType);
        } catch (RepositoryException e) {
            fail("Failed to create a second versionable node: " + e.getMessage());
        }
    }


    protected void setUp() throws Exception {
        super.setUp();
        try {
            versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            propertyValue1 = getProperty("propertyValue1");
            propertyValue2 = getProperty("propertyValue2");
            versionableNode.setProperty(propertyName1, propertyValue1);
            versionableNode.getSession().save();
            version = versionManager.checkin(path);
            versionManager.checkout(path);
            versionableNode.setProperty(propertyName1, propertyValue2);
            versionableNode.getSession().save();
            version2 = versionManager.checkin(path);
            versionManager.checkout(path);
            rootVersion = versionManager.getVersionHistory(path).getRootVersion();
        } catch (RepositoryException e) {
            cleanUp();
            fail("Failed to setup test: " + e.getMessage());
        }

        // build a second versionable node below the testroot
        try {
            versionableNode2 = createVersionableNode(testRootNode, nodeName2, versionableNodeType);
        } catch (RepositoryException e) {
            fail("Failed to create a second versionable node: " + e.getMessage());
        }
    }


    public void testRestoreInvalidVersion2() throws RepositoryException {
        String invalidName;
        do {
            invalidName = createRandomString(3);
            for (VersionIterator it = versionableNode.getVersionHistory().getAllVersions(); it.hasNext();) {
                Version v = it.nextVersion();
                if (invalidName.equals(v.getName())) {
                    invalidName = null;
                    break;
                }
            }
        } while (invalidName == null);

        try {
            versionableNode.restore(invalidName, true);
            fail("VersionException expected on Node.restore(String, boolean) if the specified version is not part of this node's version history.");
        } catch (VersionException e) {
            // ok
        }
    }


    public void testRestoreInvalidVersion2() throws RepositoryException {
        String invalidName;
        do {
            invalidName = createRandomString(3);
            for (VersionIterator it = versionableNode.getVersionHistory().getAllVersions(); it.hasNext();) {
                Version v = it.nextVersion();
                if (invalidName.equals(v.getName())) {
                    invalidName = null;
                    break;
                }
            }
        } while (invalidName == null);

        try {
            versionableNode.restore(invalidName, true);
            fail("VersionException expected on Node.restore(String, boolean) if the specified version is not part of this node's version history.");
        } catch (VersionException e) {
            // ok
        }
    }


    public void testRestoreInvalidVersion2Jcr2() throws RepositoryException {
        String invalidName;
        do {
            invalidName = createRandomString(3);
            for (VersionIterator it = versionManager.getVersionHistory(versionableNode.getPath()).getAllVersions(); it.hasNext();) {
                Version v = it.nextVersion();
                if (invalidName.equals(v.getName())) {
                    invalidName = null;
                    break;
                }
            }
        } while (invalidName == null);

        try {
            versionManager.restore(versionableNode.getPath(), invalidName, true);
            fail("VersionException expected on Node.restore(String, boolean) if the specified version is not part of this node's version history.");
        } catch (VersionException e) {
            // ok
        }
    }


    public void testRestoreInvalidVersion2Jcr2() throws RepositoryException {
        String invalidName;
        do {
            invalidName = createRandomString(3);
            for (VersionIterator it = versionManager.getVersionHistory(versionableNode.getPath()).getAllVersions(); it.hasNext();) {
                Version v = it.nextVersion();
                if (invalidName.equals(v.getName())) {
                    invalidName = null;
                    break;
                }
            }
        } while (invalidName == null);

        try {
            versionManager.restore(versionableNode.getPath(), invalidName, true);
            fail("VersionException expected on Node.restore(String, boolean) if the specified version is not part of this node's version history.");
        } catch (VersionException e) {
            // ok
        }
    }


    public void testRestoreWithUUIDConflict() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionableNode.checkin();
            versionableNode.checkout();
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionableNode.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testWorkspaceRestoreWithUUIDConflict() throws RepositoryException, NotExecutableException {
        try {
            // Verify that nodes used for the test are indeed versionable
            NodeDefinition nd = wVersionableNode.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Nodes must be versionable in order to run this test.");
            }

            Version v = wVersionableNode.checkin();
            wVersionableNode.checkout();
            wSuperuser.move(wVersionableChildNode.getPath(), wVersionableNode2.getPath() + "/" + wVersionableChildNode.getName());
            wSuperuser.save();
            wSuperuser.getWorkspace().restore(new Version[]{v}, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testWorkspaceRestoreWithUUIDConflictJcr2() throws RepositoryException, NotExecutableException {
        try {
            // Verify that nodes used for the test are indeed versionable
            NodeDefinition nd = wVersionableNode.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Nodes must be versionable in order to run this test.");
            }

            VersionManager versionManager = wVersionableNode.getSession().getWorkspace().getVersionManager();
            String path = wVersionableNode.getPath();
            Version v = versionManager.checkin(path);
            versionManager.checkout(path);
            wSuperuser.move(wVersionableChildNode.getPath(), wVersionableNode2.getPath() + "/" + wVersionableChildNode.getName());
            wSuperuser.save();
            wSuperuser.getWorkspace().getVersionManager().restore(new Version[]{v}, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_2() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_2() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_3() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(versionableNode.getPath(), v.getName(), false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_3() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(versionableNode.getPath(), v.getName(), false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_4() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(new Version[] {v}, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2_4() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(new Version[] {v}, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflict() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionableNode.checkin();
            versionableNode.checkout();
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionableNode.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreWithUUIDConflictJcr2() throws RepositoryException, NotExecutableException {
        try {
            Node naa = createVersionableNode(versionableNode, nodeName4, versionableNodeType);
            // Verify that nodes used for the test have proper opv behaviour
            NodeDefinition nd = naa.getDefinition();
            if (nd.getOnParentVersion() != OnParentVersionAction.COPY && nd.getOnParentVersion() != OnParentVersionAction.VERSION) {
                throw new NotExecutableException("Child nodes must have OPV COPY or VERSION in order to be able to test Node.restore with uuid conflict.");
            }

            Version v = versionManager.checkin(versionableNode.getPath());
            versionManager.checkout(versionableNode.getPath());
            superuser.move(naa.getPath(), versionableNode2.getPath() + "/" + naa.getName());
            superuser.save();
            versionManager.restore(v, false);

            fail("Node.restore( Version, boolean ): An ItemExistsException must be thrown if the node to be restored already exsits and removeExisting was set to false.");
        } catch (ItemExistsException e) {
            // success
        }
    }


    public void testRestoreChild1() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionableNode.checkin();
        versionableNode.checkout();
        Version v2 = versionableNode.checkin();

        versionableNode.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionableNode.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionableNode.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_2() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_2() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionableNode.checkin();
        versionableNode.checkout();
        Version v2 = versionableNode.checkin();

        versionableNode.restore(v1, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionableNode.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionableNode.restore(v2, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_3() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(versionableNode.getPath(), v1.getName(), true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(versionableNode.getPath(), version.getName(), true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(versionableNode.getPath(), v2.getName(), true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_3() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(versionableNode.getPath(), v1.getName(), true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(versionableNode.getPath(), version.getName(), true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(versionableNode.getPath(), v2.getName(), true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_4() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(new Version[] {v1}, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(new Version[] {version}, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(new Version[] {v2}, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreChild1Jcr2_4() throws RepositoryException {
        versionableNode.addNode("child1");
        versionableNode.getSession().save();
        Version v1 = versionManager.checkin(versionableNode.getPath());
        versionManager.checkout(versionableNode.getPath());
        Version v2 = versionManager.checkin(versionableNode.getPath());

        versionManager.restore(new Version[] {v1}, true);
        assertTrue("Node.restore('1.2') must not remove child node.", versionableNode.hasNode("child1"));

        versionManager.restore(new Version[] {version}, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode("child1"));

        try {
            versionManager.restore(new Version[] {v2}, true);
        } catch (RepositoryException e) {
            fail("Node.restore('1.3') must fail.");
        }
    }


    public void testRestoreRemoved() throws RepositoryException {
        Node parent = versionableNode.getParent();
        String oldName = versionableNode.getName();
        Version v1 = versionableNode.checkin();
        versionableNode.remove();
        versionableNode = null;
        parent.getSession().save();

        parent.restore(v1, oldName, true);

        versionableNode = parent.getNode(oldName);

        String value = versionableNode.getProperty(propertyName1).getString();
        assertEquals("Restoring a node must set the correct property.", propertyValue2, value);
    }


    public void testRestoreRemovedJcr2() throws RepositoryException {
        String path = versionableNode.getPath();
        Version v1 = versionManager.checkin(path);
        versionableNode.remove();
        versionableNode = null;
        superuser.save();

        versionManager.restore(path, v1, true);

        versionableNode = superuser.getNode(path);

        String value = versionableNode.getProperty(propertyName1).getString();
        assertEquals("Restoring a node must set the correct property.", propertyValue2, value);
    }


    public void testRestoreName() throws RepositoryException,
            NotExecutableException {
        // V1.0 of versionableNode has no child
        Node child1 = versionableNode.addNode(nodeName4);
        ensureMixinType(child1, mixVersionable);
        versionableNode.getSession().save();
        // create v1.0 of child
        Version v1Child = child1.checkin();

        // V1 of versionable node has child1
        String v1 = versionableNode.checkin().getName();

        // create V1.1 of child
        child1.checkout();
        child1.checkin();

        // V2 of versionable node has child1
        versionableNode.checkout();
        String v2 = versionableNode.checkin().getName();

        // restore 1.0 of versionable node --> no child
        versionableNode.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode(nodeName4));

        // restore V1 via name. since child was checkin first, 1.0 should be restored
        versionableNode.restore(v1, true);
        assertTrue("Node.restore('test') must restore child node.", versionableNode.hasNode(nodeName4));
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('test') must restore child node version 1.0.", v1Child.getName(), child1.getBaseVersion().getName());

        // JSR283 is more clear about restoring versionable OPV=VERSION nodes
        // and states that an existing one is not restored when the parent
        // is restored (see 15.7.5 Chained Versions on Restore)

        // Old JSR170 version:
        // restore V2 via name. child should be 1.1
        // versionableNode.restore(v2, true);
        // child1 = versionableNode.getNode(nodeName4);
        // assertEquals("Node.restore('foo') must restore child node version 1.1.", v11Child.getName(), child1.getBaseVersion().getName());

        // New JSR283 version:
        // restore V2 via name. child should still be be 1.0
        versionableNode.restore(v2, true);
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('foo') must not restore child node and keep version 1.0.", v1Child.getName(), child1.getBaseVersion().getName());
    }


    public void testRestoreName() throws RepositoryException,
            NotExecutableException {
        // V1.0 of versionableNode has no child
        Node child1 = versionableNode.addNode(nodeName4);
        ensureMixinType(child1, mixVersionable);
        versionableNode.getSession().save();
        // create v1.0 of child
        Version v1Child = child1.checkin();

        // V1 of versionable node has child1
        String v1 = versionableNode.checkin().getName();

        // create V1.1 of child
        child1.checkout();
        Version v11Child = child1.checkin();

        // V2 of versionable node has child1
        versionableNode.checkout();
        String v2 = versionableNode.checkin().getName();

        // restore 1.0 of versionable node --> no child
        versionableNode.restore(version, true);
        assertFalse("Node.restore('1.0') must remove child node.", versionableNode.hasNode(nodeName4));

        // restore V1 via name. since child was checkin first, 1.0 should be restored
        versionableNode.restore(v1, true);
        assertTrue("Node.restore('test') must restore child node.", versionableNode.hasNode(nodeName4));
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('test') must restore child node version 1.0.", v1Child.getName(), child1.getBaseVersion().getName());

        // restore V2 via name. child should be 1.1
        versionableNode.restore(v2, true);
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('foo') must restore child node version 1.1.", v11Child.getName(), child1.getBaseVersion().getName());
    }


    public void testRestoreNameJcr2() throws RepositoryException,
            NotExecutableException {
        // V1.0 of versionableNode has no child
        Node child1 = versionableNode.addNode(nodeName4);
        ensureMixinType(child1, mixVersionable);
        versionableNode.getSession().save();
        // create v1.0 of child
        Version v1Child = versionManager.checkin(child1.getPath());

        // V1 of versionable node has child1
        String v1 = versionManager.checkin(versionableNode.getPath()).getName();

        // create V1.1 of child
        versionManager.checkout(child1.getPath());
        versionManager.checkin(child1.getPath());

        // V2 of versionable node has child1
        versionManager.checkout(versionableNode.getPath());
        String v2 = versionManager.checkin(versionableNode.getPath()).getName();

        // restore 1.0 of versionable node --> no child
        versionManager.restore(version, true);
        assertFalse("restore must remove child node.", versionableNode.hasNode(nodeName4));

        // restore V1 via name. since child was checkin first, 1.0 should be restored
        versionManager.restore(versionableNode.getPath(), v1, true);
        assertTrue("restore must restore child node.", versionableNode.hasNode(nodeName4));
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("restore must restore child node version 1.0.", v1Child.getName(), versionManager.getBaseVersion(child1.getPath()).getName());

        // JSR283 is more clear about restoring versionable OPV=VERSION nodes
        // and states that an existing one is not restored when the parent
        // is restored (see 15.7.5 Chained Versions on Restore)

        // New JSR283 version:
        // restore V2 via name. child should still be be 1.0
        versionManager.restore(versionableNode.getPath(), v2, true);
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('foo') must not restore child node and keep version 1.0.", v1Child.getName(), versionManager.getBaseVersion(child1.getPath()).getName());
    }


    public void testRestoreNameJcr2() throws RepositoryException,
            NotExecutableException {
        // V1.0 of versionableNode has no child
        Node child1 = versionableNode.addNode(nodeName4);
        ensureMixinType(child1, mixVersionable);
        versionableNode.getSession().save();
        // create v1.0 of child
        Version v1Child = child1.checkin();

        // V1 of versionable node has child1
        String v1 = versionManager.checkin(versionableNode.getPath()).getName();

        // create V1.1 of child
        versionManager.checkout(child1.getPath());
        Version v11Child = versionManager.checkin(child1.getPath());

        // V2 of versionable node has child1
        versionManager.checkout(versionableNode.getPath());
        String v2 = versionManager.checkin(versionableNode.getPath()).getName();

        // restore 1.0 of versionable node --> no child
        versionManager.restore(version, true);
        assertFalse("restore must remove child node.", versionableNode.hasNode(nodeName4));

        // restore V1 via name. since child was checkin first, 1.0 should be restored
        versionManager.restore(versionableNode.getPath(), v1, true);
        assertTrue("restore must restore child node.", versionableNode.hasNode(nodeName4));
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("restore must restore child node version 1.0.", v1Child.getName(), versionManager.getBaseVersion(child1.getPath()).getName());

        // restore V2 via name. child should be 1.1
        versionManager.restore(versionableNode.getPath(), v2, true);
        child1 = versionableNode.getNode(nodeName4);
        assertEquals("Node.restore('foo') must restore child node version 1.1.", v11Child.getName(), versionManager.getBaseVersion(child1.getPath()).getName());
    }


    public void testRestoreOrder() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        child1.checkin();
        child2.checkin();
        Version v1 = testRoot.checkin();

        // remove node 1
        testRoot.checkout();
        child1.remove();
        testRoot.getSession().save();
        testRoot.checkin();

        // restore version 1.0
        testRoot.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_3() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(testRoot.getPath(), v1.getName(), true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        child1.checkin();
        child2.checkin();
        Version v1 = testRoot.checkin();

        // reoder nodes
        testRoot.checkout();
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        testRoot.checkin();

        // restore version 1.0
        testRoot.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_4() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(new Version[] {v1}, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_3() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        child1.checkin();
        child2.checkin();
        Version v1 = testRoot.checkin();

        // reoder nodes
        testRoot.checkout();
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        testRoot.checkin();

        // restore version 1.0
        testRoot.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_4() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(new Version[] {v1}, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_3() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_4() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(new Version[] {v1}, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_3() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(testRoot.getPath(), v1.getName(), true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrderJcr2_2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 = versionManager.checkin(testRoot.getPath());

        // remove node 1
        versionManager.checkout(testRoot.getPath());
        child1.remove();
        testRoot.getSession().save();
        versionManager.checkout(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_2() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        child1.checkin();
        child2.checkin();
        Version v1 = testRoot.checkin();

        // remove node 1
        testRoot.checkout();
        child1.remove();
        testRoot.getSession().save();
        testRoot.checkin();

        // restore version 1.0
        testRoot.restore(v1, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testRestoreOrder2Jcr2_4() throws RepositoryException,
            NotExecutableException {
        // create a test-root that has orderable child nodes
        Node testRoot = versionableNode.addNode(nodeName4, "nt:unstructured");
        ensureMixinType(testRoot, mixVersionable);
        versionableNode.getSession().save();

        // create children of vNode and checkin
        Node child1 = testRoot.addNode(nodeName1);
        ensureMixinType(child1, mixVersionable);
        Node child2 = testRoot.addNode(nodeName2);
        ensureMixinType(child2, mixVersionable);
        testRoot.getSession().save();
        versionManager.checkin(child1.getPath());
        versionManager.checkin(child2.getPath());
        Version v1 =  versionManager.checkin(testRoot.getPath());

        // reoder nodes
        versionManager.checkout(testRoot.getPath());
        testRoot.orderBefore(nodeName2, nodeName1);
        testRoot.getSession().save();
        versionManager.checkin(testRoot.getPath());

        // restore version 1.0
        versionManager.restore(new Version[] {v1}, true);

        // check order
        NodeIterator iter = testRoot.getNodes();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n1 = iter.nextNode();
        assertTrue(testRoot.getName() + " should have 2 child nodes.", iter.hasNext());
        Node n2 = iter.nextNode();
        String orderOk = nodeName1 + ", " + nodeName2;
        String order = n1.getName() + ", " + n2.getName();
        assertEquals("Invalid child node ordering", orderOk, order);
    }


    public void testAddDuplicateVersionLabel() throws RepositoryException {
        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        try {
            versionableNode.checkout();
            Version v = versionableNode.checkin();
            vHistory.addVersionLabel(v.getName(), versionLabel, false);

            fail("Adding a version label that already exist in the version history must throw a VersionException.");
        } catch (VersionException e) {
            //success
        }
    }


    public void testAddDuplicateVersionLabelJcr2() throws RepositoryException {
        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        try {
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkout(path);
            Version v = versionManager.checkin(path);
            vHistory.addVersionLabel(v.getName(), versionLabel, false);

            fail("Adding a version label that already exist in the version history must throw a VersionException.");
        } catch (VersionException e) {
            //success
        }
    }


    public void testMoveLabel() throws RepositoryException {
        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        try {
            versionableNode.checkout();
            Version v = versionableNode.checkin();
            vHistory.addVersionLabel(v.getName(), versionLabel, true);

            if (!vHistory.hasVersionLabel(v, versionLabel)) {
                fail("If 'moveLabel' is true, an existing version label must be moved to the indicated version.");
            }

        } catch (VersionException e) {
            fail("If 'moveLabel' is true, an existing version label must be moved to the indicated version.");
        }
    }


    public void testMoveLabelJcr2() throws RepositoryException {
        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        try {
            VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
            String path = versionableNode.getPath();
            versionManager.checkout(path);
            Version v = versionManager.checkin(path);
            vHistory.addVersionLabel(v.getName(), versionLabel, true);

            if (!vHistory.hasVersionLabel(v, versionLabel)) {
                fail("If 'moveLabel' is true, an existing version label must be moved to the indicated version.");
            }

        } catch (VersionException e) {
            fail("If 'moveLabel' is true, an existing version label must be moved to the indicated version.");
        }
    }


    public void testGetVersionLabels() throws RepositoryException {

        Set<String> testLabels = new HashSet<String>(Arrays.asList(vHistory.getVersionLabels()));
        versionableNode.checkout();
        Version v = versionableNode.checkin();

        vHistory.addVersionLabel(v.getName(), versionLabel, false);
        testLabels.add(versionLabel);
        vHistory.addVersionLabel(version.getName(), versionLabel2, false);
        testLabels.add(versionLabel2);

        String[] labels = vHistory.getVersionLabels();
        for (int i = 0; i < labels.length; i++) {
            String l = labels[i];
            if (!testLabels.contains(l)) {
                fail("VersionHistory.getVersionLabels() must only return labels, that have been added to the history.");
            }
            testLabels.remove(l);
        }

        assertTrue("VersionHistory.getVersionLabels() must return all labels, that have been added to the history.", testLabels.isEmpty());
    }


    public void testGetVersionLabelsJcr2() throws RepositoryException {

        Set<String> testLabels = new HashSet<String>(Arrays.asList(vHistory.getVersionLabels()));

        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        versionManager.checkout(path);
        Version v = versionManager.checkin(path);

        vHistory.addVersionLabel(v.getName(), versionLabel, false);
        testLabels.add(versionLabel);
        vHistory.addVersionLabel(version.getName(), versionLabel2, false);
        testLabels.add(versionLabel2);

        String[] labels = vHistory.getVersionLabels();
        for (int i = 0; i < labels.length; i++) {
            String l = labels[i];
            if (!testLabels.contains(l)) {
                fail("VersionHistory.getVersionLabels() must only return labels, that have been added to the history.");
            }
            testLabels.remove(l);
        }

        assertTrue("VersionHistory.getVersionLabels() must return all labels, that have been added to the history.", testLabels.isEmpty());
    }


    public void testGetVersionLabelsForVersion() throws RepositoryException {

        Set<String> testLabels = new HashSet<String>(Arrays.asList(vHistory.getVersionLabels(version)));

        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        testLabels.add(versionLabel);

        // add a version label to another version (not added to the testLabel set)
        versionableNode.checkout();
        Version v = versionableNode.checkin();
        vHistory.addVersionLabel(v.getName(), versionLabel2, false);

        String[] labels = vHistory.getVersionLabels(version);
        for (int i = 0; i < labels.length; i++) {
            String l = labels[i];
            if (!testLabels.contains(l)) {
                fail("VersionHistory.getVersionLabels(Version) must only return labels, that have been added for this version.");
            }
            testLabels.remove(l);
        }

        assertTrue("VersionHistory.getVersionLabels(Version)  must return all labels, that have been added for this version.", testLabels.isEmpty());
    }


    public void testGetVersionLabelsForVersionJcr2() throws RepositoryException {

        Set<String> testLabels = new HashSet<String>(Arrays.asList(vHistory.getVersionLabels(version)));

        vHistory.addVersionLabel(version.getName(), versionLabel, false);
        testLabels.add(versionLabel);

        // add a version label to another version (not added to the testLabel set)
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        versionManager.checkout(path);
        Version v = versionManager.checkin(path);
        vHistory.addVersionLabel(v.getName(), versionLabel2, false);

        String[] labels = vHistory.getVersionLabels(version);
        for (int i = 0; i < labels.length; i++) {
            String l = labels[i];
            if (!testLabels.contains(l)) {
                fail("VersionHistory.getVersionLabels(Version) must only return labels, that have been added for this version.");
            }
            testLabels.remove(l);
        }

        assertTrue("VersionHistory.getVersionLabels(Version)  must return all labels, that have been added for this version.", testLabels.isEmpty());
    }


    protected void tearDown() throws Exception {
        try {
            // remove all versionable nodes below the test
            versionableNode2.remove();
            wVersionableNode.remove();
            wVersionableNode2.remove();
            wTestRoot.save();
        } finally {
            if (wSuperuser != null) {
                wSuperuser.logout();
                wSuperuser = null;
            }
            version = null;
            version2 = null;
            rootVersion = null;
            versionableNode2 = null;
            wTestRoot = null;
            wVersionableNode = null;
            wVersionableNode2 = null;
            wVersionableChildNode = null;
            wChildVersion = null;
            super.tearDown();
        }
    }


    protected void tearDown() throws Exception {
        try {
            superuser.refresh(false);
            node.checkout();
        } finally {
            if (session != null) {
                session.logout();
                session = null;
            }
            node = null;
            property = null;
            multiProperty = null;
            initialValue = null;
            initialValues = null;
            modifiedValue = null;
            modifiedValues = null;
            super.tearDown();
        }
    }


    public void testWorkspaceRestoreWithRemoveExisting() throws NotExecutableException, RepositoryException {
        // create version for parentNode of childNode
        superuser.getWorkspace().clone(workspaceName, wVersionableChildNode.getPath(), wVersionableChildNode.getPath(), false);
        Version parentV = versionableNode.checkin();

        // move child node in order to produce the uuid conflict
        String newChildPath = wVersionableNode2.getPath() + "/" + wVersionableChildNode.getName();
        wSuperuser.move(wVersionableChildNode.getPath(), newChildPath);
        wSuperuser.save();

        // restore the parent with removeExisting == true >> moved child node
        // must be removed.
        wSuperuser.getWorkspace().restore(new Version[]{parentV}, true);
        if (wSuperuser.itemExists(newChildPath)) {
            fail("Workspace.restore(Version[], boolean) with the boolean flag set to true, must remove the existing node in case of Uuid conflict.");
        }
    }


    public void testWorkspaceRestoreWithRemoveExistingJcr2() throws NotExecutableException, RepositoryException {
        // create version for parentNode of childNode
        superuser.getWorkspace().clone(workspaceName, wVersionableChildNode.getPath(), wVersionableChildNode.getPath(), false);
        Version parentV = versionableNode.getSession().getWorkspace().getVersionManager().checkin(versionableNode.getPath());

        // move child node in order to produce the uuid conflict
        String newChildPath = wVersionableNode2.getPath() + "/" + wVersionableChildNode.getName();
        wSuperuser.move(wVersionableChildNode.getPath(), newChildPath);
        wSuperuser.save();

        // restore the parent with removeExisting == true >> moved child node
        // must be removed.
        wSuperuser.getWorkspace().getVersionManager().restore(new Version[]{parentV}, true);
        if (wSuperuser.itemExists(newChildPath)) {
            fail("Workspace.restore(Version[], boolean) with the boolean flag set to true, must remove the existing node in case of Uuid conflict.");
        }
    }


    public void testMergeNodeVersionAmbiguousJcr2() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);

        // "merge" the clonedNode with the newNode from the default workspace
        // besteffort set to false to stop at the first failure
        try {
            vmWsp2.checkout(path);
            vmWsp2.merge(path, workspace.getName(), false);
            fail("Node has ambigous versions. Merge must throw a MergeException");
        } catch (MergeException e) {
            // success if the merge exception thrown
        }
    }


    public void testMergeNodeBestEffortFalseAmbiguousVersionsJcr2() throws RepositoryException {
        /// create 2 independent base versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);

        // "merge" the clonedNode with the newNode from the default workspace
        vmWsp2.checkout(path);

        // merge, besteffort set to false
        try {
            vmWsp2.merge(path, workspace.getName(), false);
            fail("BestEffort is false and corresponding node's version is ambiguous. Merge should throw a MergeException.");
        } catch (MergeException e) {
            // successful
        }
    }


    public void disable_testMergeNodeForceFailureJcr2() throws RepositoryException {
        // create 2 independent versions for a node and its corresponding node
        // so merge fails for this node

        // default workspace
        Node originalNode = testRootNode.getNode(nodeName1);
        VersionManager vmWsp1 = originalNode.getSession().getWorkspace().getVersionManager();
        String originalPath = originalNode.getPath();
        vmWsp1.checkout(originalPath);
        vmWsp1.checkin(originalPath);

        // second workspace
        VersionManager vmWsp2 = nodeToMerge.getSession().getWorkspace().getVersionManager();
        String path = nodeToMerge.getPath();
        vmWsp2.checkin(path);

        // "merge" the clonedNode with the newNode from the default workspace
        // besteffort set to true to report all failures
        vmWsp2.checkout(path);
        vmWsp2.merge(path, workspace.getName(), true);

        try {
            vmWsp2.merge(path, workspace.getName(), true);
            fail("Merge failed for node in earlier merge operations. Because the mergeFailedProperty is present, merge must throw a VersionException");
        } catch (VersionException e) {
            // success version exception expected
        }
    }


    public void disable_testMergeLocked()
            throws NotExecutableException, RepositoryException {

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // try to make nodeToMerge lockable if it is not
        ensureMixinType(nodeToMerge, mixLockable);
        nodeToMerge.getParent().save();

        // lock the node
        // remove first slash of path to get rel path to root
        String pathRelToRoot = nodeToMerge.getPath().substring(1);
        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.lock(false, false);

            try {
                nodeToMerge.merge(workspace.getName(), false);
                fail("merge must throw a LockException if applied on a " +
                        "locked node");
            } catch (LockException e) {
                // success
            }

            node2.unlock();
        } finally {
            session2.logout();
        }
    }


    public void disable_testMergeLockedJcr2()
            throws NotExecutableException, RepositoryException {

        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Locking is not supported.");
        }

        // try to make nodeToMerge lockable if it is not
        ensureMixinType(nodeToMerge, mixLockable);
        nodeToMerge.getParent().getSession().save();

        // lock the node
        // remove first slash of path to get rel path to root
        String pathRelToRoot = nodeToMerge.getPath().substring(1);
        // access node through another session to lock it
        Session session2 = getHelper().getSuperuserSession();
        try {
            Node node2 = session2.getRootNode().getNode(pathRelToRoot);
            node2.getSession().getWorkspace().getLockManager().lock(node2.getPath(), false, false, 60, "");

            try {
                nodeToMerge.getSession().getWorkspace().getVersionManager().merge(
                        nodeToMerge.getPath(), workspace.getName(), false);
                fail("merge must throw a LockException if applied on a " +
                        "locked node");
            } catch (LockException e) {
                // success
            }

            node2.getSession().getWorkspace().getLockManager().unlock(node2.getPath());
        } finally {
            session2.logout();
        }
    }


    public void testNodeIterator() throws RepositoryException {

        Node nodeToMerge = testRootNodeW2.getNode(nodeName1);

        NodeIterator failedNodes1 = nodeToMerge.merge(workspace.getName(), true);

        List<Node> nodeList = new ArrayList<Node>();
        while (failedNodes1.hasNext()) {
            nodeList.add(failedNodes1.nextNode());
        }

        assertEquals("Node.merge() does not return a NodeIterator with " +
                "expected number of elements.",
                expectedFailedNodes.length,
                nodeList.size());

        // re-aquire iterator, has been consumed to get size
        Iterator<Node> failedNodes2 = nodeList.iterator();
        compareReturnedWithExpected:
        while (failedNodes2.hasNext()) {
            String path = failedNodes2.next().getPath();
            for (int i = 0; i < expectedFailedNodes.length; i++) {
                if (expectedFailedNodes[i] != null) {
                    String expectedPath = expectedFailedNodes[i].getPath();
                    if (path.equals(expectedPath)) {
                        // to assure every failed node appears only once in the
                        // NodeIterator, set each found expected node to null
                        expectedFailedNodes[i] = null;
                        continue compareReturnedWithExpected;
                    }
                }
            }
            fail("Node.merge() must return a NodeIterator over all " +
                    "nodes that did receive a result of fail.");
        }
    }


    public void testNodeIteratorJcr2() throws RepositoryException {

        Node nodeToMerge = testRootNodeW2.getNode(nodeName1);

        NodeIterator failedNodes1 = nodeToMerge.getSession().getWorkspace().getVersionManager().merge(
                nodeToMerge.getPath(), workspace.getName(), true);

        List<Node> nodeList = new ArrayList<Node>();
        while (failedNodes1.hasNext()) {
            nodeList.add(failedNodes1.nextNode());
        }

        assertEquals("Node.merge() does not return a NodeIterator with " +
                "expected number of elements.",
                expectedFailedNodes.length,
                nodeList.size());

        // re-aquire iterator, has been consumed to get size
        Iterator<Node> failedNodes2 = nodeList.iterator();
        compareReturnedWithExpected:
        while (failedNodes2.hasNext()) {
            String path = failedNodes2.next().getPath();
            for (int i = 0; i < expectedFailedNodes.length; i++) {
                if (expectedFailedNodes[i] != null) {
                    String expectedPath = expectedFailedNodes[i].getPath();
                    if (path.equals(expectedPath)) {
                        // to assure every failed node appears only once in the
                        // NodeIterator, set each found expected node to null
                        expectedFailedNodes[i] = null;
                        continue compareReturnedWithExpected;
                    }
                }
            }
            fail("Node.merge() must return a NodeIterator over all " +
                    "nodes that did receive a result of fail.");
        }
    }


    public void testRestoreBaseline() throws Exception {
        // create configuration
        String path = versionableNode.getPath();
        Version bv1 = vm.checkpoint(path);
        Node config = vm.createConfiguration(path);
        // record baseline 1 (should contain bv1)
        Version bl1 = vm.checkpoint(config.getPath());
        // create bv2
        Version bv2 = vm.checkpoint(path);
        // record baseline 2 (should contain bv2)
        Version bl2 = vm.checkpoint(config.getPath());

        // restore bl1
        vm.restore(bl1, true);
        Version bv = vm.getBaseVersion(path);
        assertTrue("restored node must have former base version V1.0.", bv.isSame(bv1));

        // restore bl2
        vm.restore(bl2, true);
        bv = vm.getBaseVersion(path);
        assertTrue("restored node must have former base version V1.1.", bv.isSame(bv2));
    }


    public void testRestoreConfig() throws Exception {
        // create configuration
        String path = versionableNode.getPath();
        Version bv1 = vm.checkpoint(path);
        Node config = vm.createConfiguration(path);
        String configPath = config.getPath();

        // record baseline 1 (should contain bv1)
        Version bl1 = vm.checkpoint(config.getPath());
        // create bv2
        Version bv2 = vm.checkpoint(path);
        // record baseline 2 (should contain bv2)
        Version bl2 = vm.checkpoint(config.getPath());

        // restore bl1
        vm.restore(configPath, bl1.getName(), true);
        Version bv = vm.getBaseVersion(path);
        assertTrue("restored node must have former base version V1.0.", bv.isSame(bv1));

        // restore bl2
        vm.restore(configPath, bl2.getName(), true);
        bv = vm.getBaseVersion(path);
        assertTrue("restored node must have former base version V1.1.", bv.isSame(bv2));
    }


    public void testFrozenChildNodeUUUID() throws RepositoryException {
        versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String puuid = n.getProperty(jcrUUID).getValue().getString();
        String nuuid = n.getIdentifier();
        assertEquals("jcr:uuid needs to be equal to the getIdentifier() return value.", nuuid, puuid);
    }


    public void testFrozenChildNodeNodeType() throws RepositoryException {
        versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String puuid = n.getProperty(jcrPrimaryType).getValue().getString();
        String nuuid = n.getPrimaryNodeType().getName();
        assertEquals("jcr:primaryType needs to be equal to the getPrimaryNodeType() return value.", nuuid, puuid);
    }


    public void testFrozenChildNodeNodeType() throws RepositoryException {
        versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String puuid = n.getProperty(jcrPrimaryType).getValue().getString();
        String nuuid = n.getPrimaryNodeType().getName();
        assertEquals("jcr:primaryType needs to be equal to the getPrimaryNodeType() return value.", nuuid, puuid);
    }


    public void testFrozenChildNodeUUUID() throws RepositoryException {
        versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String puuid = n.getProperty(jcrUUID).getValue().getString();
        String nuuid = n.getIdentifier();
        assertEquals("jcr:uuid needs to be equal to the getIdentifier() return value.", nuuid, puuid);
    }


    public void testFrozenChildNodeType() throws RepositoryException {
        Node n1 = versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String fuuid = n.getProperty("jcr:frozenPrimaryType").getValue().getString();
        String ruuid = n1.getPrimaryNodeType().getName();
        assertEquals("jcr:frozenPrimaryType needs to be equal to the getPrimaryNodeType() return value.", ruuid, fuuid);
    }


    public void testFrozenChildNodeType() throws RepositoryException {
        Node n1 = versionableNode.addNode("child");
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String fuuid = n.getProperty("jcr:frozenPrimaryType").getValue().getString();
        String ruuid = n1.getPrimaryNodeType().getName();
        assertEquals("jcr:frozenPrimaryType needs to be equal to the getPrimaryNodeType() return value.", ruuid, fuuid);
    }


    public void testFrozenUUUID() throws RepositoryException,
            NotExecutableException {
        // make versionable node referenceable
        ensureMixinType(versionableNode, mixReferenceable);
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode();
        String fuuid = n.getProperty(jcrFrozenUuid).getValue().getString();
        String ruuid = versionableNode.getIdentifier();
        assertEquals("jcr:frozenUuid needs to be equal to the getIdentifier() return value.", ruuid, fuuid);
    }


    public void testFrozenChildUUUID() throws RepositoryException,
            NotExecutableException {
        Node n1 = versionableNode.addNode("child");
        ensureMixinType(n1, mixReferenceable);
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String fuuid = n.getProperty(jcrFrozenUuid).getValue().getString();
        String ruuid = n1.getIdentifier();
        assertEquals("jcr:frozenUuid needs to be equal to the getIdentifier() return value.", ruuid, fuuid);
    }


    public void testFrozenChildUUUID() throws RepositoryException,
            NotExecutableException {
        Node n1 = versionableNode.addNode("child");
        ensureMixinType(n1, mixReferenceable);
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode().getNode("child");
        String fuuid = n.getProperty(jcrFrozenUuid).getValue().getString();
        String ruuid = n1.getIdentifier();
        assertEquals("jcr:frozenUuid needs to be equal to the getIdentifier() return value.", ruuid, fuuid);
    }


    public void testFrozenUUUID() throws RepositoryException,
            NotExecutableException {
        // make versionable node referenceable
        ensureMixinType(versionableNode, mixReferenceable);
        versionableNode.getSession().save();
        VersionManager versionManager = versionableNode.getSession().getWorkspace().getVersionManager();
        String path = versionableNode.getPath();
        Version v = versionManager.checkin(path);
        Node n = v.getFrozenNode();
        String fuuid = n.getProperty(jcrFrozenUuid).getValue().getString();
        String ruuid = versionableNode.getIdentifier();
        assertEquals("jcr:frozenUuid needs to be equal to the getIdentifier() return value.", ruuid, fuuid);
    }


    public void testLinearVersions() throws Exception {
        // first get all linear versions
        VersionIterator iter = versionableNode.getVersionHistory().getAllLinearVersions();
        StringBuffer expected = new StringBuffer();
        while (iter.hasNext()) {
            expected.append(iter.nextVersion().getName()).append(",");
        }
        // restore version
        versionableNode.restore(version, true);
        // append new base version
        expected.append(versionableNode.getBaseVersion().getName()).append(",");

        // get the version names again
        iter = versionableNode.getVersionHistory().getAllLinearVersions();
        StringBuffer actual = new StringBuffer();
        while (iter.hasNext()) {
            actual.append(iter.nextVersion().getName()).append(",");
        }
        assertEquals("Node.restore() on simple versioning must create a new version.",
                expected.toString(), actual.toString());
    }


    public void testLinearVersionsJcr2_3() throws Exception {
        // first get all linear versions
        VersionIterator iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer expected = new StringBuffer();
        while (iter.hasNext()) {
            expected.append(iter.nextVersion().getName()).append(",");
        }
        // restore version
        versionManager.restore(versionableNode.getPath(), version.getName(), true);
        // append new base version
        expected.append(versionManager.getBaseVersion(versionableNode.getPath()).getName()).append(",");

        // get the version names again
        iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer actual = new StringBuffer();
        while (iter.hasNext()) {
            actual.append(iter.nextVersion().getName()).append(",");
        }
        assertEquals("Node.restore() on simple versioning must create a new version.",
                expected.toString(), actual.toString());
    }


    public void testLinearVersionsJcr2_2() throws Exception {
        // first get all linear versions
        VersionIterator iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer expected = new StringBuffer();
        while (iter.hasNext()) {
            expected.append(iter.nextVersion().getName()).append(",");
        }
        // restore version
        versionManager.restore(version, true);
        // append new base version
        expected.append(versionManager.getBaseVersion(versionableNode.getPath()).getName()).append(",");

        // get the version names again
        iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer actual = new StringBuffer();
        while (iter.hasNext()) {
            actual.append(iter.nextVersion().getName()).append(",");
        }
        assertEquals("Node.restore() on simple versioning must create a new version.",
                expected.toString(), actual.toString());
    }


    public void testLinearVersionsJcr2() throws Exception {
        // first get all linear versions
        VersionIterator iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer expected = new StringBuffer();
        while (iter.hasNext()) {
            expected.append(iter.nextVersion().getName()).append(",");
        }
        // restore version
        versionManager.restore(version, true);
        // append new base version
        expected.append(versionManager.getBaseVersion(versionableNode.getPath()).getName()).append(",");

        // get the version names again
        iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer actual = new StringBuffer();
        while (iter.hasNext()) {
            actual.append(iter.nextVersion().getName()).append(",");
        }
        assertEquals("Node.restore() on simple versioning must create a new version.",
                expected.toString(), actual.toString());
    }


    public void testLinearVersionsJcr2_4() throws Exception {
        // first get all linear versions
        VersionIterator iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer expected = new StringBuffer();
        while (iter.hasNext()) {
            expected.append(iter.nextVersion().getName()).append(",");
        }
        // restore version
        versionManager.restore(new Version[] {version}, true);
        // append new base version
        expected.append(versionManager.getBaseVersion(versionableNode.getPath()).getName()).append(",");

        // get the version names again
        iter = versionManager.getVersionHistory(versionableNode.getPath()).getAllLinearVersions();
        StringBuffer actual = new StringBuffer();
        while (iter.hasNext()) {
            actual.append(iter.nextVersion().getName()).append(",");
        }
        assertEquals("Node.restore() on simple versioning must create a new version.",
                expected.toString(), actual.toString());
    }


    public void testGetNode() throws RepositoryException {
        if (!multiple) {
            String path = prop.getString();
            if (prop.getParent().hasNode(path)) {
                Node n = prop.getNode();
                assertEquals("The name of the dereferenced property must be equal to the value", path, n.getName());
            } else {
                try {
                    prop.getNode();
                    fail("Calling Property.getNode() for a NAME value that doesn't have a corresponding Node, ItemNotFoundException is expected");
                } catch (ItemNotFoundException e) {
                    // success.
                }
            }
        } else {
            try {
                prop.getNode();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                //ok
            }
        }
    }


    public void testGetProperty() throws RepositoryException {
        if (!multiple) {
            String path = prop.getString();
            if (prop.getParent().hasProperty(path)) {
                Property p = prop.getProperty();
                assertEquals("The name of the dereferenced property must be equal to the value", path, p.getName());
            } else {
                try {
                    prop.getProperty();
                    fail("Calling Property.getProperty() for a NAME value that doesn't have a corresponding Node, ItemNotFoundException is expected");
                } catch (ItemNotFoundException e) {
                    // success.
                }
            }
        } else {
            try {
                prop.getProperty();
                fail("Property.getNode() called on a multivalue property " +
                        "should throw a ValueFormatException.");
            } catch (ValueFormatException vfe) {
                // ok
            }
        }
    }


    public void testInputStream()
        throws NotExecutableException, RepositoryException {

        Property dateProperty = createProperty(PropertyType.DATE, false);
        try {
            byte[] bytes = {123};
            InputStream value = new ByteArrayInputStream(bytes);
            dateProperty.setValue(value);
            fail("Property.setValue(InputStream) must throw a ValueFormatException " +
                    "immediately if a conversion fails.");
        } catch (ValueFormatException e) {
            // success
        }
    }


    public void testInputStream() throws RepositoryException {
        try {
            byte[] bytes = {123};
            InputStream value = new ByteArrayInputStream(bytes);
            property.setValue(value);
            node.save();
            fail("Property.setValue(InputStream) must throw a VersionException " +
                 "immediately or on save if the parent node of this property " +
                 "is checked-in.");
        }
        catch (VersionException e) {
            // success
        }
    }


    public void testSameStream() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        InputStream in = val.getStream();
        InputStream in2 = val.getStream();
        Value otherVal = PropertyUtil.getValue(prop);
        InputStream in3 = otherVal.getStream();
        try {
            assertSame("Same InputStream object expected when " +
                    "Value.getStream is called twice.", in, in2);
            assertNotSame("Value.getStream() called on a new value " +
                    "object should return a different Stream object.", in, in3);
        } finally {
            // cleaning up
            try {
                in.close();
            } catch (IOException ignore) {}
            if (in2 != in) {
                try {
                    in2.close();
                } catch (IOException ignore) {}
            }
            if (in3 != in) {
                try {
                    in3.close();
                } catch (IOException ignore) {}
            }
        }
    }


    public void testSameStreamJcr2() throws RepositoryException, IOException {
        Value val = PropertyUtil.getValue(prop);
        Binary bin = val.getBinary();
        try {
            InputStream in = bin.getStream();
            InputStream in2 = bin.getStream();
            try {
                assertNotSame("Value.getStream() called on a new value " +
                        "object should return a different Stream object.", in, in2);
                //check if both streams can be read independently but contain the same bytes
                int n,n2;
                while ((n = in.read()) != -1) {
                    n2 = in2.read();
                    assertEquals("streams from the same binary object should have identical content", n, n2);
                }
                assertEquals("streams from the same binary object should have identical content", -1, in2.read());
            } finally {
                // cleaning up
                try {
                    in.close();
                } catch (IOException ignore) {}
                if (in2 != in) {
                    try {
                        in2.close();
                    } catch (IOException ignore) {}
                }
            }
        } finally {
            bin.dispose();
        }
    }


    public void testValueJcr2() throws IOException, RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        InputStream in = val.getStream();
        Binary bin = val.getBinary();
        try {
            InputStream in2 = bin.getStream();
            try {
                int b = in.read();
                while (b != -1) {
                    int b2 = in2.read();
                    assertEquals("Value.getStream() and Value.getBinary().getStream() " +
                            "return different values.", b, b2);
                    b = in.read();
                }
                assertEquals("Value.getStream() and Value.getBinary().getStream() " +
                        "return different values.", -1, in2.read());
            } finally {
                try {
                    in.close();
                } catch (IOException ignore) {}
                try {
                    in2.close();
                } catch (IOException ignore) {}
            }
        } finally {
            bin.dispose();
        }
    }


    public void testValue() throws IOException, RepositoryException {
        Value val = PropertyUtil.getValue(prop);
        InputStream in = val.getStream();
        InputStream in2;
        if (prop.getDefinition().isMultiple()) {
            // prop has at least one value (checked in #setUp())
            in2 = prop.getValues()[0].getStream();
        } else {
            in2 = prop.getStream();
        }
        try {
            int b = in.read();
            while (b != -1) {
                int b2 = in2.read();
                assertEquals("Value.getStream() and Property.getStream() " +
                        "return different values.", b, b2);
                b = in.read();
            }
            assertEquals("Value.getStream() and Property.getStream() " +
                    "return different values.", -1, in2.read());
        } finally {
            try {
                in.close();
            } catch (IOException ignore) {}
            try {
                in2.close();
            } catch (IOException ignore) {}
        }
    }


    public void testCloneNodesLocked()
            throws RepositoryException, NotExecutableException {
        // we assume repository supports locking
        String dstAbsPath = node2W2.getPath() + "/" + node1.getName();

        // get lock target node in destination wsp through other session
        Node lockTarget = (Node) rwSessionW2.getItem(node2W2.getPath());

        // add mixin "lockable" to be able to lock the node
        ensureMixinType(lockTarget, mixLockable);
        lockTarget.getParent().save();

        // lock dst parent node using other session
        lockTarget.lock(true, true);

        try {
            workspaceW2.clone(workspace.getName(), node1.getPath(), dstAbsPath, true);
            fail("LockException was expected.");
        } catch (LockException e) {
            // successful
        } finally {
            lockTarget.unlock();
        }
    }


    public void testCopyNodesLocked() throws RepositoryException, NotExecutableException {
        if (!isSupported(Repository.OPTION_LOCKING_SUPPORTED)) {
            throw new NotExecutableException("Repository does not support locking.");
        }
        // we assume repository supports locking
        String dstAbsPath = node2W2.getPath() + "/" + node1.getName();

        // get lock target node in destination wsp through other session
        Node lockTarget = (Node) rwSessionW2.getItem(node2W2.getPath());

        // add mixin "lockable" to be able to lock the node
        ensureMixinType(lockTarget, mixLockable);
        lockTarget.getParent().save();

        // lock dst parent node using other session
        lockTarget.lock(true, true);

        try {
            workspaceW2.copy(workspace.getName(), node1.getPath(), dstAbsPath);
            fail("LockException was expected.");
        } catch (LockException e) {
            // successful
        } finally {
            lockTarget.unlock();
        }
    }


    public void testValue() throws NotExecutableException, RepositoryException {

        setUpNodeWithUndefinedProperty(false);

        Property prop;

        prop = testNode.setProperty(testPropName, binaryValue, PropertyType.BINARY);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.BINARY,
                     prop.getType());

        prop = testNode.setProperty(testPropName, stringValue, PropertyType.BOOLEAN);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.BOOLEAN,
                     prop.getType());

        prop = testNode.setProperty(testPropName, doubleValue, PropertyType.DATE);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.DATE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValue, PropertyType.DOUBLE);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.DOUBLE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValue, PropertyType.LONG);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.LONG,
                     prop.getType());

        // create a PathValue that is convertible to the value of name property
        Value valueConvertibleToName = superuser.getValueFactory().createValue(nameValue.getString(), PropertyType.PATH);
        prop = testNode.setProperty(testPropName, valueConvertibleToName, PropertyType.NAME);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.NAME,
                     prop.getType());

        prop = testNode.setProperty(testPropName, nameValue, PropertyType.PATH);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.PATH,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValue, PropertyType.STRING);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.STRING,
                     prop.getType());
    }


    public void testValues() throws NotExecutableException, RepositoryException {

        setUpNodeWithUndefinedProperty(true);

        Property prop;

        prop = testNode.setProperty(testPropName, binaryValues, PropertyType.BINARY);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.BINARY,
                     prop.getType());

        prop = testNode.setProperty(testPropName, stringValues, PropertyType.BOOLEAN);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.BOOLEAN,
                     prop.getType());

        prop = testNode.setProperty(testPropName, doubleValues, PropertyType.DATE);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.DATE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValues, PropertyType.DOUBLE);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.DOUBLE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValues, PropertyType.LONG);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.LONG,
                     prop.getType());

        // create a PathValue that is convertible to the value of name property
        Value valuesConvertibleToName[] =
            new Value[] {superuser.getValueFactory().createValue(nameValue.getString(), PropertyType.PATH)};
        prop = testNode.setProperty(testPropName, valuesConvertibleToName, PropertyType.NAME);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.NAME,
                     prop.getType());

        prop = testNode.setProperty(testPropName, nameValues, PropertyType.PATH);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.PATH,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValues, PropertyType.STRING);
        assertEquals("setProperty(String, Value, int) of a property of type undefined " +
                     "must assume the property type of the type parameter.",
                     PropertyType.STRING,
                     prop.getType());
    }


    public void testValueAssumeTypeOfValue() throws NotExecutableException, RepositoryException {

        setUpNodeWithUndefinedProperty(false);

        Property prop;

        prop = testNode.setProperty(testPropName, binaryValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.BINARY,
                     prop.getType());

        prop = testNode.setProperty(testPropName, booleanValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.BOOLEAN,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.DATE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, doubleValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.DOUBLE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, longValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.LONG,
                     prop.getType());

        prop = testNode.setProperty(testPropName, nameValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.NAME,
                     prop.getType());

        prop = testNode.setProperty(testPropName, pathValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.PATH,
                     prop.getType());

        prop = testNode.setProperty(testPropName, stringValue);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.STRING,
                     prop.getType());
    }


    public void testValuesAssumeTypeOfValue() throws NotExecutableException, RepositoryException {

        setUpNodeWithUndefinedProperty(true);

        Property prop;

        prop = testNode.setProperty(testPropName, binaryValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.BINARY,
                     prop.getType());

        prop = testNode.setProperty(testPropName, booleanValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.BOOLEAN,
                     prop.getType());

        prop = testNode.setProperty(testPropName, dateValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.DATE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, doubleValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.DOUBLE,
                     prop.getType());

        prop = testNode.setProperty(testPropName, longValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.LONG,
                     prop.getType());

        prop = testNode.setProperty(testPropName, nameValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.NAME,
                     prop.getType());

        prop = testNode.setProperty(testPropName, pathValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.PATH,
                     prop.getType());

        prop = testNode.setProperty(testPropName, stringValues);
        assertEquals("setProperty(String, Value) of a property of type undefined " +
                     "must assume the property type of the supplied value object.",
                     PropertyType.STRING,
                     prop.getType());
    }


    public void testValueConstraintViolationExceptionBecauseOfInvalidTypeParameter()
        throws NotExecutableException, RepositoryException {

        try {
            Calendar cal = Calendar.getInstance();
            cal.setTime(new Date(0));
            Value v = superuser.getValueFactory().createValue(ISO8601.format(cal));
            testNode.setProperty(propertyName1, v, PropertyType.DATE);
            testRootNode.getSession().save();
            fail("Node.setProperty(String, Value, int) must throw a " +
                 "ConstraintViolationExcpetion if the type parameter and the " +
                 "type of the property do not match." );
        }
        catch (ConstraintViolationException e) {
            // success
        }
    }


    public void testStringConstraintViolationExceptionBecauseOfInvalidTypeParameter()
        throws NotExecutableException, RepositoryException {

        try {
            Calendar cal = Calendar.getInstance();
            cal.setTime(new Date(0));
            testNode.setProperty(propertyName1, ISO8601.format(cal), PropertyType.DATE);
            testRootNode.getSession().save();
            fail("Node.setProperty(String, Value, int) must throw a " +
                 "ConstraintViolationExcpetion if the type parameter and the " +
                 "type of the property do not match." );
        }
        catch (ConstraintViolationException e) {
            // success
        }
    }


    public static Property searchProp(Session session, Node node, int type, Boolean multiple)
            throws RepositoryException, ValueFormatException {

        Property prop = null;
        int propType = PropertyType.UNDEFINED;
        if (prop == null) {
            for (PropertyIterator props = node.getProperties(); props.hasNext();) {
                Property property = props.nextProperty();
                propType = property.getType();
                if (propType == type && (multiple == null || multiple.booleanValue() == property.getDefinition().isMultiple())) {
                    prop = property;
                    break;
                }
            }
        }
        if (prop == null) {
            for (NodeIterator nodes = node.getNodes(); nodes.hasNext();) {
                Node n = nodes.nextNode();
                prop = searchProp(session, n, type, multiple);
                if (prop != null) {
                    break;
                }
            }
        }
        return prop;
    }


    public static Property searchMultivalProp(Node node, int type) throws RepositoryException {
        Property multiVal = null;
        for (PropertyIterator props = node.getProperties(); props.hasNext();) {
            Property property = props.nextProperty();
            if (property.getDefinition().isMultiple()
                    && property.getType() == type) {
                multiVal = property;
                break;
            }
        }

        if (multiVal == null) {
            for (NodeIterator nodes = node.getNodes(); nodes.hasNext();) {
                Node n = nodes.nextNode();
                multiVal = searchMultivalProp(n, type);
                if (multiVal != null) {
                    break;
                }
            }
        }
        return multiVal;
    }


    public static Property searchMultivalProp(Node node) throws RepositoryException {
        Property multiVal = null;
        for (PropertyIterator props = node.getProperties(); props.hasNext();) {
            Property property = props.nextProperty();
            if (property.getDefinition().isMultiple()) {
                multiVal = property;
                break;
            }
        }

        if (multiVal == null) {
            for (NodeIterator nodes = node.getNodes(); nodes.hasNext();) {
                Node n = nodes.nextNode();
                multiVal = searchMultivalProp(n);
                if (multiVal != null) {
                    break;
                }
            }
        }
        return multiVal;
    }


    public void testNewInputStreamPropertySession() throws Exception {
        testNode.setProperty(propertyName1, is1);
        superuser.save();
        is1 = new ByteArrayInputStream(bytes1);
        InputStream in = testNode.getProperty(propertyName1).getStream();
        try {
            assertTrue("Setting property with Node.setProperty(String, InputStream) and Session.save() not working",
                    compareInputStreams(is1, in));
        } finally {
            try { in.close(); } catch (IOException ignore) {}
         }
    }


    public void testModifyInputStreamPropertyParent() throws Exception {
        testNode.setProperty(propertyName1, is1);
        testRootNode.getSession().save();
        testNode.setProperty(propertyName1, is2);
        testRootNode.getSession().save();
        is2 = new ByteArrayInputStream(bytes2);
        InputStream in = testNode.getProperty(propertyName1).getStream();
        try {
            assertTrue("Modifying property with Node.setProperty(String, InputStream) and parentNode.save() not working",
                    compareInputStreams(is2, in));
        } finally {
            try { in.close(); } catch (IOException ignore) {}
         }
    }


    public void testNewInputStreamPropertyParent() throws Exception {
        testNode.setProperty(propertyName1, is1);
        testRootNode.getSession().save();
        is1 = new ByteArrayInputStream(bytes1);
        InputStream in = testNode.getProperty(propertyName1).getStream();
        try {
            assertTrue("Setting property with Node.setProperty(String, InputStream) and parentNode.save() not working",
                    compareInputStreams(is1, in));
        } finally {
            try { in.close(); } catch (IOException ignore) {}
        }
    }


    public void testModifyInputStreamPropertySession() throws Exception {
        testNode.setProperty(propertyName1, is1);
        superuser.save();
        testNode.setProperty(propertyName1, is2);
        superuser.save();
        is2 = new ByteArrayInputStream(bytes2);
        InputStream in = testNode.getProperty(propertyName1).getStream();
        try {
            assertTrue("Modifying property with Node.setProperty(String, InputStream) and Session.save() not working",
                    compareInputStreams(is2, in));
        } finally {
            try { in.close(); } catch (IOException ignore) {}
         }
    }


    public void testRemoveInputStreamPropertySession() throws Exception {
        testNode.setProperty(propertyName1, is1);
        superuser.save();

        Property property = testNode.getProperty(propertyName1);
        if (property.getDefinition().isMandatory() || property.getDefinition().isProtected()) {
            throw new NotExecutableException("property " + property.getName() + " can not be removed");
        }

        testNode.setProperty(propertyName1, (InputStream) null);
        superuser.save();
        assertFalse("Removing property with Node.setProperty(String, (InputStream)null) and Session.save() not working",
                testNode.hasProperty(propertyName1));
    }


    public void testRemoveInputStreamPropertyParent() throws Exception {
        testNode.setProperty(propertyName1, is1);
        testRootNode.getSession().save();

        Property property = testNode.getProperty(propertyName1);
        if (property.getDefinition().isMandatory() || property.getDefinition().isProtected()) {
            throw new NotExecutableException("property " + property.getName() + " can not be removed");
        }

        testNode.setProperty(propertyName1, (InputStream) null);
        testRootNode.getSession().save();
        assertFalse("Removing property with Node.setProperty(String, (InputStream)null) and parentNode.save() not working",
                testNode.hasProperty(propertyName1));
    }


    public void testSingleValue() throws RepositoryException {
        Value weakRef = vf.createValue(target, true);
        referring.setProperty(propertyName1, weakRef);
        superuser.save();

        PropertyIterator it = target.getWeakReferences();
        assertTrue("no weak references returned", it.hasNext());
        Property p = it.nextProperty();
        assertEquals("wrong weak reference property", referring.getProperty(propertyName1).getPath(), p.getPath());
        assertFalse("no more weak references expected", it.hasNext());
    }


    public void testSingleValueWithName() throws RepositoryException {
        Value weakRef = vf.createValue(target, true);
        referring.setProperty(propertyName1, weakRef);
        superuser.save();

        PropertyIterator it = target.getWeakReferences(propertyName1);
        assertTrue("no weak references returned", it.hasNext());
        Property p = it.nextProperty();
        assertEquals("wrong weak reference property", referring.getProperty(propertyName1).getPath(), p.getPath());
        assertFalse("no more weak references expected", it.hasNext());
    }


    public void testMultiValuesWithName() throws RepositoryException {
        Value weakRef = vf.createValue(target, true);
        Value[] refs = new Value[]{weakRef, weakRef};
        referring.setProperty(propertyName1, refs);
        superuser.save();

        PropertyIterator it = target.getWeakReferences(propertyName1);
        assertTrue("no weak references returned", it.hasNext());
        Property p = it.nextProperty();
        assertEquals("wrong weak reference property", referring.getProperty(propertyName1).getPath(), p.getPath());
        assertFalse("no more weak references expected", it.hasNext());
    }


    public void testMultiValues() throws RepositoryException {
        Value weakRef = vf.createValue(target, true);
        Value[] refs = new Value[]{weakRef, weakRef};
        referring.setProperty(propertyName1, refs);
        superuser.save();

        PropertyIterator it = target.getWeakReferences();
        assertTrue("no weak references returned", it.hasNext());
        Property p = it.nextProperty();
        assertEquals("wrong weak reference property", referring.getProperty(propertyName1).getPath(), p.getPath());
        assertFalse("no more weak references expected", it.hasNext());
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.NAME, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No name property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No name property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.BINARY, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No binary property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.STRING, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No string property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No string property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.DOUBLE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No double property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.LONG, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No long property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.PATH, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No path property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No path property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.BOOLEAN, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No boolean property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfied()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.DATE, false, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No date property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();

        assertFalse("canSetProperty(String propertyName, Value value) must " +
                "return false if value does not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), value));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.NAME, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple name property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple name property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.STRING, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple string property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple string property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.PATH, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple path property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple path property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.LONG, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple long property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(superuser, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple long property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.DATE, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple date property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple date property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.BOOLEAN, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple boolean property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple boolean property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.BINARY, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple binary property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple binary property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testValueConstraintNotSatisfiedMultiple()
            throws NotExecutableException, ParseException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.DOUBLE, true, false, true, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple double property def with " +
                    "testable value constraints has been found");
        }

        Value value = NodeTypeUtil.getValueAccordingToValueConstraints(session, propDef, false);
        if (value == null) {
            throw new NotExecutableException("No multiple double property def with " +
                    "testable value constraints has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();
        Value values[] = new Value[] {value};

        assertFalse("canSetProperty(String propertyName, Value[] values) must " +
                "return false if values do not match the value constraints.",
                nodeType.canSetProperty(propDef.getName(), values));
    }


    public void testConversionsMultiple()
            throws NotExecutableException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.BINARY, true, false, false, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple string property def that meets the " +
                    "requirements of the test has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();


        Value binaryValue = NodeTypeUtil.getValueOfType(session, PropertyType.BINARY);

        Value stringValue = NodeTypeUtil.getValueOfType(session, PropertyType.STRING);
        Value stringValues[] = new Value[] {stringValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type StringValue",
                nodeType.canSetProperty(propDef.getName(), stringValues));

        Value binaryValues[] = new Value[] {binaryValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type BinaryValue",
                nodeType.canSetProperty(propDef.getName(), binaryValues));

        Value dateValue = NodeTypeUtil.getValueOfType(session, PropertyType.DATE);
        Value dateValues[] = new Value[] {dateValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type DateValue",
                nodeType.canSetProperty(propDef.getName(), dateValues));

        Value doubleValue = NodeTypeUtil.getValueOfType(session, PropertyType.DOUBLE);
        Value doubleValues[] = new Value[] {doubleValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type DoubleValue",
                nodeType.canSetProperty(propDef.getName(), doubleValues));

        Value longValue = NodeTypeUtil.getValueOfType(session, PropertyType.LONG);
        Value longValues[] = new Value[] {longValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type LongValue",
                nodeType.canSetProperty(propDef.getName(), longValues));

        Value booleanValue = NodeTypeUtil.getValueOfType(session, PropertyType.BOOLEAN);
        Value booleanValues[] = new Value[] {booleanValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type BooleanValue",
                nodeType.canSetProperty(propDef.getName(), booleanValues));

        Value nameValue = NodeTypeUtil.getValueOfType(session, PropertyType.NAME);
        Value nameValues[] = new Value[] {nameValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type NameValue",
                nodeType.canSetProperty(propDef.getName(), nameValues));

        Value pathValue = NodeTypeUtil.getValueOfType(session, PropertyType.PATH);
        Value pathValues[] = new Value[] {pathValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type Binary and values are of type PathValue",
                nodeType.canSetProperty(propDef.getName(), pathValues));
    }


    public void testConversionsMultiple()
            throws NotExecutableException, RepositoryException {

        PropertyDefinition propDef =
                NodeTypeUtil.locatePropertyDef(session, PropertyType.STRING, true, false, false, false);

        if (propDef == null) {
            throw new NotExecutableException("No multiple string property def that meets the " +
                    "requirements of the test has been found");
        }

        NodeType nodeType = propDef.getDeclaringNodeType();


        Value stringValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.STRING);
        Value stringValues[] = new Value[] {stringValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type StringValue",
                nodeType.canSetProperty(propDef.getName(), stringValues));

        Value binaryValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.BINARY);
        Value binaryValues[] = new Value[] {binaryValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type BinaryValue " +
                "and is UTF-8",
                nodeType.canSetProperty(propDef.getName(), binaryValues));

        Value dateValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.DATE);
        Value dateValues[] = new Value[] {dateValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type DateValue",
                nodeType.canSetProperty(propDef.getName(), dateValues));

        Value doubleValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.DOUBLE);
        Value doubleValues[] = new Value[] {doubleValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type DoubleValue",
                nodeType.canSetProperty(propDef.getName(), doubleValues));

        Value longValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.LONG);
        Value longValues[] = new Value[] {longValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type LongValue",
                nodeType.canSetProperty(propDef.getName(), longValues));

        Value booleanValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.BOOLEAN);
        Value booleanValues[] = new Value[] {booleanValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type BooleanValue",
                nodeType.canSetProperty(propDef.getName(), booleanValues));

        Value nameValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.NAME);
        Value nameValues[] = new Value[] {nameValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type NameValue",
                nodeType.canSetProperty(propDef.getName(), nameValues));

        Value pathValue = NodeTypeUtil.getValueOfType(superuser, PropertyType.PATH);
        Value pathValues[] = new Value[] {pathValue};
        assertTrue("canSetProperty(String propertyName, Value[] values) must return " +
                "true if the property is of type String and values are of type PathValue",
                nodeType.canSetProperty(propDef.getName(), pathValues));
    }


    public void testDefinedAndIllegalType()
            throws NotExecutableException, RepositoryException {

        NodeDefinition nodeDef = NodeTypeUtil.locateChildNodeDef(session, false, false, false);

        if (nodeDef == null) {
            throw new NotExecutableException("No testable node type found.");
        }

        NodeType nodeType = nodeDef.getDeclaringNodeType();
        String childNodeName = nodeDef.getName();

        String legalType = nodeDef.getRequiredPrimaryTypes()[0].getName();
        String illegalType = NodeTypeUtil.getIllegalChildNodeType(manager, legalType);
        if (illegalType == null) {
            throw new NotExecutableException("No illegal node type name found");
        }

        assertFalse("NodeType.canAddChildNode(String childNodeName, String nodeTypeName) " +
                "must return false if childNodeName does and nodeTypeName does not " +
                "match the child node def of NodeType.",
                nodeType.canAddChildNode(childNodeName, illegalType));
    }


    public void testResidualAndIllegalType()
            throws NotExecutableException, RepositoryException {

        NodeDefinition nodeDef = NodeTypeUtil.locateChildNodeDef(session, false, false, true);

        if (nodeDef == null) {
            throw new NotExecutableException("No testable residual child node def.");
        }

        NodeType nodeType = nodeDef.getDeclaringNodeType();
        String undefinedName = NodeTypeUtil.getUndefinedChildNodeName(nodeType);

        String legalType = nodeDef.getRequiredPrimaryTypes()[0].getName();
        String illegalType = NodeTypeUtil.getIllegalChildNodeType(manager, legalType);
        if (illegalType == null) {
            throw new NotExecutableException("No illegal node type name found");
        }

        assertFalse("NodeType.canAddChildNode(String childNodeName, String nodeTypeName) " +
                "must return false for a not defined childNodeName if nodeTypeName " +
                "does not matches the type of a residual child node def",
                nodeType.canAddChildNode(undefinedName, illegalType));
    }


    public void testGetDeclaredPropertyDefs()
            throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();

            PropertyDefinition declaredDefs[] = type.getDeclaredPropertyDefinitions();
            PropertyDefinition defs[] = type.getPropertyDefinitions();

            try {
                for (int i = 0; i < declaredDefs.length; i++) {
                    boolean exists = false;
                    for (int j = 0; j < defs.length; j++) {
                        if (defs[j].getName().equals(declaredDefs[i].getName())) {
                            exists = true;
                            break;
                        }
                    }
                    assertTrue("All property defs returned by " +
                            "getDeclaredPropertyDefs() must also be " +
                            "returned by getPropertyDefs()",
                            exists);
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                fail("The array returned by " +
                        "getDeclaredPropertyDefs() must not exceed " +
                        "the one returned by getPropertyDefs()");
            }
        }
    }


    public void testGetDeclaredChildNodeDefs()
            throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();

            NodeDefinition declaredDefs[] = type.getDeclaredChildNodeDefinitions();
            NodeDefinition defs[] = type.getChildNodeDefinitions();

            try {
                for (int i = 0; i < declaredDefs.length; i++) {
                    boolean exists = false;
                    for (int j = 0; j < defs.length; j++) {
                        if (defs[j].getName().equals(declaredDefs[i].getName())) {
                            exists = true;
                            break;
                        }
                    }
                    assertTrue("All node defs returned by " +
                            "getDeclaredChildNodeDefs() must also be " +
                            "returned by getChildNodeDefs().",
                            exists);
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                fail("The array returned by " +
                        "getDeclaredChildNodeDefs() must not exceed " +
                        "the one returned by getChildNodeDefs()");
            }
        }
    }


    public void testGetDeclaringNodeType() throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        // loop all node types
        while (types.hasNext()) {
            NodeType currentType = types.nextNodeType();
            PropertyDefinition defsOfCurrentType[] =
                    currentType.getPropertyDefinitions();

            // loop all property defs of each node type
            for (int i = 0; i < defsOfCurrentType.length; i++) {
                PropertyDefinition def = defsOfCurrentType[i];
                NodeType type = def.getDeclaringNodeType();

                // check if def is part of the property defs of the
                // declaring node type
                PropertyDefinition defs[] = type.getPropertyDefinitions();
                boolean hasType = false;
                for (int j = 0; j < defs.length; j++) {
                    if (defs[j].getName().equals(def.getName())) {
                        hasType = true;
                        break;
                    }
                }
                assertTrue("getDeclaringNodeType() must return the node " +
                        "which defines the corresponding property def.",
                        hasType);
            }
        }
    }


    public void testGetDeclaringNodeType()
            throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        // loop all node types
        while (types.hasNext()) {
            NodeType currentType = types.nextNodeType();
            NodeDefinition defsOfCurrentType[] =
                    currentType.getChildNodeDefinitions();

            // loop all child node defs of each node type
            for (int i = 0; i < defsOfCurrentType.length; i++) {
                NodeDefinition def = defsOfCurrentType[i];
                NodeType type = def.getDeclaringNodeType();

                // check if def is part of the child node defs of the
                // declaring node type
                NodeDefinition defs[] = type.getChildNodeDefinitions();
                boolean hasType = false;
                for (int j = 0; j < defs.length; j++) {
                    if (defs[j].getName().equals(def.getName())) {
                        hasType = true;
                        break;
                    }
                }
                assertTrue("getDeclaringNodeType() must return the node " +
                        "which defines the corresponding child node def.",
                        hasType);
            }
        }
    }


    public void testGetDefaultValues()
            throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        // loop all node types
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            PropertyDefinition defs[] = type.getPropertyDefinitions();
            for (int i = 0; i < defs.length; i++) {
                PropertyDefinition def = defs[i];

                Value values[] = def.getDefaultValues();
                if (values != null) {

                    for (int j = 0; j < values.length; j++) {

                        if (!def.isMultiple()) {
                            assertEquals(
                                    "Single-valued property "
                                    + type.getName() +"/" + def.getName()
                                    + " must not have more than one default value.",
                                    1, values.length);
                        }
                    }
                }
            }
        }
    }


    public static NodeDefinition locateChildNodeDef(Session session,
                                                    boolean regardDefaultPrimaryType,
                                                    boolean defaultPrimaryType,
                                                    boolean residual)
            throws RepositoryException {

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        boolean skip = false;

        while (types.hasNext()) {
            NodeType type = types.nextNodeType();

            // node types with more than one residual child node definition
            // will cause trouble in test cases. the implementation
            // might pick another definition than the definition returned by
            // this method, when a child node is set.
            NodeDefinition[] childDefs = type.getChildNodeDefinitions();
            int residuals = 0;
            for (int i = 0; i < childDefs.length; i++) {
                if (childDefs[i].getName().equals("*")) {
                    residuals++;
                }
            }
            if (residuals > 1) {
                // more than one residual, not suitable for tests
                continue;
            }

            NodeDefinition nodeDefs[] = type.getDeclaredChildNodeDefinitions();

            for (int i = 0; i < nodeDefs.length; i++) {
                NodeDefinition nodeDef = nodeDefs[i];

                if (nodeDef.getDeclaringNodeType().isAbstract()) {
                    continue;
                }

                if (nodeDef.isProtected()) {
                    continue;
                }

                if (nodeDef.getRequiredPrimaryTypes().length > 1) {
                    // behaviour of implementations that support multiple multiple inheritance
                    // of primary node types is not specified
                    continue;
                }

                if (regardDefaultPrimaryType) {

                    if (defaultPrimaryType && nodeDef.getDefaultPrimaryType() == null) {
                        continue;
                    }

                    if (!defaultPrimaryType && nodeDef.getDefaultPrimaryType() != null) {
                        continue;
                    }
                }

                if (residual && !nodeDef.getName().equals("*")) {
                    continue;
                }

                if (!residual) {
                    // if another child node def is a residual definition
                    // skip the current node type
                    NodeDefinition nodeDefsAll[] = type.getChildNodeDefinitions();
                    for (int j = 0; j < nodeDefsAll.length; j++) {
                        if (nodeDefsAll[j].getName().equals("*")) {
                            skip = true;
                            break;
                        }
                    }
                    if (skip) {
                        // break the loop of the current child not defs
                        skip = false;
                        break;
                    }
                }

                return nodeDef;
            }
        }
        return null;
    }


    public static List<NodeDefinition> locateAllChildNodeDef(Session session,
                                                    boolean regardDefaultPrimaryType,
                                                    boolean defaultPrimaryType,
                                                    boolean residual)
            throws RepositoryException {
        List<NodeDefinition> nodeTypes = new ArrayList<NodeDefinition>();

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        boolean skip = false;

        while (types.hasNext()) {
            NodeType type = types.nextNodeType();

            // node types with more than one residual child node definition
            // will cause trouble in test cases. the implementation
            // might pick another definition than the definition returned by
            // this method, when a child node is set.
            NodeDefinition[] childDefs = type.getChildNodeDefinitions();
            int residuals = 0;
            for (int i = 0; i < childDefs.length; i++) {
                if (childDefs[i].getName().equals("*")) {
                    residuals++;
                }
            }
            if (residuals > 1) {
                // more than one residual, not suitable for tests
                continue;
            }

            NodeDefinition nodeDefs[] = type.getDeclaredChildNodeDefinitions();

            for (int i = 0; i < nodeDefs.length; i++) {
                NodeDefinition nodeDef = nodeDefs[i];

                if (nodeDef.getDeclaringNodeType().isAbstract()) {
                    continue;
                }

                if (nodeDef.isProtected()) {
                    continue;
                }

                if (nodeDef.getRequiredPrimaryTypes().length > 1) {
                    // behaviour of implementations that support multiple multiple inheritance
                    // of primary node types is not specified
                    continue;
                }

                if (regardDefaultPrimaryType) {

                    if (defaultPrimaryType && nodeDef.getDefaultPrimaryType() == null) {
                        continue;
                    }

                    if (!defaultPrimaryType && nodeDef.getDefaultPrimaryType() != null) {
                        continue;
                    }
                }

                if (residual && !nodeDef.getName().equals("*")) {
                    continue;
                }

                if (!residual) {
                    // if another child node def is a residual definition
                    // skip the current node type
                    NodeDefinition nodeDefsAll[] = type.getChildNodeDefinitions();
                    for (int j = 0; j < nodeDefsAll.length; j++) {
                        if (nodeDefsAll[j].getName().equals("*")) {
                            skip = true;
                            break;
                        }
                    }
                    if (skip) {
                        // break the loop of the current child not defs
                        skip = false;
                        break;
                    }
                }

                nodeTypes.add(nodeDef);
            }
        }
        return nodeTypes;
    }


    public static NodeDefinition locateChildNodeDef(Session session,
                                                    boolean isProtected,
                                                    boolean mandatory)
            throws RepositoryException {

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            NodeDefinition nodeDefs[] = type.getDeclaredChildNodeDefinitions();

            for (int i = 0; i < nodeDefs.length; i++) {
                NodeDefinition nodeDef = nodeDefs[i];

                if (nodeDef.getName().equals("*")) {
                    continue;
                }

                if (isProtected && !nodeDef.isProtected()) {
                    continue;
                }
                if (!isProtected && nodeDef.isProtected()) {
                    continue;
                }

                if (mandatory && !nodeDef.isMandatory()) {
                    continue;
                }
                if (!mandatory && nodeDef.isMandatory()) {
                    continue;
                }

                return nodeDef;
            }
        }
        return null;
    }


    public static PropertyDefinition locatePropertyDef(Session session,
                                                       boolean isProtected,
                                                       boolean mandatory)
            throws RepositoryException {

        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
        NodeTypeIterator types = manager.getAllNodeTypes();

        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            PropertyDefinition propDefs[] = type.getDeclaredPropertyDefinitions();
            for (int i = 0; i < propDefs.length; i++) {
                PropertyDefinition propDef = propDefs[i];

                if (propDef.getName().equals("*")) {
                    continue;
                }

                if (isProtected && !propDef.isProtected()) {
                    continue;
                }
                if (!isProtected && propDef.isProtected()) {
                    continue;
                }

                if (mandatory && !propDef.isMandatory()) {
                    continue;
                }
                if (!mandatory && propDef.isMandatory()) {
                    continue;
                }

                return propDef;
            }
        }
        return null;
    }


    private static String getConstraintMin(String constraint) {
        String min = constraint.substring(0, constraint.indexOf(","));
        min = min.replaceAll("\\(", "");
        min = min.replaceAll("\\[", "");
        min = min.replaceAll(" ", "");
        if (min.equals("")) {
            min = null;
        }
        return min;
    }


    private static String getConstraintMax(String constraint) {
        String max = constraint.substring(constraint.indexOf(",") + 1);
        max = max.replaceAll("\\)", "");
        max = max.replaceAll("\\]", "");
        max = max.replaceAll(" ", "");
        if (max.equals("")) {
            max = null;
        }
        return max;
    }


    public void testIsAutoCreate()
            throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        // loop all node types
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            NodeDefinition defs[] = type.getChildNodeDefinitions();
            for (int i = 0; i < defs.length; i++) {
                if (defs[i].isAutoCreated()) {
                    assertFalse("An auto create node must not be a " +
                            "residual set definition.",
                            defs[i].getName().equals("*"));
                }
            }
        }
    }


    public void testIsAutoCreate() throws RepositoryException {

        NodeTypeIterator types = manager.getAllNodeTypes();
        // loop all node types
        while (types.hasNext()) {
            NodeType type = types.nextNodeType();
            PropertyDefinition defs[] = type.getPropertyDefinitions();
            for (int i = 0; i < defs.length; i++) {
                if (defs[i].isAutoCreated()) {
                    assertFalse("An auto create property must not be a " +
                            "residual set definition.",
                            defs[i].getName().equals("*"));
                }
            }
        }
    }


    private void traverse(Node parentNode)
            throws RepositoryException {

        NodeIterator nodes = parentNode.getNodes();
        while (nodes.hasNext()) {
            Node node = nodes.nextNode();

            NodeType primaryType = node.getPrimaryNodeType();
            checkMandatoryConstraint(node, primaryType);

            NodeType mixins[] = node.getMixinNodeTypes();
            for (int i = 0; i < mixins.length; i++) {
                checkMandatoryConstraint(node, mixins[i]);
            }

            traverse(node);
        }
    }


    private void traverse(Node parentNode)
            throws RepositoryException {

        NodeIterator nodes = parentNode.getNodes();
        while (nodes.hasNext()) {
            Node node = nodes.nextNode();

            NodeType primeType = node.getPrimaryNodeType();
            checkMandatoryConstraint(node, primeType);

            NodeType mixins[] = node.getMixinNodeTypes();
            for (int i = 0; i < mixins.length; i++) {
                checkMandatoryConstraint(node, mixins[i]);
            }

            traverse(node);
        }
    }


    public void testEmptyNodeTypeTemplate() throws Exception {

        NodeTypeTemplate ntt = ntm.createNodeTypeTemplate();
        assertNull(ntt.getName());

        assertFalse(ntt.isMixin());
        assertFalse(ntt.isAbstract());
        assertFalse(ntt.hasOrderableChildNodes());
        
        // note: isQueryable cannot be tested as defautl value is defined
        // by the implementation

        assertNotNull(ntt.getDeclaredSupertypeNames());
        assertEquals(0, ntt.getDeclaredSupertypeNames().length);

        assertNull(ntt.getPrimaryItemName());

        assertNull(ntt.getDeclaredChildNodeDefinitions());
        assertNull(ntt.getDeclaredPropertyDefinitions());

        assertNotNull(ntt.getNodeDefinitionTemplates());
        assertTrue(ntt.getNodeDefinitionTemplates().isEmpty());

        assertNotNull(ntt.getPropertyDefinitionTemplates());
        assertTrue(ntt.getPropertyDefinitionTemplates().isEmpty());
    }


    public void testEmptyNodeDefinitionTemplate() throws Exception {
        NodeDefinitionTemplate ndt = ntm.createNodeDefinitionTemplate();

        assertNull(ndt.getName());
        assertFalse(ndt.isAutoCreated());
        assertFalse(ndt.isMandatory());
        assertFalse(ndt.isProtected());
        assertEquals(OnParentVersionAction.COPY, ndt.getOnParentVersion());
        assertNull(ndt.getDeclaringNodeType());

        assertNull(ndt.getRequiredPrimaryTypes());
        assertNull(ndt.getRequiredPrimaryTypeNames());
        assertNull(ndt.getDefaultPrimaryType());
        assertNull(ndt.getDefaultPrimaryTypeName());
        assertFalse(ndt.allowsSameNameSiblings());
    }


    public void testEmptyPropertyDefinitionTemplate() throws Exception {
        PropertyDefinitionTemplate pdt = ntm.createPropertyDefinitionTemplate();

        assertNull(pdt.getName());
        assertFalse(pdt.isAutoCreated());
        assertFalse(pdt.isMandatory());
        assertFalse(pdt.isProtected());
        assertEquals(OnParentVersionAction.COPY, pdt.getOnParentVersion());
        assertNull(pdt.getDeclaringNodeType());

        assertEquals(PropertyType.STRING, pdt.getRequiredType());
        assertFalse(pdt.isMultiple());
        assertNull(pdt.getValueConstraints());
        assertNull(pdt.getDefaultValues());

        // the following methods cannot be tested as default value is
        // implementation specific:
        // - getAvailableQueryOperators
        // - isFullTextSearchable
        // - isQueryOrderable

    }


    public void testRegisterNodeType() throws Exception {
        NodeTypeTemplate ntt = ntm.createNodeTypeTemplate();

        ntt.setName("mix:foo");
        ntt.setAbstract(false);
        ntt.setMixin(true);
        ntt.setOrderableChildNodes(false);
        ntt.setQueryable(false);

        PropertyDefinitionTemplate pdt = ntm.createPropertyDefinitionTemplate();
        pdt.setAutoCreated(false);
        pdt.setName("foo");
        pdt.setMultiple(false);
        pdt.setRequiredType(PropertyType.STRING);
        List pdefs = ntt.getPropertyDefinitionTemplates();
        pdefs.add(pdt);

        ntm.registerNodeType(ntt, true);

        try {
            ntm.registerNodeType(ntt, false);
            fail("NodeTypeExistsException expected.");
        } catch (NodeTypeExistsException e) {
            // success
        }
    }


    public void testRegisterNodeTypes() throws Exception {
        NodeTypeDefinition[] defs = new NodeTypeDefinition[5];
        for (int i = 0; i < defs.length; i++) {
            NodeTypeTemplate ntt = ntm.createNodeTypeTemplate();
            ntt.setName("mix:foo" + i);
            ntt.setAbstract(false);
            ntt.setMixin(true);
            ntt.setOrderableChildNodes(false);
            ntt.setQueryable(false);

            PropertyDefinitionTemplate pdt = ntm.createPropertyDefinitionTemplate();
            pdt.setAutoCreated(false);
            pdt.setName("foo" + i);
            pdt.setMultiple(false);
            pdt.setRequiredType(PropertyType.STRING);
            List pdefs = ntt.getPropertyDefinitionTemplates();
            pdefs.add(pdt);

            defs[i] = ntt;
        }
        ntm.registerNodeTypes(defs, true);

        try {
            ntm.registerNodeTypes(defs, false);
            fail("NodeTypeExistsException expected.");
        } catch (NodeTypeExistsException e) {
            // success
        }
    }


    public void testUnregisterNodeType() throws Exception {
        try {
            ntm.unregisterNodeType("unknownnodetype");
            fail("NoSuchNodeTypeException expected.");
        } catch (NoSuchNodeTypeException e) {
            // success
        }

        try {
            ntm.unregisterNodeType("nt:base");
            fail("RepositoryException expected.");
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testUnregisterNodeTypes() throws Exception {
        try {
            ntm.unregisterNodeTypes(new String[] {"unknownnodetype1","unknownnodetype2"});
            fail("NoSuchNodeTypeException expected.");
        } catch (NoSuchNodeTypeException e) {
            // success
        }

        try {
            ntm.unregisterNodeTypes(new String[] {"nt:base", "nt:address"});
            fail("RepositoryException expected.");
        } catch (RepositoryException e) {
            // success
        }
    }


    public void testGetNodePath() throws RepositoryException{
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        Node addedNode = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        assertEquals("Wrong number of events returned", 1, events.length);
        String path = events[0].getPath();
        String absPath = addedNode.getPath();
        assertEquals("Path returned by getPath() is wrong", absPath, path);
    }


    public void testGetUserId() throws RepositoryException{
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        assertEquals("Wrong number of events returned", 1, events.length);
        String userId = events[0].getUserID();
        String sessionUId = superuser.getUserID();
        assertEquals("UserId of event is not equal to userId of session", userId, sessionUId);
    }


    public void testGetType() throws RepositoryException{
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        assertEquals("Wrong number of events returned", 1, events.length);
        int type = events[0].getType();
        assertEquals("Event did not return correct event type", Event.NODE_ADDED, type);
    }


    public void testMultipleNodeAdded1() throws RepositoryException {
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkNodeAdded(events, new String[]{nodeName1, nodeName2}, null);
    }


    public void testTransientNodeAddedRemoved() throws RepositoryException {
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = testRootNode.addNode(nodeName2, testNodeType);
        n2.remove();
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkNodeAdded(events, new String[]{nodeName1}, null);
    }


    public void testMultipleNodeAdded2() throws RepositoryException {
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_ADDED);
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkNodeAdded(events, new String[]{nodeName1, nodeName1 + "/" + nodeName2}, null);
    }


    public void testSingleNodeRemoved() throws RepositoryException {
        Node foo = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_REMOVED);
        foo.remove();
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkNodeRemoved(events, new String[]{nodeName1}, null);
    }


    public void testCopy() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult listener = new EventResult(log);
        addEventListener(listener, Event.NODE_ADDED);
        superuser.getWorkspace().copy(testRoot + "/" + nodeName1, testRoot + "/" + nodeName3);
        Event[] events = listener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(listener);
        checkNodeAdded(events, new String[]{nodeName3, nodeName3 + "/" + nodeName2}, null);
    }


    public void testIsDeepFalseNodeAdded() throws RepositoryException {
        EventResult listener = new EventResult(log);
        obsMgr.addEventListener(listener, Event.NODE_ADDED, testRoot + "/" + nodeName1, false, null, null, false);
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        Event[] events = listener.getEvents(DEFAULT_WAIT_TIMEOUT);
        obsMgr.removeEventListener(listener);
        checkNodeAdded(events, new String[]{nodeName1 + "/" + nodeName2}, null);
    }


    public void testPath() throws RepositoryException {
        EventResult listener = new EventResult(log);
        obsMgr.addEventListener(listener, Event.NODE_ADDED, testRoot + "/" + nodeName1, true, null, null, false);
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        n.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        Event[] events = listener.getEvents(DEFAULT_WAIT_TIMEOUT);
        obsMgr.removeEventListener(listener);
        checkNodeAdded(events, new String[]{nodeName1 + "/" + nodeName2}, null);
    }


    public void testMultiPropertyRemoved() throws RepositoryException {
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        Property prop1 = node.setProperty(propertyName1, "foo");
        Property prop2 = node.setProperty(propertyName2, "bar");
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_REMOVED);
        prop1.remove();
        prop2.remove();
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyRemoved(events, new String[]{nodeName1 + "/" + propertyName1,
                                                  nodeName1 + "/" + propertyName2});
    }


    public void testSinglePropertyRemoved() throws RepositoryException {
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        Property prop1 = node.setProperty(propertyName1, "foo");
        node.setProperty(propertyName2, "bar");
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_REMOVED);
        prop1.remove();
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyRemoved(events, new String[]{nodeName1 + "/" + propertyName1});
    }


    public void testMultiNodesRemoved() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.NODE_REMOVED);
        n1.remove();
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkNodeRemoved(events, new String[]{nodeName1, nodeName1 + "/" + nodeName2}, null);
    }


    public void testSinglePropertyChanged() throws RepositoryException {
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        node.setProperty(propertyName1, "foo");
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_CHANGED);
        node.getProperty(propertyName1).setValue("foobar");
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyChanged(events, new String[]{nodeName1 + "/" + propertyName1});
    }


    public void testSinglePropertyAdded() throws RepositoryException {
        Node foo = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_ADDED);
        foo.setProperty(propertyName1, "test content");
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyAdded(events, new String[]{nodeName1 + "/" + propertyName1});
    }


    public void testMultiPropertyAdded() throws RepositoryException {
        Node foo = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_ADDED);
        foo.setProperty(propertyName1, "foo");
        foo.setProperty(propertyName2, "bar");
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyAdded(events, new String[]{nodeName1 + "/" + propertyName1,
                                                nodeName1 + "/" + propertyName2});
    }


    public void testMultiPropertyChanged() throws RepositoryException {
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        node.setProperty(propertyName1, "foo");
        node.setProperty(propertyName2, "bar");
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_CHANGED);
        node.getProperty(propertyName1).setValue("foobar");
        node.getProperty(propertyName2).setValue("foobar");
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyChanged(events, new String[]{nodeName1 + "/" + propertyName1,
                                                  nodeName1 + "/" + propertyName2});
    }


    public void testSinglePropertyChangedWithAdded() throws RepositoryException {
        Node node = testRootNode.addNode(nodeName1, testNodeType);
        node.setProperty(propertyName1, "foo");
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_CHANGED);
        node.getProperty(propertyName1).setValue("foobar");
        node.setProperty(propertyName2, "bar");    // will not fire prop changed event
        testRootNode.getSession().save();
        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        checkPropertyChanged(events, new String[]{nodeName1 + "/" + propertyName1});
    }


    public void testNodeAdded() throws RepositoryException {
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                testRootNode.addNode(nodeName1, testNodeType);
                testRootNode.getSession().save();
            }
        }, Event.NODE_ADDED);
        for (int i = 0; i < events.length; i++) {
            Set<?> unexpectedKeys = getUnexpectedKeys(events[i].getInfo());
            assertEquals("info map contains invalid keys: " + unexpectedKeys, 0, unexpectedKeys.size());
        }
    }


    public void testPropertyChanged() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        final Property prop = n.setProperty(propertyName1, "test");
        testRootNode.getSession().save();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                prop.setValue("modified");
                prop.getSession().save();
            }
        }, Event.PROPERTY_CHANGED);
        for (int i = 0; i < events.length; i++) {
            Set<?> unexpectedKeys = getUnexpectedKeys(events[i].getInfo());
            assertEquals("info map must be empty: " + unexpectedKeys, 0, unexpectedKeys.size());
        }
    }


    public void testPropertyAdded() throws RepositoryException {
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                testRootNode.addNode(nodeName1, testNodeType).setProperty(propertyName1, "test");
                testRootNode.getSession().save();
            }
        }, Event.PROPERTY_ADDED);
        for (int i = 0; i < events.length; i++) {
            Set<?> unexpectedKeys = getUnexpectedKeys(events[i].getInfo());
            assertEquals("info map must be empty", 0, unexpectedKeys.size());
        }
    }


    public void testNodeRemoved() throws RepositoryException {
        final Node n = testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                n.remove();
                testRootNode.getSession().save();
            }
        }, Event.NODE_REMOVED);
        for (int i = 0; i < events.length; i++) {
            Set<?> unexpectedKeys = getUnexpectedKeys(events[i].getInfo());
            assertEquals("info map must be empty", 0, unexpectedKeys.size());
        }
    }


    public void testPropertyRemoved() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        final Property prop = n.setProperty(propertyName1, "test");
        testRootNode.getSession().save();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                Session s = prop.getSession();
                prop.remove();
                s.save();
            }
        }, Event.PROPERTY_REMOVED);
        for (int i = 0; i < events.length; i++) {
            Set<?> unexpectedKeys = getUnexpectedKeys(events[i].getInfo());
            assertEquals("info map must be empty: " + unexpectedKeys, 0, unexpectedKeys.size());
        }
    }


    public void testPropertyChanged() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        final Property prop = n.setProperty(propertyName1, "test");
        testRootNode.getSession().save();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                prop.setValue("modified");
                testRootNode.getSession().save();
            }
        }, Event.PROPERTY_CHANGED);
        assertEquals(n.getIdentifier(), getEventByPath(events, prop.getPath()).getIdentifier());
    }


    public void testPropertyRemoved() throws RepositoryException {
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        final Property prop = n.setProperty(propertyName1, "test");
        String propPath = prop.getPath();
        testRootNode.getSession().save();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                prop.remove();
                testRootNode.getSession().save();
            }
        }, Event.PROPERTY_REMOVED);
        assertEquals(n.getIdentifier(), getEventByPath(events, propPath).getIdentifier());
    }


    public void testNodeRemoved() throws RepositoryException {
        final Node n = testRootNode.addNode(nodeName1, testNodeType);
        String path = n.getPath();
        testRootNode.getSession().save();
        String identifier = n.getIdentifier();
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                n.remove();
                testRootNode.getSession().save();
            }
        }, Event.NODE_REMOVED);
        assertEquals(identifier, getEventByPath(events, path).getIdentifier());
    }


    public void testNodeAdded() throws RepositoryException {
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                testRootNode.addNode(nodeName1, testNodeType);
                testRootNode.getSession().save();
            }
        }, Event.NODE_ADDED);
        Node n = testRootNode.getNode(nodeName1);
        assertEquals(n.getIdentifier(), getEventByPath(events, n.getPath()).getIdentifier());
    }


    public void testPropertyAdded() throws RepositoryException {
        Event[] events = getEvents(new Callable(){
            public void call() throws RepositoryException {
                testRootNode.addNode(nodeName1, testNodeType).setProperty(propertyName1, "test");
                testRootNode.getSession().save();
            }
        }, Event.PROPERTY_ADDED);
        Node n = testRootNode.getNode(nodeName1);
        Property prop = n.getProperty(propertyName1);
        assertEquals(n.getIdentifier(), getEventByPath(events, prop.getPath()).getIdentifier());
    }


    public void testMoveTree() throws RepositoryException {
        /**
         * Initial tree:
         *  + testroot
         *      + nodename1
         *          + nodename2
         *
         * After move:
         *  + testroot
         *      + nodename3
         *          + nodename2
         */

        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        EventResult moveNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        addEventListener(moveNodeListener, Event.NODE_MOVED);
        superuser.move(n1.getPath(), testRoot + "/" + nodeName3);
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] moved = moveNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        removeEventListener(moveNodeListener);
        checkNodeAdded(added, new String[]{nodeName3}, new String[]{nodeName3 + "/" + nodeName2});
        checkNodeRemoved(removed, new String[]{nodeName1}, new String[]{nodeName1 + "/" + nodeName2});
        checkNodeMoved(moved, nodeName1, nodeName3);
    }


    public void testMoveNode() throws RepositoryException {
        /**
         * Initial tree:
         *  + testroot
         *      + nodename1
         *          + nodename2
         *
         * After move:
         *  + testroot
         *      + nodename1
         *      + nodename2
         */

        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        EventResult moveNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        addEventListener(moveNodeListener, Event.NODE_MOVED);
        superuser.move(n2.getPath(), testRoot + "/" + nodeName2);
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] moved = moveNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        removeEventListener(moveNodeListener);
        checkNodeAdded(added, new String[]{nodeName2}, null);
        checkNodeRemoved(removed, new String[]{nodeName1 + "/" + nodeName2}, null);
        checkNodeMoved(moved, nodeName1 + "/" + nodeName2, nodeName2);
    }


    public void testMoveWithRemove() throws RepositoryException {
        /**
         * Initial tree:
         *  + testroot
         *      + nodename1
         *          + nodename2
         *      + nodename3
         *
         * After move and remove:
         *  + testroot
         *      + nodename3
         *          + nodename2
         */
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        Node n2 = n1.addNode(nodeName2, testNodeType);
        Node n3 = testRootNode.addNode(nodeName3, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        EventResult moveNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        addEventListener(moveNodeListener, Event.NODE_MOVED);
        // move n2
        superuser.move(n2.getPath(), n3.getPath() + "/" + nodeName2);
        // remove n1
        n1.remove();
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] moved = moveNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        removeEventListener(moveNodeListener);
        checkNodeAdded(added, new String[]{nodeName3 + "/" + nodeName2}, null);
        checkNodeRemoved(removed, new String[]{nodeName1 + "/" + nodeName2, nodeName1}, null);
        checkNodeMoved(moved, nodeName1 + "/" + nodeName2, nodeName3 + "/" + nodeName2);
    }


    public void testRename() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        superuser.getWorkspace().move(n1.getPath(), testRoot + "/" + nodeName3);
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        checkNodeAdded(added, new String[]{nodeName3}, new String[]{nodeName3 + "/" + nodeName2});
        checkNodeRemoved(removed, new String[]{nodeName1}, new String[]{nodeName1 + "/" + nodeName2});
    }


    public void testMove() throws RepositoryException {
        Node n1 = testRootNode.addNode(nodeName1, testNodeType);
        Node n3 = testRootNode.addNode(nodeName3, testNodeType);
        n1.addNode(nodeName2, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        superuser.getWorkspace().move(n1.getPath(), n3.getPath() + "/" + nodeName4);
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        checkNodeAdded(added, new String[]{nodeName3 + "/" + nodeName4}, new String[]{nodeName3 + "/" + nodeName4 + "/" + nodeName2});
        checkNodeRemoved(removed, new String[]{nodeName1}, new String[]{nodeName1 + "/" + nodeName2});
    }


    public void testNodeReorderSameName()
            throws RepositoryException, NotExecutableException {
        if (!testRootNode.getDefinition().getDeclaringNodeType().hasOrderableChildNodes()) {
            throw new NotExecutableException("Node at '" + testRoot + "' does not support orderable child nodes.");
        }

        /**
         * Initial tree:
         *  + testroot
         *      + nodename1[1]
         *      + nodename1[2]
         *      + nodename1[3]
         *
         * After reorder:
         *  + testroot
         *      + nodename1[1]
         *      + nodename1[2] (was 3)
         *      + nodename1[3] (was 2)
         */
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        if (!n.getDefinition().allowsSameNameSiblings()) {
            throw new NotExecutableException("Node at " + testRoot + " does not allow same name siblings with name " + nodeName1);
        }
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        EventResult moveNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        addEventListener(moveNodeListener, Event.NODE_MOVED);
        testRootNode.orderBefore(nodeName1 + "[3]", nodeName1 + "[2]");
        //testRootNode.orderBefore(nodeName1 + "[2]", null);
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] moved = moveNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        removeEventListener(moveNodeListener);
        // either
        // 1) nodename1[2] has been reordered to the end
        // or:
        // 2) nodename1[3] has been reordered before nodename1[2]
        // that is, the following event sets are correct:
        // 1) nodename1[2]:remove, nodename1[3]:add
        // or:
        // 2) nodename1[3]:remove, nodename1[2]:add

        // if true, check for option 1)
        boolean reorderEnd = false;
        for (int i = 0; i < added.length; i++) {
            if (added[i].getPath().endsWith(nodeName1 + "[3]")) {
                reorderEnd = true;
                break;
            }
        }
        if (reorderEnd) {
            checkNodeAdded(added, new String[]{nodeName1 + "[3]"}, null);
            checkNodeRemoved(removed, new String[]{nodeName1 + "[2]"}, null);
            checkNodeReordered(moved, nodeName1 + "[2]", nodeName1 + "[3]", null);
        } else {
            checkNodeAdded(added, new String[]{nodeName1 + "[2]"}, null);
            checkNodeRemoved(removed, new String[]{nodeName1 + "[3]"}, null);
            checkNodeReordered(moved, nodeName1 + "[3]", nodeName1 + "[2]", nodeName1 + "[2]");
        }
    }


    public void testNodeReorderSameNameWithRemove()
            throws RepositoryException, NotExecutableException {
        if (!testRootNode.getDefinition().getDeclaringNodeType().hasOrderableChildNodes()) {
            throw new NotExecutableException("Node at '" + testRoot + "' does not support orderable child nodes.");
        }

        /**
         * Initial tree:
         *  + testroot
         *      + nodename1[1]
         *      + nodename2
         *      + nodename1[2]
         *      + nodename1[3]
         *      + nodename3
         *
         * After reorder:
         *  + testroot
         *      + nodename1[1]
         *      + nodename2
         *      + nodename1[2] (was 3)
         *      + nodename1[3] (was 2)
         */
        Node n = testRootNode.addNode(nodeName1, testNodeType);
        if (!n.getDefinition().allowsSameNameSiblings()) {
            throw new NotExecutableException("Node at " + testRoot + " does not allow same name siblings with name " + nodeName1);
        }
        testRootNode.addNode(nodeName2, testNodeType);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName1, testNodeType);
        testRootNode.addNode(nodeName3, testNodeType);
        testRootNode.getSession().save();
        EventResult addNodeListener = new EventResult(log);
        EventResult removeNodeListener = new EventResult(log);
        EventResult moveNodeListener = new EventResult(log);
        addEventListener(addNodeListener, Event.NODE_ADDED);
        addEventListener(removeNodeListener, Event.NODE_REMOVED);
        addEventListener(moveNodeListener, Event.NODE_MOVED);
        testRootNode.orderBefore(nodeName1 + "[2]", null);
        testRootNode.getNode(nodeName3).remove();
        testRootNode.getSession().save();
        Event[] added = addNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] removed = removeNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        Event[] moved = moveNodeListener.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(addNodeListener);
        removeEventListener(removeNodeListener);
        removeEventListener(moveNodeListener);
        // either
        // 1) nodename1[2] has been reordered to the end
        // or:
        // 2) nodename1[3] has been reordered before nodename1[2]
        //
        // that is, the following event sets are correct:
        // 1) nodename1[2]:remove, nodename1[3]:add, nodename3:remove
        // or:
        // 2) nodename1[3]:remove, nodename1[2]:add, nodename3:remove

        // if true, check for option 1)
        boolean reorderEnd = false;
        for (int i = 0; i < added.length; i++) {
            if (added[i].getPath().endsWith(nodeName1 + "[3]")) {
                reorderEnd = true;
                break;
            }
        }
        if (reorderEnd) {
            checkNodeAdded(added, new String[]{nodeName1 + "[3]"}, null);
            checkNodeRemoved(removed, new String[]{nodeName1 + "[2]", nodeName3}, null);
            checkNodeReordered(moved, nodeName1 + "[2]", nodeName1 + "[3]", null);
        } else {
            checkNodeAdded(added, new String[]{nodeName1 + "[2]"}, null);
            checkNodeRemoved(removed, new String[]{nodeName1 + "[3]", nodeName3}, null);
            checkNodeReordered(moved, nodeName1 + "[3]", nodeName1 + "[2]", nodeName1 + "[2]");
        }
    }


    public void testAddLockToNode() throws RepositoryException,
            NotExecutableException {
        Node lockable = createLockable(nodeName1, testNodeType);
        testRootNode.getSession().save();
        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_ADDED);

        // now lock node. no save needed
        lockable.lock(false,true);

        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);

        assertEquals("Wrong number of events.", 2, events.length);
        for (int i = 0; i < events.length; i++) {
            assertEquals("Wrong type of event.", Event.PROPERTY_ADDED, events[i].getType());
        }
        List<String> paths = new ArrayList<String>();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }
        String lockOwnerPath = testRoot + "/" + nodeName1 + "/" + jcrLockOwner;
        assertTrue("No event created for jcr:lockOwner", paths.contains(lockOwnerPath));
        String lockIsDeepPath = testRoot + "/" + nodeName1 + "/" + jcrlockIsDeep;
        assertTrue("No event created for jcr:lockIsDeep", paths.contains(lockIsDeepPath));

        lockable.unlock();
    }


    public void testRemoveLockFromNode() throws RepositoryException,
            NotExecutableException {
        Node lockable = createLockable(nodeName1, testNodeType);
        testRootNode.getSession().save();
        // lock the node
        lockable.lock(false, true);

        EventResult result = new EventResult(log);
        addEventListener(result, Event.PROPERTY_REMOVED);
        lockable.unlock();

        Event[] events = result.getEvents(DEFAULT_WAIT_TIMEOUT);
        removeEventListener(result);
        assertEquals("Wrong number of events.", 2, events.length);
        for (int i = 0; i < events.length; i++) {
            assertEquals("Wrong type of event.", Event.PROPERTY_REMOVED, events[i].getType());
        }
        List<String> paths = new ArrayList<String>();
        for (int i = 0; i < events.length; i++) {
            paths.add(events[i].getPath());
        }
        String lockOwnerPath = testRoot + "/" + nodeName1 + "/" + jcrLockOwner;
        assertTrue("No event created for jcr:lockOwner", paths.contains(lockOwnerPath));
        String lockIsDeepPath = testRoot + "/" + nodeName1 + "/" + jcrlockIsDeep;
        assertTrue("No event created for jcr:lockIsDeep", paths.contains(lockIsDeepPath));
    }

