['136', '40', '54', '40', '162', '218', '94', '238', '386', '619', '176', '54', '42', '54', '42', '176', '300', '233', '499', '539', '499', '579', '539', '579', '703', '277', '79', '755', '79', '837', '79', '162', '228', '271', '274', '315', '70', '109', '319', '555', '319', '613', '148', '319', '218', '319', '108', '319', '755', '837', '162', '755', '936', '1870', '73', '66', '228', '262', '154', '79', '162', '837', '41', '42', '112', '135', '47', '86', '426', '276', '138', '91', '555', '613', '148', '555', '218', '555', '183', '555', '108', '555', '2516', '555', '2573', '555', '2488', '555', '2674', '555', '2702', '555', '379', '555', '351', '555', '2342', '555', '2122', '555', '1505', '555', '1417', '555', '323', '555', '1336', '555', '1236', '555', '626', '555', '407', '555', '598', '555', '570', '555', '515', '555', '41', '44', '84', '86', '148', '613', '218', '613', '183', '613', '108', '613', '2516', '613', '2573', '613', '2488', '613', '2674', '613', '2702', '613', '379', '613', '351', '613', '2342', '613', '2122', '613', '1505', '613', '1417', '613', '323', '613', '1336', '613', '1236', '613', '626', '613', '407', '613', '598', '613', '570', '613', '515', '613', '42', '77', '135', '135', '148', '218', '148', '183', '148', '108', '148', '78', '2516', '148', '2573', '148', '2488', '148', '2674', '148', '2702', '148', '379', '148', '351', '148', '2342', '148', '2122', '148', '1505', '148', '1417', '148', '323', '148', '1336', '148', '1236', '148', '626', '148', '407', '148', '598', '148', '570', '148', '515', '148', '125', '530', '183', '218', '218', '108', '218', '78', '2516', '218', '2573', '218', '2488', '218', '2674', '218', '2702', '218', '379', '218', '351', '218', '2342', '218', '2122', '218', '1505', '218', '1417', '218', '323', '218', '1336', '218', '1236', '218', '626', '218', '407', '218', '598', '218', '570', '218', '515', '218', '183', '108', '2516', '183', '2573', '183', '2488', '183', '2674', '183', '2702', '183', '379', '183', '351', '183', '2342', '183', '2122', '183', '1505', '183', '1417', '183', '323', '183', '1336', '183', '1236', '183', '626', '183', '407', '183', '598', '183', '570', '183', '515', '183', '365', '323', '66', '65', '78', '108', '2516', '108', '2573', '108', '2488', '108', '2674', '108', '2702', '108', '379', '108', '351', '108', '2342', '108', '2122', '108', '1505', '108', '1417', '108', '323', '108', '1336', '108', '1236', '108', '626', '108', '407', '108', '598', '108', '570', '108', '515', '108', '1670', '1766', '1593', '1766', '1642', '1766', '1593', '1670', '1642', '1670', '1593', '1642', '124', '208', '208', '293', '208', '431', '1750', '1779', '49', '48', '49', '49', '49', '54', '49', '48', '49', '48', '48', '54', '48', '48', '49', '54', '49', '48', '593', '240', '246', '77', '124', '293', '124', '431', '2516', '2573', '2488', '2516', '2516', '2674', '2516', '2702', '379', '2516', '351', '2516', '2342', '2516', '2122', '2516', '1505', '2516', '1417', '2516', '323', '2516', '1336', '2516', '1236', '2516', '626', '2516', '407', '2516', '598', '2516', '570', '2516', '515', '2516', '2488', '2573', '2573', '2674', '2573', '2702', '379', '2573', '351', '2573', '2342', '2573', '2122', '2573', '1505', '2573', '1417', '2573', '323', '2573', '1336', '2573', '1236', '2573', '626', '2573', '407', '2573', '598', '2573', '570', '2573', '515', '2573', '2488', '2674', '2488', '2702', '379', '2488', '351', '2488', '2342', '2488', '2122', '2488', '1505', '2488', '1417', '2488', '323', '2488', '1336', '2488', '1236', '2488', '626', '2488', '407', '2488', '598', '2488', '570', '2488', '515', '2488', '2674', '2702', '379', '2674', '351', '2674', '2342', '2674', '2122', '2674', '1505', '2674', '1417', '2674', '323', '2674', '1336', '2674', '1236', '2674', '626', '2674', '407', '2674', '598', '2674', '570', '2674', '515', '2674', '379', '2702', '351', '2702', '2342', '2702', '2122', '2702', '1505', '2702', '1417', '2702', '323', '2702', '1336', '2702', '1236', '2702', '626', '2702', '407', '2702', '598', '2702', '570', '2702', '515', '2702', '351', '379', '379', '2342', '379', '2122', '379', '1505', '379', '1417', '323', '379', '379', '1336', '379', '1236', '379', '626', '379', '407', '379', '598', '379', '570', '379', '515', '351', '2342', '351', '2122', '351', '1505', '351', '1417', '323', '351', '351', '1336', '351', '1236', '351', '626', '351', '407', '351', '598', '351', '570', '351', '515', '293', '431', '2122', '2342', '1505', '2342', '1417', '2342', '323', '2342', '1336', '2342', '1236', '2342', '626', '2342', '407', '2342', '598', '2342', '570', '2342', '515', '2342', '1505', '2122', '1417', '2122', '323', '2122', '1336', '2122', '1236', '2122', '626', '2122', '407', '2122', '598', '2122', '570', '2122', '515', '2122', '1417', '1505', '323', '1505', '1336', '1505', '1236', '1505', '626', '1505', '407', '1505', '598', '1505', '570', '1505', '515', '1505', '323', '1417', '1336', '1417', '1236', '1417', '626', '1417', '407', '1417', '598', '1417', '570', '1417', '515', '1417', '323', '1336', '323', '1236', '323', '626', '323', '407', '323', '598', '323', '570', '323', '515', '1236', '1336', '626', '1336', '407', '1336', '598', '1336', '570', '1336', '515', '1336', '626', '1236', '407', '1236', '598', '1236', '570', '1236', '515', '1236', '407', '626', '598', '626', '570', '626', '515', '626', '407', '598', '407', '570', '407', '515', '570', '598', '515', '598', '515', '570', '201', '302', '179', '201', '48', '54', '206', '233', '206', '185', '206', '253', '185', '233', '253', '233', '253', '185', '101', '297', '137', '176', '784', '364', '178', '379', '231', '258', '149', '258', '122', '258', '97', '258', '258', '285', '176', '258', '70', '93', '88', '86', '340', '369', '369', '1720', '149', '231', '122', '231', '97', '231', '231', '285', '176', '231', '155', '155', '55', '111', '111', '140', '84', '111', '122', '149', '97', '149', '149', '285', '149', '176', '97', '122', '122', '285', '122', '176', '55', '140', '55', '84', '59', '95', '48', '59', '92', '125', '143', '173', '116', '143', '92', '124', '101', '146', '84', '111', '116', '173', '44', '721', '531', '341', '491', '187', '179', '302', '167', '194', '48', '46', '41', '83', '79', '104', '79', '128', '104', '128', '59', '397', '228', '59', '36', '35', '35', '59', '35', '58', '35', '32', '46', '45', '84', '140', '344', '558', '228', '397', '334', '355', '36', '59', '36', '58', '36', '32', '59', '58', '32', '59', '97', '285', '97', '176', '67', '97', '32', '58', '340', '1720', '340', '397', '397', '1720', '570', '589', '34', '36', '359', '591', '483', '440', '451', '440', '166', '440', '117', '440', '135', '440', '153', '440', '401', '440', '420', '440', '2551', '440', '979', '440', '963', '440', '766', '440', '748', '440', '731', '440', '686', '440', '670', '440', '654', '440', '500', '440', '467', '440', '435', '440', '307', '440', '40', '70', '40', '100', '40', '130', '70', '100', '70', '130', '69', '88', '260', '124', '222', '124', '100', '130', '72', '95', '72', '118', '72', '141', '95', '118', '95', '141', '91', '116', '222', '260', '118', '141', '43', '43', '96', '96', '31', '32', '52', '67', '89', '67', '89', '52', '176', '285', '67', '285', '67', '176', '99', '87', '39', '43', '202', '142', '202', '155', '142', '155', '132', '141', '51', '141', '60', '141', '141', '180', '79', '141', '99', '141', '141', '160', '51', '132', '132', '60', '132', '171', '132', '151', '90', '132', '70', '132', '51', '60', '51', '171', '51', '151', '51', '90', '51', '70', '334', '183', '93', '113', '93', '132', '113', '132', '60', '180', '60', '79', '60', '99', '60', '160', '81', '206', '96', '115', '140', '158', '156', '177', '323', '345', '58', '61', '702', '1922', '1922', '206', '1922', '2188', '79', '180', '99', '180', '160', '180', '2753', '79', '59', '56', '56', '83', '60', '56', '56', '82', '123', '130', '123', '127', '702', '206', '702', '2188', '451', '483', '166', '483', '483', '117', '483', '135', '483', '153', '483', '401', '483', '420', '483', '2551', '483', '979', '483', '963', '483', '766', '483', '748', '483', '731', '483', '686', '483', '670', '483', '654', '483', '500', '467', '483', '435', '483', '307', '483', '127', '130', '103', '97', '166', '451', '451', '117', '451', '135', '451', '153', '451', '401', '451', '420', '451', '2551', '451', '979', '451', '963', '451', '766', '451', '748', '451', '731', '451', '686', '451', '670', '451', '654', '451', '500', '451', '467', '435', '451', '307', '451', '79', '99', '79', '160', '151', '79', '70', '79', '166', '117', '166', '135', '166', '153', '166', '401', '166', '420', '166', '2551', '166', '979', '166', '963', '166', '766', '166', '748', '166', '731', '166', '686', '166', '670', '166', '654', '166', '500', '166', '467', '166', '435', '166', '307', '2188', '206', '184', '379', '99', '160', '151', '160', '70', '160', '94', '476', '94', '495', '94', '514', '117', '135', '117', '153', '117', '401', '117', '420', '2551', '117', '979', '117', '963', '117', '766', '117', '748', '117', '731', '117', '686', '117', '670', '117', '654', '117', '500', '117', '467', '117', '435', '117', '307', '117', '135', '153', '135', '401', '135', '420', '2551', '135', '979', '135', '963', '135', '766', '135', '748', '135', '731', '135', '686', '135', '670', '135', '654', '135', '500', '135', '467', '135', '435', '135', '307', '135', '151', '171', '90', '171', '70', '171', '153', '401', '153', '420', '2551', '153', '979', '153', '963', '153', '766', '153', '748', '153', '731', '153', '686', '153', '670', '153', '654', '153', '500', '153', '467', '153', '435', '153', '307', '153', '90', '151', '70', '151', '401', '420', '2551', '401', '979', '401', '963', '401', '766', '401', '748', '401', '731', '401', '686', '401', '670', '401', '654', '401', '500', '401', '467', '401', '435', '401', '307', '401', '2551', '420', '979', '420', '963', '420', '766', '420', '748', '420', '731', '420', '686', '420', '670', '420', '654', '420', '500', '420', '467', '420', '435', '420', '307', '420', '476', '495', '476', '514', '70', '90', '495', '514', '51', '583', '76', '583', '49', '583', '85', '583', '72', '583', '77', '583', '68', '583', '583', '149', '91', '583', '121', '583', '583', '182', '108', '583', '88', '583', '56', '583', '70', '583', '105', '583', '83', '583', '29', '35', '59', '83', '60', '59', '59', '82', '148', '166', '73', '95', '248', '1045', '161', '178', '119', '56', '119', '56', '60', '83', '83', '82', '60', '82', '46', '461', '244', '265', '199', '265', '155', '265', '265', '392', '265', '413', '75', '113', '75', '94', '155', '199', '199', '392', '199', '413', '94', '113', '979', '2551', '963', '2551', '2551', '558', '766', '2551', '748', '2551', '731', '2551', '686', '2551', '670', '2551', '654', '2551', '500', '2551', '467', '2551', '435', '2551', '307', '2551', '155', '392', '155', '413', '1110', '304', '1110', '1811', '543', '1110', '963', '979', '979', '558', '766', '979', '748', '979', '731', '979', '686', '979', '670', '979', '654', '979', '500', '979', '467', '979', '435', '979', '307', '979', '392', '413', '161', '177', '161', '214', '963', '558', '766', '963', '748', '963', '731', '963', '686', '963', '670', '963', '654', '963', '500', '963', '467', '963', '435', '963', '307', '963', '56', '56', '284', '114', '71', '81', '455', '688', '766', '558', '748', '558', '731', '558', '686', '558', '670', '558', '654', '558', '500', '558', '467', '558', '435', '558', '307', '558', '273', '1616', '524', '220', '177', '214', '748', '766', '731', '766', '686', '766', '670', '766', '654', '766', '500', '766', '467', '766', '435', '766', '307', '766', '731', '748', '686', '748', '670', '748', '654', '748', '500', '748', '467', '748', '435', '748', '307', '748', '686', '731', '670', '731', '654', '731', '500', '731', '467', '731', '435', '731', '307', '731', '102', '118', '819', '857', '670', '686', '654', '686', '500', '686', '467', '686', '435', '686', '307', '686', '654', '670', '500', '670', '467', '670', '435', '670', '307', '670', '500', '654', '467', '654', '435', '654', '307', '654', '113', '348', '467', '500', '435', '500', '307', '500', '435', '467', '307', '467', '307', '435', '278', '299', '108', '81', '108', '88', '108', '174', '88', '81', '81', '174', '88', '174', '94', '112', '148', '167', '113', '133', '1811', '304', '543', '304', '327', '345', '1572', '1746', '125', '133', '123', '133', '71', '71', '237', '321', '237', '457', '152', '237', '51', '237', '76', '237', '237', '49', '93', '237', '237', '96', '237', '85', '72', '237', '237', '77', '68', '237', '237', '149', '237', '91', '121', '237', '237', '182', '108', '237', '237', '88', '237', '56', '76', '237', '237', '70', '105', '237', '83', '237', '321', '457', '152', '321', '51', '321', '76', '321', '321', '49', '93', '321', '321', '96', '321', '85', '72', '321', '321', '77', '68', '321', '321', '149', '321', '91', '121', '321', '321', '182', '108', '321', '321', '88', '321', '56', '76', '321', '321', '70', '105', '321', '83', '321', '152', '457', '51', '457', '76', '457', '457', '49', '93', '457', '457', '96', '457', '85', '72', '457', '457', '77', '68', '457', '457', '149', '457', '91', '121', '457', '457', '182', '108', '457', '457', '88', '457', '56', '76', '457', '457', '70', '105', '457', '83', '457', '185', '70', '51', '152', '76', '152', '152', '49', '93', '152', '152', '96', '152', '85', '72', '152', '152', '77', '68', '152', '152', '149', '152', '91', '121', '152', '152', '182', '108', '152', '152', '88', '152', '56', '76', '152', '152', '70', '105', '152', '83', '152', '48', '65', '76', '51', '51', '49', '93', '51', '51', '96', '51', '85', '72', '51', '51', '77', '51', '68', '51', '149', '51', '91', '121', '51', '51', '182', '108', '51', '51', '88', '51', '56', '76', '51', '51', '70', '105', '51', '51', '83', '76', '49', '76', '93', '76', '96', '76', '85', '72', '76', '76', '77', '76', '68', '76', '149', '76', '91', '76', '121', '76', '182', '76', '108', '76', '88', '76', '56', '76', '76', '76', '70', '105', '76', '76', '83', '93', '49', '96', '49', '85', '49', '72', '49', '77', '49', '68', '49', '49', '149', '91', '49', '121', '49', '49', '182', '108', '49', '88', '49', '49', '56', '76', '49', '49', '70', '105', '49', '83', '49', '93', '96', '93', '85', '72', '93', '93', '77', '93', '68', '93', '149', '93', '91', '121', '93', '93', '182', '108', '93', '93', '88', '93', '56', '76', '93', '93', '70', '105', '93', '93', '83', '210', '963', '125', '123', '54', '112', '96', '85', '72', '96', '96', '77', '68', '96', '96', '149', '96', '91', '121', '96', '96', '182', '108', '96', '96', '88', '96', '56', '76', '96', '96', '70', '105', '96', '83', '96', '39', '54', '1067', '1087', '838', '877', '136', '152', '120', '152', '104', '152', '120', '136', '104', '136', '104', '120', '72', '85', '85', '77', '68', '85', '85', '149', '85', '91', '121', '85', '85', '182', '108', '85', '85', '88', '85', '56', '76', '85', '85', '70', '105', '85', '83', '85', '2901', '2915', '2810', '2915', '2474', '2915', '1908', '2915', '1776', '2915', '556', '2915', '2810', '2901', '2474', '2901', '1908', '2901', '1776', '2901', '556', '2901', '2474', '2810', '1908', '2810', '1776', '2810', '556', '2810', '1908', '2474', '1776', '2474', '556', '2474', '1776', '1908', '556', '1908', '543', '1811', '556', '1776', '221', '53', '791', '805', '144', '135', '135', '135', '250', '120', '120', '120', '281', '304', '239', '304', '217', '304', '239', '281', '217', '281', '198', '262', '217', '239', '279', '298', '87', '102', '72', '77', '72', '68', '72', '149', '72', '91', '72', '121', '72', '182', '72', '108', '72', '88', '72', '56', '72', '76', '72', '70', '105', '72', '72', '83', '68', '77', '77', '149', '91', '77', '121', '77', '77', '182', '108', '77', '77', '88', '77', '56', '76', '77', '77', '70', '105', '77', '83', '77', '176', '121', '121', '143', '68', '149', '68', '91', '121', '68', '68', '182', '108', '68', '68', '88', '68', '56', '76', '68', '68', '70', '105', '68', '68', '83', '91', '149', '121', '149', '182', '149', '108', '149', '88', '149', '56', '149', '76', '149', '70', '149', '105', '149', '83', '149', '121', '91', '91', '182', '108', '91', '91', '88', '91', '56', '76', '91', '91', '70', '105', '91', '83', '91', '176', '143', '121', '182', '121', '108', '121', '88', '121', '56', '76', '121', '121', '70', '105', '121', '121', '83', '108', '182', '88', '182', '56', '182', '76', '182', '70', '182', '105', '182', '83', '182', '108', '88', '108', '56', '76', '108', '108', '70', '105', '108', '108', '83', '88', '56', '76', '88', '88', '70', '105', '88', '83', '88', '160', '179', '130', '179', '130', '160', '119', '137', '865', '1112', '822', '1112', '779', '1112', '822', '865', '779', '865', '779', '822', '76', '56', '70', '56', '105', '56', '83', '56', '76', '70', '105', '76', '76', '83', '105', '70', '83', '70', '105', '83', '250', '120', '144', '135', '469', '487', '433', '487', '415', '487', '433', '469', '415', '469', '415', '433']
-------------------------------
['216', '122', '130', '122', '262', '317', '145', '301', '453', '686', '224', '104', '90', '104', '90', '224', '349', '262', '537', '577', '537', '617', '577', '617', '733', '307', '126', '801', '126', '881', '126', '206', '269', '306', '312', '353', '107', '147', '357', '588', '357', '644', '180', '357', '249', '357', '138', '357', '801', '881', '206', '801', '970', '1913', '106', '93', '260', '300', '200', '121', '206', '881', '65', '78', '144', '167', '83', '131', '457', '312', '175', '130', '588', '644', '180', '588', '249', '588', '215', '588', '138', '588', '2542', '588', '2599', '588', '2514', '588', '2700', '588', '2730', '588', '405', '588', '377', '588', '2368', '588', '2148', '588', '1531', '588', '1443', '588', '349', '588', '1363', '588', '1263', '588', '652', '588', '433', '588', '624', '588', '596', '588', '541', '588', '76', '79', '116', '118', '180', '644', '249', '644', '215', '644', '138', '644', '2542', '644', '2599', '644', '2514', '644', '2700', '644', '2730', '644', '405', '644', '377', '644', '2368', '644', '2148', '644', '1531', '644', '1443', '644', '349', '644', '1363', '644', '1263', '644', '652', '644', '433', '644', '624', '644', '596', '644', '541', '644', '75', '113', '162', '165', '180', '249', '180', '215', '180', '138', '180', '105', '2542', '180', '2599', '180', '2514', '180', '2700', '180', '2730', '180', '405', '180', '377', '180', '2368', '180', '2148', '180', '1531', '180', '1443', '180', '349', '180', '1363', '180', '1263', '180', '652', '180', '433', '180', '624', '180', '596', '180', '541', '180', '164', '569', '215', '249', '249', '138', '249', '105', '2542', '249', '2599', '249', '2514', '249', '2700', '249', '2730', '249', '405', '249', '377', '249', '2368', '249', '2148', '249', '1531', '249', '1443', '249', '349', '249', '1363', '249', '1263', '249', '652', '249', '433', '249', '624', '249', '596', '249', '541', '249', '215', '138', '2542', '215', '2599', '215', '2514', '215', '2700', '215', '2730', '215', '405', '215', '377', '215', '2368', '215', '2148', '215', '1531', '215', '1443', '215', '349', '215', '1363', '215', '1263', '215', '652', '215', '433', '215', '624', '215', '596', '215', '541', '215', '401', '361', '88', '92', '105', '138', '2542', '138', '2599', '138', '2514', '138', '2700', '138', '2730', '138', '405', '138', '377', '138', '2368', '138', '2148', '138', '1531', '138', '1443', '138', '349', '138', '1363', '138', '1263', '138', '652', '138', '433', '138', '624', '138', '596', '138', '541', '138', '1699', '1795', '1623', '1795', '1667', '1795', '1623', '1699', '1667', '1699', '1623', '1667', '149', '234', '234', '318', '234', '454', '1776', '1805', '80', '80', '79', '80', '80', '84', '80', '77', '79', '80', '80', '84', '77', '80', '79', '84', '79', '77', '617', '264', '270', '101', '149', '318', '149', '454', '2542', '2599', '2514', '2542', '2542', '2700', '2542', '2730', '405', '2542', '377', '2542', '2368', '2542', '2148', '2542', '1531', '2542', '1443', '2542', '349', '2542', '1363', '2542', '1263', '2542', '652', '2542', '433', '2542', '624', '2542', '596', '2542', '541', '2542', '2514', '2599', '2599', '2700', '2599', '2730', '405', '2599', '377', '2599', '2368', '2599', '2148', '2599', '1531', '2599', '1443', '2599', '349', '2599', '1363', '2599', '1263', '2599', '652', '2599', '433', '2599', '624', '2599', '596', '2599', '541', '2599', '2514', '2700', '2514', '2730', '405', '2514', '377', '2514', '2368', '2514', '2148', '2514', '1531', '2514', '1443', '2514', '349', '2514', '1363', '2514', '1263', '2514', '652', '2514', '433', '2514', '624', '2514', '596', '2514', '541', '2514', '2700', '2730', '405', '2700', '377', '2700', '2368', '2700', '2148', '2700', '1531', '2700', '1443', '2700', '349', '2700', '1363', '2700', '1263', '2700', '652', '2700', '433', '2700', '624', '2700', '596', '2700', '541', '2700', '405', '2730', '377', '2730', '2368', '2730', '2148', '2730', '1531', '2730', '1443', '2730', '349', '2730', '1363', '2730', '1263', '2730', '652', '2730', '433', '2730', '624', '2730', '596', '2730', '541', '2730', '377', '405', '405', '2368', '405', '2148', '405', '1531', '405', '1443', '349', '405', '405', '1363', '405', '1263', '405', '652', '405', '433', '405', '624', '405', '596', '405', '541', '377', '2368', '377', '2148', '377', '1531', '377', '1443', '349', '377', '377', '1363', '377', '1263', '377', '652', '377', '433', '377', '624', '377', '596', '377', '541', '318', '454', '2148', '2368', '1531', '2368', '1443', '2368', '349', '2368', '1363', '2368', '1263', '2368', '652', '2368', '433', '2368', '624', '2368', '596', '2368', '541', '2368', '1531', '2148', '1443', '2148', '349', '2148', '1363', '2148', '1263', '2148', '652', '2148', '433', '2148', '624', '2148', '596', '2148', '541', '2148', '1443', '1531', '349', '1531', '1363', '1531', '1263', '1531', '652', '1531', '433', '1531', '624', '1531', '596', '1531', '541', '1531', '349', '1443', '1363', '1443', '1263', '1443', '652', '1443', '433', '1443', '624', '1443', '596', '1443', '541', '1443', '349', '1363', '349', '1263', '349', '652', '349', '433', '349', '624', '349', '596', '349', '541', '1263', '1363', '652', '1363', '433', '1363', '624', '1363', '596', '1363', '541', '1363', '652', '1263', '433', '1263', '624', '1263', '596', '1263', '541', '1263', '433', '652', '624', '652', '596', '652', '541', '652', '433', '624', '433', '596', '433', '541', '596', '624', '541', '624', '541', '596', '226', '323', '199', '226', '77', '84', '250', '278', '250', '230', '250', '297', '230', '278', '297', '278', '297', '230', '134', '332', '163', '197', '813', '395', '201', '405', '256', '283', '174', '283', '147', '283', '120', '283', '283', '307', '198', '283', '90', '113', '104', '103', '365', '395', '395', '1743', '174', '256', '147', '256', '120', '256', '256', '307', '198', '256', '181', '181', '82', '138', '138', '165', '109', '138', '147', '174', '120', '174', '174', '307', '174', '198', '120', '147', '147', '307', '147', '198', '82', '165', '82', '109', '83', '118', '77', '83', '123', '150', '171', '200', '141', '171', '122', '154', '121', '166', '109', '134', '141', '200', '68', '745', '556', '362', '510', '206', '199', '323', '192', '217', '77', '75', '66', '108', '102', '126', '102', '150', '126', '150', '79', '421', '251', '79', '58', '57', '57', '81', '57', '80', '57', '54', '68', '64', '109', '165', '367', '573', '251', '421', '351', '373', '58', '81', '58', '80', '58', '54', '81', '80', '54', '81', '120', '307', '120', '198', '88', '120', '54', '80', '365', '1743', '365', '418', '418', '1743', '587', '604', '52', '54', '378', '610', '498', '459', '465', '459', '180', '459', '132', '459', '150', '459', '168', '459', '417', '459', '437', '459', '2565', '459', '993', '459', '977', '459', '780', '459', '764', '459', '746', '459', '700', '459', '684', '459', '668', '459', '513', '459', '481', '459', '449', '459', '321', '459', '68', '98', '68', '128', '68', '161', '98', '128', '98', '161', '85', '104', '279', '143', '241', '143', '128', '161', '93', '116', '93', '139', '93', '162', '116', '139', '116', '162', '114', '141', '241', '279', '139', '162', '64', '64', '118', '118', '51', '47', '70', '85', '106', '85', '106', '70', '198', '307', '88', '307', '88', '198', '117', '106', '60', '65', '226', '160', '226', '173', '160', '173', '149', '158', '68', '158', '77', '158', '158', '198', '97', '158', '117', '158', '158', '178', '68', '149', '149', '77', '149', '189', '149', '169', '108', '149', '88', '149', '68', '77', '68', '189', '68', '169', '68', '108', '68', '88', '352', '203', '111', '130', '111', '149', '130', '149', '77', '198', '77', '97', '77', '117', '77', '178', '98', '223', '113', '132', '156', '174', '175', '197', '343', '365', '69', '74', '719', '1939', '1939', '224', '1939', '2203', '97', '198', '117', '198', '178', '198', '2771', '96', '75', '72', '72', '99', '76', '72', '72', '98', '142', '149', '142', '146', '719', '224', '719', '2203', '465', '498', '180', '498', '498', '132', '498', '150', '498', '168', '498', '417', '498', '437', '498', '2565', '498', '993', '498', '977', '498', '780', '498', '764', '498', '746', '498', '700', '498', '684', '498', '668', '498', '513', '481', '498', '449', '498', '321', '498', '146', '149', '115', '108', '180', '465', '465', '132', '465', '150', '465', '168', '465', '417', '465', '437', '465', '2565', '465', '993', '465', '977', '465', '780', '465', '764', '465', '746', '465', '700', '465', '684', '465', '668', '465', '513', '465', '481', '449', '465', '321', '465', '97', '117', '97', '178', '169', '97', '88', '97', '180', '132', '180', '150', '180', '168', '180', '417', '180', '437', '180', '2565', '180', '993', '180', '977', '180', '780', '180', '764', '180', '746', '180', '700', '180', '684', '180', '668', '180', '513', '180', '481', '180', '449', '180', '321', '2203', '224', '200', '395', '117', '178', '169', '178', '88', '178', '110', '492', '110', '511', '110', '531', '132', '150', '132', '168', '132', '417', '132', '437', '2565', '132', '993', '132', '977', '132', '780', '132', '764', '132', '746', '132', '700', '132', '684', '132', '668', '132', '513', '132', '481', '132', '449', '132', '321', '132', '150', '168', '150', '417', '150', '437', '2565', '150', '993', '150', '977', '150', '780', '150', '764', '150', '746', '150', '700', '150', '684', '150', '668', '150', '513', '150', '481', '150', '449', '150', '321', '150', '169', '189', '108', '189', '88', '189', '168', '417', '168', '437', '2565', '168', '993', '168', '977', '168', '780', '168', '764', '168', '746', '168', '700', '168', '684', '168', '668', '168', '513', '168', '481', '168', '449', '168', '321', '168', '108', '169', '88', '169', '417', '437', '2565', '417', '993', '417', '977', '417', '780', '417', '764', '417', '746', '417', '700', '417', '684', '417', '668', '417', '513', '417', '481', '417', '449', '417', '321', '417', '2565', '437', '993', '437', '977', '437', '780', '437', '764', '437', '746', '437', '700', '437', '684', '437', '668', '437', '513', '437', '481', '437', '449', '437', '321', '437', '492', '511', '492', '531', '88', '108', '511', '531', '66', '602', '91', '602', '64', '602', '98', '602', '88', '602', '93', '602', '83', '602', '602', '172', '108', '602', '142', '602', '602', '200', '127', '602', '104', '602', '71', '602', '85', '602', '120', '602', '98', '602', '42', '49', '75', '99', '76', '75', '75', '98', '164', '183', '92', '114', '267', '1065', '176', '191', '139', '74', '139', '74', '76', '99', '99', '98', '76', '98', '69', '483', '263', '299', '220', '299', '173', '299', '299', '411', '299', '432', '92', '130', '92', '111', '173', '220', '220', '411', '220', '432', '111', '130', '993', '2565', '977', '2565', '2565', '573', '780', '2565', '764', '2565', '746', '2565', '700', '2565', '684', '2565', '668', '2565', '513', '2565', '481', '2565', '449', '2565', '321', '2565', '173', '411', '173', '432', '1122', '316', '1122', '1822', '554', '1122', '977', '993', '993', '573', '780', '993', '764', '993', '746', '993', '700', '993', '684', '993', '668', '993', '513', '993', '481', '993', '449', '993', '321', '993', '411', '432', '175', '191', '175', '226', '977', '573', '780', '977', '764', '977', '746', '977', '700', '977', '684', '977', '668', '977', '513', '977', '481', '977', '449', '977', '321', '977', '74', '74', '300', '130', '91', '95', '472', '705', '780', '573', '764', '573', '746', '573', '700', '573', '684', '573', '668', '573', '513', '573', '481', '573', '449', '573', '321', '573', '292', '1635', '542', '238', '191', '226', '764', '780', '746', '780', '700', '780', '684', '780', '668', '780', '513', '780', '481', '780', '449', '780', '321', '780', '746', '764', '700', '764', '684', '764', '668', '764', '513', '764', '481', '764', '449', '764', '321', '764', '700', '746', '684', '746', '668', '746', '513', '746', '481', '746', '449', '746', '321', '746', '115', '131', '836', '875', '684', '700', '668', '700', '513', '700', '481', '700', '449', '700', '321', '700', '668', '684', '513', '684', '481', '684', '449', '684', '321', '684', '513', '668', '481', '668', '449', '668', '321', '668', '130', '365', '481', '513', '449', '513', '321', '513', '449', '481', '321', '481', '321', '449', '292', '313', '124', '97', '124', '104', '124', '190', '104', '97', '97', '190', '104', '190', '109', '127', '164', '183', '131', '151', '1822', '316', '554', '316', '343', '361', '1590', '1763', '139', '147', '137', '147', '88', '88', '252', '336', '252', '472', '167', '252', '66', '252', '91', '252', '252', '64', '108', '252', '252', '110', '252', '98', '88', '252', '252', '93', '83', '252', '252', '172', '252', '108', '142', '252', '252', '200', '127', '252', '252', '104', '252', '71', '92', '252', '252', '85', '120', '252', '98', '252', '336', '472', '167', '336', '66', '336', '91', '336', '336', '64', '108', '336', '336', '110', '336', '98', '88', '336', '336', '93', '83', '336', '336', '172', '336', '108', '142', '336', '336', '200', '127', '336', '336', '104', '336', '71', '92', '336', '336', '85', '120', '336', '98', '336', '167', '472', '66', '472', '91', '472', '472', '64', '108', '472', '472', '110', '472', '98', '88', '472', '472', '93', '83', '472', '472', '172', '472', '108', '142', '472', '472', '200', '127', '472', '472', '104', '472', '71', '92', '472', '472', '85', '120', '472', '98', '472', '200', '85', '66', '167', '91', '167', '167', '64', '108', '167', '167', '110', '167', '98', '88', '167', '167', '93', '83', '167', '167', '172', '167', '108', '142', '167', '167', '200', '127', '167', '167', '104', '167', '71', '92', '167', '167', '85', '120', '167', '98', '167', '62', '79', '91', '66', '66', '64', '108', '66', '66', '110', '66', '98', '88', '66', '66', '93', '66', '83', '66', '172', '66', '108', '142', '66', '66', '200', '127', '66', '66', '104', '66', '71', '92', '66', '66', '85', '120', '66', '66', '98', '91', '64', '91', '108', '91', '110', '91', '98', '88', '91', '91', '93', '91', '83', '91', '172', '91', '108', '91', '142', '91', '200', '91', '127', '91', '104', '91', '71', '92', '91', '91', '85', '120', '91', '91', '98', '108', '64', '110', '64', '98', '64', '88', '64', '93', '64', '83', '64', '64', '172', '108', '64', '142', '64', '64', '200', '127', '64', '104', '64', '64', '71', '92', '64', '64', '85', '120', '64', '98', '64', '108', '110', '108', '98', '88', '108', '108', '93', '108', '83', '108', '172', '108', '108', '142', '108', '108', '200', '127', '108', '108', '104', '108', '71', '92', '108', '108', '85', '120', '108', '108', '98', '226', '980', '139', '137', '68', '127', '110', '98', '88', '110', '110', '93', '83', '110', '110', '172', '110', '108', '142', '110', '110', '200', '127', '110', '110', '104', '110', '71', '92', '110', '110', '85', '120', '110', '98', '110', '50', '65', '1085', '1104', '849', '888', '150', '166', '134', '166', '118', '166', '134', '150', '118', '150', '118', '134', '88', '98', '98', '93', '83', '98', '98', '172', '98', '108', '142', '98', '98', '200', '127', '98', '98', '104', '98', '71', '92', '98', '98', '85', '120', '98', '98', '98', '2913', '2927', '2822', '2927', '2486', '2927', '1920', '2927', '1788', '2927', '568', '2927', '2822', '2913', '2486', '2913', '1920', '2913', '1788', '2913', '568', '2913', '2486', '2822', '1920', '2822', '1788', '2822', '568', '2822', '1920', '2486', '1788', '2486', '568', '2486', '1788', '1920', '568', '1920', '554', '1822', '568', '1788', '233', '65', '802', '816', '157', '148', '148', '148', '263', '133', '133', '133', '297', '320', '255', '320', '232', '320', '255', '297', '232', '297', '210', '274', '232', '255', '296', '315', '100', '114', '88', '93', '88', '83', '88', '172', '88', '108', '88', '142', '88', '200', '88', '127', '88', '104', '88', '71', '88', '92', '88', '85', '120', '88', '88', '98', '83', '93', '93', '172', '108', '93', '142', '93', '93', '200', '127', '93', '93', '104', '93', '71', '92', '93', '93', '85', '120', '93', '98', '93', '191', '136', '136', '158', '83', '172', '83', '108', '142', '83', '83', '200', '127', '83', '83', '104', '83', '71', '92', '83', '83', '85', '120', '83', '83', '98', '108', '172', '142', '172', '200', '172', '127', '172', '104', '172', '71', '172', '92', '172', '85', '172', '120', '172', '98', '172', '142', '108', '108', '200', '127', '108', '108', '104', '108', '71', '92', '108', '108', '85', '120', '108', '98', '108', '191', '158', '142', '200', '142', '127', '142', '104', '142', '71', '92', '142', '142', '85', '120', '142', '142', '98', '127', '200', '104', '200', '71', '200', '92', '200', '85', '200', '120', '200', '98', '200', '127', '104', '127', '71', '92', '127', '127', '85', '120', '127', '127', '98', '104', '71', '92', '104', '104', '85', '120', '104', '98', '104', '172', '191', '143', '191', '143', '172', '135', '153', '880', '1127', '837', '1127', '794', '1127', '837', '880', '794', '880', '794', '837', '92', '71', '85', '71', '120', '71', '98', '71', '92', '85', '120', '92', '92', '98', '120', '85', '98', '85', '120', '98', '263', '133', '157', '148', '485', '503', '449', '503', '431', '503', '449', '485', '431', '485', '431', '449']
-------------------------------
['maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/ProfilesConversionUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/ProfilesConversionUtils.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/configuration/SettingsXmlConfigurationProcessor.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequestPopulator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/path/DefaultModelPathTranslator.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/path/DefaultModelPathTranslator.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultVersionResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultVersionRangeResolver.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/manager/DefaultWagonManager.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/manager/DefaultWagonManager.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsBuilder.java', 'maven/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilder.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java', 'maven/maven-core/src/main/java/org/apache/maven/session/scope/internal/SessionScope.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifecycleTaskSegmentCalculatorStub.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleTaskSegmentCalculator.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/ModelUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-compat/src/test/java/org/apache/maven/artifact/metadata/TestMetadataSource.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/TestMetadataSource.java', 'maven/maven-builder-support/src/main/java/org/apache/maven/building/DefaultProblem.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsProblem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/AbstractMavenProjectTestCase.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/AbstractMavenProjectTestCase.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/factory/DefaultArtifactFactory.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileInjector.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/ActiveProjectArtifact.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/DefaultArtifact.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/SettingsBuildingException.java', 'maven/maven-core/src/main/java/org/apache/maven/toolchain/building/ToolchainsBuildingException.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t08/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t07/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t06/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t08/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t08/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t04/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t08/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t06/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t07/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t07/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t04/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t07/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t06/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t04/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t06/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/transfer/AbstractMavenTransferListener.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/transfer/Slf4jMavenTransferListener.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t04/ProjectInheritanceTest.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorReaderDelegate.java', 'maven/maven-core/src/main/java/org/apache/maven/RepositoryUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/repository/DefaultArtifactRepository.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/interpolation/StringSearchModelInterpolator.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilderTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuildingRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t09/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t09/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/inheritance/t09/ProjectInheritanceTest.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/CacheUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/CacheUtils.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginManager.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginManager.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/extension/internal/CoreExtensionEntry.java', 'maven/maven-core/src/main/java/org/apache/maven/extension/internal/CoreExtensionEntry.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/profiles/manager/DefaultProfileManagerTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/ModelUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/ModelUtilsTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultClasspathTransformationTest.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/prefix/NoPluginFoundForPrefixException.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/version/PluginVersionResolutionException.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorUtils.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/layout/DefaultRepositoryLayout.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/repository/layout/FlatRepositoryLayout.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/MetadataResolutionResult.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/ArtifactResolutionResult.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/logging/impl/Log4j2Configuration.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/logging/impl/Slf4jSimpleConfiguration.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/exception/DefaultExceptionHandlerTest.java', 'maven/maven-core/src/test/java/org/apache/maven/exception/DefaultExceptionHandlerTest.java', 'maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/ProfilesConversionUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/ProfilesConversionUtils.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExceptionTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/LegacyRepositoryLayout.java', 'maven/maven-core/src/test/java/org/apache/maven/repository/LegacyRepositoryLayout.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/PluginPrefixResolverStub.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/PluginVersionResolverStub.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/LocalSnapshotMetadataGenerator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RemoteSnapshotMetadataGenerator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/VersionsMetadataGenerator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RemoteSnapshotMetadataGenerator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/VersionsMetadataGenerator.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/LocalSnapshotMetadataGenerator.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/mapping/LifecyclePhase.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/mapping/Lifecycle.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/transform/LatestArtifactTransformation.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/transform/ReleaseArtifactTransformation.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/test/java/org/apache/maven/repository/TestRepositorySystem.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-core/src/test/java/org/apache/maven/repository/TestRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java', 'maven/maven-core/src/main/java/org/apache/maven/repository/DelegatingLocalArtifactRepository.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/LegacyRepositorySystemTest.java', 'maven/maven-core/src/test/java/org/apache/maven/AbstractCoreMavenComponentTestCase.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectBuilderTest.java', 'maven/maven-settings-builder/src/test/java/org/apache/maven/settings/validation/DefaultSettingsValidatorTest.java', 'maven/maven-settings-builder/src/test/java/org/apache/maven/settings/validation/DefaultSettingsValidatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginManager.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginManager.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/main/java/org/apache/maven/toolchain/merge/MavenToolchainMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifeCyclePluginAnalyzerStub.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-builder-support/src/main/java/org/apache/maven/building/DefaultProblem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelProblem.java', 'maven/maven-builder-support/src/main/java/org/apache/maven/building/DefaultProblem.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsProblem.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsProblem.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelProblem.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ProjectModelResolver.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/RepositoryUtils.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectModelResolverTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/DefaultModelResolverTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/BuildListCalculatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/LifecycleTaskSegmentCalculatorImplTest.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivateTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivateTest.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifecycleExecutionPlanCalculatorStub.java', 'maven/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifecycleExecutionPlanCalculatorStub.java', 'maven/maven-core/src/test/java/org/apache/maven/repository/TestRepositoryConnector.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/repository/TestRepositoryConnector.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecyclePluginAnalyzer.java', 'maven/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java', 'maven/maven-core/src/main/java/org/apache/maven/configuration/BasedirBeanConfigurationPathTranslator.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingRequest.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsBuildingRequest.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/AbstractArtifactResolutionException.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelResolver.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-compat/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/configuration/SettingsXmlConfigurationProcessor.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java', 'maven/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java', 'maven/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/DefaultToolchainManagerTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/DefaultToolchainManagerTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/prefix/internal/DefaultPluginPrefixResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/version/internal/DefaultPluginVersionResolver.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/prefix/internal/DefaultPluginPrefixResolver.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/version/internal/DefaultPluginVersionResolver.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilderTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultWagonManagerTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultWagonManagerTest.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-core/src/main/java/org/apache/maven/project/MavenProject.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsBuilder.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleTaskSegmentCalculator.java', 'maven/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilder.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleTaskSegmentCalculator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/io/DefaultModelWriter.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/io/DefaultSettingsWriter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/ArtifactUtils.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java', 'maven/maven-builder-support/src/test/java/org/apache/maven/building/DefaultProblemTest.java', 'maven/maven-builder-support/src/test/java/org/apache/maven/building/DefaultProblemTest.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/InversionArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/TypeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsBuilder.java', 'maven/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuilder.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/RepositorySystemTest.java', 'maven/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/RepositorySystemTest.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/merge/MavenModelMergerTest.java', 'maven/maven-model-builder/src/test/java/org/apache/maven/model/merge/MavenModelMergerTest.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/transfer/AbstractMavenTransferListener.java', 'maven/maven-embedder/src/main/java/org/apache/maven/cli/transfer/Slf4jMavenTransferListener.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/PomConstructionTest.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/project/DefaultMavenProjectBuilderTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java', 'maven/maven-core/src/test/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java', 'maven/maven-core/src/main/java/org/apache/maven/session/scope/internal/SessionScope.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/ReactorModelCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequestPopulator.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequestPopulator.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequest.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionSetFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AndArtifactFilter.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-core/src/main/java/org/apache/maven/artifact/repository/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/project/LegacyLocalRepositoryManager.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java', 'maven/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java']
startlist:2452
endlist:2452
allpathlist:2452


    public static org.apache.maven.model.Profile convertFromSettingsProfile( Profile settingsProfile )
    {
        org.apache.maven.model.Profile profile = new org.apache.maven.model.Profile();

        profile.setId( settingsProfile.getId() );

        profile.setSource( "settings.xml" );

        Activation settingsActivation = settingsProfile.getActivation();

        if ( settingsActivation != null )
        {
            org.apache.maven.model.Activation activation = new org.apache.maven.model.Activation();

            activation.setActiveByDefault( settingsActivation.isActiveByDefault() );

            activation.setJdk( settingsActivation.getJdk() );

            ActivationProperty settingsProp = settingsActivation.getProperty();

            if ( settingsProp != null )
            {
                org.apache.maven.model.ActivationProperty prop = new org.apache.maven.model.ActivationProperty();

                prop.setName( settingsProp.getName() );
                prop.setValue( settingsProp.getValue() );

                activation.setProperty( prop );
            }

            ActivationOS settingsOs = settingsActivation.getOs();

            if ( settingsOs != null )
            {
                org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();

                os.setArch( settingsOs.getArch() );
                os.setFamily( settingsOs.getFamily() );
                os.setName( settingsOs.getName() );
                os.setVersion( settingsOs.getVersion() );

                activation.setOs( os );
            }

            org.apache.maven.settings.ActivationFile settingsFile = settingsActivation.getFile();

            if ( settingsFile != null )
            {
                ActivationFile file = new ActivationFile();

                file.setExists( settingsFile.getExists() );
                file.setMissing( settingsFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( settingsProfile.getProperties() );

        List<Repository> repos = settingsProfile.getRepositories();
        if ( repos != null )
        {
            for ( Repository repo : repos )
            {
                profile.addRepository( convertFromSettingsRepository( repo ) );
            }
        }

        List<Repository> pluginRepos = settingsProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( Repository pluginRepo : pluginRepos )
            {
                profile.addPluginRepository( convertFromSettingsRepository( pluginRepo ) );
            }
        }

        return profile;
    }


    public static Profile convertFromProfileXmlProfile( org.apache.maven.profiles.Profile profileXmlProfile )
    {
        Profile profile = new Profile();

        profile.setId( profileXmlProfile.getId() );

        profile.setSource( "profiles.xml" );

        org.apache.maven.profiles.Activation profileActivation = profileXmlProfile.getActivation();

        if ( profileActivation != null )
        {
            Activation activation = new Activation();

            activation.setActiveByDefault( profileActivation.isActiveByDefault() );

            activation.setJdk( profileActivation.getJdk() );

            org.apache.maven.profiles.ActivationProperty profileProp = profileActivation.getProperty();

            if ( profileProp != null )
            {
                ActivationProperty prop = new ActivationProperty();

                prop.setName( profileProp.getName() );
                prop.setValue( profileProp.getValue() );

                activation.setProperty( prop );
            }


            ActivationOS profileOs = profileActivation.getOs();

            if ( profileOs != null )
            {
                org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();

                os.setArch( profileOs.getArch() );
                os.setFamily( profileOs.getFamily() );
                os.setName( profileOs.getName() );
                os.setVersion( profileOs.getVersion() );

                activation.setOs( os );
            }

            org.apache.maven.profiles.ActivationFile profileFile = profileActivation.getFile();

            if ( profileFile != null )
            {
                ActivationFile file = new ActivationFile();

                file.setExists( profileFile.getExists() );
                file.setMissing( profileFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( profileXmlProfile.getProperties() );

        List repos = profileXmlProfile.getRepositories();
        if ( repos != null )
        {
            for ( Object repo : repos )
            {
                profile.addRepository( convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) repo ) );
            }
        }

        List pluginRepos = profileXmlProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( Object pluginRepo : pluginRepos )
            {
                profile.addPluginRepository(
                    convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) pluginRepo ) );
            }
        }

        return profile;
    }


    public static Profile convertToSettingsProfile( org.apache.maven.model.Profile modelProfile )
    {
        Profile profile = new Profile();

        profile.setId( modelProfile.getId() );

        org.apache.maven.model.Activation modelActivation = modelProfile.getActivation();

        if ( modelActivation != null )
        {
            Activation activation = new Activation();

            activation.setActiveByDefault( modelActivation.isActiveByDefault() );

            activation.setJdk( modelActivation.getJdk() );

            org.apache.maven.model.ActivationProperty modelProp = modelActivation.getProperty();

            if ( modelProp != null )
            {
                ActivationProperty prop = new ActivationProperty();
                prop.setName( modelProp.getName() );
                prop.setValue( modelProp.getValue() );
                activation.setProperty( prop );
            }

            org.apache.maven.model.ActivationOS modelOs = modelActivation.getOs();

            if ( modelOs != null )
            {
                ActivationOS os = new ActivationOS();

                os.setArch( modelOs.getArch() );
                os.setFamily( modelOs.getFamily() );
                os.setName( modelOs.getName() );
                os.setVersion( modelOs.getVersion() );

                activation.setOs( os );
            }

            ActivationFile modelFile = modelActivation.getFile();

            if ( modelFile != null )
            {
                org.apache.maven.settings.ActivationFile file = new org.apache.maven.settings.ActivationFile();

                file.setExists( modelFile.getExists() );
                file.setMissing( modelFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( modelProfile.getProperties() );

        List<org.apache.maven.model.Repository> repos = modelProfile.getRepositories();
        if ( repos != null )
        {
            for ( org.apache.maven.model.Repository repo : repos )
            {
                profile.addRepository( convertToSettingsRepository( repo ) );
            }
        }

        List<org.apache.maven.model.Repository> pluginRepos = modelProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( org.apache.maven.model.Repository pluginRepo : pluginRepos )
            {
                profile.addPluginRepository( convertToSettingsRepository( pluginRepo ) );
            }
        }

        return profile;
    }


    public static Profile convertFromProfileXmlProfile( org.apache.maven.profiles.Profile profileXmlProfile )
    {
        Profile profile = new Profile();

        profile.setId( profileXmlProfile.getId() );

        profile.setSource( "profiles.xml" );

        org.apache.maven.profiles.Activation profileActivation = profileXmlProfile.getActivation();

        if ( profileActivation != null )
        {
            Activation activation = new Activation();

            activation.setActiveByDefault( profileActivation.isActiveByDefault() );

            activation.setJdk( profileActivation.getJdk() );

            org.apache.maven.profiles.ActivationProperty profileProp = profileActivation.getProperty();

            if ( profileProp != null )
            {
                ActivationProperty prop = new ActivationProperty();

                prop.setName( profileProp.getName() );
                prop.setValue( profileProp.getValue() );

                activation.setProperty( prop );
            }


            ActivationOS profileOs = profileActivation.getOs();

            if ( profileOs != null )
            {
                org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();

                os.setArch( profileOs.getArch() );
                os.setFamily( profileOs.getFamily() );
                os.setName( profileOs.getName() );
                os.setVersion( profileOs.getVersion() );

                activation.setOs( os );
            }

            org.apache.maven.profiles.ActivationFile profileFile = profileActivation.getFile();

            if ( profileFile != null )
            {
                ActivationFile file = new ActivationFile();

                file.setExists( profileFile.getExists() );
                file.setMissing( profileFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( profileXmlProfile.getProperties() );

        List repos = profileXmlProfile.getRepositories();
        if ( repos != null )
        {
            for ( Object repo : repos )
            {
                profile.addRepository( convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) repo ) );
            }
        }

        List pluginRepos = profileXmlProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( Object pluginRepo : pluginRepos )
            {
                profile.addPluginRepository(
                    convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) pluginRepo ) );
            }
        }

        return profile;
    }


    private MavenExecutionRequest populateFromSettings( MavenExecutionRequest request, Settings settings )
        throws MavenExecutionRequestPopulationException
    {
        if ( settings == null )
        {
            return request;
        }

        request.setOffline( settings.isOffline() );

        request.setInteractiveMode( settings.isInteractiveMode() );

        request.setPluginGroups( settings.getPluginGroups() );

        request.setLocalRepositoryPath( settings.getLocalRepository() );

        for ( Server server : settings.getServers() )
        {
            server = server.clone();

            request.addServer( server );
        }

        //  <proxies>
        //    <proxy>
        //      <active>true</active>
        //      <protocol>http</protocol>
        //      <host>proxy.somewhere.com</host>
        //      <port>8080</port>
        //      <username>proxyuser</username>
        //      <password>somepassword</password>
        //      <nonProxyHosts>www.google.com|*.somewhere.com</nonProxyHosts>
        //    </proxy>
        //  </proxies>

        for ( Proxy proxy : settings.getProxies() )
        {
            if ( !proxy.isActive() )
            {
                continue;
            }

            proxy = proxy.clone();

            request.addProxy( proxy );
        }

        // <mirrors>
        //   <mirror>
        //     <id>nexus</id>
        //     <mirrorOf>*</mirrorOf>
        //     <url>http://repository.sonatype.org/content/groups/public</url>
        //   </mirror>
        // </mirrors>

        for ( Mirror mirror : settings.getMirrors() )
        {
            mirror = mirror.clone();

            request.addMirror( mirror );
        }

        request.setActiveProfiles( settings.getActiveProfiles() );

        for ( org.apache.maven.settings.Profile rawProfile : settings.getProfiles() )
        {
            request.addProfile( SettingsUtils.convertFromSettingsProfile( rawProfile ) );

            if ( settings.getActiveProfiles().contains( rawProfile.getId() ) )
            {
                List<Repository> remoteRepositories = rawProfile.getRepositories();
                for ( Repository remoteRepository : remoteRepositories )
                {
                    try
                    {
                        request.addRemoteRepository( 
                            MavenRepositorySystem.buildArtifactRepository( remoteRepository ) );
                    }
                    catch ( InvalidRepositoryException e )
                    {
                        // do nothing for now
                    }
                }
                
                List<Repository> pluginRepositories = rawProfile.getPluginRepositories();
                for ( Repository pluginRepository : pluginRepositories )
                {
                    try
                    {
                        request.addPluginArtifactRepository( 
                            MavenRepositorySystem.buildArtifactRepository( pluginRepository ) );
                    }
                    catch ( InvalidRepositoryException e )
                    {
                        // do nothing for now
                    }
                }                
            }
        }
        return request;
    }


    public MavenExecutionRequest populateFromSettings( MavenExecutionRequest request, Settings settings )
        throws MavenExecutionRequestPopulationException
    {
        if ( settings == null )
        {
            return request;
        }

        request.setOffline( settings.isOffline() );

        request.setInteractiveMode( settings.isInteractiveMode() );

        request.setPluginGroups( settings.getPluginGroups() );

        request.setLocalRepositoryPath( settings.getLocalRepository() );

        for ( Server server : settings.getServers() )
        {
            server = server.clone();

            request.addServer( server );
        }

        //  <proxies>
        //    <proxy>
        //      <active>true</active>
        //      <protocol>http</protocol>
        //      <host>proxy.somewhere.com</host>
        //      <port>8080</port>
        //      <username>proxyuser</username>
        //      <password>somepassword</password>
        //      <nonProxyHosts>www.google.com|*.somewhere.com</nonProxyHosts>
        //    </proxy>
        //  </proxies>

        for ( Proxy proxy : settings.getProxies() )
        {
            if ( !proxy.isActive() )
            {
                continue;
            }

            proxy = proxy.clone();

            request.addProxy( proxy );
        }

        // <mirrors>
        //   <mirror>
        //     <id>nexus</id>
        //     <mirrorOf>*</mirrorOf>
        //     <url>http://repository.sonatype.org/content/groups/public</url>
        //   </mirror>
        // </mirrors>

        for ( Mirror mirror : settings.getMirrors() )
        {
            mirror = mirror.clone();

            request.addMirror( mirror );
        }

        request.setActiveProfiles( settings.getActiveProfiles() );

        for ( org.apache.maven.settings.Profile rawProfile : settings.getProfiles() )
        {
            request.addProfile( SettingsUtils.convertFromSettingsProfile( rawProfile ) );

            if ( settings.getActiveProfiles().contains( rawProfile.getId() ) )
            {
                List<Repository> remoteRepositories = rawProfile.getRepositories();
                for ( Repository remoteRepository : remoteRepositories )
                {
                    try
                    {
                        request.addRemoteRepository( repositorySystem.buildArtifactRepository( remoteRepository ) );
                    }
                    catch ( InvalidRepositoryException e )
                    {
                        // do nothing for now
                    }
                }

                List<Repository> pluginRepositories = rawProfile.getPluginRepositories();
                for ( Repository pluginRepo : pluginRepositories )
                {
                    try
                    {
                        request.addPluginArtifactRepository( repositorySystem.buildArtifactRepository( pluginRepo ) );
                    }
                    catch ( InvalidRepositoryException e )
                    {
                        // do nothing for now
                    }
                }
            }
        }

        return request;
    }    


        protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                     boolean sourceDominant, Map<Object, Object> context )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();
                Map<Object, Plugin> master = new LinkedHashMap<>( tgt.size() * 2 );

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    master.put( key, element );
                }

                Map<Object, List<Plugin>> predecessors = new LinkedHashMap<>();
                List<Plugin> pending = new ArrayList<>();
                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    Plugin existing = master.get( key );
                    if ( existing != null )
                    {
                        mergePlugin( existing, element, sourceDominant, context );

                        if ( !pending.isEmpty() )
                        {
                            predecessors.put( key, pending );
                            pending = new ArrayList<>();
                        }
                    }
                    else
                    {
                        pending.add( element );
                    }
                }

                List<Plugin> result = new ArrayList<>( src.size() + tgt.size() );
                for ( Map.Entry<Object, Plugin> entry : master.entrySet() )
                {
                    List<Plugin> pre = predecessors.get( entry.getKey() );
                    if ( pre != null )
                    {
                        result.addAll( pre );
                    }
                    result.add( entry.getValue() );
                }
                result.addAll( pending );

                target.setPlugins( result );
            }
        }


        protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                     boolean sourceDominant, Map<Object, Object> context )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();
                Map<Object, Plugin> master = new LinkedHashMap<>( src.size() * 2 );

                for ( Plugin element : src )
                {
                    if ( element.isInherited() || !element.getExecutions().isEmpty() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions
                        Plugin plugin = new Plugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergePlugin( plugin, element, sourceDominant, context );

                        Object key = getPluginKey( element );

                        master.put( key, plugin );
                    }
                }

                Map<Object, List<Plugin>> predecessors = new LinkedHashMap<>();
                List<Plugin> pending = new ArrayList<>();
                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin existing = master.get( key );
                    if ( existing != null )
                    {
                        mergePlugin( element, existing, sourceDominant, context );

                        master.put( key, element );

                        if ( !pending.isEmpty() )
                        {
                            predecessors.put( key, pending );
                            pending = new ArrayList<>();
                        }
                    }
                    else
                    {
                        pending.add( element );
                    }
                }

                List<Plugin> result = new ArrayList<>( src.size() + tgt.size() );
                for ( Map.Entry<Object, Plugin> entry : master.entrySet() )
                {
                    List<Plugin> pre = predecessors.get( entry.getKey() );
                    if ( pre != null )
                    {
                        result.addAll( pre );
                    }
                    result.add( entry.getValue() );
                }
                result.addAll( pending );

                target.setPlugins( result );
            }
        }


    public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        if ( repositories == null )
        {
            return null;
        }

        Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>();

        for ( ArtifactRepository repository : repositories )
        {
            String key = repository.getId();

            List<ArtifactRepository> aliasedRepos = reposByKey.get( key );

            if ( aliasedRepos == null )
            {
                aliasedRepos = new ArrayList<>();
                reposByKey.put( key, aliasedRepos );
            }

            aliasedRepos.add( repository );
        }

        List<ArtifactRepository> effectiveRepositories = new ArrayList<>();

        for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() )
        {
            List<ArtifactRepository> mirroredRepos = new ArrayList<>();

            List<ArtifactRepositoryPolicy> releasePolicies =
                new ArrayList<>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                releasePolicies.add( aliasedRepo.getReleases() );
                mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() );
            }

            ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );

            List<ArtifactRepositoryPolicy> snapshotPolicies =
                new ArrayList<>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                snapshotPolicies.add( aliasedRepo.getSnapshots() );
            }

            ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy( snapshotPolicies );

            ArtifactRepository aliasedRepo = aliasedRepos.get( 0 );

            ArtifactRepository effectiveRepository =
                createArtifactRepository( aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(),
                                          snapshotPolicy, releasePolicy );

            effectiveRepository.setAuthentication( aliasedRepo.getAuthentication() );

            effectiveRepository.setProxy( aliasedRepo.getProxy() );

            effectiveRepository.setMirroredRepositories( mirroredRepos );

            effectiveRepositories.add( effectiveRepository );
        }

        return effectiveRepositories;
    }


    public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        if ( repositories == null )
        {
            return null;
        }

        Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>();

        for ( ArtifactRepository repository : repositories )
        {
            String key = repository.getId();

            List<ArtifactRepository> aliasedRepos = reposByKey.get( key );

            if ( aliasedRepos == null )
            {
                aliasedRepos = new ArrayList<>();
                reposByKey.put( key, aliasedRepos );
            }

            aliasedRepos.add( repository );
        }

        List<ArtifactRepository> effectiveRepositories = new ArrayList<>();

        for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() )
        {
            List<ArtifactRepository> mirroredRepos = new ArrayList<>();

            List<ArtifactRepositoryPolicy> releasePolicies =
                    new ArrayList<>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                releasePolicies.add( aliasedRepo.getReleases() );
                mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() );
            }

            ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );

            List<ArtifactRepositoryPolicy> snapshotPolicies =
                    new ArrayList<>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                snapshotPolicies.add( aliasedRepo.getSnapshots() );
            }

            ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy( snapshotPolicies );

            ArtifactRepository aliasedRepo = aliasedRepos.get( 0 );

            ArtifactRepository effectiveRepository =
                    createArtifactRepository( aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(),
                            snapshotPolicy, releasePolicy );

            effectiveRepository.setAuthentication( aliasedRepo.getAuthentication() );

            effectiveRepository.setProxy( aliasedRepo.getProxy() );

            effectiveRepository.setMirroredRepositories( mirroredRepos );

            effectiveRepositories.add( effectiveRepository );
        }

        return effectiveRepositories;
    }


    public void unalignFromBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( unalignFromBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( unalignFromBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( unalignFromBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( unalignFromBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( unalignFromBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( unalignFromBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( unalignFromBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    public void alignToBaseDirectory( Model model, File basedir, ModelBuildingRequest request )
    {
        if ( model == null || basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            build.setScriptSourceDirectory( alignToBaseDirectory( build.getScriptSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>( build.getFilters().size() );
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    public void alignToBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    public void alignToBaseDirectory( Model model, File basedir, ModelBuildingRequest request )
    {
        if ( model == null || basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            build.setScriptSourceDirectory( alignToBaseDirectory( build.getScriptSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>( build.getFilters().size() );
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    public void alignToBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    public void unalignFromBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( unalignFromBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( unalignFromBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( unalignFromBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( unalignFromBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( unalignFromBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( unalignFromBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( unalignFromBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }


    private Versioning readVersions( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                     ArtifactRepository repository, VersionResult result )
    {
        Versioning versioning = null;
        try
        {
            if ( metadata != null )
            {
                try ( SyncContext syncContext = syncContextFactory.newInstance( session, true ) )
                {
                    syncContext.acquire( null, Collections.singleton( metadata ) );

                    if ( metadata.getFile() != null && metadata.getFile().exists() )
                    {
                        try ( final InputStream in = new FileInputStream( metadata.getFile() ) )
                        {
                            versioning = new MetadataXpp3Reader().read( in, false ).getVersioning();

                            /*
                            NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata
                            of the local repository. This is especially troublesome during snapshot resolution so we try
                            to handle that gracefully.
                             */
                            if ( versioning != null && repository instanceof LocalRepository
                                     && versioning.getSnapshot() != null
                                     && versioning.getSnapshot().getBuildNumber() > 0 )
                            {
                                final Versioning repaired = new Versioning();
                                repaired.setLastUpdated( versioning.getLastUpdated() );
                                repaired.setSnapshot( new Snapshot() );
                                repaired.getSnapshot().setLocalCopy( true );
                                versioning = repaired;
                                throw new IOException( "Snapshot information corrupted with remote repository data"
                                                           + ", please verify that no remote repository uses the id '"
                                                           + repository.getId() + "'" );

                            }
                        }
                    }
                }
            }
        }
        catch ( Exception e )
        {
            invalidMetadata( session, trace, metadata, repository, e );
            result.addException( e );
        }

        return ( versioning != null ) ? versioning : new Versioning();
    }


    private Versioning readVersions( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                     ArtifactRepository repository, VersionRangeResult result )
    {
        Versioning versioning = null;
        try
        {
            if ( metadata != null )
            {
                try ( SyncContext syncContext = syncContextFactory.newInstance( session, true ) )
                {
                    syncContext.acquire( null, Collections.singleton( metadata ) );

                    if ( metadata.getFile() != null && metadata.getFile().exists() )
                    {
                        try ( final InputStream in = new FileInputStream( metadata.getFile() ) )
                        {
                            versioning = new MetadataXpp3Reader().read( in, false ).getVersioning();
                        }
                    }
                }
            }
        }
        catch ( Exception e )
        {
            invalidMetadata( session, trace, metadata, repository, e );
            result.addException( e );
        }

        return ( versioning != null ) ? versioning : new Versioning();
    }


    public void testShouldNotMergePluginExecutionWhenExecInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( false ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }


    public void testShouldNotMergePluginExecutionWhenPluginInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( false ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }


    public void testShouldNotMergePluginExecutionWhenExecInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( false ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }


    public void testShouldMergePluginExecutionWhenExecInheritedIsTrueAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNotNull( "test execution should be inherited from parent.", executionMap.get( testId ) );
    }


    public void testShouldNotMergePluginExecutionWhenPluginInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( false ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }


    public void testShouldMergePluginExecutionWhenExecInheritedIsTrueAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNotNull( "test execution should be inherited from parent.", executionMap.get( testId ) );
    }


    private Proxy getProxy( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            ProxySelector selector = session.getProxySelector();
            if ( selector != null )
            {
                RemoteRepository repo = RepositoryUtils.toRepo( repository );
                org.eclipse.aether.repository.Proxy proxy = selector.getProxy( repo );
                if ( proxy != null )
                {
                    Proxy p = new Proxy();
                    p.setHost( proxy.getHost() );
                    p.setProtocol( proxy.getType() );
                    p.setPort( proxy.getPort() );
                    if ( proxy.getAuthentication() != null )
                    {
                        repo = new RemoteRepository.Builder( repo ).setProxy( proxy ).build();
                        AuthenticationContext authCtx = AuthenticationContext.forProxy( session, repo );
                        p.setUserName( authCtx.get( AuthenticationContext.USERNAME ) );
                        p.setPassword( authCtx.get( AuthenticationContext.PASSWORD ) );
                        p.setNtlmDomain( authCtx.get( AuthenticationContext.NTLM_DOMAIN ) );
                        p.setNtlmHost( authCtx.get( AuthenticationContext.NTLM_WORKSTATION ) );
                        authCtx.close();
                    }
                    return p;
                }
            }
        }
        return null;
    }


    private Proxy getProxy( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            ProxySelector selector = session.getProxySelector();
            if ( selector != null )
            {
                RemoteRepository repo = RepositoryUtils.toRepo( repository );
                org.eclipse.aether.repository.Proxy proxy = selector.getProxy( repo );
                if ( proxy != null )
                {
                    Proxy p = new Proxy();
                    p.setHost( proxy.getHost() );
                    p.setProtocol( proxy.getType() );
                    p.setPort( proxy.getPort() );
                    if ( proxy.getAuthentication() != null )
                    {
                        repo = new RemoteRepository.Builder( repo ).setProxy( proxy ).build();
                        AuthenticationContext authCtx = AuthenticationContext.forProxy( session, repo );
                        p.setUserName( authCtx.get( AuthenticationContext.USERNAME ) );
                        p.setPassword( authCtx.get( AuthenticationContext.PASSWORD ) );
                        p.setNtlmDomain( authCtx.get( AuthenticationContext.NTLM_DOMAIN ) );
                        p.setNtlmHost( authCtx.get( AuthenticationContext.NTLM_WORKSTATION ) );
                        authCtx.close();
                    }
                    return p;
                }
            }
        }
        return null;
    }


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                repo = repo.trim();
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                repo = repo.trim();
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }    


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                repo = repo.trim();
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }


    public void testPluginDependenciesInfluenceSorting()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<>();

        MavenProject parentProject = createProject( "groupId", "parent", "1.0" );
        projects.add( parentProject );

        MavenProject declaringProject = createProject( "groupId", "declarer", "1.0" );
        declaringProject.setParent( parentProject );
        declaringProject.getModel().setParent( createParent( parentProject ) );
        projects.add( declaringProject );

        MavenProject pluginLevelDepProject = createProject( "groupId", "plugin-level-dep", "1.0" );
        pluginLevelDepProject.setParent( parentProject );
        pluginLevelDepProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginLevelDepProject );

        MavenProject pluginProject = createProject( "groupId", "plugin", "1.0" );
        pluginProject.setParent( parentProject );
        pluginProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginProject );

        Plugin plugin = createPlugin( pluginProject );

        plugin.addDependency( createDependency( pluginLevelDepProject ) );

        Build build = declaringProject.getModel().getBuild();

        build.addPlugin( plugin );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( parentProject, projects.get( 0 ) );

        // the order of these two is non-deterministic, based on when they're added to the reactor.
        assertTrue( projects.contains( pluginProject ) );
        assertTrue( projects.contains( pluginLevelDepProject ) );

        // the declaring project MUST be listed after the plugin and its plugin-level dep, though.
        assertEquals( declaringProject, projects.get( 3 ) );
    }


    public void testPluginDependenciesInfluenceSorting_DeclarationInParent()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<>();

        MavenProject parentProject = createProject( "groupId", "parent-declarer", "1.0" );
        projects.add( parentProject );

        MavenProject pluginProject = createProject( "groupId", "plugin", "1.0" );
        pluginProject.setParent( parentProject );
        pluginProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginProject );

        MavenProject pluginLevelDepProject = createProject( "groupId", "plugin-level-dep", "1.0" );
        pluginLevelDepProject.setParent( parentProject );
        pluginLevelDepProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginLevelDepProject );

        Plugin plugin = createPlugin( pluginProject );

        plugin.addDependency( createDependency( pluginLevelDepProject ) );

        Build build = parentProject.getModel().getBuild();

        build.addPlugin( plugin );

        projects = new ProjectSorter( projects ).getSortedProjects();

        System.out.println( projects );

        assertEquals( parentProject, projects.get( 0 ) );

        // the order of these two is non-deterministic, based on when they're added to the reactor.
        assertTrue( projects.contains( pluginProject ) );
        assertTrue( projects.contains( pluginLevelDepProject ) );
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            List<Repository> dominant, recessive;
            if ( sourceDominant )
            {
                dominant = src;
                recessive = tgt;
            }
            else
            {
                dominant = tgt;
                recessive = src;
            }

            for ( Repository element : dominant )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : recessive )
            {
                Object key = getRepositoryKey( element );
                if ( !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            List<Repository> dominant, recessive;
            if ( sourceDominant )
            {
                dominant = src;
                recessive = tgt;
            }
            else
            {
                dominant = tgt;
                recessive = src;
            }

            for ( Repository element : dominant )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : recessive )
            {
                Object key = getRepositoryKey( element );
                if ( !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    public AuthenticationInfo getAuthenticationInfo( String id )
    {
        MavenSession session = legacySupport.getSession();

        if ( session != null && id != null )
        {
            MavenExecutionRequest request = session.getRequest();

            if ( request != null )
            {
                List<Server> servers = request.getServers();

                if ( servers != null )
                {
                    for ( Server server : servers )
                    {
                        if ( id.equalsIgnoreCase( server.getId() ) )
                        {
                            SettingsDecryptionResult result =
                                settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( server ) );
                            server = result.getServer();

                            AuthenticationInfo authInfo = new AuthenticationInfo();
                            authInfo.setUserName( server.getUsername() );
                            authInfo.setPassword( server.getPassword() );
                            authInfo.setPrivateKey( server.getPrivateKey() );
                            authInfo.setPassphrase( server.getPassphrase() );

                            return authInfo;
                        }
                    }
                }
            }
        }

        // empty one to prevent NPE
       return new AuthenticationInfo();
    }


    public ProxyInfo getProxy( String protocol )
    {
        MavenSession session = legacySupport.getSession();

        if ( session != null && protocol != null )
        {
            MavenExecutionRequest request = session.getRequest();

            if ( request != null )
            {
                List<Proxy> proxies = request.getProxies();

                if ( proxies != null )
                {
                    for ( Proxy proxy : proxies )
                    {
                        if ( proxy.isActive() && protocol.equalsIgnoreCase( proxy.getProtocol() ) )
                        {
                            SettingsDecryptionResult result =
                                settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( proxy ) );
                            proxy = result.getProxy();

                            ProxyInfo proxyInfo = new ProxyInfo();
                            proxyInfo.setHost( proxy.getHost() );
                            proxyInfo.setType( proxy.getProtocol() );
                            proxyInfo.setPort( proxy.getPort() );
                            proxyInfo.setNonProxyHosts( proxy.getNonProxyHosts() );
                            proxyInfo.setUserName( proxy.getUsername() );
                            proxyInfo.setPassword( proxy.getPassword() );

                            return proxyInfo;
                        }
                    }
                }
            }
        }

        return null;
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }    


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }


    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }


    public Xpp3Dom getGoalConfiguration( String pluginGroupId, String pluginArtifactId, String executionId,
                                         String goalId )
    {
        Xpp3Dom dom = null;

        if ( getBuildPlugins() != null )
        {
            for ( Plugin plugin : getBuildPlugins() )
            {
                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( executionId != null )
                    {
                        PluginExecution execution = plugin.getExecutionsAsMap().get( executionId );
                        if ( execution != null )
                        {
                            // NOTE: The PluginConfigurationExpander already merged the plugin-level config in
                            dom = (Xpp3Dom) execution.getConfiguration();
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }


    public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId )
    {
        Xpp3Dom dom = null;

        // ----------------------------------------------------------------------
        // I would like to be able to lookup the Mojo object using a key but
        // we have a limitation in modello that will be remedied shortly. So
        // for now I have to iterate through and see what we have.
        // ----------------------------------------------------------------------

        if ( getReportPlugins() != null )
        {
            for ( ReportPlugin plugin : getReportPlugins() )
            {
                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( reportSetId != null )
                    {
                        ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );
                        if ( reportSet != null )
                        {
                            Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();
                            if ( executionConfiguration != null )
                            {
                                Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );
                                dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );
                            }
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }


        public CacheKey( Plugin plugin, ClassLoader parentRealm, Map<String, ClassLoader> foreignImports,
                         DependencyFilter dependencyFilter, List<RemoteRepository> repositories,
                         RepositorySystemSession session )
        {
            this.plugin = plugin.clone();
            this.workspace = RepositoryUtils.getWorkspace( session );
            this.localRepo = session.getLocalRepository();
            this.repositories = new ArrayList<>( repositories.size() );
            for ( RemoteRepository repository : repositories )
            {
                if ( repository.isRepositoryManager() )
                {
                    this.repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    this.repositories.add( repository );
                }
            }
            this.parentRealm = parentRealm;
            this.foreignImports =
                ( foreignImports != null ) ? foreignImports : Collections.<String, ClassLoader>emptyMap();
            this.filter = dependencyFilter;

            int hash = 17;
            hash = hash * 31 + CacheUtils.pluginHashCode( plugin );
            hash = hash * 31 + Objects.hashCode( workspace );
            hash = hash * 31 + Objects.hashCode( localRepo );
            hash = hash * 31 + RepositoryUtils.repositoriesHashCode( repositories );
            hash = hash * 31 + Objects.hashCode( parentRealm );
            hash = hash * 31 + this.foreignImports.hashCode();
            hash = hash * 31 + Objects.hashCode( dependencyFilter );
            this.hashCode = hash;
        }


        public CacheKey( Plugin plugin, DependencyFilter extensionFilter, List<RemoteRepository> repositories,
                         RepositorySystemSession session )
        {
            this.plugin = plugin.clone();
            workspace = RepositoryUtils.getWorkspace( session );
            this.localRepo = session.getLocalRepository();
            this.repositories = new ArrayList<>( repositories.size() );
            for ( RemoteRepository repository : repositories )
            {
                if ( repository.isRepositoryManager() )
                {
                    this.repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    this.repositories.add( repository );
                }
            }
            this.filter = extensionFilter;

            int hash = 17;
            hash = hash * 31 + CacheUtils.pluginHashCode( plugin );
            hash = hash * 31 + Objects.hashCode( workspace );
            hash = hash * 31 + Objects.hashCode( localRepo );
            hash = hash * 31 + RepositoryUtils.repositoriesHashCode( repositories );
            hash = hash * 31 + Objects.hashCode( extensionFilter );
            this.hashCode = hash;
        }


    public void testShouldMergeOnePluginWithInheritExecutionWithoutDuplicatingPluginInList()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Build parentContainer = new Build();
        parentContainer.addPlugin( parent );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        Build childContainer = new Build();
        childContainer.addPlugin( child );

        ModelUtils.mergePluginLists( childContainer, parentContainer, true );

        List plugins = childContainer.getPlugins();

        assertEquals( 1, plugins.size() );

        Plugin plugin = (Plugin) plugins.get( 0 );

        assertEquals( 1, plugin.getExecutions().size() );
    }


    public void testShouldMergePluginWithDifferentExecutionFromParentWithoutDuplicatingPluginInList()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Build parentContainer = new Build();
        parentContainer.addPlugin( parent );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution = new PluginExecution();
        childExecution.setId( "testExecution2" );

        child.addExecution( childExecution );


        Build childContainer = new Build();
        childContainer.addPlugin( child );

        ModelUtils.mergePluginLists( childContainer, parentContainer, true );

        List plugins = childContainer.getPlugins();

        assertEquals( 1, plugins.size() );

        Plugin plugin = (Plugin) plugins.get( 0 );

        assertEquals( 2, plugin.getExecutions().size() );
    }


    private Settings readSettings( Source settingsSource, SettingsBuildingRequest request,
                                   DefaultSettingsProblemCollector problems )
    {
        if ( settingsSource == null )
        {
            return new Settings();
        }

        problems.setSource( settingsSource.getLocation() );

        Settings settings;

        try
        {
            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.TRUE );

            try
            {
                settings = settingsReader.read( settingsSource.getInputStream(), options );
            }
            catch ( SettingsParseException e )
            {
                options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );

                settings = settingsReader.read( settingsSource.getInputStream(), options );

                problems.add( SettingsProblem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(),
                              e );
            }
        }
        catch ( SettingsParseException e )
        {
            problems.add( SettingsProblem.Severity.FATAL, "Non-parseable settings " + settingsSource.getLocation()
                + ": " + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
            return new Settings();
        }
        catch ( IOException e )
        {
            problems.add( SettingsProblem.Severity.FATAL, "Non-readable settings " + settingsSource.getLocation()
                + ": " + e.getMessage(), -1, -1, e );
            return new Settings();
        }

        settingsValidator.validate( settings, problems );

        return settings;
    }


    private PersistedToolchains readToolchains( Source toolchainsSource, ToolchainsBuildingRequest request,
                                                ProblemCollector problems )
    {
        if ( toolchainsSource == null )
        {
            return new PersistedToolchains();
        }

        PersistedToolchains toolchains;

        try
        {
            Map<String, ?> options = Collections.singletonMap( ToolchainsReader.IS_STRICT, Boolean.TRUE );

            try
            {
                toolchains = toolchainsReader.read( toolchainsSource.getInputStream(), options );
            }
            catch ( ToolchainsParseException e )
            {
                options = Collections.singletonMap( ToolchainsReader.IS_STRICT, Boolean.FALSE );

                toolchains = toolchainsReader.read( toolchainsSource.getInputStream(), options );

                problems.add( Problem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(),
                              e );
            }
        }
        catch ( ToolchainsParseException e )
        {
            problems.add( Problem.Severity.FATAL, "Non-parseable toolchains " + toolchainsSource.getLocation()
                + ": " + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
            return new PersistedToolchains();
        }
        catch ( IOException e )
        {
            problems.add( Problem.Severity.FATAL, "Non-readable toolchains " + toolchainsSource.getLocation()
                + ": " + e.getMessage(), -1, -1, e );
            return new PersistedToolchains();
        }

        return toolchains;
    }


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }


    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }    


    public boolean isActive( Profile profile )
    {
        Activation activation = profile.getActivation();
        ActivationOS os = activation.getOs();

        boolean result = ensureAtLeastOneNonNull( os );

        if ( result && os.getFamily() != null )
        {
            result = determineFamilyMatch( os.getFamily() );
        }
        if ( result && os.getName() != null )
        {
            result = determineNameMatch( os.getName() );
        }
        if ( result && os.getArch() != null )
        {
            result = determineArchMatch( os.getArch() );
        }
        if ( result && os.getVersion() != null )
        {
            result = determineVersionMatch( os.getVersion() );
        }
        return result;
    }


    public boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationOS os = activation.getOs();

        if ( os == null )
        {
            return false;
        }

        boolean active = ensureAtLeastOneNonNull( os );

        if ( active && os.getFamily() != null )
        {
            active = determineFamilyMatch( os.getFamily() );
        }
        if ( active && os.getName() != null )
        {
            active = determineNameMatch( os.getName() );
        }
        if ( active && os.getArch() != null )
        {
            active = determineArchMatch( os.getArch() );
        }
        if ( active && os.getVersion() != null )
        {
            active = determineVersionMatch( os.getVersion() );
        }

        return active;
    }


    public <T> Provider<T> scope( final Key<T> key, final Provider<T> unscoped )
    {
        return new Provider<T>()
        {
            @SuppressWarnings( "unchecked" )
            public T get()
            {
                LinkedList<ScopeState> stack = values.get();
                if ( stack == null || stack.isEmpty() )
                {
                    throw new OutOfScopeException( "Cannot access " + key + " outside of a scoping block" );
                }

                ScopeState state = stack.getFirst();

                Provider<?> seeded = state.seeded.get( key );

                if ( seeded != null )
                {
                    return (T) seeded.get();
                }

                T provided = (T) state.provided.get( key );
                if ( provided == null && unscoped != null )
                {
                    provided = unscoped.get();
                    state.provided.put( key, provided );
                }

                return provided;
            }
        };
    }


    public <T> Provider<T> scope( final Key<T> key, final Provider<T> unscoped )
    {
        return new Provider<T>()
        {
            @SuppressWarnings( "unchecked" )
            public T get()
            {
                LinkedList<ScopeState> stack = values.get();
                if ( stack == null || stack.isEmpty() )
                {
                    throw new OutOfScopeException( "Cannot access " + key + " outside of a scoping block" );
                }

                ScopeState state = stack.getFirst();

                Provider<?> seeded = state.seeded.get( key );

                if ( seeded != null )
                {
                    return (T) seeded.get();
                }

                T provided = (T) state.provided.get( key );
                if ( provided == null && unscoped != null )
                {
                    provided = unscoped.get();
                    state.provided.put( key, provided );
                }

                return provided;
            }
        };
    }


    public List<TaskSegment> calculateTaskSegments( MavenSession session, List<String> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        List<TaskSegment> taskSegments = new ArrayList<>( tasks.size() );

        TaskSegment currentSegment = null;

        for ( String task : tasks )
        {
            if ( aggr.equals( task ) )
            {
                boolean aggregating = true;

                if ( currentSegment == null || currentSegment.isAggregating() != aggregating )
                {
                    currentSegment = new TaskSegment( aggregating );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new GoalTask( task ) );
            }
            else
            {
                // lifecycle phase
                if ( currentSegment == null || currentSegment.isAggregating() )
                {
                    currentSegment = new TaskSegment( false );
                    taskSegments.add( currentSegment );
                }
                currentSegment.getTasks().add( new LifecycleTask( task ) );
            }
        }

        return taskSegments;
    }


    public List<TaskSegment> calculateTaskSegments( MavenSession session, List<String> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        List<TaskSegment> taskSegments = new ArrayList<>( tasks.size() );

        TaskSegment currentSegment = null;

        for ( String task : tasks )
        {
            if ( isGoalSpecification( task ) )
            {
                // "pluginPrefix:goal" or "groupId:artifactId[:version]:goal"

                lifecyclePluginResolver.resolveMissingPluginVersions( session.getTopLevelProject(), session );

                MojoDescriptor mojoDescriptor =
                    mojoDescriptorCreator.getMojoDescriptor( task, session, session.getTopLevelProject() );

                boolean aggregating = mojoDescriptor.isAggregator() || !mojoDescriptor.isProjectRequired();

                if ( currentSegment == null || currentSegment.isAggregating() != aggregating )
                {
                    currentSegment = new TaskSegment( aggregating );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new GoalTask( task ) );
            }
            else
            {
                // lifecycle phase

                if ( currentSegment == null || currentSegment.isAggregating() )
                {
                    currentSegment = new TaskSegment( false );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new LifecycleTask( task ) );
            }
        }

        return taskSegments;
    }


    private static void mergeReportSetDefinitions( ReportSet child, ReportSet parent )
    {
        List<String> parentReports = parent.getReports();
        List<String> childReports = child.getReports();

        List<String> reports = new ArrayList<>();

        if ( ( childReports != null ) && !childReports.isEmpty() )
        {
            reports.addAll( childReports );
        }

        if ( parentReports != null )
        {
            for ( String report : parentReports )
            {
                if ( !reports.contains( report ) )
                {
                    reports.add( report );
                }
            }
        }

        child.setReports( reports );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }


    private static void mergePluginExecutionDefinitions( PluginExecution child, PluginExecution parent )
    {
        if ( child.getPhase() == null )
        {
            child.setPhase( parent.getPhase() );
        }

        List<String> parentGoals = parent.getGoals();
        List<String> childGoals = child.getGoals();

        List<String> goals = new ArrayList<>();

        if ( ( childGoals != null ) && !childGoals.isEmpty() )
        {
            goals.addAll( childGoals );
        }

        if ( parentGoals != null )
        {
            for (  String goal : parentGoals )
            {
                if ( !goals.contains( goal ) )
                {
                    goals.add( goal );
                }
            }
        }

        child.setGoals( goals );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }


    public Artifact createDependencyArtifact( Dependency d )
    {
        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            // MNG-5368: Log a message instead of returning 'null' silently.
            this.logger.error( String.format( "Invalid version specification '%s' creating dependency artifact '%s'.",
                                              d.getVersion(), d ), e );
            return null;
        }

        Artifact artifact =
            artifactFactory.createDependencyArtifact( d.getGroupId(), d.getArtifactId(), versionRange, d.getType(),
                                                      d.getClassifier(), d.getScope(), d.isOptional() );

        if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && d.getSystemPath() != null )
        {
            artifact.setFile( new File( d.getSystemPath() ) );
        }

        if ( !d.getExclusions().isEmpty() )
        {
            List<String> exclusions = new ArrayList<>();

            for ( Exclusion exclusion : d.getExclusions() )
            {
                exclusions.add( exclusion.getGroupId() + ':' + exclusion.getArtifactId() );
            }

            artifact.setDependencyFilter( new ExcludesArtifactFilter( exclusions ) );
        }

        return artifact;
    }


    public Artifact createDependencyArtifact( Dependency d )
    {
        if ( d.getVersion() == null )
        {
            return null;
        }

        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        Artifact artifact =
            createDependencyArtifactX( d.getGroupId(), d.getArtifactId(), versionRange, d.getType(),
                                                      d.getClassifier(), d.getScope(), d.isOptional() );

        if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && d.getSystemPath() != null )
        {
            artifact.setFile( new File( d.getSystemPath() ) );
        }

        if ( !d.getExclusions().isEmpty() )
        {
            List<String> exclusions = new ArrayList<>();

            for ( Exclusion exclusion : d.getExclusions() )
            {
                exclusions.add( exclusion.getGroupId() + ':' + exclusion.getArtifactId() );
            }

            artifact.setDependencyFilter( new ExcludesArtifactFilter( exclusions ) );
        }

        return artifact;
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        Set<Artifact> dependencies = new HashSet<>();

        if ( "g".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "h", "1.0", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }

        if ( "i".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "j", "1.0-SNAPSHOT", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }


        return new ResolutionGroup( artifact, dependencies, remoteRepositories );
    }


    public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        Set<Artifact> dependencies = new HashSet<>();

        if ( "g".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "h", "1.0", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }

        if ( "i".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "j", "1.0-SNAPSHOT", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }


        return new ResolutionGroup( artifact, dependencies, remoteRepositories );
    }


    public String getLocation()
    {
        StringBuilder buffer = new StringBuilder( 256 );

        if ( getSource().length() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( getSource() );
        }

        if ( getLineNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "line " ).append( getLineNumber() );
        }

        if ( getColumnNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "column " ).append( getColumnNumber() );
        }

        return buffer.toString();
    }


    public String getLocation()
    {
        StringBuilder buffer = new StringBuilder( 256 );

        if ( getSource().length() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( getSource() );
        }

        if ( getLineNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "line " ).append( getLineNumber() );
        }

        if ( getColumnNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "column " ).append( getColumnNumber() );
        }

        return buffer.toString();
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet rset : src )
            {
                if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( rset );
                    merged.put( key, rset );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    public void testShouldActivateDefaultProfile()
        throws Exception
    {
        Profile notActivated = new Profile();
        notActivated.setId( "notActivated" );

        Activation nonActivation = new Activation();

        nonActivation.setJdk( "19.2" );

        notActivated.setActivation( nonActivation );

        Profile defaultActivated = new Profile();
        defaultActivated.setId( "defaultActivated" );

        Activation defaultActivation = new Activation();

        defaultActivation.setActiveByDefault( true );

        defaultActivated.setActivation( defaultActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( notActivated );
        profileManager.addProfile( defaultActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "defaultActivated", ( (Profile) active.get( 0 ) ).getId() );
    }


    public void testShouldNotActivateDefaultProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Profile defaultActivated = new Profile();
        defaultActivated.setId( "defaultActivated" );

        Activation defaultActivation = new Activation();

        defaultActivation.setActiveByDefault( true );

        defaultActivated.setActivation( defaultActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );
        profileManager.addProfile( defaultActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "syspropActivated", ( (Profile) active.get( 0 ) ).getId() );
    }


    protected MavenProject getProjectWithDependencies( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = newBuildingRequest();
        configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) );
        configuration.setProcessPlugins( false );
        configuration.setResolveDependencies( true );

        try
        {
            return projectBuilder.build( pom, configuration ).getProject();
        }
        catch ( Exception e )
        {
            Throwable cause = e.getCause();
            if ( cause instanceof ModelBuildingException )
            {
                String message = "In: " + pom + "\n\n";
                for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() )
                {
                    message += problem + "\n";
                }
                System.out.println( message );
            }

            throw e;
        }
    }


    protected MavenProject getProjectWithDependencies( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setLocalRepository( getLocalRepository() );
        configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) );
        configuration.setProcessPlugins( false );
        configuration.setResolveDependencies( true );
        initRepoSession( configuration );

        try
        {
            return projectBuilder.build( pom, configuration ).getProject();
        }
        catch ( Exception e )
        {
            Throwable cause = e.getCause();
            if ( cause instanceof ModelBuildingException )
            {
                String message = "In: " + pom + "\n\n";
                for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() )
                {
                    message += problem + "\n";
                }
                System.out.println( message );
                fail( message );
            }

            throw e;
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        private void mergePluginContainerPlugins( PluginContainer target, PluginContainer source )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();

                Map<Object, Plugin> managedPlugins = new LinkedHashMap<>( src.size() * 2 );

                Map<Object, Object> context = Collections.emptyMap();

                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    managedPlugins.put( key, element );
                }

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin managedPlugin = managedPlugins.get( key );
                    if ( managedPlugin != null )
                    {
                        mergePlugin( element, managedPlugin, false, context );
                    }
                }
            }
        }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    private Artifact createArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                     String classifier, String scope, String inheritedScope, boolean optional )
    {
        String desiredScope = Artifact.SCOPE_RUNTIME;

        if ( inheritedScope == null )
        {
            desiredScope = scope;
        }
        else if ( Artifact.SCOPE_TEST.equals( scope ) || Artifact.SCOPE_PROVIDED.equals( scope ) )
        {
            return null;
        }
        else if ( Artifact.SCOPE_COMPILE.equals( scope ) && Artifact.SCOPE_COMPILE.equals( inheritedScope ) )
        {
            // added to retain compile artifactScope. Remove if you want compile inherited as runtime
            desiredScope = Artifact.SCOPE_COMPILE;
        }

        if ( Artifact.SCOPE_TEST.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_TEST;
        }

        if ( Artifact.SCOPE_PROVIDED.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_PROVIDED;
        }

        if ( Artifact.SCOPE_SYSTEM.equals( scope ) )
        {
            // system scopes come through unchanged...
            desiredScope = Artifact.SCOPE_SYSTEM;
        }

        ArtifactHandler handler = artifactHandlerManager.getArtifactHandler( type );

        return new DefaultArtifact( groupId, artifactId, versionRange, desiredScope, type, classifier, handler,
                                    optional );
    }


    private Artifact createArtifactX( String groupId, String artifactId, VersionRange versionRange, String type,
                                     String classifier, String scope, String inheritedScope, boolean optional )
    {
        String desiredScope = Artifact.SCOPE_RUNTIME;

        if ( inheritedScope == null )
        {
            desiredScope = scope;
        }
        else if ( Artifact.SCOPE_TEST.equals( scope ) || Artifact.SCOPE_PROVIDED.equals( scope ) )
        {
            return null;
        }
        else if ( Artifact.SCOPE_COMPILE.equals( scope ) && Artifact.SCOPE_COMPILE.equals( inheritedScope ) )
        {
            // added to retain compile artifactScope. Remove if you want compile inherited as runtime
            desiredScope = Artifact.SCOPE_COMPILE;
        }

        if ( Artifact.SCOPE_TEST.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_TEST;
        }

        if ( Artifact.SCOPE_PROVIDED.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_PROVIDED;
        }

        if ( Artifact.SCOPE_SYSTEM.equals( scope ) )
        {
            // system scopes come through unchanged...
            desiredScope = Artifact.SCOPE_SYSTEM;
        }

        ArtifactHandler handler = artifactHandlerManager.getArtifactHandler( type );

        return new DefaultArtifact( groupId, artifactId, versionRange, desiredScope, type, classifier, handler,
                                    optional );
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        private void mergePluginContainerPlugins( PluginContainer target, PluginContainer source )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();

                Map<Object, Plugin> managedPlugins = new LinkedHashMap<>( src.size() * 2 );

                Map<Object, Object> context = Collections.emptyMap();

                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    managedPlugins.put( key, element );
                }

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin managedPlugin = managedPlugins.get( key );
                    if ( managedPlugin != null )
                    {
                        mergePlugin( element, managedPlugin, false, context );
                    }
                }
            }
        }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<>( merged.values() ) );
            }
        }


    public boolean equals( Object o )
    {
        if ( o == this )
        {
            return true;
        }

        if ( !( o instanceof Artifact ) )
        {
            return false;
        }

        Artifact a = (Artifact) o;

        if ( !a.getGroupId().equals( getGroupId() ) )
        {
            return false;
        }
        else if ( !a.getArtifactId().equals( getArtifactId() ) )
        {
            return false;
        }
        else if ( !a.getVersion().equals( getVersion() ) )
        {
            return false;
        }
        else if ( !a.getType().equals( getType() ) )
        {
            return false;
        }
        else if ( a.getClassifier() == null ? getClassifier() != null : !a.getClassifier().equals( getClassifier() ) )
        {
            return false;
        }

        return true;
    }


    public boolean equals( Object o )
    {
        if ( o == this )
        {
            return true;
        }

        if ( !( o instanceof Artifact ) )
        {
            return false;
        }

        Artifact a = (Artifact) o;

        if ( !a.getGroupId().equals( groupId ) )
        {
            return false;
        }
        else if ( !a.getArtifactId().equals( artifactId ) )
        {
            return false;
        }
        else if ( !a.getVersion().equals( version ) )
        {
            return false;
        }
        else if ( !a.getType().equals( type ) )
        {
            return false;
        }
        else if ( a.getClassifier() == null ? classifier != null : !a.getClassifier().equals( classifier ) )
        {
            return false;
        }

        // We don't consider the version range in the comparison, just the resolved version

        return true;
    }


    private static String toMessage( List<SettingsProblem> problems )
    {
        StringWriter buffer = new StringWriter( 1024 );

        PrintWriter writer = new PrintWriter( buffer );

        writer.print( problems.size() );
        writer.print( ( problems.size() == 1 ) ? " problem was " : " problems were " );
        writer.print( "encountered while building the effective settings" );
        writer.println();

        for ( SettingsProblem problem : problems )
        {
            writer.print( "[" );
            writer.print( problem.getSeverity() );
            writer.print( "] " );
            writer.print( problem.getMessage() );
            writer.print( " @ " );
            writer.println( problem.getLocation() );
        }

        return buffer.toString();
    }


    private static String toMessage( List<Problem> problems )
    {
        StringWriter buffer = new StringWriter( 1024 );

        PrintWriter writer = new PrintWriter( buffer );

        writer.print( problems.size() );
        writer.print( ( problems.size() == 1 ) ? " problem was " : " problems were " );
        writer.print( "encountered while building the effective toolchains" );
        writer.println();

        for ( Problem problem : problems )
        {
            writer.print( "[" );
            writer.print( problem.getSeverity() );
            writer.print( "] " );
            writer.print( problem.getMessage() );
            String location = problem.getLocation();
            if ( !location.isEmpty() )
            {
                writer.print( " @ " );
                writer.print( location );
            }
            writer.println();
        }

        return buffer.toString();
    }


        private void mergePluginContainerPlugins( PluginContainer target, PluginContainer source )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();

                Map<Object, Plugin> managedPlugins = new LinkedHashMap<>( src.size() * 2 );

                Map<Object, Object> context = Collections.emptyMap();

                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    managedPlugins.put( key, element );
                }

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin managedPlugin = managedPlugins.get( key );
                    if ( managedPlugin != null )
                    {
                        mergePlugin( element, managedPlugin, false, context );
                    }
                }
            }
        }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<>( merged.values() ) );
            }
        }


    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getSystemDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getCompileDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                     || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getSystemDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getTestDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            Dependency dependency = new Dependency();

            dependency.setArtifactId( a.getArtifactId() );
            dependency.setGroupId( a.getGroupId() );
            dependency.setVersion( a.getVersion() );
            dependency.setScope( a.getScope() );
            dependency.setType( a.getType() );
            dependency.setClassifier( a.getClassifier() );

            list.add( dependency );
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getSystemDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getCompileDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                     || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getTestDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            Dependency dependency = new Dependency();

            dependency.setArtifactId( a.getArtifactId() );
            dependency.setGroupId( a.getGroupId() );
            dependency.setVersion( a.getVersion() );
            dependency.setScope( a.getScope() );
            dependency.setType( a.getType() );
            dependency.setClassifier( a.getClassifier() );

            list.add( dependency );
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getCompileDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                     || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return Collections.unmodifiableList( list );
    }


    public List<Dependency> getTestDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<>( artifacts.size() );

        for ( Artifact a : getArtifacts() )
        {
            Dependency dependency = new Dependency();

            dependency.setArtifactId( a.getArtifactId() );
            dependency.setGroupId( a.getGroupId() );
            dependency.setVersion( a.getVersion() );
            dependency.setScope( a.getScope() );
            dependency.setType( a.getType() );
            dependency.setClassifier( a.getClassifier() );

            list.add( dependency );
        }
        return Collections.unmodifiableList( list );
    }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    int itemValue = ( (IntItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    return 1;
                case LONG_ITEM:
                    long itemValue = ( (LongItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    return 1;
                case LONG_ITEM:
                    long itemValue = ( (LongItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return BigInteger.ZERO.equals( value ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                    return 1;

                case BIGINTEGER_ITEM:
                    return value.compareTo( ( (BigIntegerItem) item ).value );

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    return 1;
                case LONG_ITEM:
                    long itemValue = ( (LongItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                // 1-rc < 1, 1-ga > 1
                return comparableQualifier( value ).compareTo( RELEASE_VERSION_INDEX );
            }
            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1; // 1.any < 1.1 ?

                case STRING_ITEM:
                    return comparableQualifier( value ).compareTo( comparableQualifier( ( (StringItem) item ).value ) );

                case LIST_ITEM:
                    return -1; // 1.any < 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


    public void testPluginOrderAfterMergingWithInheritedPlugins()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-inheritance-merge-order/sub" );

        List<String> expected = new ArrayList<>();
        expected.add( "maven-it-plugin-error" );
        expected.add( "maven-it-plugin-configuration" );
        expected.add( "maven-it-plugin-dependency-resolution" );
        expected.add( "maven-it-plugin-packaging" );
        expected.add( "maven-it-plugin-log-file" );
        expected.add( "maven-it-plugin-expression" );
        expected.add( "maven-it-plugin-fork" );
        expected.add( "maven-it-plugin-touch" );

        List<String> actual = new ArrayList<>();
        @SuppressWarnings( "unchecked" )
        List<Plugin> plugins = (List<Plugin>) pom.getValue( "build/plugins" );
        for ( Plugin plugin : plugins )
        {
            actual.add( plugin.getArtifactId() );
        }

        actual.retainAll( expected );

        assertEquals( actual, expected );
    }


    public void testPluginOrderAfterMergingWithInjectedPlugins()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-injection-merge-order" );

        List<String> expected = new ArrayList<>();
        expected.add( "maven-it-plugin-error" );
        expected.add( "maven-it-plugin-configuration" );
        expected.add( "maven-it-plugin-dependency-resolution" );
        expected.add( "maven-it-plugin-packaging" );
        expected.add( "maven-it-plugin-log-file" );
        expected.add( "maven-it-plugin-expression" );
        expected.add( "maven-it-plugin-fork" );
        expected.add( "maven-it-plugin-touch" );

        List<String> actual = new ArrayList<>();
        @SuppressWarnings( "unchecked" )
        List<Plugin> plugins = (List<Plugin>) pom.getValue( "build/plugins" );
        for ( Plugin plugin : plugins )
        {
            actual.add( plugin.getArtifactId() );
        }

        actual.retainAll( expected );

        assertEquals( actual, expected );
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println( "Project " + project1.getId() + " " + project1 );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Set set = project1.getArtifacts();
        assertNotNull("No artifacts", set);
        assertTrue("No Artifacts", set.size() > 0);
        assertTrue("Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            assertFalse( "", artifact.getArtifactId().equals( "t07-d" ) );
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println( "Project " + project1.getId() + " " + project1 );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println( "Project " + project1.getId() + " " + project1 );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        assertTrue( "Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println( "Project " + project1.getId() + " " + project1 );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: "
                    + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Set set = project1.getArtifacts();
        assertNotNull("No artifacts", set);
        assertTrue("No Artifacts", set.size() > 0);
        assertTrue("Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            assertFalse( "", artifact.getArtifactId().equals( "t07-d" ) );
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Set set = project1.getArtifacts();
        assertNotNull("No artifacts", set);
        assertTrue("No Artifacts", set.size() > 0);
        assertTrue("Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            assertFalse( "", artifact.getArtifactId().equals( "t07-d" ) );
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }
    }


    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        assertTrue( "Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: "
                    + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Set set = project1.getArtifacts();
        assertNotNull("No artifacts", set);
        assertTrue("No Artifacts", set.size() > 0);
        assertTrue("Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            assertFalse( "", artifact.getArtifactId().equals( "t07-d" ) );
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        assertTrue( "Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: "
                    + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    private Authentication getAuthentication( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            AuthenticationSelector selector = session.getAuthenticationSelector();
            if ( selector != null )
            {
                RemoteRepository repo = RepositoryUtils.toRepo( repository );
                org.eclipse.aether.repository.Authentication auth = selector.getAuthentication( repo );
                if ( auth != null )
                {
                    repo = new RemoteRepository.Builder( repo ).setAuthentication( auth ).build();
                    AuthenticationContext authCtx = AuthenticationContext.forRepository( session, repo );
                    Authentication result =
                        new Authentication( authCtx.get( AuthenticationContext.USERNAME ),
                                            authCtx.get( AuthenticationContext.PASSWORD ) );
                    result.setPrivateKey( authCtx.get( AuthenticationContext.PRIVATE_KEY_PATH ) );
                    result.setPassphrase( authCtx.get( AuthenticationContext.PRIVATE_KEY_PASSPHRASE ) );
                    authCtx.close();
                    return result;
                }
            }
        }
        return null;
    }


    private Authentication getAuthentication( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            AuthenticationSelector selector = session.getAuthenticationSelector();
            if ( selector != null )
            {
                RemoteRepository repo = RepositoryUtils.toRepo( repository );
                org.eclipse.aether.repository.Authentication auth = selector.getAuthentication( repo );
                if ( auth != null )
                {
                    repo = new RemoteRepository.Builder( repo ).setAuthentication( auth ).build();
                    AuthenticationContext authCtx = AuthenticationContext.forRepository( session, repo );
                    Authentication result =
                        new Authentication( authCtx.get( AuthenticationContext.USERNAME ),
                                            authCtx.get( AuthenticationContext.PASSWORD ) );
                    result.setPrivateKey( authCtx.get( AuthenticationContext.PRIVATE_KEY_PATH ) );
                    result.setPassphrase( authCtx.get( AuthenticationContext.PRIVATE_KEY_PASSPHRASE ) );
                    authCtx.close();
                    return result;
                }
            }
        }
        return null;
    }


    public void transferSucceeded( TransferEvent event )
    {
        String action = ( event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded" );
        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";

        TransferResource resource = event.getResource();
        long contentLength = event.getTransferredBytes();
        FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH );

        StringBuilder message = new StringBuilder();
        message.append( action ).append( ' ' ).append( direction ).append( ' ' ).append( resource.getRepositoryId() );
        message.append( ": " );
        message.append( resource.getRepositoryUrl() ).append( resource.getResourceName() );
        message.append( " (" ).append( format.format( contentLength ) );

        long duration = System.currentTimeMillis() - resource.getTransferStartTime();
        if ( duration > 0L )
        {
            double bytesPerSecond = contentLength / ( duration / 1000.0 );
            message.append( " at " ).append( format.format( (long) bytesPerSecond ) ).append( "/s" );
        }

        message.append( ')' );
        out.println( message.toString() );
    }


    public void transferSucceeded( TransferEvent event )
    {
        String action = ( event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded" );
        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";

        TransferResource resource = event.getResource();
        long contentLength = event.getTransferredBytes();
        FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH );

        StringBuilder message = new StringBuilder();
        message.append( action ).append( ' ' ).append( direction ).append( ' ' ).append( resource.getRepositoryId() );
        message.append( ": " );
        message.append( resource.getRepositoryUrl() ).append( resource.getResourceName() );
        message.append( " (" ).append( format.format( contentLength ) );

        long duration = System.currentTimeMillis() - resource.getTransferStartTime();
        if ( duration > 0L )
        {
            double bytesPerSecond = contentLength / ( duration / 1000.0 );
            message.append( " at " ).append( format.format( (long) bytesPerSecond ) ).append( "/s" );
        }

        message.append( ')' );
        out.info( message.toString() );
    }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    int itemValue = ( (IntItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return BigInteger.ZERO.equals( value ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                    return 1;

                case BIGINTEGER_ITEM:
                    return value.compareTo( ( (BigIntegerItem) item ).value );

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return ( value == 0 ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                    int itemValue = ( (IntItem) item ).value;
                    return ( value < itemValue ) ? -1 : ( ( value == itemValue ) ? 0 : 1 );
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1;

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                // 1-rc < 1, 1-ga > 1
                return comparableQualifier( value ).compareTo( RELEASE_VERSION_INDEX );
            }
            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1; // 1.any < 1.1 ?

                case STRING_ITEM:
                    return comparableQualifier( value ).compareTo( comparableQualifier( ( (StringItem) item ).value ) );

                case LIST_ITEM:
                    return -1; // 1.any < 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                return BigInteger.ZERO.equals( value ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                    return 1;

                case BIGINTEGER_ITEM:
                    return value.compareTo( ( (BigIntegerItem) item ).value );

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


        public int compareTo( Item item )
        {
            if ( item == null )
            {
                // 1-rc < 1, 1-ga > 1
                return comparableQualifier( value ).compareTo( RELEASE_VERSION_INDEX );
            }
            switch ( item.getType() )
            {
                case INT_ITEM:
                case LONG_ITEM:
                case BIGINTEGER_ITEM:
                    return -1; // 1.any < 1.1 ?

                case STRING_ITEM:
                    return comparableQualifier( value ).compareTo( comparableQualifier( ( (StringItem) item ).value ) );

                case LIST_ITEM:
                    return -1; // 1.any < 1-1

                default:
                    throw new IllegalStateException( "invalid item: " + item.getClass() );
            }
        }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<>( merged.values() ) );
        }
    }


    protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<>( merged.values() ) );
        }
    }


    public void testShouldMergeInheritedPluginHavingExecutionWithLocalPlugin()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution = new PluginExecution();
        childExecution.setId( "testExecution2" );

        child.addExecution( childExecution );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 2, child.getExecutions().size() );
    }


    public void testShouldNOTMergeInheritedPluginHavingInheritEqualFalse()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );
        parent.setInherited( "false" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, true );

        assertEquals( 0, child.getExecutions().size() );
    }


    public void testShouldInheritOnePluginWithExecution()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 1, child.getExecutions().size() );
    }


    public void testShouldMergeInheritedPluginHavingExecutionWithLocalPlugin()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution = new PluginExecution();
        childExecution.setId( "testExecution2" );

        child.addExecution( childExecution );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 2, child.getExecutions().size() );
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: "
                    + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        assertTrue( "Set size should be 3, is " + set.size(), set.size() == 3 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (
                    artifact.isOptional()
                        ? "true"
                        : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Dependency dependency )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), "",
                                                           "pom", dependency.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult = resolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested dependency version range '%s'",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-4463 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested dependency version range '%s' does not specify an upper bound",
                                   dependency.getVersion() ),
                    dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );

            }

            dependency.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );
        }
        catch ( VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(),
                                                  dependency.getVersion(), e );

        }
    }


    public ModelSource resolveModel( final Parent parent )
        throws UnresolvableModelException
    {
        try
        {
            final Artifact artifact = new DefaultArtifact( parent.getGroupId(), parent.getArtifactId(), "", "pom",
                                                           parent.getVersion() );

            final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context );
            versionRangeRequest.setTrace( trace );

            final VersionRangeResult versionRangeResult =
                versionRangeResolver.resolveVersionRange( session, versionRangeRequest );

            if ( versionRangeResult.getHighestVersion() == null )
            {
                throw new UnresolvableModelException(
                    String.format( "No versions matched the requested parent version range '%s'",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            if ( versionRangeResult.getVersionConstraint() != null
                     && versionRangeResult.getVersionConstraint().getRange() != null
                     && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
            {
                // Message below is checked for in the MNG-2199 core IT.
                throw new UnresolvableModelException(
                    String.format( "The requested parent version range '%s' does not specify an upper bound",
                                   parent.getVersion() ),
                    parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );

            }

            parent.setVersion( versionRangeResult.getHighestVersion().toString() );

            return resolveModel( parent.getGroupId(), parent.getArtifactId(), parent.getVersion() );
        }
        catch ( final VersionRangeResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), parent.getGroupId(), parent.getArtifactId(),
                                                  parent.getVersion(), e );

        }
    }


    private Dependency convert( org.apache.maven.model.Dependency dependency, ArtifactTypeRegistry stereotypes )
    {
        ArtifactType stereotype = stereotypes.get( dependency.getType() );
        if ( stereotype == null )
        {
            stereotype = new DefaultArtifactType( dependency.getType() );
        }

        boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;

        Map<String, String> props = null;
        if ( system )
        {
            props = Collections.singletonMap( ArtifactProperties.LOCAL_PATH, dependency.getSystemPath() );
        }

        Artifact artifact =
            new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null,
                                 dependency.getVersion(), props, stereotype );

        List<Exclusion> exclusions = new ArrayList<>( dependency.getExclusions().size() );
        for ( org.apache.maven.model.Exclusion exclusion : dependency.getExclusions() )
        {
            exclusions.add( convert( exclusion ) );
        }

        Dependency result = new Dependency( artifact, dependency.getScope(),
                                            dependency.getOptional() != null
                                                ? dependency.isOptional()
                                                : null,
                                            exclusions );

        return result;
    }


    public static Dependency toDependency( org.apache.maven.model.Dependency dependency,
                                           ArtifactTypeRegistry stereotypes )
    {
        ArtifactType stereotype = stereotypes.get( dependency.getType() );
        if ( stereotype == null )
        {
            stereotype = new DefaultArtifactType( dependency.getType() );
        }

        boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;

        Map<String, String> props = null;
        if ( system )
        {
            props = Collections.singletonMap( ArtifactProperties.LOCAL_PATH, dependency.getSystemPath() );
        }

        Artifact artifact =
            new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null,
                                 dependency.getVersion(), props, stereotype );

        List<Exclusion> exclusions = new ArrayList<>( dependency.getExclusions().size() );
        for ( org.apache.maven.model.Exclusion exclusion : dependency.getExclusions() )
        {
            exclusions.add( toExclusion( exclusion ) );
        }

        Dependency result = new Dependency( artifact,
                                            dependency.getScope(),
                                            dependency.getOptional() != null
                                                ? dependency.isOptional()
                                                : null,
                                            exclusions );

        return result;
    }


    public String toString()
    {
        StringBuilder sb = new StringBuilder( 256 );

        sb.append( "      id: " ).append( getId() ).append( '\n' );
        sb.append( "      url: " ).append( getUrl() ).append( '\n' );
        sb.append( "   layout: " ).append( layout != null ? layout : "none" ).append( '\n' );

        if ( proxy != null )
        {
            sb.append( "    proxy: " ).append( proxy.getHost() ).append( ':' ).append( proxy.getPort() ).append( '\n' );
        }

        if ( snapshots != null )
        {
            sb.append( "snapshots: [enabled => " ).append( snapshots.isEnabled() );
            sb.append( ", update => " ).append( snapshots.getUpdatePolicy() ).append( "]\n" );
        }

        if ( releases != null )
        {
            sb.append( " releases: [enabled => " ).append( releases.isEnabled() );
            sb.append( ", update => " ).append( releases.getUpdatePolicy() ).append( "]\n" );
        }

        return sb.toString();
    }


    public String toString()
    {
        StringBuilder sb = new StringBuilder( 256 );

        sb.append( "       id: " ).append( getId() ).append( '\n' );
        sb.append( "      url: " ).append( getUrl() ).append( '\n' );
        sb.append( "   layout: " ).append( layout != null ? layout : "none" ).append( '\n' );

        if ( snapshots != null )
        {
            sb.append( "snapshots: [enabled => " ).append( snapshots.isEnabled() );
            sb.append( ", update => " ).append( snapshots.getUpdatePolicy() ).append( "]\n" );
        }

        if ( releases != null )
        {
            sb.append( " releases: [enabled => " ).append( releases.isEnabled() );
            sb.append( ", update => " ).append( releases.getUpdatePolicy() ).append( "]\n" );
        }

        return sb.toString();
    }


    public ArtifactRepository buildArtifactRepository( Repository repo )
        throws InvalidRepositoryException
    {
        if ( repo != null )
        {
            String id = repo.getId();

            if ( StringUtils.isEmpty( id ) )
            {
                throw new InvalidRepositoryException( "Repository identifier missing", "" );
            }

            String url = repo.getUrl();

            if ( StringUtils.isEmpty( url ) )
            {
                throw new InvalidRepositoryException( "URL missing for repository " + id, id );
            }

            ArtifactRepositoryPolicy snapshots = buildArtifactRepositoryPolicy( repo.getSnapshots() );

            ArtifactRepositoryPolicy releases = buildArtifactRepositoryPolicy( repo.getReleases() );

            return createArtifactRepository( id, url, getLayout( repo.getLayout() ), snapshots, releases );
        }
        else
        {
            return null;
        }
    }


    public static ArtifactRepository buildArtifactRepository( org.apache.maven.model.Repository repo )
        throws InvalidRepositoryException
    {
        if ( repo != null )
        {
            String id = repo.getId();

            if ( StringUtils.isEmpty( id ) )
            {
                throw new InvalidRepositoryException( "Repository identifier missing", "" );
            }

            String url = repo.getUrl();

            if ( StringUtils.isEmpty( url ) )
            {
                throw new InvalidRepositoryException( "URL missing for repository " + id, id );
            }

            ArtifactRepositoryPolicy snapshots = buildArtifactRepositoryPolicy( repo.getSnapshots() );

            ArtifactRepositoryPolicy releases = buildArtifactRepositoryPolicy( repo.getReleases() );

            ArtifactRepositoryLayout layout = new DefaultRepositoryLayout();

            return createArtifactRepository( id, url, layout, snapshots, releases );
        }
        else
        {
            return null;
        }
    }


        private static void evaluateArray( Object target, InterpolateObjectAction ctx )
        {
            int len = Array.getLength( target );
            for ( int i = 0; i < len; i++ )
            {
                Object value = Array.get( target, i );
                if ( value != null )
                {
                    if ( String.class == value.getClass() )
                    {
                        String interpolated = ctx.interpolate( (String) value );

                        if ( !interpolated.equals( value ) )
                        {
                            Array.set( target, i, interpolated );
                        }
                    }
                    else
                    {
                        ctx.interpolationTargets.add( value );
                    }
                }
            }
        }


        private void evaluateArray( Object target )
            throws ModelInterpolationException
        {
            int len = Array.getLength( target );
            for ( int i = 0; i < len; i++ )
            {
                Object value = Array.get( target, i );
                if ( value != null )
                {
                    if ( String.class == value.getClass() )
                    {
                        String interpolated =
                            modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors,
                                                                   debugEnabled );

                        if ( !interpolated.equals( value ) )
                        {
                            Array.set( target, i, interpolated );
                        }
                    }
                    else
                    {
                        interpolationTargets.add( value );
                    }
                }
            }
        }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testBuildRequestWithUserToolchains()
        throws Exception
    {
        ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();
        request.setUserToolchainsSource( new StringSource( "" ) );

        PersistedToolchains userResult = new PersistedToolchains();
        ToolchainModel toolchain = new ToolchainModel();
        toolchain.setType( "TYPE" );
        toolchain.addProvide( "key", "user_value" );
        userResult.addToolchain(  toolchain );
        when( toolchainsReader.read( any( InputStream.class ), ArgumentMatchers.<String, Object>anyMap()) ).thenReturn( userResult );

        ToolchainsBuildingResult result = toolchainBuilder.build( request );
        assertNotNull( result.getEffectiveToolchains() );
        assertEquals( 1, result.getEffectiveToolchains().getToolchains().size() );
        assertEquals( "TYPE", result.getEffectiveToolchains().getToolchains().get(0).getType() );
        assertEquals( "user_value", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty( "key" ) );
        assertNotNull( result.getProblems() );
        assertEquals( 0, result.getProblems().size() );
    }


    public void testBuildRequestWithGlobalToolchains()
        throws Exception
    {
        ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();
        request.setGlobalToolchainsSource( new StringSource( "" ) );

        PersistedToolchains globalResult = new PersistedToolchains();
        ToolchainModel toolchain = new ToolchainModel();
        toolchain.setType( "TYPE" );
        toolchain.addProvide( "key", "global_value" );
        globalResult.addToolchain(  toolchain );
        when( toolchainsReader.read( any( InputStream.class ), ArgumentMatchers.<String, Object>anyMap()) ).thenReturn( globalResult );

        ToolchainsBuildingResult result = toolchainBuilder.build( request );
        assertNotNull( result.getEffectiveToolchains() );
        assertEquals( 1, result.getEffectiveToolchains().getToolchains().size() );
        assertEquals( "TYPE", result.getEffectiveToolchains().getToolchains().get(0).getType() );
        assertEquals( "global_value", result.getEffectiveToolchains().getToolchains().get(0).getProvides().getProperty( "key" ) );
        assertNotNull( result.getProblems() );
        assertEquals( 0, result.getProblems().size() );
    }


    public DefaultModelBuildingRequest( ModelBuildingRequest request )
    {
        setPomFile( request.getPomFile() );
        setModelSource( request.getModelSource() );
        setValidationLevel( request.getValidationLevel() );
        setProcessPlugins( request.isProcessPlugins() );
        setTwoPhaseBuilding( request.isTwoPhaseBuilding() );
        setProfiles( request.getProfiles() );
        setActiveProfileIds( request.getActiveProfileIds() );
        setInactiveProfileIds( request.getInactiveProfileIds() );
        setSystemProperties( request.getSystemProperties() );
        setUserProperties( request.getUserProperties() );
        setBuildStartTime( request.getBuildStartTime() );
        setModelResolver( request.getModelResolver() );
        setModelBuildingListener( request.getModelBuildingListener() );
        setModelCache( request.getModelCache() );
    }


    public DefaultProjectBuildingRequest( ProjectBuildingRequest request )
    {
        this();
        setProcessPlugins( request.isProcessPlugins() );
        setProfiles( request.getProfiles() );
        setActiveProfileIds( request.getActiveProfileIds() );
        setInactiveProfileIds( request.getInactiveProfileIds() );
        setSystemProperties( request.getSystemProperties() );
        setUserProperties( request.getUserProperties() );
        setRemoteRepositories( request.getRemoteRepositories() );
        setPluginArtifactRepositories( request.getPluginArtifactRepositories() );
        setRepositorySession( request.getRepositorySession() );
        setLocalRepository( request.getLocalRepository() );
        setBuildStartTime( request.getBuildStartTime() );
        setProject( request.getProject() );
        setResolveDependencies( request.isResolveDependencies() );
        setValidationLevel( request.getValidationLevel() );
    }


    public List<String> getCompileClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                    || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }

        return list;
    }


    public List<String> getTestClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 2 );

        String d = getBuild().getTestOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                addArtifactPath( a, list );
            }
        }

        return list;
    }


    public List<String> getTestClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 2 );

        String d = getBuild().getTestOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                addArtifactPath( a, list );
            }
        }

        return list;
    }


    public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }


    public LocalMetadataResult find( RepositorySystemSession session, LocalMetadataRequest request )
    {
        LocalMetadataResult result = new LocalMetadataResult( request );

        String path;

        Metadata metadata = request.getMetadata();
        String context = request.getContext();
        RemoteRepository remote = request.getRepository();

        if ( remote != null )
        {
            path = getPathForRemoteMetadata( metadata, remote, context );
        }
        else
        {
            path = getPathForLocalMetadata( metadata );
        }

        File file = new File( getRepository().getBasedir(), path );
        if ( file.isFile() )
        {
            result.setFile( file );
        }

        return result;
    }


    public LocalMetadataResult find( RepositorySystemSession session, LocalMetadataRequest request )
    {
        LocalMetadataResult result = new LocalMetadataResult( request );

        String path;

        Metadata metadata = request.getMetadata();
        String context = request.getContext();
        RemoteRepository remote = request.getRepository();

        if ( remote != null )
        {
            path = getPathForRemoteMetadata( metadata, remote, context );
        }
        else
        {
            path = getPathForLocalMetadata( metadata );
        }

        File file = new File( getRepository().getBasedir(), path );
        if ( file.isFile() )
        {
            result.setFile( file );
        }

        return result;
    }


    public void testArtifact() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testPom() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testPom() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testMissingPom()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    public void testMissingArtifact()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    public void testPom() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testArtifact() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testMissingPom()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    public void testArtifact() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );

        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }


    public void testMissingArtifact()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    public void testDependencyManagementExclusionsExcludeTransitively()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertNotNull("Parent is null", project1.getParent());
        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Map map = project1.getArtifactMap();

        assertNotNull("No artifacts", map);
        assertTrue("No Artifacts", map.size() > 0);
        assertTrue("Set size should be 2, is " + map.size(), map.size() == 2);

        assertTrue("maven-test:t09-a is not in the project", map.containsKey( "maven-test:t09-a" ));
        assertTrue("maven-test:t09-b is not in the project", map.containsKey( "maven-test:t09-b" ));
        assertFalse("maven-test:t09-c is in the project", map.containsKey( "maven-test:t09-c" ));
    }


    public void testDependencyManagementExclusionDoesNotOverrideGloballyForTransitives()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom2 = new File( pom0Basedir, "p2/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project2 = getProjectWithDependencies( pom2 );

        assertEquals( pom0Basedir, project2.getParent().getBasedir() );
        Map map = project2.getArtifactMap();
        assertNotNull( "No artifacts", map );
        assertTrue( "No Artifacts", map.size() > 0 );
        assertTrue( "Set size should be 4, is " + map.size(), map.size() == 4 );

        assertTrue( "maven-test:t09-a is not in the project", map.containsKey( "maven-test:t09-a" ) );
        assertTrue( "maven-test:t09-b is not in the project", map.containsKey( "maven-test:t09-b" ) );
        assertTrue( "maven-test:t09-c is not in the project", map.containsKey( "maven-test:t09-c" ) );
        assertTrue( "maven-test:t09-d is not in the project", map.containsKey( "maven-test:t09-d" ) );
    }


    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );

        for ( Object aSet : set )
        {
            Artifact artifact = (Artifact) aSet;
            System.out.println(
                "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Scope: "
                    + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }


    public void testDependencyManagementExclusionsExcludeTransitively()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertNotNull("Parent is null", project1.getParent());
        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Map map = project1.getArtifactMap();

        assertNotNull("No artifacts", map);
        assertTrue("No Artifacts", map.size() > 0);
        assertTrue("Set size should be 2, is " + map.size(), map.size() == 2);

        assertTrue("maven-test:t09-a is not in the project", map.containsKey( "maven-test:t09-a" ));
        assertTrue("maven-test:t09-b is not in the project", map.containsKey( "maven-test:t09-b" ));
        assertFalse("maven-test:t09-c is in the project", map.containsKey( "maven-test:t09-c" ));
    }


    private static boolean dependenciesEquals( List<Dependency> a, List<Dependency> b )
    {
        if ( a.size() != b.size() )
        {
            return false;
        }

        Iterator<Dependency> aI = a.iterator();
        Iterator<Dependency> bI = b.iterator();

        while ( aI.hasNext() )
        {
            Dependency aD = aI.next();
            Dependency bD = bI.next();

            boolean r = Objects.equals( aD.getGroupId(), bD.getGroupId() ) //
                && Objects.equals( aD.getArtifactId(), bD.getArtifactId() ) //
                && Objects.equals( aD.getVersion(), bD.getVersion() ) //
                && Objects.equals( aD.getType(), bD.getType() ) //
                && Objects.equals( aD.getClassifier(), bD.getClassifier() ) //
                && Objects.equals( aD.getScope(), bD.getScope() );

            r &= exclusionsEquals( aD.getExclusions(), bD.getExclusions() );

            if ( !r )
            {
                return false;
            }
        }

        return true;
    }


    private static boolean exclusionsEquals( List<Exclusion> a, List<Exclusion> b )
    {
        if ( a.size() != b.size() )
        {
            return false;
        }

        Iterator<Exclusion> aI = a.iterator();
        Iterator<Exclusion> bI = b.iterator();

        while ( aI.hasNext() )
        {
            Exclusion aD = aI.next();
            Exclusion bD = bI.next();

            boolean r = Objects.equals( aD.getGroupId(), bD.getGroupId() ) //
                && Objects.equals( aD.getArtifactId(), bD.getArtifactId() );

            if ( !r )
            {
                return false;
            }
        }

        return true;
    }


    public void testShouldOverrideAndActivateInactiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyActivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "syspropActivated", ( (Profile) active.get( 0 ) ).getId() );
    }


    public void testShouldOverrideAndDeactivateActiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyDeactivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }


    public void testShouldNotActivateReversalOfPresentSystemProperty()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }


    public void testShouldOverrideAndActivateInactiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyActivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "syspropActivated", ( (Profile) active.get( 0 ) ).getId() );
    }


    public Object getPluginComponent( Plugin plugin, String role, String roleHint )
        throws PluginManagerException, ComponentLookupException
    {
        MavenSession session = legacySupport.getSession();

        PluginDescriptor pluginDescriptor;
        try
        {
            pluginDescriptor =
                pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                                   session.getRepositorySession() );

            pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );
        }
        catch ( Exception e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( pluginDescriptor.getClassRealm() );

            return container.lookup( role, roleHint );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldClassLoader );
        }
    }


    public Map<String, Object> getPluginComponents( Plugin plugin, String role )
        throws ComponentLookupException, PluginManagerException
    {
        MavenSession session = legacySupport.getSession();

        PluginDescriptor pluginDescriptor;
        try
        {
            pluginDescriptor =
                pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                                   session.getRepositorySession() );

            pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );
        }
        catch ( Exception e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( pluginDescriptor.getClassRealm() );

            return container.lookupMap( role );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldClassLoader );
        }
    }


    public void testVersionRangeInclusiveBounds()
        throws Exception
    {
        Profile profile = newProfile( "[1.5,1.6]" );

        assertActivation( false, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.6" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09-b03" ) ) );
    }


    public void testVersionRangeInclusiveLowerBound()
        throws Exception
    {
        Profile profile = newProfile( "[1.5,)" );

        assertActivation( false, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.6" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09-b03" ) ) );
    }


    public static CoreExtensionEntry discoverFrom( ClassRealm loader )
    {
        Set<String> artifacts = new LinkedHashSet<>();
        Set<String> packages = new LinkedHashSet<>();

        try
        {
            Enumeration<URL> urls = loader.getResources( BUILDER.getExtensionDescriptorLocation() );
            while ( urls.hasMoreElements() )
            {

                try ( InputStream is = urls.nextElement().openStream() )
                {
                    ExtensionDescriptor descriptor = BUILDER.build( is );
                    artifacts.addAll( descriptor.getExportedArtifacts() );
                    packages.addAll( descriptor.getExportedPackages() );
                }
            }
        }
        catch ( IOException ignored )
        {
            // exports descriptors are entirely optional
        }

        return new CoreExtensionEntry( loader, artifacts, packages );
    }


    public static CoreExtensionEntry discoverFrom( ClassRealm loader, Collection<File> classpath )
    {
        Set<String> artifacts = new LinkedHashSet<>();
        Set<String> packages = new LinkedHashSet<>();

        try
        {
            for ( File entry : classpath )
            {
                ExtensionDescriptor descriptor = BUILDER.build( entry );
                if ( descriptor != null )
                {
                    artifacts.addAll( descriptor.getExportedArtifacts() );
                    packages.addAll( descriptor.getExportedPackages() );
                }
            }
        }
        catch ( IOException ignored )
        {
            // exports descriptors are entirely optional
        }

        return new CoreExtensionEntry( loader, artifacts, packages );
    }


    public void testShouldNotActivateReversalOfPresentSystemProperty()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }


    public void testShouldOverrideAndDeactivateActiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyDeactivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }


    public Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors )
    {
        String repoId = repository.getId();

        if ( repoId != null && mirrors != null )
        {
            for ( Mirror mirror : mirrors )
            {
                if ( repoId.equals( mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }

            for ( Mirror mirror : mirrors )
            {
                if ( matchPattern( repository, mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }
        }

        return null;
    }


    public static Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors )
    {
        String repoId = repository.getId();

        if ( repoId != null && mirrors != null )
        {
            for ( Mirror mirror : mirrors )
            {
                if ( repoId.equals( mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }

            for ( Mirror mirror : mirrors )
            {
                if ( matchPattern( repository, mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }
        }

        return null;
    }


    private void assembleDependencyInheritance( Model child, Model parent )
    {
        Map<String, Dependency> depsMap = new LinkedHashMap<>();

        List<Dependency> deps = parent.getDependencies();

        if ( deps != null )
        {
            for ( Dependency dependency : deps )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        deps = child.getDependencies();

        if ( deps != null )
        {
            for ( Dependency dependency : deps )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        child.setDependencies( new ArrayList<>( depsMap.values() ) );
    }


    private static List<Dependency> mergeDependencyList( List<Dependency> child, List<Dependency> parent )
    {
        Map<String, Dependency> depsMap = new LinkedHashMap<>();

        if ( parent != null )
        {
            for ( Dependency dependency : parent )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        if ( child != null )
        {
            for ( Dependency dependency : child )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        return new ArrayList<>( depsMap.values() );
    }


    private Mirror getMirror( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            org.eclipse.aether.repository.MirrorSelector selector = session.getMirrorSelector();
            if ( selector != null )
            {
                RemoteRepository repo = selector.getMirror( RepositoryUtils.toRepo( repository ) );
                if ( repo != null )
                {
                    Mirror mirror = new Mirror();
                    mirror.setId( repo.getId() );
                    mirror.setUrl( repo.getUrl() );
                    mirror.setLayout( repo.getContentType() );
                    return mirror;
                }
            }
        }
        return null;
    }


    private Mirror getMirror( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            org.eclipse.aether.repository.MirrorSelector selector = session.getMirrorSelector();
            if ( selector != null )
            {
                RemoteRepository repo = selector.getMirror( RepositoryUtils.toRepo( repository ) );
                if ( repo != null )
                {
                    Mirror mirror = new Mirror();
                    mirror.setId( repo.getId() );
                    mirror.setUrl( repo.getUrl() );
                    mirror.setLayout( repo.getContentType() );
                    return mirror;
                }
            }
        }
        return null;
    }


    public void testShouldInheritOnePluginWithExecution()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 1, child.getExecutions().size() );
    }


    public void testShouldNOTMergeInheritedPluginHavingInheritEqualFalse()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );
        parent.setInherited( "false" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, true );

        assertEquals( 0, child.getExecutions().size() );
    }


    public void testMetadata() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createRemoteArtifact( "a", "0.0.1-SNAPSHOT" );
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( a );

        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOfLocalRepositoryMetadata( metadata, localRepository ) );
        file.delete();

        File touchFile = updateCheckManager.getTouchfile( metadata, file );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( metadata, remoteRepository, file );

        assertFalse( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        assertNotNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getMetadataKey( remoteRepository, file ) ) );
    }


    public void testMissingMetadata() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createRemoteArtifact( "a", "0.0.1-SNAPSHOT" );
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( a );

        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOfLocalRepositoryMetadata( metadata, localRepository ) );
        file.delete();

        File touchFile = updateCheckManager.getTouchfile( metadata, file );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        updateCheckManager.touch( metadata, remoteRepository, file );

        assertFalse( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        assertNotNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getMetadataKey( remoteRepository, file ) ) );
    }


	protected void setUp() throws Exception
	{
		super.setUp();
		resolver = (GraphConflictResolver) lookup( GraphConflictResolver.ROLE, "default" );

    	/*
    	 *       v2
    	 *   v1<
    	 *      v3-v4
    	 *
    	 */
    	graph = new MetadataGraph( 4, 3 );
    	v1 = graph.addVertex(new ArtifactMetadata("g","a1","1.0"));
    	graph.setEntry(v1);
    	v2 = graph.addVertex(new ArtifactMetadata("g","a2","1.0"));
    	v3 = graph.addVertex(new ArtifactMetadata("g","a3","1.0"));
    	v4 = graph.addVertex(new ArtifactMetadata("g","a4","1.0"));

    	// v1-->v2
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.2", true, null, null, 2, 2 ) );
    	
    	// v1-->v3
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.2", true, null, null, 4, 2 ) );
    	
    	// v3-->v4
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.1", true, ArtifactScopeEnum.runtime, null, 2, 1 ) );
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.2", true, ArtifactScopeEnum.provided, null, 2, 2 ) );
	}


	protected void setUp() throws Exception
	{
		super.setUp();
		transform = (ClasspathTransformation) lookup( ClasspathTransformation.ROLE, "default" );
    	
    	graph = new MetadataGraph( 4, 3 );
    	/*
    	 *       v2
    	 *   v1<
    	 *       v3-v4
    	 *
    	 */
    	v1 = graph.addVertex(new ArtifactMetadata("g","a1","1.0"));
    	graph.setEntry(v1);
    	v2 = graph.addVertex(new ArtifactMetadata("g","a2","1.0"));
    	v3 = graph.addVertex(new ArtifactMetadata("g","a3","1.0"));
    	v4 = graph.addVertex(new ArtifactMetadata("g","a4","1.0"));
    	
    	// v1-->v2
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.2", true, null, null, 2, 2 ) );
    	
    	// v1-->v3
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.2", true, null, null, 4, 2 ) );
    	
    	// v3-->v4
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.1", true, ArtifactScopeEnum.runtime, null, 2, 2 ) );
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.2", true, ArtifactScopeEnum.test, null, 2, 2 ) );
	}


    private static String format( LocalRepository localRepository, List<RemoteRepository> remoteRepositories )
    {
        String repos = "[";

        if ( localRepository != null )
        {
            repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";
        }

        if ( remoteRepositories != null && !remoteRepositories.isEmpty() )
        {
            for ( RemoteRepository repository : remoteRepositories )
            {
                repos += ", ";

                if ( repository != null )
                {
                    repos += repository.getId() + " (" + repository.getUrl() + ")";
                }
            }
        }

        repos += "]";

        return repos;
    }


    private static String format( LocalRepository localRepository, List<RemoteRepository> remoteRepositories )
    {
        String repos = "[";

        if ( localRepository != null )
        {
            repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";
        }

        if ( remoteRepositories != null && !remoteRepositories.isEmpty() )
        {
            for ( RemoteRepository repository : remoteRepositories )
            {
                repos += ", ";

                if ( repository != null )
                {
                    repos += repository.getId() + " (" + repository.getUrl() + ")";
                }
            }
        }

        repos += "]";

        return repos;
    }


    public void testCompileResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );

    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public void testRuntimeResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.runtime );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public void testCompileResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );

    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public void testTestResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.test );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public void testRuntimeResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.runtime );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public void testTestResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.test );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }


    public static RepositoryPolicy toRepositoryPolicy( org.apache.maven.model.RepositoryPolicy policy )
    {
        boolean enabled = true;
        String checksums = RepositoryPolicy.CHECKSUM_POLICY_WARN;
        String updates = RepositoryPolicy.UPDATE_POLICY_DAILY;

        if ( policy != null )
        {
            enabled = policy.isEnabled();
            if ( policy.getUpdatePolicy() != null )
            {
                updates = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksums = policy.getChecksumPolicy();
            }
        }

        return new RepositoryPolicy( enabled, updates, checksums );
    }


    public static ArtifactRepositoryPolicy buildArtifactRepositoryPolicy( org.apache.maven.model.RepositoryPolicy
                                                                          policy )
    {
        boolean enabled = true;

        String updatePolicy = null;

        String checksumPolicy = null;

        if ( policy != null )
        {
            enabled = policy.isEnabled();

            if ( policy.getUpdatePolicy() != null )
            {
                updatePolicy = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksumPolicy = policy.getChecksumPolicy();
            }
        }

        return new ArtifactRepositoryPolicy( enabled, updatePolicy, checksumPolicy );
    }    


    public ArtifactRepositoryPolicy buildArtifactRepositoryPolicy( RepositoryPolicy policy )
    {
        boolean enabled = true;

        String updatePolicy = null;

        String checksumPolicy = null;

        if ( policy != null )
        {
            enabled = policy.isEnabled();

            if ( policy.getUpdatePolicy() != null )
            {
                updatePolicy = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksumPolicy = policy.getChecksumPolicy();
            }
        }

        return new ArtifactRepositoryPolicy( enabled, updatePolicy, checksumPolicy );
    }


    public static RepositoryPolicy toRepositoryPolicy( org.apache.maven.model.RepositoryPolicy policy )
    {
        boolean enabled = true;
        String checksums = RepositoryPolicy.CHECKSUM_POLICY_WARN;
        String updates = RepositoryPolicy.UPDATE_POLICY_DAILY;

        if ( policy != null )
        {
            enabled = policy.isEnabled();
            if ( policy.getUpdatePolicy() != null )
            {
                updates = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksums = policy.getChecksumPolicy();
            }
        }

        return new RepositoryPolicy( enabled, updates, checksums );
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( formatAsDirectory( artifact.getGroupId() ) ).append( PATH_SEPARATOR );
        path.append( artifact.getArtifactId() ).append( PATH_SEPARATOR );
        path.append( artifact.getBaseVersion() ).append( PATH_SEPARATOR );
        path.append( artifact.getArtifactId() ).append( ARTIFACT_SEPARATOR ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( ARTIFACT_SEPARATOR ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( GROUP_SEPARATOR ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }


    public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getArtifactId() ).append( ARTIFACT_SEPARATOR ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( ARTIFACT_SEPARATOR ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( GROUP_SEPARATOR ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }


    public void testMissingArtifact()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    public void testMissingPom()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }


    private void assembleReportingInheritance( Model child, Model parent )
    {
        // Reports :: aggregate
        Reporting childReporting = child.getReporting();
        Reporting parentReporting = parent.getReporting();

        if ( parentReporting != null )
        {
            if ( childReporting == null )
            {
                childReporting = new Reporting();
                child.setReporting( childReporting );
            }

            childReporting.setExcludeDefaults( parentReporting.isExcludeDefaults() );

            if ( StringUtils.isEmpty( childReporting.getOutputDirectory() ) )
            {
                childReporting.setOutputDirectory( parentReporting.getOutputDirectory() );
            }

            mergeReportPluginLists( childReporting, parentReporting, true );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    public ArtifactRepositoryPolicy buildArtifactRepositoryPolicy( RepositoryPolicy policy )
    {
        boolean enabled = true;

        String updatePolicy = null;

        String checksumPolicy = null;

        if ( policy != null )
        {
            enabled = policy.isEnabled();

            if ( policy.getUpdatePolicy() != null )
            {
                updatePolicy = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksumPolicy = policy.getChecksumPolicy();
            }
        }

        return new ArtifactRepositoryPolicy( enabled, updatePolicy, checksumPolicy );
    }


    public static ArtifactRepositoryPolicy buildArtifactRepositoryPolicy( org.apache.maven.model.RepositoryPolicy
                                                                          policy )
    {
        boolean enabled = true;

        String updatePolicy = null;

        String checksumPolicy = null;

        if ( policy != null )
        {
            enabled = policy.isEnabled();

            if ( policy.getUpdatePolicy() != null )
            {
                updatePolicy = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksumPolicy = policy.getChecksumPolicy();
            }
        }

        return new ArtifactRepositoryPolicy( enabled, updatePolicy, checksumPolicy );
    }    


    public String toString()
    {
        if ( artifacts == null )
        {
            return "";
        }
        StringBuilder sb = new StringBuilder( 256 );
        int i = 1;
        sb.append( "---------\n" );
        sb.append( artifacts.size() ).append( '\n' );
        for ( Artifact a : artifacts )
        {
            sb.append( i ).append( ' ' ).append( a ).append( '\n' );
            i++;
        }
        sb.append( "---------\n" );
        return sb.toString();
    }


    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        if ( artifacts != null )
        {
            int i = 1;
            sb.append( "---------\n" );
            sb.append( artifacts.size() ).append( '\n' );
            for ( Artifact a : artifacts )
            {
                sb.append( i ).append( ' ' ).append( a ).append( '\n' );
                i++;
            }
            sb.append( "---------\n" );
        }

        return sb.toString();
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testInterpolateStringArray()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest(p);

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( values, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", values[0] );
        assertEquals( "value2", values[1] );
    }


    public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }


    public List<String> getCompileClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                    || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }

        return list;
    }


    public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }


    public List<String> getCompileClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                    || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }

        return list;
    }


    public List<String> getRuntimeClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath()
            // TODO let the scope handler deal with this
                && ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) )
            {
                addArtifactPath( a, list );
            }
        }
        return list;
    }


    public List<String> getRuntimeClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath()
            // TODO let the scope handler deal with this
                && ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) )
            {
                addArtifactPath( a, list );
            }
        }
        return list;
    }


    public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<>( getArtifacts().size() );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }


    public void testOrderOfMergedPluginDependenciesWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-class-path-order/wo-plugin-mgmt/sub" );

        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertNotNull( pom.getValue( "build/plugins[1]/dependencies[1]" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/dependencies[2]/artifactId" ) );
        assertEquals( "2", pom.getValue( "build/plugins[1]/dependencies[2]/version" ) );
        assertEquals( "b", pom.getValue( "build/plugins[1]/dependencies[3]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[3]/version" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/dependencies[4]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[4]/version" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/dependencies[5]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[5]/version" ) );
    }


    public void testOrderOfMergedPluginDependenciesWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-class-path-order/w-plugin-mgmt/sub" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertEquals( "c", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/dependencies[2]/artifactId" ) );
        assertEquals( "2", pom.getValue( "build/plugins[1]/dependencies[2]/version" ) );
        assertEquals( "b", pom.getValue( "build/plugins[1]/dependencies[3]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[3]/version" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/dependencies[4]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[4]/version" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/dependencies[5]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[5]/version" ) );
    }


    public void setRootLoggerLevel( Level level )
    {
        String value;
        switch ( level )
        {
            case DEBUG:
                value = "debug";
                break;

            case INFO:
                value = "info";
                break;

            default:
                value = "error";
                break;
        }
        System.setProperty( "maven.logging.root.level", value );
    }


    public void setRootLoggerLevel( Level level )
    {
        String value;
        switch ( level )
        {
            case DEBUG:
                value = "debug";
                break;

            case INFO:
                value = "info";
                break;

            default:
                value = "error";
                break;
        }
        System.setProperty( "org.slf4j.simpleLogger.defaultLogLevel", value );
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            Set<String> excludes = new LinkedHashSet<>( tgt );
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            for ( String s : src )
            {
                if ( !excludes.contains( s ) )
                {
                    merged.add( s );
                }
            }
            target.setFilters( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            Set<String> excludes = new LinkedHashSet<>( tgt );
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            for ( String s : src )
            {
                if ( !excludes.contains( s ) )
                {
                    merged.add( s );
                }
            }
            target.setGoals( merged );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null || isSiteEmpty( tgt ) )
            {
                if ( tgt == null )
                {
                    tgt = new Site();
                }
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
            mergeSite_ChildSiteUrlInheritAppendPath( tgt, src, sourceDominant, context );
        }
    }


    public void testMissingRequiredStringArrayTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.lang.String[]" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
        		"\n" +
        		"[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
        		"\n" +
        		"<configuration>\n" +
        		"  ...\n" +
        		"  <toAddresses>\n" +
        		"    <item>VALUE</item>\n" +
        		"  </toAddresses>\n" +
        		"</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredCollectionTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.List" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <item>VALUE</item>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredStringArrayTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.lang.String[]" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
        		"\n" +
        		"[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
        		"\n" +
        		"<configuration>\n" +
        		"  ...\n" +
        		"  <toAddresses>\n" +
        		"    <item>VALUE</item>\n" +
        		"  </toAddresses>\n" +
        		"</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredMapTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Map" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <KEY>VALUE</KEY>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredStringArrayTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.lang.String[]" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
        		"\n" +
        		"[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
        		"\n" +
        		"<configuration>\n" +
        		"  ...\n" +
        		"  <toAddresses>\n" +
        		"    <item>VALUE</item>\n" +
        		"  </toAddresses>\n" +
        		"</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredPropertiesTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Properties" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <property>\n" +
                "      <name>KEY</name>\n" +
                "      <value>VALUE</value>\n" +
                "    </property>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredCollectionTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.List" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <item>VALUE</item>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredMapTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Map" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <KEY>VALUE</KEY>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredCollectionTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.List" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <item>VALUE</item>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredPropertiesTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Properties" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <property>\n" +
                "      <name>KEY</name>\n" +
                "      <value>VALUE</value>\n" +
                "    </property>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testHandleExceptionAetherClassNotFound()
    {
        Throwable cause2 = new NoClassDefFoundError( "org/sonatype/aether/RepositorySystem" );
        Plugin plugin = new Plugin();
        Exception cause = new PluginContainerException( plugin, null, null, cause2 );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );
        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);
        Throwable exception = new PluginExecutionException( mojoExecution, null, cause );

        DefaultExceptionHandler handler = new DefaultExceptionHandler();
        ExceptionSummary summary = handler.handleException( exception );

        String expectedReference = "http://cwiki.apache.org/confluence/display/MAVEN/AetherClassNotFound";
        assertEquals( expectedReference, summary.getReference() );
    }


    public void testHandleExceptionNoClassDefFoundErrorNull()
    {
        Throwable cause2 = new NoClassDefFoundError();
        Plugin plugin = new Plugin();
        Exception cause = new PluginContainerException( plugin, null, null, cause2 );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );
        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);
        Throwable exception = new PluginExecutionException( mojoExecution, null, cause );

        DefaultExceptionHandler handler = new DefaultExceptionHandler();
        ExceptionSummary summary = handler.handleException( exception );

        String expectedReference = "http://cwiki.apache.org/confluence/display/MAVEN/PluginContainerException";
        assertEquals( expectedReference, summary.getReference() );
    }


    private static Repository convertToSettingsRepository( org.apache.maven.model.Repository modelRepo )
    {
        Repository repo = new Repository();

        repo.setId( modelRepo.getId() );
        repo.setLayout( modelRepo.getLayout() );
        repo.setName( modelRepo.getName() );
        repo.setUrl( modelRepo.getUrl() );

        if ( modelRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( modelRepo.getSnapshots() ) );
        }
        if ( modelRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( modelRepo.getReleases() ) );
        }

        return repo;
    }


    private static Repository convertFromProfileXmlRepository( org.apache.maven.profiles.Repository profileXmlRepo )
    {
        Repository repo = new Repository();

        repo.setId( profileXmlRepo.getId() );
        repo.setLayout( profileXmlRepo.getLayout() );
        repo.setName( profileXmlRepo.getName() );
        repo.setUrl( profileXmlRepo.getUrl() );

        if ( profileXmlRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( profileXmlRepo.getSnapshots() ) );
        }
        if ( profileXmlRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( profileXmlRepo.getReleases() ) );
        }

        return repo;
    }


    private static org.apache.maven.model.Repository convertFromSettingsRepository( Repository settingsRepo )
    {
        org.apache.maven.model.Repository repo = new org.apache.maven.model.Repository();

        repo.setId( settingsRepo.getId() );
        repo.setLayout( settingsRepo.getLayout() );
        repo.setName( settingsRepo.getName() );
        repo.setUrl( settingsRepo.getUrl() );

        if ( settingsRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( settingsRepo.getSnapshots() ) );
        }
        if ( settingsRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( settingsRepo.getReleases() ) );
        }

        return repo;
    }


    private static Repository convertFromProfileXmlRepository( org.apache.maven.profiles.Repository profileXmlRepo )
    {
        Repository repo = new Repository();

        repo.setId( profileXmlRepo.getId() );
        repo.setLayout( profileXmlRepo.getLayout() );
        repo.setName( profileXmlRepo.getName() );
        repo.setUrl( profileXmlRepo.getUrl() );

        if ( profileXmlRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( profileXmlRepo.getSnapshots() ) );
        }
        if ( profileXmlRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( profileXmlRepo.getReleases() ) );
        }

        return repo;
    }


    public void testMissingRequiredMapTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Map" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <KEY>VALUE</KEY>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    public void testMissingRequiredPropertiesTypeParameter()
    {
        MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setGoal( "goal" );
        PluginDescriptor pluginDescriptor = new PluginDescriptor();
        pluginDescriptor.setGoalPrefix( "goalPrefix" );
        pluginDescriptor.setArtifactId( "artifactId" );
        mojoDescriptor.setPluginDescriptor( pluginDescriptor );

        Parameter parameter = new Parameter();
        parameter.setType( "java.util.Properties" );
        parameter.setName( "toAddresses" );

        parameter.setRequired( true );

        PluginParameterException exception =
            new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );

        assertEquals( "One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\n" +
                "\n" +
                "[0] Inside the definition for plugin 'artifactId', specify the following:\n" +
                "\n" +
                "<configuration>\n" +
                "  ...\n" +
                "  <toAddresses>\n" +
                "    <property>\n" +
                "      <name>KEY</name>\n" +
                "      <value>VALUE</value>\n" +
                "    </property>\n" +
                "  </toAddresses>\n" +
                "</configuration>.\n", exception.buildDiagnosticMessage() );
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    public void testPluginArtifactsExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        Artifact depArtifact = createArtifact( "group", "artifact", "1" );

        List<Artifact> deps = new ArrayList<>();
        deps.add( depArtifact );

        exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps );

        MavenSession session = newMavenSession();

        @SuppressWarnings( "unchecked" )
        List<Artifact> depResults =
            (List<Artifact>) new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin.artifacts}" );

        System.out.println( "Result: " + depResults );

        assertNotNull( depResults );
        assertEquals( 1, depResults.size() );
        assertSame( "dependency artifact is wrong.", depArtifact, depResults.get( 0 ) );
    }


    public void testPluginArtifactMapExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        Artifact depArtifact = createArtifact( "group", "artifact", "1" );

        List<Artifact> deps = new ArrayList<>();
        deps.add( depArtifact );

        exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps );

        MavenSession session = newMavenSession();

        @SuppressWarnings( "unchecked" )
        Map<String, Artifact> depResults =
            (Map<String, Artifact>) new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin.artifactMap}" );

        System.out.println( "Result: " + depResults );

        assertNotNull( depResults );
        assertEquals( 1, depResults.size() );
        assertSame( "dependency artifact is wrong.",
                    depArtifact,
                    depResults.get( ArtifactUtils.versionlessKey( depArtifact ) ) );
    }


    private static org.apache.maven.model.Repository convertFromSettingsRepository( Repository settingsRepo )
    {
        org.apache.maven.model.Repository repo = new org.apache.maven.model.Repository();

        repo.setId( settingsRepo.getId() );
        repo.setLayout( settingsRepo.getLayout() );
        repo.setName( settingsRepo.getName() );
        repo.setUrl( settingsRepo.getUrl() );

        if ( settingsRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( settingsRepo.getSnapshots() ) );
        }
        if ( settingsRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( settingsRepo.getReleases() ) );
        }

        return repo;
    }


    private static Repository convertToSettingsRepository( org.apache.maven.model.Repository modelRepo )
    {
        Repository repo = new Repository();

        repo.setId( modelRepo.getId() );
        repo.setLayout( modelRepo.getLayout() );
        repo.setName( modelRepo.getName() );
        repo.setUrl( modelRepo.getUrl() );

        if ( modelRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( modelRepo.getSnapshots() ) );
        }
        if ( modelRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( modelRepo.getReleases() ) );
        }

        return repo;
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }


    public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );
        path.append( artifactHandler.getDirectory() ).append( '/' );
        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( '.' ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }


    public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );
        path.append( artifactHandler.getDirectory() ).append( '/' );
        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( '.' ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }


    private String getPath( Metadata metadata, String repositoryKey )
    {
        StringBuilder path = new StringBuilder( 128 );

        if ( metadata.getGroupId().length() > 0 )
        {
            path.append( metadata.getGroupId().replace( '.', '/' ) ).append( '/' );

            if ( metadata.getArtifactId().length() > 0 )
            {
                path.append( metadata.getArtifactId() ).append( '/' );

                if ( metadata.getVersion().length() > 0 )
                {
                    path.append( metadata.getVersion() ).append( '/' );
                }
            }
        }

        path.append( insertRepositoryKey( metadata.getType(), repositoryKey ) );

        return path.toString();
    }


    private String getPath( Metadata metadata, String repositoryKey )
    {
        StringBuilder path = new StringBuilder( 128 );

        if ( metadata.getGroupId().length() > 0 )
        {
            path.append( metadata.getGroupId().replace( '.', '/' ) ).append( '/' );

            if ( metadata.getArtifactId().length() > 0 )
            {
                path.append( metadata.getArtifactId() ).append( '/' );

                if ( metadata.getVersion().length() > 0 )
                {
                    path.append( metadata.getVersion() ).append( '/' );
                }
            }
        }

        path.append( insertRepositoryKey( metadata.getType(), repositoryKey ) );

        return path.toString();
    }


    public PluginPrefixResult resolve( PluginPrefixRequest request )
        throws NoPluginFoundForPrefixException
    {
        return new PluginPrefixResult()
        {
            public String getGroupId()
            {
                return "com.foobar";
            }

            public String getArtifactId()
            {
                return "bazbaz";
            }

            public ArtifactRepository getRepository()
            {
                return null;
            }
        };
    }


    public PluginVersionResult resolve( PluginVersionRequest request )
        throws PluginVersionResolutionException
    {
        return new PluginVersionResult()
        {
            public String getVersion()
            {
                return "0.42";
            }

            public ArtifactRepository getRepository()
            {
                return null;
            }
        };
    }


    public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = LocalSnapshotMetadata.getKey( artifact );
                LocalSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new LocalSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return Collections.emptyList();
    }


    public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = RemoteSnapshotMetadata.getKey( artifact );
                RemoteSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return snapshots.values();
    }


    public Collection<? extends Metadata> finish( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            Object key = VersionsMetadata.getKey( artifact );
            if ( processedVersions.get( key ) == null )
            {
                VersionsMetadata versionsMetadata = versions.get( key );
                if ( versionsMetadata == null )
                {
                    versionsMetadata = new VersionsMetadata( artifact );
                    versions.put( key, versionsMetadata );
                }
            }
        }

        return versions.values();
    }


    public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = RemoteSnapshotMetadata.getKey( artifact );
                RemoteSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return snapshots.values();
    }


    public Collection<? extends Metadata> finish( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            Object key = VersionsMetadata.getKey( artifact );
            if ( processedVersions.get( key ) == null )
            {
                VersionsMetadata versionsMetadata = versions.get( key );
                if ( versionsMetadata == null )
                {
                    versionsMetadata = new VersionsMetadata( artifact );
                    versions.put( key, versionsMetadata );
                }
            }
        }

        return versions.values();
    }


    public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = LocalSnapshotMetadata.getKey( artifact );
                LocalSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new LocalSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return Collections.emptyList();
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateStringArray()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest(p);

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( values, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", values[0] );
        assertEquals( "value2", values[1] );
    }


    public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }


    public void testInterpolateStringArray()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest(p);

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( values, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", values[0] );
        assertEquals( "value2", values[1] );
    }


    public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( 0 ) );
    }


    public static Map<String, String> toLegacyMap( Map<String, LifecyclePhase> lifecyclePhases )
    {
        if ( lifecyclePhases == null )
        {
            return null;
        }
        
        if ( lifecyclePhases.isEmpty() )
        {
            return Collections.emptyMap();
        }
        
        Map<String, String> phases = new LinkedHashMap<>();
        for ( Map.Entry<String, LifecyclePhase> e: lifecyclePhases.entrySet() )
        {
            phases.put( e.getKey(), e.getValue().toString() );
        }
        return phases;
    }


    public Map<String, String> getPhases()
    {
        Map<String, LifecyclePhase> lphases = getLifecyclePhases();
        if ( lphases == null )
        {
            return null;
        }

        if ( lphases.isEmpty() )
        {
            return Collections.emptyMap();
        }

        Map<String, String> phases = new LinkedHashMap<>();
        for ( Map.Entry<String, LifecyclePhase> e: lphases.entrySet() )
        {
            phases.put( e.getKey(), e.getValue().toString() );
        }
        return phases;
    }


    public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        if ( Artifact.LATEST_VERSION.equals( artifact.getVersion() ) )
        {
            try
            {
                String version = resolveVersion( artifact, request );
                if ( Artifact.LATEST_VERSION.equals( version ) )
                {
                    throw new ArtifactNotFoundException( "Unable to determine the latest version", artifact );
                }

                artifact.setBaseVersion( version );
                artifact.updateVersion( version, request.getLocalRepository() );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactResolutionException( e.getMessage(), artifact, e );
            }
        }
    }


    public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        if ( Artifact.RELEASE_VERSION.equals( artifact.getVersion() ) )
        {
            try
            {
                String version = resolveVersion( artifact, request );

                if ( Artifact.RELEASE_VERSION.equals( version ) )
                {
                    throw new ArtifactNotFoundException( "Unable to determine the release version", artifact );
                }

                artifact.setBaseVersion( version );
                artifact.updateVersion( version, request.getLocalRepository() );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactResolutionException( e.getMessage(), artifact, e );
            }
        }
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        String version = plugin.getVersion();
        if ( StringUtils.isEmpty( version ) )
        {
            version = "RELEASE";
        }

        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            // MNG-5368: Log a message instead of returning 'null' silently.
            this.logger.error( String.format(
                "Invalid version specification '%s' creating plugin artifact '%s'.",
                version, plugin ), e );

            return null;
        }

        return artifactFactory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        VersionRange versionRange;
        try
        {
            String version = plugin.getVersion();
            if ( StringUtils.isEmpty( version ) )
            {
                version = "RELEASE";
            }
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return artifactFactory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        String version = plugin.getVersion();
        if ( StringUtils.isEmpty( version ) )
        {
            version = "RELEASE";
        }

        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            // MNG-5368: Log a message instead of returning 'null' silently.
            this.logger.error( String.format(
                "Invalid version specification '%s' creating plugin artifact '%s'.",
                version, plugin ), e );

            return null;
        }

        return artifactFactory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        VersionRange versionRange;
        try
        {
            String version = plugin.getVersion();
            if ( StringUtils.isEmpty( version ) )
            {
                version = "RELEASE";
            }
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return createPluginArtifactX( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        VersionRange versionRange;
        try
        {
            String version = plugin.getVersion();
            if ( StringUtils.isEmpty( version ) )
            {
                version = "RELEASE";
            }
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return artifactFactory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public Artifact createPluginArtifact( Plugin plugin )
    {
        VersionRange versionRange;
        try
        {
            String version = plugin.getVersion();
            if ( StringUtils.isEmpty( version ) )
            {
                version = "RELEASE";
            }
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return createPluginArtifactX( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact ut.simple:artifact:pom:0 in repo" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( obj == null )
        {
            return false;
        }
        if ( getClass() != obj.getClass() )
        {
            return false;
        }

        ArtifactRepository other = (ArtifactRepository) obj;

        return eq( getId(), other.getId() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( obj == null )
        {
            return false;
        }
        if ( getClass() != obj.getClass() )
        {
            return false;
        }

        DelegatingLocalArtifactRepository other = (DelegatingLocalArtifactRepository) obj;

        return eq( buildReactor, other.buildReactor )
            && eq( ideWorkspace, other.ideWorkspace )
            && eq( userLocalArtifactRepository, other.userLocalArtifactRepository );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom()
        throws Exception
    {
        // We are doing something like "mvn resources:resources" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "resources:resources" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-resources-plugin",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom()
        throws Exception
    {
        // We are doing something like "mvn resources:resources" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "resources:resources" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-resources-plugin",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean:clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean:clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNotFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "0" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().startsWith( "Could not find artifact org.apache:apache:pom:0 in central" ) );
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    protected List<ArtifactRepository> getRemoteRepositories()
        throws Exception
    {
        File repoDir = new File( getBasedir(), "src/test/remote-repo" ).getAbsoluteFile();

        RepositoryPolicy policy = new RepositoryPolicy();
        policy.setEnabled( true );
        policy.setChecksumPolicy( "ignore" );
        policy.setUpdatePolicy( "always" );

        Repository repository = new Repository();
        repository.setId( RepositorySystem.DEFAULT_REMOTE_REPO_ID );
        repository.setUrl( "file://" + repoDir.toURI().getPath() );
        repository.setReleases( policy );
        repository.setSnapshots( policy );

        return Arrays.asList( repositorySystem.buildArtifactRepository( repository ) );
    }


    protected List<ArtifactRepository> getRemoteRepositories()
        throws InvalidRepositoryException
    {
        File repoDir = new File( getBasedir(), "src/test/remote-repo" ).getAbsoluteFile();

        RepositoryPolicy policy = new RepositoryPolicy();
        policy.setEnabled( true );
        policy.setChecksumPolicy( "ignore" );
        policy.setUpdatePolicy( "always" );

        Repository repository = new Repository();
        repository.setId( RepositorySystem.DEFAULT_REMOTE_REPO_ID );
        repository.setUrl( "file://" + repoDir.toURI().getPath() );
        repository.setReleases( policy );
        repository.setSnapshots( policy );

        return Arrays.asList( repositorySystem.buildArtifactRepository( repository ) );
    }


    public void testResolveDependencies()
        throws Exception
    {
        File pomFile = new File( "src/test/resources/projects/basic-resolveDependencies.xml" );
        MavenSession mavenSession = createMavenSession( null );
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setRepositorySession( mavenSession.getRepositorySession() );
        configuration.setResolveDependencies( true );

        // single project build entry point
        ProjectBuildingResult result = lookup( org.apache.maven.project.ProjectBuilder.class ).build( pomFile, configuration );
        assertEquals( 1, result.getProject().getArtifacts().size() );
        // multi projects build entry point
        List<ProjectBuildingResult> results = lookup( org.apache.maven.project.ProjectBuilder.class ).build( Collections.singletonList( pomFile ), false, configuration );
        assertEquals( 1, results.size() );
        MavenProject mavenProject = results.get( 0 ).getProject();
        assertEquals( 1, mavenProject.getArtifacts().size() );
    }


    public void testDontResolveDependencies()
        throws Exception
    {
        File pomFile = new File( "src/test/resources/projects/basic-resolveDependencies.xml" );
        MavenSession mavenSession = createMavenSession( null );
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setRepositorySession( mavenSession.getRepositorySession() );
        configuration.setResolveDependencies( false );

        // single project build entry point
        ProjectBuildingResult result = lookup( org.apache.maven.project.ProjectBuilder.class ).build( pomFile, configuration );
        assertEquals( 0, result.getProject().getArtifacts().size() );
        // multi projects build entry point
        List<ProjectBuildingResult> results = lookup( org.apache.maven.project.ProjectBuilder.class ).build( Collections.singletonList( pomFile ), false, configuration );
        assertEquals( 1, results.size() );
        MavenProject mavenProject = results.get( 0 ).getProject();
        assertEquals( 0, mavenProject.getArtifacts().size() );
    }


    public void testValidateUniqueServerId()
        throws Exception
    {
        Settings settings = new Settings();
        Server server1 = new Server();
        server1.setId( "test" );
        settings.addServer( server1 );
        Server server2 = new Server();
        server2.setId( "test" );
        settings.addServer( server2 );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 1, problems.messages.size() );
        assertContains( problems.messages.get( 0 ),
                        "'servers.server.id' must be unique but found duplicate server with id test" );
    }


    public void testValidateUniqueProfileId()
        throws Exception
    {
        Settings settings = new Settings();
        Profile profile1 = new Profile();
        profile1.setId( "test" );
        settings.addProfile( profile1 );
        Profile profile2 = new Profile();
        profile2.setId( "test" );
        settings.addProfile( profile2 );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 1, problems.messages.size() );
        assertContains( problems.messages.get( 0 ),
                        "'profiles.profile.id' must be unique but found duplicate profile with id test" );
    }


    public Plugin getPluginDefinitionForPrefix( String prefix, MavenSession session, MavenProject project )
    {
        PluginPrefixRequest request = new DefaultPluginPrefixRequest( prefix, session );
        request.setPom( project.getModel() );

        try
        {
            PluginPrefixResult result = pluginPrefixResolver.resolve( request );

            Plugin plugin = new Plugin();
            plugin.setGroupId( result.getGroupId() );
            plugin.setArtifactId( result.getArtifactId() );

            return plugin;
        }
        catch ( NoPluginFoundForPrefixException e )
        {
            return null;
        }
    }


    public PluginDescriptor getPluginDescriptorForPrefix( String prefix )
    {
        MavenSession session = legacySupport.getSession();

        PluginPrefixRequest request = new DefaultPluginPrefixRequest( prefix, session );

        try
        {
            PluginPrefixResult result = pluginPrefixResolver.resolve( request );

            Plugin plugin = new Plugin();
            plugin.setGroupId( result.getGroupId() );
            plugin.setArtifactId( result.getArtifactId() );

            return loadPluginDescriptor( plugin, session.getCurrentProject(), session );
        }
        catch ( Exception e )
        {
            return null;
        }
    }


    public void testBasedir()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );
        model.setArtifactId( "foo" );

        Repository repository = new Repository();

        repository.setUrl( "file://localhost/${basedir}/temp-repo" );

        model.addRepository( repository );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out = interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "file://localhost/myBasedir/temp-repo", ( out.getRepositories().get( 0 ) ).getUrl() );
    }


    public void testBaseUri()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );
        model.setArtifactId( "foo" );

        Repository repository = new Repository();

        repository.setUrl( "${project.baseUri}/temp-repo" );

        model.addRepository( repository );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out = interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "myBaseUri/temp-repo", ( out.getRepositories().get( 0 ) ).getUrl() );
    }


        CacheKey( String groupId, String artifactId, String version )
        {
            this.groupId = ( groupId != null ) ? groupId : "";
            this.artifactId = ( artifactId != null ) ? artifactId : "";
            this.version = ( version != null ) ? version : "";

            int hash = 17;
            hash = hash * 31 + this.groupId.hashCode();
            hash = hash * 31 + this.artifactId.hashCode();
            hash = hash * 31 + this.version.hashCode();
            hashCode = hash;
        }


        CacheKey( String groupId, String artifactId, String version, String tag )
        {
            this.groupId = ( groupId != null ) ? groupId : "";
            this.artifactId = ( artifactId != null ) ? artifactId : "";
            this.version = ( version != null ) ? version : "";
            this.tag = ( tag != null ) ? tag : "";

            int hash = 17;
            hash = hash * 31 + this.groupId.hashCode();
            hash = hash * 31 + this.artifactId.hashCode();
            hash = hash * 31 + this.version.hashCode();
            hash = hash * 31 + this.tag.hashCode();
            hashCode = hash;
        }


    protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


    protected void mergeContributor_Properties( Contributor target, Contributor source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


    protected void mergeContributor_Properties( Contributor target, Contributor source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


        protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                                  Map<Object, Object> context )
        {
            Properties merged = new Properties();
            if ( sourceDominant )
            {
                merged.putAll( target.getProperties() );
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
            }
            else
            {
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
                merged.putAll( target.getProperties() );
            }
            target.setProperties( merged );
            target.setLocation( "properties",
                                InputLocation.merge( target.getLocation( "properties" ),
                                                     source.getLocation( "properties" ), sourceDominant ) );
        }


    protected void mergeContributor_Properties( Contributor target, Contributor source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


    protected void mergeNotifier_Configuration( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getConfiguration() );
            merged.putAll( source.getConfiguration() );
        }
        else
        {
            merged.putAll( source.getConfiguration() );
            merged.putAll( target.getConfiguration() );
        }
        target.setConfiguration( merged );
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    protected void mergeConfigurationContainer_Configuration( ConfigurationContainer target,
                                                              ConfigurationContainer source, boolean sourceDominant,
                                                              Map<Object, Object> context )
    {
        Xpp3Dom src = (Xpp3Dom) source.getConfiguration();
        if ( src != null )
        {
            Xpp3Dom tgt = (Xpp3Dom) target.getConfiguration();
            if ( sourceDominant || tgt == null )
            {
                tgt = Xpp3Dom.mergeXpp3Dom( new Xpp3Dom( src ), tgt );
            }
            else
            {
                tgt = Xpp3Dom.mergeXpp3Dom( tgt, src );
            }
            target.setConfiguration( tgt );
        }
    }


    protected void mergeToolchainModelConfiguration( ToolchainModel target,
                                                    ToolchainModel source )
    {
        Xpp3Dom src = (Xpp3Dom) source.getConfiguration();
        if ( src != null )
        {
            Xpp3Dom tgt = (Xpp3Dom) target.getConfiguration();
            if ( tgt == null )
            {
                tgt = Xpp3Dom.mergeXpp3Dom( new Xpp3Dom( src ), tgt );
            }
            else
            {
                tgt = Xpp3Dom.mergeXpp3Dom( tgt, src );
            }
            target.setConfiguration( tgt );
        }
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


        protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                                  Map<Object, Object> context )
        {
            Properties merged = new Properties();
            if ( sourceDominant )
            {
                merged.putAll( target.getProperties() );
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
            }
            else
            {
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
                merged.putAll( target.getProperties() );
            }
            target.setProperties( merged );
            target.setLocation( "properties",
                                InputLocation.merge( target.getLocation( "properties" ),
                                                     source.getLocation( "properties" ), sourceDominant ) );
        }


    protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }


    protected void mergeNotifier_Configuration( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getConfiguration() );
            merged.putAll( source.getConfiguration() );
        }
        else
        {
            merged.putAll( source.getConfiguration() );
            merged.putAll( target.getConfiguration() );
        }
        target.setConfiguration( merged );
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }


    private ProjectModelResolver( ProjectModelResolver original )
    {
        this.session = original.session;
        this.trace = original.trace;
        this.resolver = original.resolver;
        this.remoteRepositoryManager = original.remoteRepositoryManager;
        this.pomRepositories = new ArrayList<>( original.pomRepositories );
        this.externalRepositories = original.externalRepositories;
        this.repositories = new ArrayList<>( original.repositories );
        this.repositoryMerging = original.repositoryMerging;
        this.repositoryIds = new HashSet<>( original.repositoryIds );
        this.modelPool = original.modelPool;
    }


    private DefaultModelResolver( DefaultModelResolver original )
    {
        this.session = original.session;
        this.trace = original.trace;
        this.context = original.context;
        this.resolver = original.resolver;
        this.versionRangeResolver = original.versionRangeResolver;
        this.remoteRepositoryManager = original.remoteRepositoryManager;
        this.repositories = new ArrayList<>( original.repositories );
        this.externalRepositories = original.externalRepositories;
        this.repositoryIds = new HashSet<>( original.repositoryIds );
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeNotifier_Configuration( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getConfiguration() );
            merged.putAll( source.getConfiguration() );
        }
        else
        {
            merged.putAll( source.getConfiguration() );
            merged.putAll( target.getConfiguration() );
        }
        target.setConfiguration( merged );
    }


        protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                                  Map<Object, Object> context )
        {
            Properties merged = new Properties();
            if ( sourceDominant )
            {
                merged.putAll( target.getProperties() );
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
            }
            else
            {
                putAll( merged, source.getProperties(), CHILD_DIRECTORY_PROPERTY );
                merged.putAll( target.getProperties() );
            }
            target.setProperties( merged );
            target.setLocation( "properties",
                                InputLocation.merge( target.getLocation( "properties" ),
                                                     source.getLocation( "properties" ), sourceDominant ) );
        }


    private static boolean repositoriesEquals( List<ArtifactRepository> r1, List<ArtifactRepository> r2 )
    {
        if ( r1.size() != r2.size() )
        {
            return false;
        }

        for ( Iterator<ArtifactRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); )
        {
            if ( !repositoryEquals( it1.next(), it2.next() ) )
            {
                return false;
            }
        }

        return true;
    }


    public static boolean repositoriesEquals( List<RemoteRepository> r1, List<RemoteRepository> r2 )
    {
        if ( r1.size() != r2.size() )
        {
            return false;
        }
    
        for ( Iterator<RemoteRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); )
        {
            if ( !repositoryEquals( it1.next(), it2.next() ) )
            {
                return false;
            }
        }
    
        return true;
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "org.apache" );
        parent.setArtifactId( "apache" );
        parent.setVersion( "[1,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "org.apache" );
        dependency.setArtifactId( "apache" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    protected void mergeModel_Url( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildProjectUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeSite_Url( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildSiteUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeModel_Url( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildProjectUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeScm_Url( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildScmUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeModel_Url( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildProjectUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeScm_Connection( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getConnection();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setConnection( src );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
            else if ( target.getConnection() == null )
            {
                target.setConnection( extrapolateChildUrl( src, source.isChildScmConnectionInheritAppendPath(),
                                                           context ) );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested dependency version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveDependencyThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Dependency dependency = new Dependency();
        dependency.setGroupId( "ut.simple" );
        dependency.setArtifactId( "artifact" );
        dependency.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( dependency );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested dependency version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }


    protected void mergeSite_Url( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildSiteUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeScm_Url( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildScmUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeSite_Url( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildSiteUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeScm_Connection( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getConnection();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setConnection( src );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
            else if ( target.getConnection() == null )
            {
                target.setConnection( extrapolateChildUrl( src, source.isChildScmConnectionInheritAppendPath(),
                                                           context ) );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenNoMatchingVersionFound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[2.0,2.1)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "No versions matched the requested parent version range '[2.0,2.1)'",
                          e.getMessage() );

        }
    }


    public void testResolveParentThrowsUnresolvableModelExceptionWhenUsingRangesWithoutUpperBound() throws Exception
    {
        final Parent parent = new Parent();
        parent.setGroupId( "ut.simple" );
        parent.setArtifactId( "artifact" );
        parent.setVersion( "[1.0,)" );

        try
        {
            this.newModelResolver().resolveModel( parent );
            fail( "Expected 'UnresolvableModelException' not thrown." );
        }
        catch ( final UnresolvableModelException e )
        {
            assertEquals( "The requested parent version range '[1.0,)' does not specify an upper bound",
                          e.getMessage() );

        }
    }


    protected void mergeScm_Url( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( extrapolateChildUrl( src, source.isChildScmUrlInheritAppendPath(), context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }


    protected void mergeScm_Connection( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getConnection();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setConnection( src );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
            else if ( target.getConnection() == null )
            {
                target.setConnection( extrapolateChildUrl( src, source.isChildScmConnectionInheritAppendPath(),
                                                           context ) );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
        }
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }


    public void testCalculateProjectBuilds()
        throws Exception
    {
        LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();
        BuildListCalculator buildListCalculator = new BuildListCalculator();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );
        final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds( session, taskSegments );
        final ProjectBuildList segments = buildList.getByTaskSegment( taskSegments.get( 0 ) );
        assertEquals( "Stub data contains 3 segments", 3, taskSegments.size() );
        assertEquals( "Stub data contains 6 items", 6, segments.size() );
        final ProjectSegment build = segments.get( 0 );
        assertNotNull( build );
    }


    public void testCalculateProjectBuilds()
        throws Exception
    {
        LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();
        BuildListCalculator buildListCalculator = new BuildListCalculator();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );

        final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds( session, taskSegments );
        final ProjectBuildList segments = buildList.getByTaskSegment( taskSegments.get( 0 ) );
        assertEquals( "Stub data contains 3 segments", 3, taskSegments.size() );
        assertEquals( "Stub data contains 6 items", 6, segments.size() );
        final ProjectSegment build = segments.get( 0 );
        assertNotNull( build );
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    public void testResolveCorrectDependenciesWhenDifferentDependenciesOnNearest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c2 = b.addDependency( "c", "2.0" );
        c2.addDependency( "d", "1.0" );

        ArtifactSpec e = createArtifactSpec( "e", "1.0" );
        ArtifactSpec c1 = e.addDependency( "c", "1.0" );
        ArtifactSpec f = c1.addDependency( "f", "1.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, e.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, e.artifact, c1.artifact,
            f.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "1.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }


    public void disabledtestResolveCorrectDependenciesWhenDifferentDependenciesOnNewest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        // TODO use newest conflict resolver
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c2 = b.addDependency( "c", "2.0" );
        ArtifactSpec d = c2.addDependency( "d", "1.0" );

        ArtifactSpec e = createArtifactSpec( "e", "1.0" );
        ArtifactSpec c1 = e.addDependency( "c", "1.0" );
        c1.addDependency( "f", "1.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, e.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, e.artifact, c2.artifact,
            d.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }


    public void testToolchainsForAvailableType()
        throws Exception
    {
        // prepare
        MavenSession session = mock( MavenSession.class );
        MavenExecutionRequest req = new DefaultMavenExecutionRequest();
        when( session.getRequest() ).thenReturn( req );

        ToolchainPrivate basicToolchain = mock( ToolchainPrivate.class );
        when( toolchainFactory_basicType.createDefaultToolchain() ).thenReturn( basicToolchain );
        ToolchainPrivate rareToolchain = mock( ToolchainPrivate.class );
        when( toolchainFactory_rareType.createDefaultToolchain() ).thenReturn( rareToolchain );

        // execute
        ToolchainPrivate[] toolchains = toolchainManager.getToolchainsForType( "basic", session );

        // verify
        verify( logger, never() ).error( anyString() );
        assertEquals( 1, toolchains.length );
    }


    public void testToolchainsForUnknownType()
        throws Exception
    {
        // prepare
        MavenSession session = mock( MavenSession.class );
        MavenExecutionRequest req = new DefaultMavenExecutionRequest();
        when( session.getRequest() ).thenReturn( req );

        ToolchainPrivate basicToolchain = mock( ToolchainPrivate.class );
        when( toolchainFactory_basicType.createDefaultToolchain() ).thenReturn( basicToolchain );
        ToolchainPrivate rareToolchain = mock( ToolchainPrivate.class );
        when( toolchainFactory_rareType.createDefaultToolchain() ).thenReturn( rareToolchain );

        // execute
        ToolchainPrivate[] toolchains = toolchainManager.getToolchainsForType( "unknown", session );

        // verify
        verify( logger ).error( "Missing toolchain factory for type: unknown. Possibly caused by misconfigured project." );
        assertEquals( 0, toolchains.length );
    }


    private static boolean validateBannedCharacters( SettingsProblemCollector problems, String fieldName,
                                                     Severity severity, String string, String sourceHint,
                                                     String banned )
    {
        if ( string != null )
        {
            for ( int i = string.length() - 1; i >= 0; i-- )
            {
                if ( banned.indexOf( string.charAt( i ) ) >= 0 )
                {
                    addViolation( problems, severity, fieldName, sourceHint,
                                  "must not contain any of these characters " + banned + " but found "
                                      + string.charAt( i ) );
                    return false;
                }
            }
        }

        return true;
    }


    private boolean validateBannedCharacters( String fieldName, ModelProblemCollector problems, Severity severity,
                                              Version version, String string, String sourceHint,
                                              InputLocationTracker tracker, String banned )
    {
        if ( string != null )
        {
            for ( int i = string.length() - 1; i >= 0; i-- )
            {
                if ( banned.indexOf( string.charAt( i ) ) >= 0 )
                {
                    addViolation( problems, severity, version, fieldName, sourceHint,
                                  "must not contain any of these characters " + banned + " but found "
                                      + string.charAt( i ),
                                  tracker );
                    return false;
                }
            }
        }

        return true;
    }


    public static MavenExecutionPlan getProjectAExceutionPlan()
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        List<MojoExecution> me = new ArrayList<>();
        me.add( createMojoExecution( "initialize", "default-initialize", INITIALIZE ) );
        me.add( createMojoExecution( "resources", "default-resources", PROCESS_RESOURCES ) );
        me.add( createMojoExecution( "compile", "default-compile", COMPILE ) );
        me.add( createMojoExecution( "testResources", "default-testResources", PROCESS_TEST_RESOURCES ) );
        me.add( createMojoExecution( "testCompile", "default-testCompile", TEST_COMPILE ) );
        me.add( createMojoExecution( "test", "default-test", TEST ) );
        me.add( createMojoExecution( "war", "default-war", PACKAGE ) );
        me.add( createMojoExecution( "install", "default-install", INSTALL ) );
        return createExecutionPlan( ProjectDependencyGraphStub.A.getExecutionProject(), me );
    }


    public static MavenExecutionPlan getProjectBExecutionPlan()
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        List<MojoExecution> me = new ArrayList<>();
        me.add( createMojoExecution( "enforce", "enforce-versions", VALIDATE ) );
        me.add( createMojoExecution( "resources", "default-resources", PROCESS_RESOURCES ) );
        me.add( createMojoExecution( "compile", "default-compile", COMPILE ) );
        me.add( createMojoExecution( "testResources", "default-testResources", PROCESS_TEST_RESOURCES ) );
        me.add( createMojoExecution( "testCompile", "default-testCompile", TEST_COMPILE ) );
        me.add( createMojoExecution( "test", "default-test", TEST ) );
        return createExecutionPlan( ProjectDependencyGraphStub.B.getExecutionProject(), me );
    }


    private String path( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId().replace( '.', '/' ) ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '/' );

        path.append( artifact.getBaseVersion() ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( "s/" );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    private String path( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId().replace( '.', '/' ) ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '/' );

        path.append( artifact.getBaseVersion() ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( "s/" );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }


    public File translatePath( File path )
    {
        File result = path;

        if ( path != null && basedir != null )
        {
            if ( path.isAbsolute() )
            {
                // path is already absolute, we're done
            }
            else if ( path.getPath().startsWith( File.separator ) )
            {
                // drive-relative Windows path, don't align with base dir but with drive root
                result = path.getAbsoluteFile();
            }
            else
            {
                // an ordinary relative path, align with base dir
                result = new File( new File( basedir, path.getPath() ).toURI().normalize() ).getAbsoluteFile();
            }
        }

        return result;
    }


    public File alignToBaseDirectory( File file )
    {
        // TODO Copied from the DefaultInterpolator. We likely want to resurrect the PathTranslator or at least a
        // similar component for re-usage
        if ( file != null )
        {
            if ( file.isAbsolute() )
            {
                // path was already absolute, just normalize file separator and we're done
            }
            else if ( file.getPath().startsWith( File.separator ) )
            {
                // drive-relative Windows path, don't align with project directory but with drive root
                file = file.getAbsoluteFile();
            }
            else
            {
                // an ordinary relative path, align with project directory
                file = new File( new File( basedir, file.getPath() ).toURI().normalize() ).getAbsoluteFile();
            }
        }
        return file;
    }


    public void testShouldInterpolateDependencyVersionToSetSameAsProjectVersion()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${version}" );

        model.addDependency( dep );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertCollectorState(0, 0, 1, collector );

        assertEquals( "3.8.1", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        model.addProperty( "test", "test" );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );

        assertEquals( "test/somepath", out.getScm().getConnection() );
    }


    public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testShouldNotThrowExceptionOnReferenceToNonExistentValue()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );
        assertEquals( "${test}/somepath", out.getScm().getConnection() );
    }


    public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${env.DOES_NOT_EXIST}" );
    }


    public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }


    public void testExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${DOES_NOT_EXIST}" );
    }


    public void init( EventSpy.Context context )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.init( context );
            }
            catch ( Exception | LinkageError e )
            {
                logError( "initialize", e, eventSpy );
            }
        }
    }


    public void close()
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.close();
            }
            catch ( Exception | LinkageError e )
            {
                logError( "close", e, eventSpy );
            }
        }
    }


    public void init( EventSpy.Context context )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.init( context );
            }
            catch ( Exception | LinkageError e )
            {
                logError( "initialize", e, eventSpy );
            }
        }
    }


    public void onEvent( Object event )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.onEvent( event );
            }
            catch ( Exception | LinkageError e )
            {
                logError( "notify", e, eventSpy );
            }
        }
    }


    public void testShouldNotThrowExceptionOnReferenceToNonExistentValue()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );
        assertEquals( "${test}/somepath", out.getScm().getConnection() );
    }


    public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        model.addProperty( "test", "test" );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );

        assertEquals( "test/somepath", out.getScm().getConnection() );
    }


    public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        model.addProperty( "test", "test" );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );

        assertEquals( "test/somepath", out.getScm().getConnection() );
    }


    public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${env.DOES_NOT_EXIST}" );
    }


    public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        model.addProperty( "test", "test" );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );

        assertEquals( "test/somepath", out.getScm().getConnection() );
    }


    public void testExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${DOES_NOT_EXIST}" );
    }


    public void onEvent( Object event )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.onEvent( event );
            }
            catch ( Exception | LinkageError e )
            {
                logError( "notify", e, eventSpy );
            }
        }
    }


    public void close()
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.close();
            }
            catch ( Exception | LinkageError e )
            {
                logError( "close", e, eventSpy );
            }
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }


    public void testShouldNotThrowExceptionOnReferenceToNonExistentValue()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );
        assertEquals( "${test}/somepath", out.getScm().getConnection() );
    }


    public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${env.DOES_NOT_EXIST}" );
    }


    public void testShouldNotThrowExceptionOnReferenceToNonExistentValue()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );
        assertEquals( "${test}/somepath", out.getScm().getConnection() );
    }


    public void testExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${DOES_NOT_EXIST}" );
    }


    protected void mergeDependency( Dependency target, Dependency source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeDependency_GroupId( target, source, sourceDominant, context );
        mergeDependency_ArtifactId( target, source, sourceDominant, context );
        mergeDependency_Version( target, source, sourceDominant, context );
        mergeDependency_Type( target, source, sourceDominant, context );
        mergeDependency_Classifier( target, source, sourceDominant, context );
        mergeDependency_Scope( target, source, sourceDominant, context );
        mergeDependency_SystemPath( target, source, sourceDominant, context );
        mergeDependency_Optional( target, source, sourceDominant, context );
        mergeDependency_Exclusions( target, source, sourceDominant, context );
    }


        protected void mergePlugin( Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context )
        {
            if ( source.isInherited() )
            {
                mergeConfigurationContainer( target, source, sourceDominant, context );
            }
            mergePlugin_GroupId( target, source, sourceDominant, context );
            mergePlugin_ArtifactId( target, source, sourceDominant, context );
            mergePlugin_Version( target, source, sourceDominant, context );
            mergePlugin_Extensions( target, source, sourceDominant, context );
            mergePlugin_Dependencies( target, source, sourceDominant, context );
            mergePlugin_Executions( target, source, sourceDominant, context );
        }


    protected void mergeDependency( Dependency target, Dependency source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeDependency_GroupId( target, source, sourceDominant, context );
        mergeDependency_ArtifactId( target, source, sourceDominant, context );
        mergeDependency_Version( target, source, sourceDominant, context );
        mergeDependency_Type( target, source, sourceDominant, context );
        mergeDependency_Classifier( target, source, sourceDominant, context );
        mergeDependency_Scope( target, source, sourceDominant, context );
        mergeDependency_SystemPath( target, source, sourceDominant, context );
        mergeDependency_Optional( target, source, sourceDominant, context );
        mergeDependency_Exclusions( target, source, sourceDominant, context );
    }


    protected void mergeContributor( Contributor target, Contributor source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        mergeContributor_Name( target, source, sourceDominant, context );
        mergeContributor_Email( target, source, sourceDominant, context );
        mergeContributor_Url( target, source, sourceDominant, context );
        mergeContributor_Organization( target, source, sourceDominant, context );
        mergeContributor_OrganizationUrl( target, source, sourceDominant, context );
        mergeContributor_Timezone( target, source, sourceDominant, context );
        mergeContributor_Roles( target, source, sourceDominant, context );
        mergeContributor_Properties( target, source, sourceDominant, context );
    }


    protected void mergeModelBase( ModelBase target, ModelBase source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeModelBase_DistributionManagement( target, source, sourceDominant, context );
        mergeModelBase_Modules( target, source, sourceDominant, context );
        mergeModelBase_Repositories( target, source, sourceDominant, context );
        mergeModelBase_PluginRepositories( target, source, sourceDominant, context );
        mergeModelBase_Dependencies( target, source, sourceDominant, context );
        mergeModelBase_Reporting( target, source, sourceDominant, context );
        mergeModelBase_DependencyManagement( target, source, sourceDominant, context );
        mergeModelBase_Properties( target, source, sourceDominant, context );
    }


    protected void mergeDependency( Dependency target, Dependency source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeDependency_GroupId( target, source, sourceDominant, context );
        mergeDependency_ArtifactId( target, source, sourceDominant, context );
        mergeDependency_Version( target, source, sourceDominant, context );
        mergeDependency_Type( target, source, sourceDominant, context );
        mergeDependency_Classifier( target, source, sourceDominant, context );
        mergeDependency_Scope( target, source, sourceDominant, context );
        mergeDependency_SystemPath( target, source, sourceDominant, context );
        mergeDependency_Optional( target, source, sourceDominant, context );
        mergeDependency_Exclusions( target, source, sourceDominant, context );
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${env.DOES_NOT_EXIST}" );
    }


    public void testExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${DOES_NOT_EXIST}" );
    }


    public void testMatchingArtifactIdsDifferentGroupIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId1", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId2", "artifactId", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }


    public void testMatchingGroupIdsDifferentArtifactIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId", "artifactId1", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId2", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }


    public void testMatchingArtifactIdsDifferentGroupIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId1", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId2", "artifactId", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }


    public void testMatchingIdsAndDifferentVersions()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId", "2.0" );
        projects.add( project2 );

        projects = new ProjectSorter( projects ).getSortedProjects();
        assertEquals( project1, projects.get( 0 ) );
        assertEquals( project2, projects.get( 1 ) );
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }


    public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( "s/" );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( "s/" );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }


    public DefaultModelBuildingRequest setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = new Properties();
            synchronized ( systemProperties )
            { // avoid concurrentmodification if someone else sets/removes an unrelated system property
                this.systemProperties.putAll( systemProperties );
            }
        }
        else
        {
            this.systemProperties = null;
        }

        return this;
    }


    public DefaultSettingsBuildingRequest setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = new Properties();
            synchronized ( systemProperties )
            { // avoid concurrentmodification if someone else sets/removes an unrelated system property
                this.systemProperties.putAll( systemProperties );
            }
        }
        else
        {
            this.systemProperties = null;
        }

        return this;
    }


    protected AbstractArtifactResolutionException( String message,
                                                   String groupId,
                                                   String artifactId,
                                                   String version,
                                                   String type,
                                                   String classifier,
                                                   List<ArtifactRepository> remoteRepositories,
                                                   List<String> path,
                                                   Throwable t )
    {
        super( constructMessageBase( message, groupId, artifactId, version, type, remoteRepositories, path ), t );

        this.originalMessage = message;
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.type = type;
        this.classifier = classifier;
        this.version = version;
        this.remoteRepositories = remoteRepositories;
        this.path = constructArtifactPath( path, "" );
    }


    DefaultModelResolver( RepositorySystemSession session, RequestTrace trace, String context,
                          ArtifactResolver resolver, VersionRangeResolver versionRangeResolver,
                          RemoteRepositoryManager remoteRepositoryManager, List<RemoteRepository> repositories )
    {
        this.session = session;
        this.trace = trace;
        this.context = context;
        this.resolver = resolver;
        this.versionRangeResolver = versionRangeResolver;
        this.remoteRepositoryManager = remoteRepositoryManager;
        this.repositories = repositories;
        this.externalRepositories = Collections.unmodifiableList( new ArrayList<>( repositories ) );

        this.repositoryIds = new HashSet<>();
    }


    private ArtifactRepositoryPolicy getEffectivePolicy( Collection<ArtifactRepositoryPolicy> policies )
    {
        ArtifactRepositoryPolicy effectivePolicy = null;

        for ( ArtifactRepositoryPolicy policy : policies )
        {
            if ( effectivePolicy == null )
            {
                effectivePolicy = new ArtifactRepositoryPolicy( policy );
            }
            else
            {
                effectivePolicy.merge( policy );
            }
        }

        return effectivePolicy;
    }


    private ArtifactRepositoryPolicy getEffectivePolicy( Collection<ArtifactRepositoryPolicy> policies )
    {
        ArtifactRepositoryPolicy effectivePolicy = null;

        for ( ArtifactRepositoryPolicy policy : policies )
        {
            if ( effectivePolicy == null )
            {
                effectivePolicy = new ArtifactRepositoryPolicy( policy );
            }
            else
            {
                effectivePolicy.merge( policy );
            }
        }

        return effectivePolicy;
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }


    static File resolveFile( File file, String workingDirectory )
    {
        if ( file == null )
        {
            return null;
        }
        else if ( file.isAbsolute() )
        {
            return file;
        }
        else if ( file.getPath().startsWith( File.separator ) )
        {
            // drive-relative Windows path
            return file.getAbsoluteFile();
        }
        else
        {
            return new File( workingDirectory, file.getPath() ).getAbsoluteFile();
        }
    }


    static File resolveFile( File file, String workingDirectory )
    {
        if ( file == null )
        {
            return null;
        }
        else if ( file.isAbsolute() )
        {
            return file;
        }
        else if ( file.getPath().startsWith( File.separator ) )
        {
            // drive-relative Windows path
            return file.getAbsoluteFile();
        }
        else
        {
            return new File( workingDirectory, file.getPath() ).getAbsoluteFile();
        }
    }


    private void injectMirror( ArtifactRepository repository, Mirror mirror )
    {
        if ( mirror != null )
        {
            ArtifactRepository original =
                createArtifactRepository( repository.getId(), repository.getUrl(), repository.getLayout(),
                                          repository.getSnapshots(), repository.getReleases() );

            repository.setMirroredRepositories( Collections.singletonList( original ) );

            repository.setId( mirror.getId() );
            repository.setUrl( mirror.getUrl() );

            if ( StringUtils.isNotEmpty( mirror.getLayout() ) )
            {
                repository.setLayout( getLayout( mirror.getLayout() ) );
            }
        }
    }


    private void injectMirror( ArtifactRepository repository, Mirror mirror )
    {
        if ( mirror != null )
        {
            ArtifactRepository original =
                createArtifactRepository( repository.getId(), repository.getUrl(), repository.getLayout(),
                                          repository.getSnapshots(), repository.getReleases() );

            repository.setMirroredRepositories( Collections.singletonList( original ) );

            repository.setId( mirror.getId() );
            repository.setUrl( mirror.getUrl() );

            if ( StringUtils.isNotEmpty( mirror.getLayout() ) )
            {
                repository.setLayout( getLayout( mirror.getLayout() ) );
            }
        }
    }


    public void testMatchingGroupIdsDifferentArtifactIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId", "artifactId1", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId2", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }


    public void testMatchingIdsAndDifferentVersions()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<>();
        MavenProject project1 = createProject( "groupId", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId", "2.0" );
        projects.add( project2 );

        projects = new ProjectSorter( projects ).getSortedProjects();
        assertEquals( project1, projects.get( 0 ) );
        assertEquals( project2, projects.get( 1 ) );
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }


    public void testModelAndFactory()
    {
        MavenSession session = mock( MavenSession.class );
        MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();
        Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();
        toolchainModels.put( "basic", Arrays.asList( new ToolchainModel(), new ToolchainModel() ) );
        toolchainModels.put( "rare", Collections.singletonList( new ToolchainModel() ) );
        executionRequest.setToolchains( toolchainModels );
        when( session.getRequest() ).thenReturn( executionRequest );

        List<Toolchain> toolchains = toolchainManager.getToolchains( session, "rare", null );

        assertEquals( 1, toolchains.size() );
    }


    public void testModelsAndFactory()
    {
        MavenSession session = mock( MavenSession.class );
        MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();
        Map<String, List<ToolchainModel>> toolchainModels = new HashMap<>();
        toolchainModels.put( "basic", Arrays.asList( new ToolchainModel(), new ToolchainModel() ) );
        toolchainModels.put( "rare", Collections.singletonList( new ToolchainModel() ) );
        executionRequest.setToolchains( toolchainModels );
        when( session.getRequest() ).thenReturn( executionRequest );

        List<Toolchain> toolchains = toolchainManager.getToolchains( session, "basic", null );

        assertEquals( 2, toolchains.size() );
    }


    private boolean validateId( String fieldName, ModelProblemCollector problems, Severity severity, Version version,
                                String id, String sourceHint, InputLocationTracker tracker )
    {
        if ( !validateStringNotEmpty( fieldName, problems, severity, version, id, sourceHint, tracker ) )
        {
            return false;
        }
        else
        {
            if ( !isValidId( id ) )
            {
                addViolation( problems, severity, version, fieldName, sourceHint,
                              "with value '" + id + "' does not match a valid id pattern.", tracker );
                return false;
            }
            return true;
        }
    }


    private boolean validateIdWithWildcards( String fieldName, ModelProblemCollector problems, Severity severity,
                                             Version version, String id, String sourceHint,
                                             InputLocationTracker tracker )
    {
        if ( !validateStringNotEmpty( fieldName, problems, severity, version, id, sourceHint, tracker ) )
        {
            return false;
        }
        else
        {
            if ( !isValidIdWithWildCards( id ) )
            {
                addViolation( problems, severity, version, fieldName, sourceHint,
                              "with value '" + id + "' does not match a valid id pattern.", tracker );
                return false;
            }
            return true;
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }


    private PluginPrefixResult resolveFromProject( PluginPrefixRequest request )
    {
        PluginPrefixResult result = null;

        if ( request.getPom() != null && request.getPom().getBuild() != null )
        {
            Build build = request.getPom().getBuild();

            result = resolveFromProject( request, build.getPlugins() );

            if ( result == null && build.getPluginManagement() != null )
            {
                result = resolveFromProject( request, build.getPluginManagement().getPlugins() );
            }
        }

        return result;
    }


    private PluginVersionResult resolveFromProject( PluginVersionRequest request )
    {
        PluginVersionResult result = null;

        if ( request.getPom() != null && request.getPom().getBuild() != null )
        {
            Build build = request.getPom().getBuild();

            result = resolveFromProject( request, build.getPlugins() );

            if ( result == null && build.getPluginManagement() != null )
            {
                result = resolveFromProject( request, build.getPluginManagement().getPlugins() );
            }
        }

        return result;
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }


    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }


    private void invalidMetadata( RepositorySystemSession session, RequestTrace trace,
                                  org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository,
                                  Exception exception )
    {
        RepositoryListener listener = session.getRepositoryListener();
        if ( listener != null )
        {
            RepositoryEvent.Builder event = new RepositoryEvent.Builder( session, EventType.METADATA_INVALID );
            event.setTrace( trace );
            event.setMetadata( metadata );
            event.setException( exception );
            event.setRepository( repository );
            listener.metadataInvalid( event.build() );
        }
    }


    private void invalidMetadata( RepositorySystemSession session, RequestTrace trace,
                                  org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository,
                                  Exception exception )
    {
        RepositoryListener listener = session.getRepositoryListener();
        if ( listener != null )
        {
            RepositoryEvent.Builder event = new RepositoryEvent.Builder( session, EventType.METADATA_INVALID );
            event.setTrace( trace );
            event.setMetadata( metadata );
            event.setException( exception );
            event.setRepository( repository );
            listener.metadataInvalid( event.build() );
        }
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationProperty property = activation.getProperty();

        if ( property == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationOS os = activation.getOs();

        if ( os == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationProperty property = activation.getProperty();

        if ( property == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        String jdk = activation.getJdk();

        if ( jdk == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationProperty property = activation.getProperty();

        if ( property == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationFile file = activation.getFile();

        if ( file == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        String jdk = activation.getJdk();

        if ( jdk == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationOS os = activation.getOs();

        if ( os == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationOS os = activation.getOs();

        if ( os == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationFile file = activation.getFile();

        if ( file == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        String jdk = activation.getJdk();

        if ( jdk == null )
        {
            return false;
        }
        return true;
    }


    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationFile file = activation.getFile();

        if ( file == null )
        {
            return false;
        }
        return true;
    }


    public void disabledtestCircularDependencyNotIncludingCurrentProject()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        b.addDependency( "a", "1.0" );
        try
        {
            collect( a );
            fail( "Should have failed on cyclic dependency not involving project" );
        }
        catch ( CyclicDependencyException expected )
        {
            assertTrue( true );
        }
    }


    public void disabledtestCircularDependencyIncludingCurrentProject()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        b.addDependency( "project", "1.0" );
        try
        {
            collect( a );
            fail( "Should have failed on cyclic dependency involving project" );
        }
        catch ( CyclicDependencyException expected )
        {
            assertTrue( true );
        }
    }


    public void testStrictToolchainsParseException() throws Exception
    {
        ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();
        request.setGlobalToolchainsSource( new StringSource( "" ) );
        ToolchainsParseException parseException = new ToolchainsParseException( "MESSAGE", 4, 2 );
        when( toolchainsReader.read( any( InputStream.class ), ArgumentMatchers.<String, Object>anyMap()) ).thenThrow( parseException );
        
        try
        {
            toolchainBuilder.build( request );
        }
        catch ( ToolchainsBuildingException e )
        {
            assertEquals( "1 problem was encountered while building the effective toolchains" + LS + 
                "[FATAL] Non-parseable toolchains (memory): MESSAGE @ line 4, column 2" + LS, e.getMessage() );
        }
    }


    public void testIOException() throws Exception
    {
        ToolchainsBuildingRequest request = new DefaultToolchainsBuildingRequest();
        request.setGlobalToolchainsSource( new StringSource( "", "LOCATION" ) );
        IOException ioException = new IOException( "MESSAGE" );
        when( toolchainsReader.read( any( InputStream.class ), ArgumentMatchers.<String, Object>anyMap()) ).thenThrow( ioException );
        
        try
        {
            toolchainBuilder.build( request );
        }
        catch ( ToolchainsBuildingException e )
        {
            assertEquals( "1 problem was encountered while building the effective toolchains" + LS + 
                "[FATAL] Non-readable toolchains LOCATION: MESSAGE" + LS, e.getMessage() );
        }
    }


    public void testGetMissingJar() throws TransferFailedException, UnsupportedProtocolException, IOException
    {
        Artifact artifact = createTestArtifact( "target/test-data/get-missing-jar", "jar" );

        ArtifactRepository repo = createStringRepo();

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );

            fail();
        }
        catch ( ResourceDoesNotExistException e )
        {
            assertTrue( true );
        }

        assertFalse( artifact.getFile().exists() );
    }


    public void testGetMissingJarForced() throws TransferFailedException, UnsupportedProtocolException, IOException
    {
        Artifact artifact = createTestArtifact( "target/test-data/get-missing-jar", "jar" );

        ArtifactRepository repo = createStringRepo();

        try
        {
            wagonManager.getArtifact( artifact, repo, null, true );

            fail();
        }
        catch ( ResourceDoesNotExistException e )
        {
            assertTrue( true );
        }

        assertFalse( artifact.getFile().exists() );
    }


    protected void mergeContributor( Contributor target, Contributor source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        mergeContributor_Name( target, source, sourceDominant, context );
        mergeContributor_Email( target, source, sourceDominant, context );
        mergeContributor_Url( target, source, sourceDominant, context );
        mergeContributor_Organization( target, source, sourceDominant, context );
        mergeContributor_OrganizationUrl( target, source, sourceDominant, context );
        mergeContributor_Timezone( target, source, sourceDominant, context );
        mergeContributor_Roles( target, source, sourceDominant, context );
        mergeContributor_Properties( target, source, sourceDominant, context );
    }


        protected void mergePlugin( Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context )
        {
            if ( source.isInherited() )
            {
                mergeConfigurationContainer( target, source, sourceDominant, context );
            }
            mergePlugin_GroupId( target, source, sourceDominant, context );
            mergePlugin_ArtifactId( target, source, sourceDominant, context );
            mergePlugin_Version( target, source, sourceDominant, context );
            mergePlugin_Extensions( target, source, sourceDominant, context );
            mergePlugin_Dependencies( target, source, sourceDominant, context );
            mergePlugin_Executions( target, source, sourceDominant, context );
        }


    protected void mergeModelBase( ModelBase target, ModelBase source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeModelBase_DistributionManagement( target, source, sourceDominant, context );
        mergeModelBase_Modules( target, source, sourceDominant, context );
        mergeModelBase_Repositories( target, source, sourceDominant, context );
        mergeModelBase_PluginRepositories( target, source, sourceDominant, context );
        mergeModelBase_Dependencies( target, source, sourceDominant, context );
        mergeModelBase_Reporting( target, source, sourceDominant, context );
        mergeModelBase_DependencyManagement( target, source, sourceDominant, context );
        mergeModelBase_Properties( target, source, sourceDominant, context );
    }


        protected void mergePlugin( Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context )
        {
            if ( source.isInherited() )
            {
                mergeConfigurationContainer( target, source, sourceDominant, context );
            }
            mergePlugin_GroupId( target, source, sourceDominant, context );
            mergePlugin_ArtifactId( target, source, sourceDominant, context );
            mergePlugin_Version( target, source, sourceDominant, context );
            mergePlugin_Extensions( target, source, sourceDominant, context );
            mergePlugin_Dependencies( target, source, sourceDominant, context );
            mergePlugin_Executions( target, source, sourceDominant, context );
        }


    public void testDependencyPrecedesProjectThatUsesSpecificDependencyVersion()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<>();

        MavenProject usingProject = createProject( "group", "project", "1.0" );
        projects.add( usingProject );
        usingProject.getModel().addDependency( createDependency( "group", "dependency", "1.0" ) );

        MavenProject pluginProject = createProject( "group", "dependency", "1.0" );
        projects.add( pluginProject );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( pluginProject, projects.get( 0 ) );
        assertEquals( usingProject, projects.get( 1 ) );
    }


    public void testDependencyPrecedesProjectThatUsesUnresolvedDependencyVersion()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<>();

        MavenProject usingProject = createProject( "group", "project", "1.0" );
        projects.add( usingProject );
        usingProject.getModel().addDependency( createDependency( "group", "dependency", "[1.0,)" ) );

        MavenProject pluginProject = createProject( "group", "dependency", "1.0" );
        projects.add( pluginProject );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( pluginProject, projects.get( 0 ) );
        assertEquals( usingProject, projects.get( 1 ) );
    }


    public List<Artifact> getCompileArtifacts()
    {
        List<Artifact> list = new ArrayList<>( getArtifacts().size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() )
                    || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    list.add( a );
                }
            }
        }
        return list;
    }


    public List<Artifact> getSystemArtifacts()
    {
        List<Artifact> list = new ArrayList<>( getArtifacts().size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    list.add( a );
                }
            }
        }
        return list;
    }


    private boolean hasErrors( List<SettingsProblem> problems )
    {
        if ( problems != null )
        {
            for ( SettingsProblem problem : problems )
            {
                if ( SettingsProblem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
                {
                    return true;
                }
            }
        }

        return false;
    }


    public boolean requiresProject( MavenSession session )
    {
        List<String> goals = session.getGoals();
        if ( goals != null )
        {
            for ( String goal : goals )
            {
                if ( !isGoalSpecification( goal ) )
                {
                    return true;
                }
            }
        }
        return false;
    }


    private boolean hasErrors( List<Problem> problems )
    {
        if ( problems != null )
        {
            for ( Problem problem : problems )
            {
                if ( Problem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
                {
                    return true;
                }
            }
        }

        return false;
    }


    public boolean requiresProject( MavenSession session )
    {
        List<String> goals = session.getGoals();
        if ( goals != null )
        {
            for ( String goal : goals )
            {
                if ( !isGoalSpecification( goal ) )
                {
                    return true;
                }
            }
        }
        return false;
    }


    public void write( OutputStream output, Map<String, Object> options, Model model )
        throws IOException
    {
        Objects.requireNonNull( output, "output cannot be null" );
        Objects.requireNonNull( model, "model cannot be null" );

        String encoding = model.getModelEncoding();
        // TODO Use StringUtils here
        if ( encoding == null || encoding.length() <= 0 )
        {
            encoding = "UTF-8";
        }

        try ( final Writer out = new OutputStreamWriter( output, encoding ) )
        {
            write( out, options, model );
        }
    }


    public void write( OutputStream output, Map<String, Object> options, Settings settings )
        throws IOException
    {
        Objects.requireNonNull( output, "output cannot be null" );
        Objects.requireNonNull( settings, "settings cannot be null" );

        String encoding = settings.getModelEncoding();
        // TODO Use StringUtils here
        if ( encoding == null || encoding.length() <= 0 )
        {
            encoding = "UTF-8";
        }

        try ( final Writer out = new OutputStreamWriter( output, encoding ) )
        {
            write( out, options, settings );
        }
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            LongItem longItem = (LongItem) o;

            return value == longItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            BigIntegerItem that = (BigIntegerItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            StringItem that = (StringItem) o;

            return value.equals( that.value );

        }


    private static <T> List<T> copyList( List<T> original )
    {
        List<T> copy = null;

        if ( original != null )
        {
            copy = new ArrayList<>();

            if ( !original.isEmpty() )
            {
                copy.addAll( original );
            }
        }

        return copy;
    }


    public VersionRange cloneOf()
    {
        List<Restriction> copiedRestrictions = null;

        if ( restrictions != null )
        {
            copiedRestrictions = new ArrayList<>();

            if ( !restrictions.isEmpty() )
            {
                copiedRestrictions.addAll( restrictions );
            }
        }

        return new VersionRange( recommendedVersion, copiedRestrictions );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( this == o )
            {
                return true;
            }
            if ( o == null || getClass() != o.getClass() )
            {
                return false;
            }

            IntItem intItem = (IntItem) o;

            return value == intItem.value;

        }


    public void testGetLineNumber()
    {
        DefaultProblem problem = new DefaultProblem( null, null, null, -1, -1, null );
        assertEquals( -1, problem.getLineNumber() );

        problem = new DefaultProblem( null, null, null, 42, -1, null );
        assertEquals( 42, problem.getLineNumber() );
        
        problem = new DefaultProblem( null, null, null, Integer.MAX_VALUE, -1, null );
        assertEquals( Integer.MAX_VALUE, problem.getLineNumber() );

        // this case is not specified, might also return -1
        problem = new DefaultProblem( null, null, null, Integer.MIN_VALUE, -1, null );
        assertEquals( Integer.MIN_VALUE, problem.getLineNumber() );
    }


    public void testGetColumnNumber()
    {
        DefaultProblem problem = new DefaultProblem( null, null, null, -1, -1, null );
        assertEquals( -1, problem.getColumnNumber() );

        problem = new DefaultProblem( null, null, null, -1, 42, null );
        assertEquals( 42, problem.getColumnNumber() );
        
        problem = new DefaultProblem( null, null, null, -1, Integer.MAX_VALUE, null );
        assertEquals( Integer.MAX_VALUE, problem.getColumnNumber() );

        // this case is not specified, might also return -1
        problem = new DefaultProblem( null, null, null, -1, Integer.MIN_VALUE, null );
        assertEquals( Integer.MIN_VALUE, problem.getColumnNumber() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }

        InversionArtifactFilter other = (InversionArtifactFilter) obj;

        return toInvert.equals( other.toInvert );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }

        OrArtifactFilter other = (OrArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }

        TypeArtifactFilter other = (TypeArtifactFilter) obj;

        return type.equals( other.type );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    private static boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string,
                                            String sourceHint )
    {
        if ( !validateNotNull( problems, fieldName, string, sourceHint ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, Severity.ERROR, fieldName, sourceHint, "is missing" );

        return false;
    }


    private boolean validateStringNotEmpty( String fieldName, ModelProblemCollector problems, Severity severity,
                                            Version version, String string, String sourceHint,
                                            InputLocationTracker tracker )
    {
        if ( !validateNotNull( fieldName, problems, severity, version, string, sourceHint, tracker ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, severity, version, fieldName, sourceHint, "is missing.", tracker );

        return false;
    }


    private boolean hasErrors( List<SettingsProblem> problems )
    {
        if ( problems != null )
        {
            for ( SettingsProblem problem : problems )
            {
                if ( SettingsProblem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
                {
                    return true;
                }
            }
        }

        return false;
    }


    private boolean hasErrors( List<Problem> problems )
    {
        if ( problems != null )
        {
            for ( Problem problem : problems )
            {
                if ( Problem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
                {
                    return true;
                }
            }
        }

        return false;
    }


    public void testReadArtifactDescriptor()
        throws Exception
    {
        Artifact artifact = new DefaultArtifact( "ut.simple:artifact:extension:classifier:1.0" );

        ArtifactDescriptorRequest request = new ArtifactDescriptorRequest();
        request.setArtifact( artifact );
        request.addRepository( newTestRepository() );

        ArtifactDescriptorResult result = system.readArtifactDescriptor( session, request );

        List<Dependency> deps = result.getDependencies();
        assertEquals( 2, deps.size() );
        checkUtSimpleArtifactDependencies( deps.get( 0 ), deps.get( 1 ) );
    }


    public void testCollectDependencies()
        throws Exception
    {
        Artifact artifact = new DefaultArtifact( "ut.simple:artifact:extension:classifier:1.0" );
        // notice: extension and classifier not really used in this test...

        CollectRequest collectRequest = new CollectRequest();
        collectRequest.setRoot( new Dependency( artifact, null ) );
        collectRequest.addRepository( newTestRepository() );

        CollectResult collectResult = system.collectDependencies( session, collectRequest );

        List<DependencyNode> nodes = collectResult.getRoot().getChildren();
        assertEquals( 2, nodes.size() );
        checkUtSimpleArtifactDependencies( nodes.get( 0 ).getDependency(), nodes.get( 1 ).getDependency() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public void testMergeModel_ModelVersion()
    {
        Model parent = new Model();
        parent.setModelVersion( "4.0.0" );
        Model model = new Model();
        modelMerger.mergeModel_ModelVersion( model, parent, false, null );
        assertNull( model.getModelVersion() );

        model.setModelVersion( "5.0.0" );
        modelMerger.mergeModel_ModelVersion( model, parent, false, null );
        assertEquals( "5.0.0", model.getModelVersion() );
    }


    public void testMergeModel_ArtifactId()
    {
        Model parent = new Model();
        parent.setArtifactId( "PARENT" );
        Model model = new Model();
        modelMerger.mergeModel_ArtifactId( model, parent, false, null );
        assertNull( model.getArtifactId() );

        model.setArtifactId( "MODEL" );
        modelMerger.mergeModel_ArtifactId( model, parent, false, null );
        assertEquals( "MODEL", model.getArtifactId() );
    }


    private boolean validateVersion( String fieldName, ModelProblemCollector problems, Severity severity,
                                     Version version, String string, String sourceHint, InputLocationTracker tracker )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        if ( hasExpression( string ) )
        {
            addViolation( problems, severity, version, fieldName, sourceHint,
                          "must be a valid version but is '" + string + "'.", tracker );
            return false;
        }

        return validateBannedCharacters( fieldName, problems, severity, version, string, sourceHint, tracker,
                                         ILLEGAL_VERSION_CHARS );

    }


    private boolean validate20ProperSnapshotVersion( String fieldName, ModelProblemCollector problems,
                                                     Severity severity, Version version, String string,
                                                     String sourceHint, InputLocationTracker tracker )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        if ( string.endsWith( "SNAPSHOT" ) && !string.endsWith( "-SNAPSHOT" ) )
        {
            addViolation( problems, severity, version, fieldName, sourceHint,
                          "uses an unsupported snapshot version format, should be '*-SNAPSHOT' instead.", tracker );
            return false;
        }

        return true;
    }


    private boolean isValidId( String id )
    {
        for ( int i = 0; i < id.length(); i++ )
        {
            char c = id.charAt( i );
            if ( !isValidIdCharacter( c ) )
            {
                return false;
            }
        }
        return true;
    }


    private boolean isValidIdWithWildCards( String id )
    {
        for ( int i = 0; i < id.length(); i++ )
        {
            char c = id.charAt( i );
            if ( !isValidIdWithWildCardCharacter( c ) )
            {
                return false;
            }
        }
        return true;
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        return reverse ? !result : result;
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        return reverse ? !result : result;
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        return reverse ? !result : result;
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        return reverse ? !result : result;
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        return reverse ? !result : result;
    }


    private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        return reverse ? !result : result;
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        return reverse ? !result : result;
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        return reverse ? !result : result;
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        return reverse ? !result : result;
    }


    private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        return reverse ? !result : result;
    }


    private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        return reverse ? !result : result;
    }


    private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        return reverse ? !result : result;
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj ) 
    {
        if ( this == obj ) 
        {
            return true;
        }
        
        if ( !( obj instanceof FileModelSource ) ) 
        {
            return false;
        }
        FileModelSource other = ( FileModelSource ) obj;
        return getFile().equals( other.getFile() );
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }


    protected void mergeModelBase( ModelBase target, ModelBase source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeModelBase_DistributionManagement( target, source, sourceDominant, context );
        mergeModelBase_Modules( target, source, sourceDominant, context );
        mergeModelBase_Repositories( target, source, sourceDominant, context );
        mergeModelBase_PluginRepositories( target, source, sourceDominant, context );
        mergeModelBase_Dependencies( target, source, sourceDominant, context );
        mergeModelBase_Reporting( target, source, sourceDominant, context );
        mergeModelBase_DependencyManagement( target, source, sourceDominant, context );
        mergeModelBase_Properties( target, source, sourceDominant, context );
    }


    protected void mergeContributor( Contributor target, Contributor source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        mergeContributor_Name( target, source, sourceDominant, context );
        mergeContributor_Email( target, source, sourceDominant, context );
        mergeContributor_Url( target, source, sourceDominant, context );
        mergeContributor_Organization( target, source, sourceDominant, context );
        mergeContributor_OrganizationUrl( target, source, sourceDominant, context );
        mergeContributor_Timezone( target, source, sourceDominant, context );
        mergeContributor_Roles( target, source, sourceDominant, context );
        mergeContributor_Properties( target, source, sourceDominant, context );
    }


    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }


    protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }


    public void transferInitiated( TransferEvent event )
    {
        String action = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";
        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";

        TransferResource resource = event.getResource();
        StringBuilder message = new StringBuilder();
        message.append( action ).append( ' ' ).append( direction ).append( ' ' ).append( resource.getRepositoryId() );
        message.append( ": " );
        message.append( resource.getRepositoryUrl() ).append( resource.getResourceName() );

        out.println( message.toString() );
    }


    public void transferInitiated( TransferEvent event )
    {
        String action = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";
        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? "to" : "from";

        TransferResource resource = event.getResource();
        StringBuilder message = new StringBuilder();
        message.append( action ).append( ' ' ).append( direction ).append( ' ' ).append( resource.getRepositoryId() );
        message.append( ": " );
        message.append( resource.getRepositoryUrl() ).append( resource.getResourceName() );

        out.info( message.toString() );
    }


    public void testOrderOfPluginExecutionConfigurationElementsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-config-order/wo-plugin-mgmt" );
        String prefix = "build/plugins[1]/executions[1]/configuration/";
        assertEquals( "one", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "key1", pom.getValue( prefix + "propertiesParam/property[1]/name" ) );
        assertEquals( "key2", pom.getValue( prefix + "propertiesParam/property[2]/name" ) );
    }


    public void testOrderOfPluginExecutionConfigurationElementsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-config-order/w-plugin-mgmt" );
        String prefix = "build/plugins[1]/executions[1]/configuration/";
        assertEquals( "one", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "key1", pom.getValue( prefix + "propertiesParam/property[1]/name" ) );
        assertEquals( "key2", pom.getValue( prefix + "propertiesParam/property[2]/name" ) );
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


        private String insertRepositoryKey( String filename, String repositoryKey )
        {
            String result;
            int idx = filename.indexOf( '.' );
            if ( idx < 0 )
            {
                result = filename + '-' + repositoryKey;
            }
            else
            {
                result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
            }
            return result;
        }


    private String insertRepositoryKey( String filename, String repositoryKey )
    {
        String result;
        int idx = filename.indexOf( '.' );
        if ( idx < 0 )
        {
            result = filename + '-' + repositoryKey;
        }
        else
        {
            result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
        }
        return result;
    }


    private String insertRepositoryKey( String filename, String repositoryKey )
    {
        String result;
        int idx = filename.indexOf( '.' );
        if ( idx < 0 )
        {
            result = filename + '-' + repositoryKey;
        }
        else
        {
            result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
        }
        return result;
    }


    private String insertRepositoryKey( String filename, String repositoryKey )
    {
        String result;
        int idx = filename.indexOf( '.' );
        if ( idx < 0 )
        {
            result = filename + '-' + repositoryKey;
        }
        else
        {
            result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
        }
        return result;
    }


    public void testBuildParentVersionRangeExternallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-without-version/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeExternallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-version-expression/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeLocallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-local-child-version-expression/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeExternallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-version-expression/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeLocallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile( "src/test/resources/projects/parent-version-range-local-child-without-version/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeExternallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-version-expression/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeLocallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-local-child-version-expression/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeExternallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-without-version/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeLocallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile( "src/test/resources/projects/parent-version-range-local-child-without-version/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeExternallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-external-child-without-version/pom.xml" );

        try
        {
            this.getProjectFromRemoteRepository( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildValidParentVersionRangeLocally() throws Exception
    {
        File f1 = getTestFile( "src/test/resources/projects/parent-version-range-local-valid/child/pom.xml" );

        final MavenProject childProject = getProject( f1 );

        assertNotNull( childProject.getParentArtifact() );
        assertEquals( childProject.getParentArtifact().getVersion(), "1" );
        assertNotNull( childProject.getParent() );
        assertEquals( childProject.getParent().getVersion(), "1" );
        assertNotNull( childProject.getModel().getParent() );
        assertEquals( childProject.getModel().getParent().getVersion(), "[1,10]" );
    }


    public void testBuildParentVersionRangeExternally() throws Exception
    {
        File f1 = getTestFile( "src/test/resources/projects/parent-version-range-external-valid/pom.xml" );

        final MavenProject childProject = this.getProjectFromRemoteRepository( f1 );

        assertNotNull( childProject.getParentArtifact() );
        assertEquals( childProject.getParentArtifact().getVersion(), "1" );
        assertNotNull( childProject.getParent() );
        assertEquals( childProject.getParent().getVersion(), "1" );
        assertNotNull( childProject.getModel().getParent() );
        assertEquals( childProject.getModel().getParent().getVersion(), "[1,1]" );
    }


    public void testBuildParentVersionRangeLocallyWithoutChildVersion() throws Exception
    {
        File f1 =
            getTestFile( "src/test/resources/projects/parent-version-range-local-child-without-version/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testBuildParentVersionRangeLocallyWithChildVersionExpression() throws Exception
    {
        File f1 =
            getTestFile(
                "src/test/resources/projects/parent-version-range-local-child-version-expression/child/pom.xml" );

        try
        {
            getProject( f1 );
            fail( "Expected 'ProjectBuildingException' not thrown." );
        }
        catch ( final ProjectBuildingException e )
        {
            assertNotNull( e.getMessage() );
            assertTrue( e.getMessage().contains( "Version must be a constant" ) );
        }
    }


    public void testValueExtractionFromSystemPropertiesWithMissingProject()
        throws Exception
    {
        String sysprop = "PPEET_sysprop1";

        Properties executionProperties = new Properties();

        if ( executionProperties.getProperty( sysprop ) == null )
        {
            executionProperties.setProperty( sysprop, "value" );
        }

        ExpressionEvaluator ee = createExpressionEvaluator( null, null, executionProperties );

        Object value = ee.evaluate( "${" + sysprop + "}" );

        assertEquals( "value", value );
    }


    public void testValueExtractionFromSystemPropertiesWithMissingProject_WithDotNotation()
        throws Exception
    {
        String sysprop = "PPEET.sysprop2";

        Properties executionProperties = new Properties();

        if ( executionProperties.getProperty( sysprop ) == null )
        {
            executionProperties.setProperty( sysprop, "value" );
        }

        ExpressionEvaluator ee = createExpressionEvaluator( null, null, executionProperties );

        Object value = ee.evaluate( "${" + sysprop + "}" );

        assertEquals( "value", value );
    }


    public void exit()
        throws MojoExecutionException
    {
        final LinkedList<ScopeState> stack = values.get();
        if ( stack == null || stack.isEmpty() )
        {
            throw new IllegalStateException();
        }
        stack.removeFirst();
        if ( stack.isEmpty() )
        {
            values.remove();
        }
    }


    public void exit()
    {
        final LinkedList<ScopeState> stack = values.get();
        if ( stack == null || stack.isEmpty() )
        {
            throw new IllegalStateException();
        }
        stack.removeFirst();
        if ( stack.isEmpty() )
        {
            values.remove();
        }
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return Objects.equals( groupId, that.groupId ) && Objects.equals( artifactId, that.artifactId )
                && Objects.equals( version, that.version )
                && Objects.equals( dependencyArtifacts, that.dependencyArtifacts )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( collect, that.collect ) 
                && Objects.equals( resolve, that.resolve )
                && aggregating == that.aggregating;
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


    public void flush()
    {
        for ( CacheRecord record : cache.values() )
        {
            ClassRealm realm = record.getRealm();
            try
            {
                realm.getWorld().disposeRealm( realm.getId() );
            }
            catch ( NoSuchRealmException e )
            {
                // ignore
            }
        }
        cache.clear();
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm 
                && CacheUtils.pluginEquals( plugin, that.plugin )
                && Objects.equals( workspace, that.workspace ) 
                && Objects.equals( localRepo, that.localRepo )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories ) 
                && Objects.equals( filter, that.filter )
                && Objects.equals( foreignImports, that.foreignImports );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && RepositoryUtils.repositoriesEquals( this.repositories, that.repositories );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) 
                && Objects.equals( workspace, that.workspace )
                && Objects.equals( localRepo, that.localRepo ) 
                && RepositoryUtils.repositoriesEquals( repositories, that.repositories )
                && Objects.equals( filter, that.filter );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }


    public Set<Plugin> getNonThreadSafePlugins()
    {
        Set<Plugin> plugins = new HashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
            if ( !mojoExecution.getMojoDescriptor().isThreadSafe() )
            {
                plugins.add( mojoExecution.getPlugin() );
            }
        }
        return plugins;
    }


    public Set<MojoDescriptor> getNonThreadSafeMojos()
    {
        Set<MojoDescriptor> mojos = new HashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
            if ( !mojoExecution.getMojoDescriptor().isThreadSafe() )
            {
                mojos.add( mojoExecution.getMojoDescriptor() );
            }
        }
        return mojos;
    }


    private static Iterable<String> getDistinctPhasesInOrderOfExecutionPlanAppearance(
        List<ExecutionPlanItem> planItems )
    {
        LinkedHashSet<String> result = new LinkedHashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItems )
        {
            final String phase = executionPlanItem.getLifecyclePhase();
            if ( !result.contains( phase ) )
            {
                result.add( phase );
            }
        }
        return result;
    }


    public Set<MojoDescriptor> getNonThreadSafeMojos()
    {
        Set<MojoDescriptor> mojos = new HashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
            if ( !mojoExecution.getMojoDescriptor().isThreadSafe() )
            {
                mojos.add( mojoExecution.getMojoDescriptor() );
            }
        }
        return mojos;
    }


    private static Iterable<String> getDistinctPhasesInOrderOfExecutionPlanAppearance(
        List<ExecutionPlanItem> planItems )
    {
        LinkedHashSet<String> result = new LinkedHashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItems )
        {
            final String phase = executionPlanItem.getLifecyclePhase();
            if ( !result.contains( phase ) )
            {
                result.add( phase );
            }
        }
        return result;
    }


    public Set<Plugin> getNonThreadSafePlugins()
    {
        Set<Plugin> plugins = new HashSet<>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
            if ( !mojoExecution.getMojoDescriptor().isThreadSafe() )
            {
                plugins.add( mojoExecution.getPlugin() );
            }
        }
        return plugins;
    }


    private void injectDefaultRepositories( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        Set<String> definedRepositories = repositorySystem.getRepoIds( request.getRemoteRepositories() );

        if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) )
        {
            try
            {
                request.addRemoteRepository( repositorySystem.createDefaultRemoteRepository( request ) );
            }
            catch ( Exception e )
            {
                throw new MavenExecutionRequestPopulationException( "Cannot create default remote repository.", e );
            }
        }
    }


    private void injectDefaultPluginRepositories( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        Set<String> definedRepositories = repositorySystem.getRepoIds( request.getPluginArtifactRepositories() );

        if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) )
        {
            try
            {
                request.addPluginArtifactRepository( repositorySystem.createDefaultRemoteRepository( request ) );
            }
            catch ( Exception e )
            {
                throw new MavenExecutionRequestPopulationException( "Cannot create default remote repository.", e );
            }
        }
    }


    public MavenExecutionRequest addMirror( Mirror mirror )
    {
        Objects.requireNonNull( mirror, "mirror cannot be null" );

        for ( Mirror p : getMirrors() )
        {
            if ( p.getId() != null && p.getId().equals( mirror.getId() ) )
            {
                return this;
            }
        }

        getMirrors().add( mirror );

        return this;
    }


    public MavenExecutionRequest addProfile( Profile profile )
    {
        Objects.requireNonNull( profile, "profile cannot be null" );

        for ( Profile p : getProfiles() )
        {
            if ( p.getId() != null && p.getId().equals( profile.getId() ) )
            {
                return this;
            }
        }

        getProfiles().add( profile );

        return this;
    }


    public MavenExecutionRequest addServer( Server server )
    {
        Objects.requireNonNull( server, "server cannot be null" );

        for ( Server p : getServers() )
        {
            if ( p.getId() != null && p.getId().equals( server.getId() ) )
            {
                return this;
            }
        }

        getServers().add( server );

        return this;
    }


    public MavenExecutionRequest addProfile( Profile profile )
    {
        Objects.requireNonNull( profile, "profile cannot be null" );

        for ( Profile p : getProfiles() )
        {
            if ( p.getId() != null && p.getId().equals( profile.getId() ) )
            {
                return this;
            }
        }

        getProfiles().add( profile );

        return this;
    }


    public MavenExecutionRequest addProxy( Proxy proxy )
    {
        Objects.requireNonNull( proxy, "proxy cannot be null" );

        for ( Proxy p : getProxies() )
        {
            if ( p.getId() != null && p.getId().equals( proxy.getId() ) )
            {
                return this;
            }
        }

        getProxies().add( proxy );

        return this;
    }


    public MavenExecutionRequest addProfile( Profile profile )
    {
        Objects.requireNonNull( profile, "profile cannot be null" );

        for ( Profile p : getProfiles() )
        {
            if ( p.getId() != null && p.getId().equals( profile.getId() ) )
            {
                return this;
            }
        }

        getProfiles().add( profile );

        return this;
    }


    public MavenExecutionRequest addServer( Server server )
    {
        Objects.requireNonNull( server, "server cannot be null" );

        for ( Server p : getServers() )
        {
            if ( p.getId() != null && p.getId().equals( server.getId() ) )
            {
                return this;
            }
        }

        getServers().add( server );

        return this;
    }


    public MavenExecutionRequest addMirror( Mirror mirror )
    {
        Objects.requireNonNull( mirror, "mirror cannot be null" );

        for ( Mirror p : getMirrors() )
        {
            if ( p.getId() != null && p.getId().equals( mirror.getId() ) )
            {
                return this;
            }
        }

        getMirrors().add( mirror );

        return this;
    }


    public MavenExecutionRequest addProxy( Proxy proxy )
    {
        Objects.requireNonNull( proxy, "proxy cannot be null" );

        for ( Proxy p : getProxies() )
        {
            if ( p.getId() != null && p.getId().equals( proxy.getId() ) )
            {
                return this;
            }
        }

        getProxies().add( proxy );

        return this;
    }


    public MavenExecutionRequest addMirror( Mirror mirror )
    {
        Objects.requireNonNull( mirror, "mirror cannot be null" );

        for ( Mirror p : getMirrors() )
        {
            if ( p.getId() != null && p.getId().equals( mirror.getId() ) )
            {
                return this;
            }
        }

        getMirrors().add( mirror );

        return this;
    }


    public MavenExecutionRequest addProxy( Proxy proxy )
    {
        Objects.requireNonNull( proxy, "proxy cannot be null" );

        for ( Proxy p : getProxies() )
        {
            if ( p.getId() != null && p.getId().equals( proxy.getId() ) )
            {
                return this;
            }
        }

        getProxies().add( proxy );

        return this;
    }


    public MavenExecutionRequest addServer( Server server )
    {
        Objects.requireNonNull( server, "server cannot be null" );

        for ( Server p : getServers() )
        {
            if ( p.getId() != null && p.getId().equals( server.getId() ) )
            {
                return this;
            }
        }

        getServers().add( server );

        return this;
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }

        ExclusionSetFilter other = (ExclusionSetFilter) obj;

        return excludes.equals( other.excludes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }


    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }

        AndArtifactFilter other = (AndArtifactFilter) obj;

        return filters.equals( other.filters );
    }


        private String insertRepositoryKey( String filename, String repositoryKey )
        {
            String result;
            int idx = filename.indexOf( '.' );
            if ( idx < 0 )
            {
                result = filename + '-' + repositoryKey;
            }
            else
            {
                result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
            }
            return result;
        }


    private String insertRepositoryKey( String filename, String repositoryKey )
    {
        String result;
        int idx = filename.indexOf( '.' );
        if ( idx < 0 )
        {
            result = filename + '-' + repositoryKey;
        }
        else
        {
            result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
        }
        return result;
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }


    public void testResolveCompileScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveCompileScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }


    public void testResolveCompileScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveCompileScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }


    public void testResolveCompileScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }


    public void testResolveCompileScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }


    public void testResolveRuntimeScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }
